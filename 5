
local w207= {}
local w208= {}
local w209= require

local function w210(w211)
    if w208[w211] then
        return w208[w211]
    end

    local w212= w207[w211]
    if not w212 then
        return w209(w211)
    end
    local w213= {}
    setmetatable(w213, { __index = _G })
    w213.require = w210

    local w214, w215
    if type(setfenv) == "function" then
        w214, w215 = load(w212, w211)
        if not w214 then
            error("Failed to load module: " .. w211 .. " (" .. tostring(w215) .. ")")
        end
        setfenv(w214, w213)
    else
        w214, w215 = load(w212, w211, nil, w213)
        if not w214 then
            error("Failed to load module: " .. w211 .. " (" .. tostring(w215) .. ")")
        end
    end

    local w216= w214()
    w208[w211] = w216 or true
    return w208[w211]
end

w207["require/aa/player_condition"] = [[
local w588= require("require/help/libs")
local w589= w588.get("antiaim_funcs")
local entity= w588.get("entity") or entity
local bit= w588.get("bit") or bit
local w590= require('require/abc/menu_setup')
local w591= { last_air = false, last_tick = 0, last_cond = nil }

local function w592(w593)
    if w593 == 'global' then return true end
    if not w590 or not w590.ui then return true end
    local w594= 'enable_' .. w593
    local w595= w590.ui[w594]
    if not w595 then
        return true
    end
    local w596, w597= pcall(ui.get, w595)
    return w596 and w597 == true
end


local function w598()
    local w599= entity.get_local_player()
    if not w599 or not entity.is_alive(w599) then
        return nil
    end
    
    if client.key_state(0x45) then
        if w592('legit') then return "legit" end
    end

    local w600= false
    if w589 and w589.get_double_tap then
        w600 = w589.get_double_tap()
    else
        w600 = true
    end

    if w600 == false then
        if w592('fakelag') then return "fakelag" end
    end

    if misc_gs_hotkey_slowmotion and ui.get(misc_gs_hotkey_slowmotion) == true then
        if w592('walk') then return "walk" end
    end
    
    if client.key_state(0x10) then
        local w601, w602= entity.get_prop(w599, 'm_vecVelocity')
        local w603= math.sqrt((w601 or 0)^2 + (w602 or 0)^2)
        if w603 >= 20 and w603 <= 140 then
            if w592('walk') then return "walk" end
        end
    end

    local w601, w602= entity.get_prop(w599, 'm_vecVelocity')
    local w603= math.sqrt((w601 or 0)^2 + (w602 or 0)^2)
    local w604= entity.get_prop(w599, 'm_flDuckAmount') > 0.5
    local w605= bit.band(entity.get_prop(w599, 'm_fFlags') or 0, 1) == 1
    local w606= globals.tickcount()

    if not w605 then
        if w604 then
            w591.last_air = true
            w591.last_tick = w606
            w591.last_cond = "jump+"
            if w592('jump+') then return "jump+" end
        else
            w591.last_air = true
            w591.last_tick = w606
            w591.last_cond = "jump"
            if w592('jump') then return "jump" end
        end
    else
        if w591.last_air and (w606 - w591.last_tick <= 2) then
            if w591.last_cond and w592(w591.last_cond) then
                return w591.last_cond
            end
        end
        w591.last_air = false
        w591.last_cond = nil
    end

    if w604 then
        if w603 >= 2 then
            if w592('duck+') then return "duck+" end
        else
            if w592('duck') then return "duck" end
        end
    else
        if w603 >= 2 then
            if w592('move') then return "move" end
        else
            if w592('stand') then return "stand" end
        end
    end

    return "global"
end

return {
    get = w598
}]]
w207["require/abc/build_menu"] = [[tab = {
    "RAGE",
    "AA",
    "LEGIT",
    "VISUALS",
    "MISC",
    "PLIST",
    "CONFIG",
    "LUA"
}

cont = {
    {
        "Aimbot",
        "Other"
    },
    {
        "Anti-aimbot angles",
        "Fake lag",
        "Other"
    },
    {},
    {
        "Player ESP",
        "Other ESP",
        "Colored models",
        "Effects"
    },
    {},
    {},
    {},
    {
        "A",
        "B",
    }
}

local w591= {
    "global",
    "stand",
    "move",
    "duck",
    "duck+",
    "jump",
    "jump+",
    "walk",
    "fakelag",
    "legit",
}

local w592= require("require/abc/menu_setup")
local w593= require("require/help/color")
local w594= require("require/abc/screen_logger")
local w595= require("require/help/emojis")

local function w596(w597)
    local w598= 'inDGnidgdisgndsin'

    local function w599()
        local w600= database.read(w598)
        return type(w600) == 'table' and w600 or {}
    end

    local function w601(w600)
        database.write(w598, w600)
    end

    local function w602(w600,w603)
        for w604 = 1, #w600 do if w600[w604] == w603 then return w604 end end
        return nil
    end

    local function w605()
        if not (w597 and w597.menu_setup and w597.menu_setup.ui and w597.menu_setup.ui.paint_logger) then
            return false
        end
        local w606, w607= pcall(ui.get, w597.menu_setup.ui.paint_logger)
        if not w606 or not w607 then return false end
        if type(w607) == 'table' then
            for w608, w609 in ipairs(w607) do
                if tostring(w609) == 'config' then return true end
            end
            return false
        else
            return tostring(w607) == 'config'
        end
    end

    local function w610(w611)
        local w612= w599()
        if #w612 == 0 then w612 = {'(empty)'} end
            if w592.ui.cfg_listbox then
                pcall(ui.set_visible, w592.ui.cfg_listbox, false)
            end
            w592.ui.cfg_listbox = w592.register_ui(
                ui.new_listbox(tab[2], cont[2][1], 'Configs', w612),
                { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
            )
        if w611 then
            local w613= w602(w612, w611)
            if w613 then ui.set(w592.ui.cfg_listbox, w613-1) end
        end
    end
 
    
    
    
    w592.ui.cache_credentials = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("pin") .. w593.get("default", "ui") .. 'Cache credentials'),
        { requires_login = false, key = 'cache_credentials', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    w592.ui.login_username = w592.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Username', 'username'),
        { requires_login = false, key = 'login_username', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    w592.ui.login_password = w592.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Password', 'password'),
        { requires_login = false, key = 'login_password', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    w592.ui.login_howto_header = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], w593.get("grey", "ui") .. '───────[ ' .. w593.get("white", "ui") .. 'How to ' .. w593.get("green", "ui") .. 'log in' .. w593.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'login_howto_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.login_console_register = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], w593.get("grey", "ui") .. '1. In console -> "register ' .. w593.get("green", "ui") .. 'user' .. w593.get("grey", "ui") .. ' ' .. w593.get("red", "ui") .. 'pass' .. w593.get("grey", "ui") .. ' ' .. w593.get("blue", "ui") .. 'code' .. w593.get("grey", "ui") .. '"'),
        { requires_login = false, key = 'login_console_register', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.login_menu_credentials = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], w593.get("grey", "ui") .. '2. Write password & username in the menu.'),
        { requires_login = false, key = 'login_menu_credentials', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.login_press_login = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], w593.get("grey", "ui") .. '3. Press log in and enjoy ' .. w593.get("green", "ui") .. 'premium features' .. w593.get("grey", "ui") .. '.'),
        { requires_login = false, key = 'login_press_login', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.login_spacer1 = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer1', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.reset_header = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], w593.get("grey", "ui") .. '───────[ ' .. w593.get("white", "ui") .. 'How to ' .. w593.get("yellow", "ui") .. 'reset pass' .. w593.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'reset_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.reset_step1 = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], w593.get("grey", "ui") .. '1. Write username -> press reset.'),
        { requires_login = false, key = 'reset_step1', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.reset_step2 = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], w593.get("grey", "ui") .. '2. Login with your oldest password.'),
        { requires_login = false, key = 'reset_step2', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.login_spacer2 = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer2', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.support_header = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], w593.get("grey", "ui") .. '───────[ ' .. w593.get("red", "ui") .. 'Support & Other' .. w593.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'support_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.support_discord = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], w593.get("grey", "ui") .. '1. Join the ' .. w593.get("discord", "ui") .. 'discord ' .. w593.get("grey", "ui") .. 'for support.'),
        { requires_login = false, key = 'support_discord', tab = 'AA', visible = true, config_type = 'label' }
    )

    w592.ui.login_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("lock_open") .. w593.get("default", "ui") .. 'Login', function()
            local w614= w597.safe.safe_get(w592.ui.login_username)
            local w615= w597.safe.safe_get(w592.ui.login_password)
            local w616= w597.safe.safe_get(w592.ui.cache_credentials)
            if w614 ~= '' and w615 ~= '' then
                local w617= w597.login.login(w614, w615)
                if w617 then
                    w597.pushlog("Welcome back, " .. w597.str.capitalize(w614) .. ". You logged in successfully.", 3, 75, 145, 55, 255)
                    if w616 then
                        database.write('cached_credentials', { username = w614, password = w615 })
                    else
                        database.write('cached_credentials', nil)
                    end
                    local w618,w619,w620= w593.get("green", "log")
                    w597.screenlog("Login successful!", 4, w618, w619, w620, 255)
                else
                    local w618,w619,w620= w593.get("red", "log")
                    w597.screenlog("Login failed!", 4, w618, w619, w620, 255)
                end
            end
                if w597.menu_visibility and w597.menu_visibility.update then
                    w597.menu_visibility.update(w597)
                end
        end),
        { requires_login = false, key = 'login_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    w592.ui.logout_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][3], w593.get("red", "ui") .. w595.get("lock") .. w593.get("default", "ui") .. 'Logout', function()
            w597.login.logout()
            local w618,w619,w620= w593.get("red", "log")
            w597.screenlog("Logged out!", 4, w618, w619, w620, 255)
                if w597.menu_visibility and w597.menu_visibility.update then
                    w597.menu_visibility.update(w597)
                end
        end),
        { requires_login = true, key = 'logout_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    w592.ui.reset_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][1], w593.get("yellow", "ui") .. w595.get("warning") .. w593.get("default", "ui") .. 'Reset', function()
            local w614= w597.safe.safe_get(w592.ui.login_username)
            w597.login.reset_password(w614)
            local w618,w619,w620= w593.get("yellow", "log")
            w597.screenlog("Password reset.", 4, w618, w619, w620, 255)
            w597.pushlog("Password reset for user: " .. w614, 5, 255, 255, 0, 255)
                if w597.menu_visibility and w597.menu_visibility.update then
                    w597.menu_visibility.update(w597)
                end
        end),
        { requires_login = true, key = 'reset_button', tab = 'AA', visible = true, config_type = 'button' }
    )

    w592.ui.discord_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][3], w593.get("discord", "ui") .. w595.get("chat") .. w593.get("default", "ui") .. 'Discord', function()
            local w621= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            w597.safe.safe_set(w621, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://discord.gg/a2bFbVWWg9')
        end),
        { requires_login = true, key = 'discord_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    w592.ui.youtube_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][3], w593.get("youtube", "ui") .. w595.get("play") .. w593.get("default", "ui") .. 'YouTube', function()
            local w621= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            w597.safe.safe_set(w621, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://www.youtube.com/@vile-gs/videos')
        end),
        { requires_login = true, key = 'youtube_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    w592.ui.sellhub_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][3], w593.get("sellhub", "ui") .. w595.get("folder") .. w593.get("default", "ui") .. 'Sellhub', function()
            local w621= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            w597.safe.safe_set(w621, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://sodium.sellhub.cx/#products-list')
        end),
        { requires_login = true, key = 'sellhub_button', tab = 'AA', visible = true, config_type = 'button' }
    )


    
    
    
    w592.ui.condition_label = w592.register_ui(
        ui.new_label(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("menu") .. w593.get("default", "ui") .. 'Condition', unpack(w591)),
        { requires_login = true, key = 'condition_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.condition = w592.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nCondition', unpack(w591)),
        { requires_login = true, key = 'condition', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    w592.ui.condition_label2 = w592.register_ui(
        ui.new_label(tab[2], cont[2][1], '\ncondition label'),
        { requires_login = true, key = 'condition_label2', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.misc_resolver = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("wrench") .. w593.get("default", "ui") .. 'Resolver'),
        { requires_login = true, key = 'misc_resolver', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    w592.ui.misc_ragebot = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("arrow_double") .. w593.get("default", "ui") .. 'Ragebot'),
        { requires_login = true, key = 'misc_ragebot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    w592.ui.misc_dormantaimbot = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("time") .. w593.get("default", "ui") .. 'Dormant aimbot'),
        { requires_login = true, key = 'misc_dormantaimbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    w592.ui.misc_dormantaimbot_key = w592.register_ui(
        ui.new_hotkey(tab[2], cont[2][1], '\ndormant aimbot key', true),
        { requires_login = true, key = 'misc_dormantaimbot_key', tab = 'MISC', visible = true, config_type = 'hotkey' }
    )
    w592.ui.misc_dormantaimbot_value = w592.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\ndormant aimbot value', 60, 100, 0, true, '%'),
        { requires_login = true, key = 'misc_dormantaimbot_value', tab = 'MISC', visible = true, config_type = 'slider' }
    )
    w592.ui.misc_exploit_fakelag = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("latency3") .. w593.get("default", "ui") .. 'Limit exploit fakelag'),
        { requires_login = true, key = 'misc_exploit_fakelag', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    w592.ui.misc_walkbot = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("arrow_up") .. w593.get("default", "ui") .. 'Walkbot'),
        { requires_login = true, key = 'misc_walkbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    w592.ui.misc_backstab = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("triangle_upside") .. w593.get("default", "ui") .. 'Backstab Assist'),
        { requires_login = true, key = 'misc_backstab', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    w592.ui.misc_spindead = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("turning2") .. w593.get("default", "ui") .. 'Spin on dead enemies'),
        { requires_login = true, key = 'misc_spindead', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    w592.ui.aa_gskey_freestandh = w592.register_ui(
        ui.new_label(tab[2], cont[2][3], w593.get("green", "ui") .. w595.get("turning2") .. w593.get("default", "ui") .. 'Freestand'),
        { requires_login = false, key = 'aa_gskey_freestandh', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.aa_gskey_freestand = w592.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'freestand', true),
        { requires_login = true, key = 'aa_gskey_freestand', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    w592.ui.aa_gskey_slowmotionh = w592.register_ui(
        ui.new_label(tab[2], cont[2][3], w593.get("green", "ui") .. w595.get("gear") .. w593.get("default", "ui") .. 'Slowmotion'),
        { requires_login = false, key = 'aa_gskey_slowmotionh', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.aa_gskey_slowmotion = w592.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'slowmotion', true),
        { requires_login = true, key = 'aa_gskey_slowmotion', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    w592.ui.aa_gskey_edgeyawh = w592.register_ui(
        ui.new_label(tab[2], cont[2][3], w593.get("green", "ui") .. w595.get("recycle") .. w593.get("default", "ui") .. 'Edge Yaw'),
        { requires_login = false, key = 'aa_gskey_edgeyawh', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.aa_gskey_edgeyaw = w592.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'edge yaw', true),
        { requires_login = true, key = 'aa_gskey_edgeyaw', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    w592.ui.aa_gskey_onshoth = w592.register_ui(
        ui.new_label(tab[2], cont[2][3], w593.get("green", "ui") .. w595.get("arrow_double") .. w593.get("default", "ui") .. 'On-shot aa'),
        { requires_login = false, key = 'aa_gskey_onshoth', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.aa_gskey_onshot = w592.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'on-shot aa', true),
        { requires_login = true, key = 'aa_gskey_onshot', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    
    for w608, w622 in ipairs(w591) do
        local w623= 'enable_' .. w622
        w592.ui[w623] = w592.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("accept") .. w593.get("default", "ui") .. 'Enable ' .. w622),
            { requires_login = true, key = w623, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        w592.ui['pitch_' .. w622] = w592.register_ui(
            ui.new_combobox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("triangle_upside") .. w593.get("default", "ui") .. 'Pitch', 'off', 'up', 'down', 'minimal', 'ideal'),
            { requires_login = true, key = 'pitch_' .. w622, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        w592.ui['yaw_base_' .. w622] = w592.register_ui(
            ui.new_combobox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("recycle") .. w593.get("default", "ui") .. 'Yaw Base', 'target', 'view', 'threat', 'distance', 'smart'),
            { requires_login = true, key = 'yaw_base_' .. w622, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        w592.ui['yaw_' .. w622] = w592.register_ui(
            ui.new_combobox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("turning2") .. w593.get("default", "ui") .. 'Yaw', 'off', 'spin', '180', '3way', 'ideal'),
            { requires_login = true, key = 'yaw_' .. w622, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        w592.ui['label1_' .. w622] = w592.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label1_' .. w622, tab = 'AA', visible = true, config_type = 'label' }
        )
        w592.ui['body_yaw_base_' .. w622] = w592.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Base', -90, 90, 0, true, '°'),
            { requires_login = true, key = 'body_yaw_base_' .. w622, tab = 'AA', visible = true, config_type = 'slider' }
        )
        w592.ui['body_yaw_left_' .. w622] = w592.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Left', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_left_' .. w622, tab = 'AA', visible = true, config_type = 'slider' }
        )
        w592.ui['body_yaw_right_' .. w622] = w592.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Right', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_right_' .. w622, tab = 'AA', visible = true, config_type = 'slider' }
        )
        w592.ui['randomize_yaw_' .. w622] = w592.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Randomize Yaw', 0, 30, 0, true, '%', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'randomize_yaw_' .. w622, tab = 'AA', visible = true, config_type = 'slider' }
        )
        w592.ui['label2_' .. w622] = w592.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label2_' .. w622, tab = 'AA', visible = true, config_type = 'label' }
        )
        w592.ui['yaw_jitter_' .. w622] = w592.register_ui(
            ui.new_combobox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("turning") .. w593.get("default", "ui") .. 'Yaw Jitter', 'off', 'center', 'skitter'),
            { requires_login = true, key = 'yaw_jitter_' .. w622, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        w592.ui['yaw_jitter_base_' .. w622] = w592.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Yaw Jitter - Base', 0, 120, 0, true, '°', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'yaw_jitter_base_' .. w622, tab = 'AA', visible = true, config_type = 'slider' }
        )
        w592.ui['body_yaw_mode_' .. w622] = w592.register_ui(
            ui.new_combobox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("gear") .. w593.get("default", "ui") .. 'Body Yaw Mode', 'off', 'static', 'opposite', 'jitter'),
            { requires_login = true, key = 'body_yaw_mode_' .. w622, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        w592.ui['static_body_yaw_' .. w622] = w592.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Static Body Yaw', -58, 58, 0, true, '°'),
            { requires_login = true, key = 'static_body_yaw_' .. w622, tab = 'AA', visible = true, config_type = 'slider' }
        )
        w592.ui['body_yaw_value_' .. w622] = w592.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw Value', 1, 3, 2, true, '', 2, {
                [1] = 'left', [2] = 'back', [3] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_value_' .. w622, tab = 'AA', visible = true, config_type = 'slider' }
        )
        w592.ui['delay_' .. w622] = w592.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Delay', 0, 17, 1, true, 't', 1, {
                [0] = 'jitter'
            }),
            { requires_login = true, key = 'delay_' .. w622, tab = 'AA', visible = true, config_type = 'slider' }
        )
        w592.ui['label3_' .. w622] = w592.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label3_' .. w622, tab = 'AA', visible = true, config_type = 'label' }
        )
        w592.ui['fifty_fifty_' .. w622] = w592.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("question") .. w593.get("default", "ui") .. '50/50'),
            { requires_login = true, key = 'fifty_fifty_' .. w622, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        w592.ui['only_flip_on_0_choke_' .. w622] = w592.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("time") .. w593.get("default", "ui") .. 'Only Flip on 0 Choke'),
            { requires_login = true, key = 'only_flip_on_0_choke_' .. w622, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        w592.ui['aa_label_space' .. w622] = w592.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n abc'),
            { requires_login = true, key = 'aa_label_space', tab = 'AA', visible = true, config_type = 'label' }
        )
        w592.ui['aa_label_combo' .. w622] = w592.register_ui(
            ui.new_label(tab[2], cont[2][1], 'Send state -> state'),
            { requires_login = true, key = 'aa_label_combo', tab = 'AA', visible = true, config_type = 'label' }
        )
        w592.ui['send_combo' .. w622] = w592.register_ui(
            ui.new_combobox(tab[2], cont[2][1], '\n', unpack(w591)),
            { requires_login = true, key = 'send_combo' .. w622, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        w592.ui['send_button' .. w622] = w592.register_ui(
            ui.new_button(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("upload") .. w593.get("default", "ui") .. 'Send', function() end),
            { requires_login = true, key = 'send_button', tab = 'AA', visible = true, config_type = 'button' }
        )

    end


    
    
    
    w592.ui.fakelag_mode = w592.register_ui(
        ui.new_combobox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("gear") .. w593.get("default", "ui") .. 'Mode', 'defensive', 'stealer', 'fakelag', 'settings'),
        { requires_login = true, key = 'fakelag_mode', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    w592.ui.fakelag_defensive = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("turning2") .. w593.get("default", "ui") .. 'Defensive'),
        { requires_login = true, key = 'fakelag_defensive', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    w592.ui.fakelag_force = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("exclamation") .. w593.get("default", "ui") .. 'Force'),
        { requires_login = true, key = 'fakelag_force', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    w592.ui.fakelag_fakedef = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("globe") .. w593.get("default", "ui") .. 'Unmatched.gg'),
        { requires_login = true, key = 'fakelag_fakedef', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    w592.ui.fakelag_force_on = w592.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("clip") .. w593.get("default", "ui") .. 'Force whilst', 'peek', 'reload', 'shot', 'damaged'),
        { requires_login = true, key = 'fakelag_force_on', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    
    
    
    w592.ui.cfg_load_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("arrow_double") .. w593.get("default", "ui") .. 'Load', function()
            local w612= w599()
            local w613= ui.get(w592.ui.cfg_listbox)
            local w624= w612[(w613 or 0) + 1]
            local w625= ui.get(w592.ui.cfg_input_box)
            local w603= (w624 and w624 ~= '(empty)' and w624 ~= '') and w624 or w625

            if w603 and w603 ~= '' and w603 ~= '(empty)' then
                local w626= require("require/abc/config_system")
                local function w627()
                    if not w592.ui.cfg_selection then return nil end
                    local w606, w628= pcall(ui.get, w592.ui.cfg_selection)
                    if not w606 or not w628 or type(w628) ~= 'table' or #w628 == 0 then return nil end
                    local w629= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local w630= {}
                    for w608, w609 in ipairs(w628) do
                        local w600= w629[tostring(w609)]
                        if w600 then w630[#w630+1] = w600 end
                    end
                    if #w630 == 0 then return nil end
                    return w630
                end
                local w631= w627()
                w626.load(w603, w631)
                w597.screenlog('[Config] Loaded config: ' .. w603, 4, 120, 180, 255, 255)
                if w597 and w597.pushlog and w605() then
                    w597.pushlog('Loaded config: ' .. w603, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for load.')
                if w597 and w597.pushlog and w605() then
                    w597.pushlog('No config name selected for load.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_load_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    w592.ui.cfg_save_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("config") .. w593.get("default", "ui") .. 'Save', function()
            local w612= w599()
            local w613= ui.get(w592.ui.cfg_listbox)
            local w624= w612[(w613 or 0) + 1]
            local w625= ui.get(w592.ui.cfg_input_box)
            local w603= (w624 and w624 ~= '(empty)' and w624 ~= '') and w624 or w625

            if w603 and w603 ~= '' then
                local w626= require("require/abc/config_system")
                local function w627()
                    if not w592.ui.cfg_selection then return nil end
                    local w606, w628= pcall(ui.get, w592.ui.cfg_selection)
                    if not w606 or not w628 or type(w628) ~= 'table' or #w628 == 0 then return nil end
                    local w629= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local w630= {}
                    for w608, w609 in ipairs(w628) do
                        local w600= w629[tostring(w609)]
                        if w600 then w630[#w630+1] = w600 end
                    end
                    if #w630 == 0 then return nil end
                    return w630
                end
                local w631= w627()
                w626.save(w603, w631)
                local w612= w599()
                if not w602(w612, w603) then
                    w612[#w612+1] = w603
                    w601(w612)
                end
                w610(w603)
                w597.screenlog('[Config] Saved config: ' .. w603, 4, 120, 180, 255, 255)
                if w597 and w597.pushlog and w605() then
                    w597.pushlog('Saved config: ' .. w603, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name provided for save.')
                if w597 and w597.pushlog and w605() then
                    w597.pushlog('No config name provided for save.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_save_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    w592.ui.cfg_create_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("plus") .. w593.get("default", "ui") .. 'Create', function()
            local w625= ui.get(w592.ui.cfg_input_box)
            if not w625 or w625 == '' then
                client.error_log('[Config] No config name provided for create.')
                if w597 and w597.pushlog and w605() then
                    w597.pushlog('No config name provided for create.', 4, 255, 255, 255, 255)
                end
                return
            end

            local w612= w599()
            if w602(w612, w625) then
                client.error_log('[Config] Config with that name already exists: ' .. w625)
                if w597 and w597.pushlog and w605() then
                    w597.pushlog('Config already exists: ' .. w625, 4, 255, 255, 255, 255)
                end
                return
            end

            local w626= require("require/abc/config_system")
            local function w627()
                if not w592.ui.cfg_selection then return nil end
                local w606, w628= pcall(ui.get, w592.ui.cfg_selection)
                if not w606 or not w628 or type(w628) ~= 'table' or #w628 == 0 then return nil end
                local w629= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local w630= {}
                for w608, w609 in ipairs(w628) do
                    local w600= w629[tostring(w609)]
                    if w600 then w630[#w630+1] = w600 end
                end
                if #w630 == 0 then return nil end
                return w630
            end
            local w631= w627()
            w626.save(w625, w631)
            w612[#w612+1] = w625
            w601(w612)
            w610(w625)
            w597.screenlog('[Config] Created config: ' .. w625, 4, 120, 180, 255, 255)
            if w597 and w597.pushlog and w605() then
                w597.pushlog('Created config: ' .. w625, 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_create_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    w592.ui.cfg_delete_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][1], w593.get("red", "ui") .. w595.get("trash") .. w593.get("default", "ui") .. 'Delete', function()
            local w612= w599()
            local w613= ui.get(w592.ui.cfg_listbox)
            local w624= w612[(w613 or 0) + 1]
            local w625= ui.get(w592.ui.cfg_input_box)
            local w603= (w624 and w624 ~= '(empty)' and w624 ~= '') and w624 or w625

            if w603 and w603 ~= '' and w603 ~= '(empty)' then
                local w626= require("require/abc/config_system")
                w626.delete(w603)
                local w612= w599()
                local w613= w602(w612, w603)
                if w613 then
                    table.remove(w612, w613)
                    w601(w612)
                end
                w610()
                w597.screenlog('[Config] Deleted config: ' .. w603, 4, 255, 80, 80, 255)
                if w597 and w597.pushlog and w605() then
                    w597.pushlog('Deleted config: ' .. w603, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for delete.')
                if w597 and w597.pushlog and w605() then
                    w597.pushlog('No config name selected for delete.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_delete_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    w592.ui.cfg_refresh_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("turning") .. w593.get("default", "ui") ..'Refresh', function()
            w610()
            w597.screenlog('[Config] Refreshed config list.', 4, 120, 180, 255, 255)
            if w597 and w597.pushlog and w605() then
                w597.pushlog('Refreshed config list.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_refresh_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    
    local w626= require("require/abc/config_system")
    local w632, w633= pcall(require, 'gamesense/clipboard')
    local w634= w633
    if not w632 or not w634 then
        w634 = {
            set = function(w608) end,
            get = function() return '' end,
        }
    end


    w592.ui.cfg_export_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("upload") .. w593.get("default", "ui") .. 'Export', function()
            local function w627()
                if not w592.ui.cfg_selection then return nil end
                local w606, w628= pcall(ui.get, w592.ui.cfg_selection)
                if not w606 or not w628 or type(w628) ~= 'table' or #w628 == 0 then return nil end
                local w629= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local w630= {}
                for w608, w609 in ipairs(w628) do
                    local w600= w629[tostring(w609)]
                    if w600 then w630[#w630+1] = w600 end
                end
                if #w630 == 0 then return nil end
                return w630
            end
            local w631= w627()
            local w635= w626.build(w631)
            w634.set(w635)
            client.log('[Config] Exported config string:')
            client.log(w635)
            w597.screenlog('[Config] Exported config string to clipboard and console.', 4, 120, 180, 255, 255)
            if w597 and w597.pushlog and w605() then
                w597.pushlog('Exported config string to clipboard.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_export_button', tab = 'CFG', visible = true, config_type = 'button' }
    )

    w592.ui.cfg_import_button = w592.register_ui(
        ui.new_button(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("download") .. w593.get("default", "ui") .. 'Import', function()
            local w636= w634.get()
            if w636 and w636 ~= '' then
                local function w627()
                    if not w592.ui.cfg_selection then return nil end
                    local w606, w628= pcall(ui.get, w592.ui.cfg_selection)
                    if not w606 or not w628 or type(w628) ~= 'table' or #w628 == 0 then return nil end
                    local w629= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local w630= {}
                    for w608, w609 in ipairs(w628) do
                        local w600= w629[tostring(w609)]
                        if w600 then w630[#w630+1] = w600 end
                    end
                    if #w630 == 0 then return nil end
                    return w630
                end
                local w631= w627()
                w626.apply(w636, w631)
                w597.screenlog('[Config] Imported config string from clipboard.', 4, 120, 180, 255, 255)
                if w597 and w597.pushlog and w605() then
                    w597.pushlog('Imported config string from clipboard.', 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config string found in clipboard.')
                if w597 and w597.pushlog and w605() then
                    w597.pushlog('No config string found in clipboard for import.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_import_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    w592.ui.cfg_selection = w592.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\n selection', 'antiaim', 'paint', 'misc'),
        { requires_login = true, key = 'cfg_selection', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    w592.ui.cfg_input_box = w592.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Config name'),
        { requires_login = true, key = 'cfg_input_box', tab = 'CFG', visible = true, config_type = 'textbox' }
    )
    w592.ui.cfg_listbox = w592.register_ui(
        ui.new_listbox(tab[2], cont[2][1], 'Configs', {}),
        { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    w610()

    w592.ui.cfg_cloud_apply = w592.register_ui(
        ui.new_button(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("globe") .. w593.get("default", "ui") .. ' Apply cloud', function()
            local w606, w628= pcall(ui.get, w592.ui.cfg_cloud)
            if not w606 then
                client.log('cfg_cloud_apply: failed to read selection')
                return
            end

            local w637= { 'Reset', 'Defensive', 'Unmatched', 'Community' }
            local w603= nil

            if type(w628) == 'number' then
                local w613= w628 + 1
                w603 = w637[w613]
            elseif type(w628) == 'table' then
                if #w628 > 0 and type(w628[1]) == 'number' then
                    w603 = w637[w628[1] + 1]
                else
                    w603 = tostring(w628[1])
                end
            else
                w603 = tostring(w628)
            end

            if not w603 or w603 == '' then
                client.log('cfg_cloud_apply: no selection')
                return
            end

            local w638, w639= pcall(require, 'require/abc/config_cloud')
            if not w638 or not w639 then
                client.log('cfg_cloud_apply: failed to load config_cloud module')
                return
            end

            local w640= w639[w603]
            if not w640 then
                client.log('cfg_cloud_apply: no cloud config string for', tostring(w603))
                return
            end

            local w641, w626= pcall(require, 'require/abc/config_system')
            if not w641 or not w626 or not w626.apply then
                client.log('cfg_cloud_apply: config_system.apply not available')
                return
            end

            w626.apply(w640)
            client.log('cfg_cloud_apply: applied cloud config', tostring(w603))
        end),
        { requires_login = true, key = 'cfg_cloud_apply', tab = 'AA', visible = true, config_type = 'button' }
    )

    w592.ui.cfg_cloud = w592.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'Cloud', { w593.get("red", "ui") .. 'Reset', w593.get("reddark", "ui") .. 'Defensive', w593.get("yellow", "ui") .. 'Unmatched', w593.get("grey", "ui") .. 'Community'}),
        { requires_login = true, key = 'cfg_cloud', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    w592.ui.fakelag_stealer = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("download") .. w593.get("default", "ui") .. 'Stealer' .. w593.get("blue", "ui") .. ' [BETA]' ),
        { requires_login = true, key = 'fakelag_stealer', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    w592.ui.fakelag_stealer_type = w592.register_ui(
        ui.new_combobox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("gear") .. w593.get("default", "ui") .. 'Type', 'mimic', 'import'),
        { requires_login = true, key = 'fakelag_stealer_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    w592.ui.fakelag_stealer_target = w592.register_ui(
        ui.new_combobox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("id") .. w593.get("default", "ui") .. 'Target', 'threat', 'closest', 'random', 'best kdas'),
        { requires_login = true, key = 'fakelag_stealer_target', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    w592.ui.fakelag_stealer_list = w592.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'target list', {'-'}),
        { requires_login = true, key = 'fakelag_stealer_list', tab = 'AA', visible = true, config_type = 'listbox' }
    )
    w592.ui.fakelag_stealer_refresh = w592.register_ui(
        ui.new_button(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("refresh") .. w593.get("default", "ui") .. 'Refresh', function() end),
        { requires_login = true, key = 'fakelag_stealer_refresh', tab = 'AA', visible = true, config_type = 'button' }
    )
    w592.ui.fakelag_stealer_steal = w592.register_ui(
        ui.new_button(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("clip") .. w593.get("default", "ui") .. 'Steal', function() end),
        { requires_login = true, key = 'fakelag_stealer_steal', tab = 'AA', visible = true, config_type = 'button' }
    )
    w592.ui.fakelag_fakelag = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("latency3") .. w593.get("default", "ui") .. 'Fakelag'),
        { requires_login = true, key = 'fakelag_fakelag', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    w592.ui.fakelag_fakelag_type = w592.register_ui(
        ui.new_combobox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("gear") .. w593.get("default", "ui") .. 'Type', 'gamesense', 'sodium'),
        { requires_login = true, key = 'fakelag_fakelag_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    w592.ui.fakelag_fakelag_amount = w592.register_ui(
        ui.new_combobox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("plus") .. w593.get("default", "ui") .. 'Amount', 'dynamic', 'maximum', 'fluctuate'),
        { requires_login = true, key = 'fakelag_fakelag_amount', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    w592.ui.fakelag_fakelag_variance = w592.register_ui(
        ui.new_slider(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("recycle") .. w593.get("default", "ui") .. 'Variance', 0, 100, 0, true, '%'),
        { requires_login = true, key = 'fakelag_fakelag_variance', tab = 'AA', visible = true, config_type = 'slider' }
    )
    w592.ui.fakelag_fakelag_limit = w592.register_ui(
        ui.new_slider(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("lock") .. w593.get("default", "ui") .. 'Limit', 1, 15, 1, true, 't'),
        { requires_login = true, key = 'fakelag_fakelag_limit', tab = 'AA', visible = true, config_type = 'slider' }
    )
    w592.ui.fakelag_fakelag_type2 = w592.register_ui(
        ui.new_combobox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("config") .. w593.get("default", "ui") .. 'Preset', 'jitter', 'max'),
        { requires_login = true, key = 'fakelag_fakelag_type2', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    w592.ui.fakelag_settings_freestanding = w592.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("turning2") .. w593.get("default", "ui") .. 'Freestanding options', 'static', 'zero pitch', 'defensive', 'side flip', 'pitch flip'),
        { requires_login = true, key = 'fakelag_settings_freestanding', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    w592.ui.fakelag_settings_enhance_onshot = w592.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("arrow_double") .. w593.get("default", "ui") .. 'Enhance on-shot aa', 'defensive', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_enhance_onshot', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    w592.ui.fakelag_settings_antibrute = w592.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("exclamation") .. w593.get("default", "ui") .. 'Antibrute', 'defensive', 'flip', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_antibrute', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    w592.ui.fakelag_settings_roll_checkbox = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], '\nuse roll'),
        { requires_login = true, key = 'fakelag_settings_roll_checkbox', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    w592.ui.fakelag_settings_roll_label = w592.register_ui(
        ui.new_label(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("recycle") .. w593.get("default", "ui") .. 'Roll'),
        { requires_login = false, key = 'label_roll', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.fakelag_settings_roll = w592.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nroll', 0, 45, 0, true, '°'),
        { requires_login = true, key = 'fakelag_settings_roll', tab = 'AA', visible = true, config_type = 'slider' }
    )
    w592.ui.fakelag_settings_side = w592.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nside', 1, 3, 1, true, '', 1, {
            [1] = 'left', [2] = 'swap', [3] = 'right'
        }),
        { requires_login = true, key = 'fakelag_settings_side', tab = 'AA', visible = true, config_type = 'slider' }
    )

    
    
    
    w592.ui.paint_advertisement = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nadvertisement', true),
        { requires_login = true, key = 'paint_advertisement', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_advertisement_animation = w592.register_ui(
        ui.new_slider(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("speaker") .. w593.get("default", "ui") .. 'Advertisement', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_advertisement_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    w592.ui.paint_advertisement_color = w592.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'rizz546456', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_advertisement_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    w592.ui.paint_watermark = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nwatermark'),
        { requires_login = true, key = 'paint_watermark', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_watermark_type = w592.register_ui(
        ui.new_slider(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("text") .. w593.get("default", "ui") .. 'Watermark', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_watermark_type', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    w592.ui.paint_watermark_color = w592.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'sigma9745', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_watermark_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    w592.ui.label_space2 = w592.register_ui(
        ui.new_label(tab[2], cont[2][1], '\n abc'),
        { requires_login = false, key = 'label_space2', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.label_space3 = w592.register_ui(
        ui.new_label(tab[2], cont[2][1], w593.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space3', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.paint_entidx = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'entidx'),
        { requires_login = true, key = 'paint_entidx', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_target_info = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'target info'),
        { requires_login = true, key = 'paint_target_info', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_filter_console = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'filter console'),
        { requires_login = true, key = 'paint_filter_console', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_minimum_damage = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'minimum damage'),
        { requires_login = true, key = 'paint_minimum_damage', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_show_damage_penetration = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'show damage penetration'),
        { requires_login = true, key = 'paint_show_damage_penetration', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_hitmiss_indicator = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'hit/miss indicator'),
        { requires_login = true, key = 'paint_hitmiss_indicator', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_self_skeleton = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'self skeleton'),
        { requires_login = true, key = 'paint_self_skeleton', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_bullet_tracer = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'bullet tracer'),
        { requires_login = true, key = 'paint_bullet_tracer', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_lagcomp_box = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lagcomp box'),
        { requires_login = true, key = 'paint_lagcomp_box', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_lagcomp_box_color = w592.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'lagcomp box color', 47, 117, 221, 255),
        { requires_login = true, key = 'paint_lagcomp_box_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    w592.ui.paint_presmoke = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'presmoke warning'),
        { requires_login = true, key = 'paint_presmoke', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_bombwarning = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'c4 warning'),
        { requires_login = true, key = 'paint_bombwarning', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_insults = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'insults'),
        { requires_login = true, key = 'paint_insults', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_rainbow_esp = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'rainbow esp'),
        { requires_login = true, key = 'paint_rainbow_esp', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_molotov = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'molotov particles'),
        { requires_login = true, key = 'paint_molotov', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_lag_record = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lag record'),
        { requires_login = true, key = 'paint_lag_record', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.label_space4 = w592.register_ui(
        ui.new_label(tab[2], cont[2][1], w593.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space4', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.paint_clantag = w592.register_ui(
        ui.new_combobox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("id") .. w593.get("default", "ui") .. 'Clantag', 'off', 'gamesense', 'sodium'),
        { requires_login = true, key = 'paint_clantag', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    w592.ui.paint_aimbot_logs = w592.register_ui(
        ui.new_combobox(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("clipboard") .. w593.get("default", "ui") .. 'Aimbot logs', 'off', 'gamesense', 'gamesense beta', 'sodium'),
        { requires_login = true, key = 'paint_aimbot_logs', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    w592.ui.label_space1 = w592.register_ui(
        ui.new_label(tab[2], cont[2][1], '\nextra space'),
        { requires_login = false, key = 'label_space1', tab = 'AA', visible = true, config_type = 'label' }
    )
    
    w592.ui.paint_indicators_enable = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n enable'),
        { requires_login = true, key = 'paint_indicators_enable', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_indicators_label = w592.register_ui(
        ui.new_label(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("pallete") .. w593.get("default", "ui") .. 'Indicators'),
        { requires_login = false, key = 'paint_indicators_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.paint_indicators = w592.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nIndicators', 'off', 'small', 'bold'),
        { requires_login = true, key = 'paint_indicators', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    w592.ui.paint_indicator_color = w592.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_indicator_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    w592.ui.paint_indicators_bar = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n bar'),
        { requires_login = true, key = 'paint_indicators_bar', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_indicators_animation = w592.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_indicators_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    w592.ui.paint_logger_checkbox = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n abc'),
        { requires_login = true, key = 'paint_logger_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_logger_label = w592.register_ui(
        ui.new_label(tab[2], cont[2][1], w593.get("green", "ui") .. w595.get("pen") .. w593.get("default", "ui") .. 'Logger'),
        { requires_login = false, key = 'paint_logger_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    w592.ui.paint_logger = w592.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\nLogger', 'aimbot', 'config', 'anti-aim', 'other'),
        { requires_login = true, key = 'paint_logger', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    w592.ui.paint_logger_color = w592.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_logger_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    w592.ui.paint_logger_animation = w592.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_logger_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    w592.ui.paint_hitmarker = w592.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("reject") .. w593.get("default", "ui") .. 'Hitmarkers', 'world +', 'skeleton', 'damage'),
        { requires_login = true, key = 'paint_hitmarker', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    w592.ui.paint_hitmarker_color = w592.register_ui(
        ui.new_color_picker(tab[2], cont[2][2], '\n + color', 0, 225, 225, 255),
        { requires_login = true, key = 'paint_hitmarker_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    w592.ui.paint_warnings = w592.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("warning") .. w593.get("default", "ui") .. 'Warnings', 'lethal', 'cant fire', 'low bullets'),
        { requires_login = true, key = 'paint_warnings', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    w592.ui.paint_performance_mode = w592.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("latency4") .. w593.get("default", "ui") .. 'Performance mode', 'blood', 'ragdolls', 'particles', 'lens flare', 'animations', 'feature updates'),
        { requires_login = true, key = 'paint_performance_mode', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    w592.ui.paint_animations = w592.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], w593.get("green", "ui") .. w595.get("turning2") .. w593.get("default", "ui") .. 'Animations', 'kingaru', 'body lean', 'gamesense legs', 'moonwalk', 'allah', 'static legs', 'no pitch on land', 'reversed legs', 'earthquake', 't-pose', 'blind', 'pitch up'),
        { requires_login = true, key = 'paint_animations', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    w592.ui.paint_aspect_ratio_checkbox = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], w593.get("green", "ui") .. w595.get("expand") .. w593.get("default", "ui") .. 'Aspect ratio'),
        { requires_login = true, key = 'paint_aspect_ratio_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_aspect_ratio = w592.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\naspect ratio', 0, 300, 0, true, '', 0.01, {
            [0] = 'default', [125] = '5:4', [133] = '4:3', [150] = '3:2', [160] = '16:10', [177] = '16:9'
        }),
        { requires_login = true, key = 'paint_aspect_ratio', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    w592.ui.paint_third_person_distance_checkbox = w592.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], w593.get("green", "ui") .. w595.get("camera") .. w593.get("default", "ui") .. 'Third person distance'),
        { requires_login = true, key = 'paint_third_person_distance_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    w592.ui.paint_third_person_distance = w592.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\nthird person distance', 30, 166, 150, true, '', 1, {
            [150] = 'default'
        }),
        { requires_login = true, key = 'paint_third_person_distance', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    
    
    
    
    local w642= {
        checkbox = 'c',
        slider = 's',
        combobox = 'o',
        multiselect = 'm',
    }
    for w643, w644 in pairs(w592.ui) do
        for w608, w645 in ipairs(w592.registered_items or {}) do
            if w645.key == w643 and w645.config_type and w642[w645.config_type] then
                w626.register(w643, w644, w642[w645.config_type], w645.tab)
            end
        end
    end
end

return w596]]
w207["require/abc/callbacks"] = [[




local w594= {}

local w595= 1
local w596= {}          
local w597= {}      
local w598= {}   

local function w599()
	local w600, w601= pcall(require, "require/abc/login_system")
	if not w600 or not w601 then return false end
	return w601.logged_in == true
end

local function w602(w603)
	if not w603 then return true end
	if w603.menu_only and not (ui and ui.is_menu_open and ui.is_menu_open()) then return false end
	if w603.alive_only then
		local w604= (entity and entity.get_local_player) and entity.get_local_player()
		if not w604 or not entity.is_alive(w604) then return false end
	end
	if w603.require_login then
		if not w599() then return false end
	end
	return true
end

local function w605(w606)
	return function(w607)
		local w608= w597[w606]
		if not w608 then return end
		local w609= {}
		for w610=1,#w608 do w609[w610] = w608[w610] end
		for w610=1,#w609 do
			local w611= w609[w610]
			local w612= w596[w611]
			if w612 and w612.wrapper then
				local w600, w613= pcall(w612.wrapper, w607)
				if not w600 then
					local w614= nil
					pcall(function()
						w614 = debug.getinfo(w612.user_fn, "Sln")
					end)
					local w615= w614 and w614.short_src or "<unknown>"
					local w616= w614 and (w614.linedefined or -1) or -1
					pcall(client.error_log, string.format("callback[%d] error: %s (source=%s:%d)", w611, tostring(w613), w615, w616))
				end
			end
		end
	end
end



function w594.register(w606,w617,w618,w619,w620)
	if type(w606) ~= 'string' then error('event must be a string') end
	if type(w617) ~= 'function' then error('callback must be a function') end

	local w603= nil
	if type(w618) == 'table' then w603 = w618
	else
		w603 = { menu_only = (w618 == true), alive_only = (w619 == true), require_login = (w620 == true) }
	end

	local w611= w595; w595 = w595 + 1
	local w621= function(w607)
		if w602(w603) then
			return w617(w607)
		end
	end

	w596[w611] = { event = w606, wrapper = w621, user_fn = w617, opts = w603 }
	w597[w606] = w597[w606] or {}
	w597[w606][#w597[w606] + 1] = w611

	
	if not w598[w606] then
		local w622= w605(w606)
		w598[w606] = w622
		pcall(client.set_event_callback, w606, w622)
	end

	return w611
end

function w594.callback(w606,w618,w619,w620,w623)
	if type(w618) == 'function' then
		return w594.register(w606, w618, w619)
	end
	if type(w623) == 'function' then
		local w617= w623
		local w603= { menu_only = (w618 == true), alive_only = (w619 == true), require_login = (w620 == true) }
		return w594.register(w606, w617, w603)
	end
	error('invalid callback signature')
end

function w594.unregister(w611)
	local w612= w596[w611]
	if not w612 then return false end
	local w606= w612.event
	w596[w611] = nil
	local w624= w597[w606]
	if w624 then
		for w610=#w624,1,-1 do if w624[w610] == w611 then table.remove(w624, w610) end end
		if #w624 == 0 then
			w597[w606] = nil
			local w622= w598[w606]
			if w622 then pcall(client.unset_event_callback, w606, w622) end
			w598[w606] = nil
		end
	end
	return true
end

function w594.clear_all()
	for w606, w622 in pairs(w598) do
		pcall(client.unset_event_callback, w606, w622)
	end
	w596 = {}
	w597 = {}
	w598 = {}
end

function w594._list()
	return { regs = w596, by_event = w597 }
end

pcall(function()
	if lua and lua.defer then
		lua.defer(w594.clear_all)
	else
		pcall(client.set_event_callback, 'shutdown', w594.clear_all)
	end
end)

return w594
]]
w207["require/abc/config_cloud"] = [[local w597= {
    Reset = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfbW92ZXx0PW98dj1vZmYKeWF3X2Zha2VsYWd8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wK3x0PXN8dj0wCmZha2VsYWdfc2V0dGluZ3Nfc2lkZXx0PXN8dj0xCnBpdGNoX21vdmV8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbW92ZXx0PXN8dj0wCmZha2VsYWdfZm9yY2Vfb258dD1tfHY9CmZha2VsYWdfZGVmZW5zaXZlfHQ9Y3x2PWZhbHNlCnlhd193YWxrfHQ9b3x2PW9mZgpzdGF0aWNfYm9keV95YXdfZmFrZWxhZ3x0PXN8dj0wCnBpdGNoX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfanVtcHx0PXN8dj0yCmJvZHlfeWF3X21vZGVfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXArfHQ9c3x2PTIKeWF3X2ppdHRlcl9iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfYmFzZV9kdWNrK3x0PW98dj10YXJnZXQKb25seV9mbGlwX29uXzBfY2hva2VfZHVjayt8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PWZhbHNlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9MApib2R5X3lhd19sZWZ0X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19zdGFuZHx0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19nbG9iYWx8dD1zfHY9MApwaXRjaF9kdWNrfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PW9mZgp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRhcmdldApmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wfHQ9c3x2PTAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PQpzZW5kX2NvbWJvanVtcHx0PW98dj1nbG9iYWwKc2VuZF9jb21ib2p1bXArfHQ9b3x2PWdsb2JhbApvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj1mYWxzZQpzdGF0aWNfYm9keV95YXdfbW92ZXx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVjayt8dD1zfHY9MAp5YXdfYmFzZV9nbG9iYWx8dD1vfHY9dGFyZ2V0CmVuYWJsZV9sZWdpdHx0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PQpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9kdWNrK3x0PXN8dj0yCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfdmFsdWVfbGVnaXR8dD1zfHY9Mgpib2R5X3lhd19iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfanVtcCt8dD1vfHY9b2ZmCmRlbGF5X3dhbGt8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdHlwZTJ8dD1vfHY9aml0dGVyCnlhd19sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9zdGFuZHx0PXN8dj0wCmVuYWJsZV9qdW1wK3x0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZmFrZWxhZ3x0PW98dj1nbG9iYWwKeWF3X2ppdHRlcl9iYXNlX2R1Y2t8dD1zfHY9MApmaWZ0eV9maWZ0eV9qdW1wfHQ9Y3x2PWZhbHNlCnBpdGNoX2xlZ2l0fHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfc3RhbmR8dD1zfHY9MAp5YXdfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfanVtcHx0PW98dj1vZmYKYm9keV95YXdfcmlnaHRfZHVja3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVjayt8dD1zfHY9MApib2R5X3lhd19tb2RlX3dhbGt8dD1vfHY9b2ZmCmJvZHlfeWF3X3JpZ2h0X2p1bXArfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10YXJnZXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj1mYWxzZQp5YXdfanVtcHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV93YWxrfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19nbG9iYWx8dD1zfHY9MApmaWZ0eV9maWZ0eV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfbW92ZXx0PW98dj1vZmYKeWF3X2Jhc2VfanVtcCt8dD1vfHY9dGFyZ2V0CnBpdGNoX2R1Y2srfHQ9b3x2PW1pbmltYWwKYm9keV95YXdfbW9kZV9qdW1wK3x0PW98dj1vZmYKc2VuZF9jb21ib2R1Y2t8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfZmFrZWxhZ3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVja3x0PW98dj1vZmYKZmFrZWxhZ19zdGVhbGVyX3RhcmdldHx0PW98dj10aHJlYXQKZmlmdHlfZmlmdHlfZHVjayt8dD1jfHY9ZmFsc2UKb25seV9mbGlwX29uXzBfY2hva2VfanVtcHx0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTAKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0wCmRlbGF5X2R1Y2srfHQ9c3x2PTEKYm9keV95YXdfbW9kZV9sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfZHVja3x0PXN8dj0yCmVuYWJsZV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PW9mZgp5YXdfYmFzZV9zdGFuZHx0PW98dj10YXJnZXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PW9mZgp5YXdfaml0dGVyX3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2xlZ2l0fHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19iYXNlX2xlZ2l0fHQ9b3x2PXRhcmdldApzdGF0aWNfYm9keV95YXdfd2Fsa3x0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X2Zha2VsYWd8dD1zfHY9MApkZWxheV9kdWNrfHQ9c3x2PTEKZmFrZWxhZ19zZXR0aW5nc19yb2xsfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2xpbWl0fHQ9c3x2PTEKZmFrZWxhZ19mYWtlbGFnX3ZhcmlhbmNlfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2Ftb3VudHx0PW98dj1keW5hbWljCmZha2VsYWdfZmFrZWxhZ190eXBlfHQ9b3x2PWdhbWVzZW5zZQpyYW5kb21pemVfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9nbG9iYWx8dD1zfHY9MApyYW5kb21pemVfeWF3X3dhbGt8dD1zfHY9MApjZmdfc2VsZWN0aW9ufHQ9bXx2PWFudGlhaW0KYm9keV95YXdfdmFsdWVfbW92ZXx0PXN8dj0yCmZpZnR5X2ZpZnR5X21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfbW92ZXx0PWN8dj1mYWxzZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ3x0PWN8dj1mYWxzZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfd2Fsa3x0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9zdGFuZHx0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZHVjayt8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnlhd19qaXR0ZXJfanVtcCt8dD1vfHY9b2ZmCnlhd19iYXNlX2p1bXB8dD1vfHY9dGFyZ2V0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKcGl0Y2hfanVtcCt8dD1vfHY9b2ZmCnlhd19kdWNrfHQ9b3x2PW9mZgpkZWxheV9qdW1wK3x0PXN8dj0xCmRlbGF5X3N0YW5kfHQ9c3x2PTEKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj0wCmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVja3x0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10YXJnZXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9MApib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgpib2R5X3lhd19sZWZ0X2dsb2JhbHx0PXN8dj0wCmRlbGF5X21vdmV8dD1zfHY9MQpkZWxheV9qdW1wfHQ9c3x2PTEKZW5hYmxlX2p1bXB8dD1jfHY9ZmFsc2UKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PTAKYm9keV95YXdfbGVmdF9qdW1wK3x0PXN8dj0wCnlhd19tb3ZlfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PWZhbHNlCmZha2VsYWdfZmFrZWRlZnx0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX2dsb2JhbHx0PW98dj1vZmYKZmlmdHlfZmlmdHlfanVtcCt8dD1jfHY9ZmFsc2UKY29uZGl0aW9ufHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X21vdmV8dD1zfHY9MApkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PWZhbHNl0000',
    Defensive = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9dHJ1ZQp5YXdfd2Fsa3x0PW98dj0xODAKc3RhdGljX2JvZHlfeWF3X2Zha2VsYWd8dD1zfHY9MApwaXRjaF9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXB8dD1zfHY9Mgpib2R5X3lhd19tb2RlX3N0YW5kfHQ9b3x2PWppdHRlcgpib2R5X3lhd192YWx1ZV9qdW1wK3x0PXN8dj0yCnlhd19qaXR0ZXJfYmFzZV9mYWtlbGFnfHQ9c3x2PTAKeWF3X2Jhc2VfZHVjayt8dD1vfHY9dGhyZWF0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2srfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PXRydWUKZGVsYXlfbGVnaXR8dD1zfHY9MQp5YXdfc3RhbmR8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVja3x0PXN8dj0wCmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKcGl0Y2hfZHVja3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfZHVjayt8dD1vfHY9aml0dGVyCnlhd19iYXNlX21vdmV8dD1vfHY9dGhyZWF0CmZha2VsYWdfbW9kZXx0PW98dj1zZXR0aW5ncwpwaXRjaF93YWxrfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9iYXNlX2p1bXB8dD1zfHY9MTIwCnNlbmRfY29tYm93YWxrfHQ9b3x2PWdsb2JhbApmYWtlbGFnX3NldHRpbmdzX2ZyZWVzdGFuZGluZ3x0PW18dj1zdGF0aWMJemVybyBwaXRjaAlkZWZlbnNpdmUJc2lkZSBmbGlwCnNlbmRfY29tYm9qdW1wfHQ9b3x2PWdsb2JhbApzZW5kX2NvbWJvanVtcCt8dD1vfHY9Z2xvYmFsCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXArfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9dHJ1ZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PWRlZmVuc2l2ZQlyb2xsCWppdHRlcgpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9MgpzZW5kX2NvbWJvbGVnaXR8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfbGVnaXR8dD1zfHY9LTU4Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTQKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9MApyYW5kb21pemVfeWF3X2R1Y2srfHQ9c3x2PTAKYm9keV95YXdfbW9kZV93YWxrfHQ9b3x2PXN0YXRpYwpib2R5X3lhd19yaWdodF9qdW1wK3x0PXN8dj0zNwpvbmx5X2ZsaXBfb25fMF9jaG9rZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmZha2VsYWdfc2V0dGluZ3NfYW50aWJydXRlfHQ9bXx2PQp5YXdfYmFzZV93YWxrfHQ9b3x2PXRocmVhdApmYWtlbGFnX3N0ZWFsZXJ8dD1jfHY9ZmFsc2UKZW5hYmxlX3N0YW5kfHQ9Y3x2PXRydWUKeWF3X2p1bXB8dD1vfHY9MTgwCmJvZHlfeWF3X2Jhc2Vfd2Fsa3x0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19zdGFuZHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZ2xvYmFsfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZHVja3x0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX21vdmV8dD1vfHY9aml0dGVyCnlhd19iYXNlX2p1bXArfHQ9b3x2PXRocmVhdApwaXRjaF9kdWNrK3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2p1bXB8dD1zfHY9MTgKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0tMwpkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjcKc2VuZF9jb21ib21vdmV8dD1vfHY9Z2xvYmFsCnJhbmRvbWl6ZV95YXdfbW92ZXx0PXN8dj0wCnBpdGNoX2p1bXB8dD1vfHY9ZG93bgp5YXdfYmFzZV9zdGFuZHx0PW98dj10aHJlYXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9zdGFuZHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2dsb2JhbHx0PWN8dj1mYWxzZQp5YXdfYmFzZV9sZWdpdHx0PW98dj10aHJlYXQKc3RhdGljX2JvZHlfeWF3X3dhbGt8dD1zfHY9MApib2R5X3lhd19yaWdodF9mYWtlbGFnfHQ9c3x2PTAKZGVsYXlfZHVja3x0PXN8dj01CmZha2VsYWdfc2V0dGluZ3Nfcm9sbHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19saW1pdHx0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ192YXJpYW5jZXx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19hbW91bnR8dD1vfHY9ZHluYW1pYwpmYWtlbGFnX2Zha2VsYWdfdHlwZXx0PW98dj1zb2RpdW0KcmFuZG9taXplX3lhd19qdW1wfHQ9c3x2PTAKeWF3X2ppdHRlcl9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKcmFuZG9taXplX3lhd193YWxrfHQ9c3x2PTAKY2ZnX3NlbGVjdGlvbnx0PW18dj1hbnRpYWltCmJvZHlfeWF3X3ZhbHVlX21vdmV8dD1zfHY9MgpmaWZ0eV9maWZ0eV9tb3ZlfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfYmFzZV9kdWNrK3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX21vdmV8dD1jfHY9dHJ1ZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0yNApmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV93YWxrfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCnNlbmRfY29tYm9kdWNrK3x0PW98dj1nbG9iYWwKYm9keV95YXdfcmlnaHRfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9qdW1wK3x0PW98dj1vZmYKeWF3X2Jhc2VfanVtcHx0PW98dj10aHJlYXQKb25seV9mbGlwX29uXzBfY2hva2VfbGVnaXR8dD1jfHY9dHJ1ZQpib2R5X3lhd19tb2RlX2R1Y2t8dD1vfHY9c3RhdGljCnN0YXRpY19ib2R5X3lhd19sZWdpdHx0PXN8dj0wCnBpdGNoX2p1bXArfHQ9b3x2PWRvd24KeWF3X2R1Y2t8dD1vfHY9MTgwCmRlbGF5X2p1bXArfHQ9c3x2PTMKZGVsYXlfc3RhbmR8dD1zfHY9NApmYWtlbGFnX2ZvcmNlfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X3JpZ2h0X2R1Y2srfHQ9c3x2PTQ0CmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0tMTUKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTE0Cnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9NTgKYm9keV95YXdfdmFsdWVfZ2xvYmFsfHQ9c3x2PTIKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApkZWxheV9tb3ZlfHQ9c3x2PTEKZGVsYXlfanVtcHx0PXN8dj0xCmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTQKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PS0xNgpib2R5X3lhd19sZWZ0X2p1bXArfHQ9c3x2PS05Cnlhd19tb3ZlfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PS0xNQpzdGF0aWNfYm9keV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3dhbGt8dD1jfHY9dHJ1ZQpmYWtlbGFnX2Zha2VkZWZ8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9nbG9iYWx8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmNvbmRpdGlvbnx0PW98dj1zdGFuZApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfbW92ZXx0PXN8dj00MgpkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PXRydWU00=',
    Unmatched = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9MgplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9ZmFsc2UKeWF3X3dhbGt8dD1vfHY9MTgwCnN0YXRpY19ib2R5X3lhd19mYWtlbGFnfHQ9c3x2PTAKcGl0Y2hfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9qdW1wfHQ9c3x2PTIKYm9keV95YXdfbW9kZV9zdGFuZHx0PW98dj1qaXR0ZXIKYm9keV95YXdfdmFsdWVfanVtcCt8dD1zfHY9Mgp5YXdfaml0dGVyX2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19iYXNlX2R1Y2srfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV9kdWNrK3x0PWN8dj10cnVlCnlhd19iYXNlX2Zha2VsYWd8dD1vfHY9dGFyZ2V0CnNlbmRfY29tYm9nbG9iYWx8dD1vfHY9Z2xvYmFsCnN0YXRpY19ib2R5X3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3dhbGt8dD1zfHY9MgplbmFibGVfd2Fsa3x0PWN8dj10cnVlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9LTM0CmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIxCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX3dhbGt8dD1zfHY9MApib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PWppdHRlcgpmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9ZG93bgp5YXdfaml0dGVyX2Jhc2VfanVtcHx0PXN8dj0xMjAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PXN0YXRpYwlkZWZlbnNpdmUKc2VuZF9jb21ib2p1bXB8dD1vfHY9Z2xvYmFsCnNlbmRfY29tYm9qdW1wK3x0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9ZmFsc2UKZmFrZWxhZ19zZXR0aW5nc19lbmhhbmNlX29uc2hvdHx0PW18dj1kZWZlbnNpdmUJcm9sbAlqaXR0ZXIKc3RhdGljX2JvZHlfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2Jhc2VfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF93YWxrfHQ9c3x2PTIzCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTIKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9NDQKcmFuZG9taXplX3lhd19kdWNrK3x0PXN8dj0wCmJvZHlfeWF3X21vZGVfd2Fsa3x0PW98dj1zdGF0aWMKYm9keV95YXdfcmlnaHRfanVtcCt8dD1zfHY9NTQKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10aHJlYXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj10cnVlCnlhd19qdW1wfHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3dhbGt8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfc3RhbmR8dD1zfHY9MApyYW5kb21pemVfeWF3X2dsb2JhbHx0PXN8dj0wCmZpZnR5X2ZpZnR5X2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9tb3ZlfHQ9b3x2PWppdHRlcgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9zdGFuZHx0PWN8dj10cnVlCmJvZHlfeWF3X2Jhc2VfanVtcHx0PXN8dj03CmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTI0CnJhbmRvbWl6ZV95YXdfZmFrZWxhZ3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfanVtcCt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9zdGFuZHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfanVtcCt8dD1zfHY9MApkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PWRvd24KeWF3X2Jhc2Vfc3RhbmR8dD1vfHY9dGhyZWF0Cnlhd19qaXR0ZXJfZmFrZWxhZ3x0PW98dj1vZmYKc2VuZF9jb21ib3N0YW5kfHQ9b3x2PWdsb2JhbApwaXRjaF9zdGFuZHx0PW98dj1kb3duCnlhd19qaXR0ZXJfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbGVnaXR8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV9nbG9iYWx8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfbGVnaXR8dD1vfHY9dGFyZ2V0CnN0YXRpY19ib2R5X3lhd193YWxrfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfZmFrZWxhZ3x0PXN8dj0wCmRlbGF5X2R1Y2t8dD1zfHY9NQpmYWtlbGFnX3NldHRpbmdzX3JvbGx8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfbGltaXR8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdmFyaWFuY2V8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfYW1vdW50fHQ9b3x2PWR5bmFtaWMKZmFrZWxhZ19mYWtlbGFnX3R5cGV8dD1vfHY9c29kaXVtCnlhd19qaXR0ZXJfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2dsb2JhbHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfd2Fsa3x0PXN8dj0wCmNmZ19zZWxlY3Rpb258dD1tfHY9YW50aWFpbQpib2R5X3lhd192YWx1ZV9tb3ZlfHQ9c3x2PTIKZmlmdHlfZmlmdHlfbW92ZXx0PWN8dj1mYWxzZQpkZWxheV9tb3ZlfHQ9c3x2PTMKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmZha2VsYWdfc3RlYWxlcl90eXBlfHQ9b3x2PW1pbWljCmJvZHlfeWF3X3JpZ2h0X3N0YW5kfHQ9c3x2PTQwCnBpdGNoX2R1Y2t8dD1vfHY9ZG93bgpmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQplbmFibGVfbW92ZXx0PWN8dj10cnVlCmVuYWJsZV9nbG9iYWx8dD1jfHY9ZmFsc2UKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApib2R5X3lhd19yaWdodF9tb3ZlfHQ9c3x2PTQyCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXArfHQ9b3x2PW9mZgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj10cnVlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1qaXR0ZXIKZGVsYXlfc3RhbmR8dD1zfHY9MQp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApwaXRjaF9qdW1wK3x0PW98dj1kb3duCmRlbGF5X2p1bXArfHQ9c3x2PTUKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQplbmFibGVfZmFrZWxhZ3x0PWN8dj1mYWxzZQpvbmx5X2ZsaXBfb25fMF9jaG9rZV9tb3ZlfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX21vdmV8dD1zfHY9MAp5YXdfZ2xvYmFsfHQ9b3x2PW9mZgpjYWNoZV9jcmVkZW50aWFsc3x0PWN8dj10cnVlCnJhbmRvbWl6ZV95YXdfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF9sZWdpdHx0PXN8dj0wCmRlbGF5X2dsb2JhbHx0PXN8dj0xCmRlbGF5X2p1bXB8dD1zfHY9MQpib2R5X3lhd19sZWZ0X2p1bXB8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2xlZnRfd2Fsa3x0PXN8dj0tMTYKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcCt8dD1zfHY9LTE4Cnlhd19kdWNrfHQ9b3x2PTE4MAp5YXdfYmFzZV9qdW1wK3x0PW98dj10aHJlYXQKeWF3X21vdmV8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVjayt8dD1zfHY9LTE1CmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKZmFrZWxhZ19mYWtlZGVmfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZ2xvYmFsfHQ9b3x2PW9mZgp5YXdfYmFzZV9qdW1wfHQ9b3x2PXRocmVhdApjb25kaXRpb258dD1vfHY9ZHVjaysKc2VuZF9jb21ib2R1Y2srfHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj00NAp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX2R1Y2srfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2Zha2VsYWd8dD1vfHY9b2ZmCmRlbGF5X2Zha2VsYWd8dD1zfHY9MQpzdGF0aWNfYm9keV95YXdfZHVjayt8dD1zfHY9MAp5YXdfaml0dGVyX2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXB8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X3dhbGt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfZmFrZWxhZ3x0PWN8dj1mYWxzZQpwaXRjaF9kdWNrK3x0PW98dj1kb3du0000',
    Community = '',
}
return w597]]
w207["require/abc/config_system"] = [[


local w600='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

local function w601(w602)
    return ((w602:gsub('.', function(w603)
        local w604,w600='',w603:byte()
        for w605=8,1,-1 do w604=w604..(w600%2^w605-w600%2^(w605-1)>0 and '1' or '0') end
        return w604
    end)..'0000'):gsub('%d%d%d%d%d%d', function(w603)
        if (#w603 < 6) then return '' end
        return w600:sub(tonumber(w603,2)+1,tonumber(w603,2)+1)
    end)..({ '', '==', '=' })[#w602%3+1])
end

local function w606(w602)
    w602 = string.gsub(w602, '[^'..w600..'=]', '')
    return (w602:gsub('.', function(w603)
        if w603 == '=' then return '' end
        local w604,w607='',(w600:find(w603)-1)
        for w605=6,1,-1 do w604=w604..(w607%2^w605-w607%2^(w605-1)>0 and '1' or '0') end
        return w604
    end):gsub('%d%d%d%d%d%d%d%d', function(w603)
        if (#w603 ~= 8) then return '' end
        local w608=0
        for w605=1,8 do w608=w608+(w603:sub(w605,w605)=='1' and 2^(8-w605) or 0) end
        return string.char(w608)
    end))
end





local database= database

local w609= {}
local w610= {}

local function w611(w612,w613,w614,w615)
    if not w612 or w612 == '' or not w613 or w610[w612] then return end
    w609[#w609+1] = { key = w612, ref = w613, type = w614, tab = w615 }
    w610[w612] = w609[#w609]
end

local function w616(w617)
    local function w618(w619,w617)
        if not w617 or #w617 == 0 then return true end
        if w619 == 'CFG' then return true end
        if not w619 then return true end
        for w620, w621 in ipairs(w617) do if w621 == w619 then return true end end
        return false
    end

    local w622= { 'v=1' }
    for w605 = 1, #w609 do
        local w623= w609[w605]
        if w618(w623.tab, w617) then
            local w621= w623.type
            local w624= ui.get(w623.ref)
            if w621 == 'c' then
                w622[#w622+1] = w623.key .. '|t=c|v=' .. (w624 and 'true' or 'false')
            elseif w621 == 's' then
                w622[#w622+1] = w623.key .. '|t=s|v=' .. tostring(w624 or 0)
            elseif w621 == 'o' then
                w622[#w622+1] = w623.key .. '|t=o|v=' .. tostring(w624 or '')
            elseif w621 == 'm' then
                if type(w624) == 'table' then
                    w622[#w622+1] = w623.key .. '|t=m|v=' .. table.concat(w624, '\t')
                end
            end
        end
    end
    return w601(table.concat(w622, '\n'))
end

local function w625(w626,w617)
    if not w626 or w626 == '' then return end
    local w627, w628= pcall(w606, w626)
    if not w627 or not w628 or w628 == '' then return end
    local function w618(w619,w617)
        if not w617 or #w617 == 0 then return true end
        if w619 == 'CFG' then return true end
        if not w619 then return true end
        for w620, w621 in ipairs(w617) do if w621 == w619 then return true end end
        return false
    end
    for w629 in w628:gmatch('([^\n]+)') do
        if w629 ~= 'v=1' then
            local w612, w630, w631= w629:match('^(.-)|t=(.)|v=(.*)$')
            if w612 and w630 and w631 then
                local w623= w610[w612]
                if w623 and w623.type == w630 and w618(w623.tab, w617) then
                    if w630 == 'c' then
                        ui.set(w623.ref, w631 == 'true')
                    elseif w630 == 's' then
                        local w632= tonumber(w631)
                        if w632 ~= nil then
                            ui.set(w623.ref, w632)
                        end
                    elseif w630 == 'o' then
                        pcall(ui.set, w623.ref, w631)
                    elseif w630 == 'm' then
                        local w633= {}
                        for w634 in w631:gmatch('[^\t]+') do w633[#w633+1] = w634 end
                        ui.set(w623.ref, w633)
                    end
                end
            end
        end
    end
end


local function w635(w636,w617)
    if not w636 or w636 == '' then return end
    local w626= w616(w617)
    database.write('cfg:' .. w636, w626)
end


local function w637(w636,w617)
    if not w636 or w636 == '' then return end
    local w626= database.read('cfg:' .. w636)
    if w626 then w625(w626, w617) end
end


local function w638(w636)
    if not w636 or w636 == '' then return end
    database.write('cfg:' .. w636, nil)
end


local w639= {
    register = w611,
    build = w616,
    apply = w625,
    save = w635,
    load = w637,
    delete = w638,
}

return w639]]
w207["require/abc/garbage_collector"] = [[local w603= {}

local w604= {
    pause = 200,
    stepmul = 600,
    mode = "collect"
}

function w603.tune(w605)
	if type(w605) == "table" then
		if w605.pause then
			collectgarbage("setpause", w605.pause)
			w604.pause = w605.pause
		end
		if w605.stepmul then
			collectgarbage("setstepmul", w605.stepmul)
			w604.stepmul = w605.stepmul
		end
		if w605.mode then
			w604.mode = w605.mode
		end
	end
end

function w603.collect(w606)
	collectgarbage(w606 or w604.mode)
end

function w603.step(w607)
	return collectgarbage("step", w607 or 0)
end

function w603.stop()
	collectgarbage("stop")
end

function w603.restart()
	collectgarbage("restart")
end

function w603.memory()
	return collectgarbage("count")
end

function w603.status()
	return {
		memory = w603.memory(),
		pause = w604.pause,
		stepmul = w604.stepmul,
		mode = w604.mode
	}
end

local w608= 0
function w603.dynamic(w605)
	w605 = type(w605) == "table" and w605 or {}
	local w609= w605.min_interval or 0.6
	local w610= (globals and globals.realtime) and globals.realtime() or (w608 + w609)
	if w610 - w608 < w609 then
		return
	end
	w608 = w610

	local w607= w605.step_size or 20
	local w611= w605.full_threshold_kb or 65536
	local w612= w605.aggressive_threshold_kb or 12288

	local w613, w614= pcall(collectgarbage, "count")
	if not w613 or type(w614) ~= "number" then
		pcall(collectgarbage, "step", w607)
		return
	end

	if w614 >= w611 then
		pcall(collectgarbage, "collect")
		return
	end

	if w614 >= w612 then
		pcall(collectgarbage, "step", w607)
		pcall(collectgarbage, "step", w607)
		return
	end

	pcall(collectgarbage, "step", w607)
end

if lua and lua.defer then
	lua.defer(function()
		w603.collect()
	end)
end

return w603]]
w207["require/abc/hwid_check"] = [[local w606= require("ffi")
local w607= require("require/brain/dll")
local w608= 2
local w609= 1

local function w610()
    return globals.curtime and globals.curtime() or 0
end

local function w611()
    local shared= rawget(_G, "loader_shared")
    if not shared or type(shared) ~= "table" then
    return nil, "missing"
    end
    local w612= tonumber(shared.expires) or 0
    if w610() > w612 then
    return nil, "expired"
    end
    if type(shared.hwids) ~= "table" then
    return nil, "bad_hwids"
    end
    return shared, nil
end

local w613= false

local function w614()
    if not w607 or type(w607) ~= "table" or type(w607.get_hwid) ~= "function" then
        print("invalid hwid 1")
    return
    end

    local w615
    
    local w616, w617= pcall(w607.get_hwid)
    if w616 and w617 and w617 ~= w606.NULL then
    if type(w617) == "cdata" then
        local w618, w619= pcall(w606.string, w617)
        if w618 then w615 = w619 end
    else
        w615 = tostring(w617)
    end
    end

    if not w615 or w615 == "" then
        print("invalid hwid 2")
    end

    local shared, w620= w611()
    if not shared then
        print("invalid hwid 3")
    end

    local w621= shared.hwids
    local w622= false
    for w623 = 1, #w621 do
    local w624= tostring(w621[w623] or "")
    if w624:find(tostring(w615), 1, true) then
        w622 = true
        break
    end
    end


    if w622 then
        local w625= rawget(_G, "loader_init_after_hwid")
        if not w613 and type(w625) == "function" then
        w613 = true
        local w626, w627= pcall(w625)
        if not w626 then
            print("invalid hwid 4: " .. tostring(w627))
        end
        end
    else
        print("invalid hwid 5")
    end
end

local w628= 0
local function w629()
    w628 = w628 + 1
    local shared= rawget(_G, "loader_shared")
    if shared then
    w614()
    return
    end
    print(w628 .. "/" .. w608)
    if w628 > w608 then
        print("invalid hwid 6")
        return
    end

    if type(client.delay_call) == "function" then
        client.delay_call(w609, w629)
    else
        w614()
    end

end


w629()]]
w207["require/abc/login_system"] = [[local w609= {}


local function w610(w611)
	if client.hash_sha256 then
		return client.hash_sha256(w611)
	end
	
	return tostring(w611):reverse()
end


local w612= "acc_" .. "897ntv45ynvttyjt980745nyv0t485vn87t6"

local function w613()
	local w614= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local w615= ""
	for w616 = 1, 16 do
		local w617= math.random(1, #w614)
		w615 = w615 .. w614:sub(w617, w617)
	end
	return w615
end

function w609.hash_password(w618,w615)
	return w610(w615 .. w618)
end

function w609.verify_password(w618,w619,w615)
	return w609.hash_password(w618, w615) == w619
end

function w609.get_hwid()
	
	return tostring(client.userid_to_entindex(client.userid_to_entindex(1)))
end

function w609.store_credentials(w620,w618)
	local w615= w613()
	local w619= w609.hash_password(w618, w615)
	database.write("login_credentials", { username = w620, hash = w619, salt = w615 })
end

function w609.load_credentials()
	return database.read("login_credentials")
end


function w609.login(w620,w618)
	
	local w621= database.read(w612) or {}
	local w622= w621[w620]
	if w622 and w622.enabled ~= false then
		if w609.verify_password(w618, w622.hash, w622.salt) then
			w609.logged_in = true
			return true
		end
	end
	
	local w623= w609.load_credentials()
	if w623 and w623.username == w620 then
		if w609.verify_password(w618, w623.hash, w623.salt) then
			w609.logged_in = true
			return true
		end
	end
	w609.logged_in = false
	return false
end

function w609.logout()
	w609.logged_in = false
end

function w609.reset_password(w624)
	
	database.write("login_credentials", nil)
end



function w609.is_valid_invite(w625)
	if not w625 or w625 == "" then
		return false, nil
	end
	local w626= database.read(w612 .. ":invites") or {}
	local w627= w626[w625]
	if not w627 then
		return false, nil
	end
	if w627.used then
		return false, w627
	end
	return true, w627
end

function w609.add_account(w620,w618)
	local w615= w613()
	local w619= w609.hash_password(w618, w615)
	local w621= database.read(w612) or {}
	w621[w620] = { hash = w619, salt = w615, role = "user", enabled = true, orig_password = w618 }
	database.write(w612, w621)
end

function w609.register_with_invite(w625,w620,w618)
	if not w625 or w625 == '' then return false, 'no invite provided' end
	local w626= database.read(w612 .. ":invites") or {}
	local w627= w626[w625]
	if not w627 then return false, 'invalid invite' end
	if w627.used then return false, 'invite already used' end

	w609.add_account(w620, w618)

	w627.used = true
	w627.used_by = w620
	w627.redeemed_at = client.unix_time()
	w626[w625] = w627
	database.write(w612 .. ":invites", w626)

	return true
end

function w609.invalidate_invite(w625)
	local w626= database.read(w612 .. ":invites") or {}
	if w626[w625] then
		w626[w625] = nil
		database.write(w612 .. ":invites", w626)
		return true
	end
	return false
end

return w609
]]
w207["require/abc/menu_header"] = [[local w612, w613, w614= 1, 398, 49
local w615= 0.85 
local w616= { "AA", "PAINT", "MISC", "CFG" }
local w617= w616[w612]
local w618= {}
local w619= {
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS1.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS2.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS3.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS4.png"
}
local w620

local w621= {
    size = {
        x = 6,
        y = 6,
        w = 120,
        h = 72, 
    },
    skeet_cur_tab = 8,
}

local function w622()
    local w623= { ui.menu_position() }
    local w624= { ui.mouse_position() }
    if not w623[1] or not w623[2] or not w624[1] or not w624[2] then
        return w621.skeet_cur_tab
    end

    for w625 = 1, 9 do
        local w626= { w621.size.x, w621.size.y + w621.size.h * (w625 - 1) }
        if w624[1] >= w623[1] + w626[1]
           and w624[1] <= w623[1] + w621.size.w + w626[1]
           and w624[2] >= w623[2] + w626[2]
           and w624[2] <= w623[2] + w621.size.h + w626[2] then
            return w625
        end
    end

    return w621.skeet_cur_tab
end

local function w627()
    if not renderer.load_png or not readfile then return end
    for w625, w628 in ipairs(w619) do
        if not w618[w625] then
            local w629= w630(w628)
            if w629 then
                w618[w625] = renderer.load_png(w629, w613, w614)
            end
        end
    end
end


local function w631()
    local w632= ui.is_menu_open()
    local w633, w634= ui.menu_position()
    local w635, w636= ui.menu_size()
    w635 = w635-2
    w633 = w633+1
    if w632 and w633 and w634 and w635 and w636 then
        local w637= (w621.skeet_cur_tab == 2)
        local w638= math.floor(90 * w615)
        local w639= math.max(1, math.floor(4 * w615))
        local w640= math.max(1, math.floor(3 * w615))
        local w641= math.max(1, math.floor(2 * w615))
        local w642= math.max(0, math.floor(1 * w615))
        local w643= 0
        local w644= w633 + w639
        local w645= w634 - math.floor(7 * w615) - w638
        local w646= w635 - 2 * w639

        if w637 then
            renderer.rectangle(w644-w639*1.3, w645-8, w646+2*w639*1.5-1, w638+16, 12, 12, 12, 255)
            renderer.rectangle(w644-w640*1.5, w645-7, w646+2*w640*1.5, w638+14, 60, 60, 60, 255)
            renderer.rectangle(w644-w641*1.51, w645-6, w646+2*w641*2, w638+12, 40, 40, 40, 255)
            renderer.rectangle(w644-w642, w645-3, w646+2*w642, w638+6, 60, 60, 60, 255)
            renderer.rectangle(w644-w643, w645-2, w646+2*w643, w638+4, 12, 12, 12, 255)

            local w647= nil
            if renderer.load_rgba then
                local w648, w649= pcall(renderer.load_rgba,
                    string.char(
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
                    ), 4, 4)
                if w648 and w649 then w647 = w649 end
            end
            if w647 and renderer.texture then
                renderer.texture(w647, w644-w643, w645-2, w646+2*w643, w638+4, 255,255,255,255, 'r')
            end

            if renderer.gradient then
                renderer.gradient(w644-w643, w645-2, (w646+2*w643)/2+1, 1, 59,175,222,255, 202,70,205,255, true)
                renderer.gradient(w644-w643+(w646+2*w643)/2+1, w645-2, (w646+2*w643)/2-1, 1, 202,70,205,255, 204,227,53,255, true)
            end

            local w650= math.max(1, math.floor(2 * w615))
            local w651= w645 - math.floor(8 * w615)

            local w652= math.max(1, math.floor(5 * w615))
            local w653= 60
            renderer.circle(w644-w639+w652, w651+w650/2, w652, 59,175,222, w653, 16)
            renderer.circle(w644+w646-w639-w643-w652, w651+w650/2, w652, 204,227,53, w653, 16)
        end

        local w654= 4
        local w655= w645 + w638 / 2
        local w656, w657= ui.mouse_position()
        local w658= {}
        local w659= w638
            local w660= math.max(1, math.floor(59 * w615))
            local w661= math.max(1, math.floor(w613 * w615))
            local w662= math.max(1, math.floor(w614 * w615))
            local w663= w654 * w661 + (w654 - 1) * w660
            local w664= math.max(0, w646 * 0.5)
            local w665= w644 + w664 + (w646 - 2 * w664 - w663) / 2
            if w663 > w646 then
                w660 = math.max(0, math.floor((w646 - w654 * w661) / (w654 - 1)))
                w663 = w654 * w661 + (w654 - 1) * w660
                w665 = w644 + (w646 - w663) / 2
            end
        w627()
        local w666= w646 / w654
        for w625=1,w654 do
            local w667= w644 + (w625-1) * w666
            local w668= w645
            w658[w625] = {x=w667, y=w668, w=w666, h=w659}
            if w637 then
                if w612 == w625 then
                    renderer.rectangle(w667, w668, w666, w659+1, 32,32,32, 85)
                end
                local w669= w667 + w666/2 - w661/2
                local w670= w668 + w659/2 - w662/2
                if w618[w625] then
                    renderer.texture(w618[w625], w669, w670, w661, w662, 255,255,255,255, "f")
                else
                    renderer.text(w669 + w661/2, w670 + w662/2, 255,255,255,255, '+c', 0, tostring(w625))
                end
            end
        end

        local w671= client.key_state(1)
        if w632 and w656 and w657 and ui.is_menu_open() then
            if w671 and not prev_mouse_down then
                for w625=1,w654 do
                    local w672= w658[w625]
                    if w656 >= w672.x and w656 <= w672.x+w672.w and w657 >= w672.y and w657 <= w672.y+w672.h then
                        w612 = w625
                        w617 = w616[w612]
                    end
                end
                local w673= { ui.menu_position() }
                if w673[1] and w673[2] then
                    for w674 = 1, 9 do
                        local w626= { w621.size.x, w621.size.y + w621.size.h * (w674 - 1) }
                        if w656 >= w673[1] + w626[1]
                           and w656 <= w673[1] + w621.size.w + w626[1]
                           and w657 >= w673[2] + w626[2]
                           and w657 <= w673[2] + w621.size.h + w626[2] then
                            w621.skeet_cur_tab = w674
                            break
                        end
                    end
                end
            end
            prev_mouse_down = w671
        else
            prev_mouse_down = false
        end
        local w675= w622()
        local w676= w621.skeet_cur_tab or 0
        local w677= "Skeet sel: " .. tostring(w676)
        if w675 and w675 ~= w676 then
            w677 = w677 .. "  (hover: " .. tostring(w675) .. ")"
        end
        if w637 then
            if renderer.measure_text then
                pcall(function() renderer.measure_text(nil, w677) end)
            end
            renderer.text(w644 + 6, w645 + w638 + 6, 200,200,200,255, nil, 0, w677)
        end
    end
end

local function w678()
    if not ui.is_menu_open() then return false end
    local w656, w657= ui.mouse_position()
    local w679, w680= ui.menu_position()
    local w681, w682= ui.menu_size()
    local w638= math.floor(90 * w615)
    local w639= math.max(1, math.floor(4 * w615))
    local w644, w645, w646= w679 + w639, w680 - math.floor(7 * w615) - w638, w681 - 2 * w639
    return not (
        w656 >= w679 and w656 <= w679 + w681 and w657 >= w680 and w657 <= w680 + w682
        or w656 >= w644 and w656 <= w644 + w646 and w657 >= w645 and w657 <= w645 + w638
    )
end

return {
    current_tab = function() return w617 end,
    current_tab_index = function() return w612 end,
    tab_names = w616,
    tab_sections = function() return w620 end,
    menu_position = function() return ui.menu_position() end,
    menu_size = function() return ui.menu_size() end,
    is_menu_open = function() return ui.is_menu_open() end,
    mouse_position = function() return ui.mouse_position() end,
    is_mouse_outside_menu = w678,
    draw_menu = w631
}]]
w207["require/abc/menu_setup"] = [[local w615= {
    ui = {},
    registered_items = {},
}

function w615.register_ui(w616,w617)
    
    
    
    if w617 and w617.key then
        for w618 = #w615.registered_items, 1, -1 do
            local w619= w615.registered_items[w618]
            if w619 and w619.key == w617.key then
                
                pcall(function()
                    if w619.item then ui.set_visible(w619.item, false) end
                end)
                table.remove(w615.registered_items, w618)
            end
        end
    end

    table.insert(w615.registered_items, {
        item = w616,
        key = w617.key,
        requires_login = w617.requires_login,
        tab = w617.tab,
        visible = w617.visible ~= false,
        config_type = w617.config_type,
        show_condition = w617.show_condition,
    })
    return w616
end

function w615.update_visibility(w620)
    for w621, w619 in ipairs(w615.registered_items) do
        local w622= w619.visible
        if w619.requires_login and not w620 then
            w622 = false
        end
        if w619.show_condition then
            w622 = w619.show_condition()
        end
        if w619.item then
            ui.set_visible(w619.item, w622)
        end
    end
end

function w615.save_config()
    local config= {}
    for w621, w619 in ipairs(w615.registered_items) do
        if w619.key and w619.item then
            config[w619.key] = ui.get(w619.item)
        end
    end
    return config
end

function w615.load_config(w623)
    for w621, w619 in ipairs(w615.registered_items) do
        if w619.key and w619.item and w623[w619.key] ~= nil then
            ui.set(w619.item, w623[w619.key])
        end
    end
end

local w624= {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

local w625= {

    { 'Rage', 'other', 'accuracy boost' },
    { 'Rage', 'other', 'anti-aim correction' },
    { 'rage', 'other', 'automatic fire' },
    { 'Rage', 'other', 'automatic penetration' },
    { 'Rage', 'other', 'silent aim' },
    { 'Rage', 'other', 'remove recoil' },
    { 'Rage', 'other', 'reduce aimstep' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'log misses due to spread' },
    { 'Rage', 'other', 'low fps mitigations ' },
    { 'rage', 'other', 'delay shot' },
    { 'Rage', 'other', 'quick peek assist' },
    { 'Rage', 'other', 'quick peek assist mode' },
    { 'Rage', 'other', 'quick peek assist distance' },
    { 'Rage', 'other', 'reduce aim step' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'low fps mitigations' },
    { 'Rage', 'other', 'duck peek assist' },


}

function w615.toggle_gamesense_menu(w622)
    w615.state = w615.state or {}
    w615.hidden_refs = w615.hidden_refs or {}
    for w621, w619 in ipairs(w624) do
        local w626, w627, w628, w629, w630= pcall(ui.reference, w619[1], w619[2], w619[3], w619[4])
        if w626 then
            if w619[1] == 'AA' and w619[2] == 'Anti-aimbot angles' and w619[3] == 'Enabled' then
                w615.state.gs_enabled_ref = w627
                if w627 ~= nil and w622 then
                    if w615.state.gs_enabled_previous ~= nil then
                        ui.set(w627, w615.state.gs_enabled_previous)
                    end
                elseif w627 ~= nil and not w622 then
                    w615.state.gs_enabled_previous = ui.get(w627)
                    ui.set(w627, true)
                end
            end
            local w631= { w627, w628, w629, w630 }
            local w632= {}
            for w621, w633 in ipairs(w631) do
                if w633 ~= nil then
                    ui.set_visible(w633, w622)
                    w632[#w632 + 1] = w633
                end
            end
            if not w622 and #w632 > 0 then
                table.insert(w615.hidden_refs, w632)
            end
        end
    end
    w615.state.gs_hidden = not w622
end

function w615.toggle_rage_menu(w622)
    w615.state = w615.state or {}
    w615.hidden_rage_refs = w615.hidden_rage_refs or {}
    w615.hidden_rage_refs = {} 

    for w621, w619 in ipairs(w625) do
        local w626, w627, w628, w629, w630= pcall(ui.reference, w619[1], w619[2], w619[3])
        if w626 then
            local w631= { w627, w628, w629, w630 }
            local w632= {}
            for w621, w633 in ipairs(w631) do
                if w633 ~= nil then
                    pcall(function() ui.set_visible(w633, w622) end)
                    w632[#w632 + 1] = w633
                end
            end
            if not w622 and #w632 > 0 then
                table.insert(w615.hidden_rage_refs, w632)
            end
        end
    end
    w615.state.rage_hidden = not w622
end

return w615]]
w207["require/abc/menu_visibility"] = [[local w618= {
	"global",
	"stand",
	"move",
	"duck",
	"duck+",
	"jump",
	"jump+",
	"walk",
	"fakelag",
	"legit",
}

local w619= require("require/abc/login_system")

local function w620(w621)
	if w621.menu_setup and w621.menu_setup.refresh_cfg_listbox then
		w621.menu_setup.refresh_cfg_listbox()
	end

	if w621 and not w621.login then
		w621.login = w619
	end
	w621.menu_setup.toggle_gamesense_menu(false)
	w621.menu_setup.toggle_rage_menu(true)
	w621.menu_setup.update_visibility(w621.login and w621.login.logged_in)
	local w622= (w621.login and w621.login.logged_in) or false

	local w623= not w622
	local w624= (w621.menu_header and w621.menu_header.current_tab and w621.menu_header.current_tab()) or w621.menu.current_tab()
	 	
	ui.set_visible(w621.menu_setup.ui.login_howto_header, w623)
	ui.set_visible(w621.menu_setup.ui.login_console_register, w623)
	ui.set_visible(w621.menu_setup.ui.login_menu_credentials, w623)
	ui.set_visible(w621.menu_setup.ui.login_press_login, w623)
	ui.set_visible(w621.menu_setup.ui.login_spacer1, w623)
	ui.set_visible(w621.menu_setup.ui.reset_header, w623)
	ui.set_visible(w621.menu_setup.ui.reset_step1, w623)
	ui.set_visible(w621.menu_setup.ui.reset_step2, w623)
	ui.set_visible(w621.menu_setup.ui.login_spacer2, w623)
	ui.set_visible(w621.menu_setup.ui.support_header, w623)
	ui.set_visible(w621.menu_setup.ui.support_discord, w623)
	ui.set_visible(w621.menu_setup.ui.login_username, w623)
	ui.set_visible(w621.menu_setup.ui.login_password, w623)
	ui.set_visible(w621.menu_setup.ui.cache_credentials, w623)
	ui.set_visible(w621.menu_setup.ui.login_button, w623)
	ui.set_visible(w621.menu_setup.ui.reset_button, w623)
	ui.set_visible(w621.menu_setup.ui.discord_button, w623)
	ui.set_visible(w621.menu_setup.ui.youtube_button, w623)
	ui.set_visible(w621.menu_setup.ui.sellhub_button, w623)
	ui.set_visible(w621.menu_setup.ui.logout_button, w622 and w624 == "CFG")

	if w621.menu_setup.ui.condition then
		local w625= ui.get(w621.menu_setup.ui.condition)
		for w626, w627 in ipairs(w618) do
			local w628= w622 and w624 == "AA" and w625 == w627
			local w629= 'enable_' .. w627
			if w621.menu_setup.ui[w629] then
				ui.set_visible(w621.menu_setup.ui[w629], w628)
				local w630= w621.safe.safe_get(w621.menu_setup.ui[w629])

				local w631= w621.menu_setup.ui['yaw_' .. w627] and ui.get(w621.menu_setup.ui['yaw_' .. w627]) or nil
				local w632= w621.menu_setup.ui['yaw_jitter_' .. w627] and ui.get(w621.menu_setup.ui['yaw_jitter_' .. w627]) or nil
				local w633= w621.menu_setup.ui['body_yaw_mode_' .. w627] and ui.get(w621.menu_setup.ui['body_yaw_mode_' .. w627]) or nil
				local w634= w621.menu_setup.ui['delay_' .. w627] and ui.get(w621.menu_setup.ui['delay_' .. w627]) or nil
				ui.set_visible(w621.menu_setup.ui['pitch_' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['yaw_base_' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['yaw_' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['label1_' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['label2_' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['label3_' .. w627], w628 and w630)
				local w635= w628 and w630 and (w631 ~= 'off' and w631 ~= 'ideal' and w631 ~= '3way')
				ui.set_visible(w621.menu_setup.ui['body_yaw_base_' .. w627], w635)
				local w636= w628 and w630 and (w631 == '180' or w631 == '3way')
				ui.set_visible(w621.menu_setup.ui['body_yaw_left_' .. w627], w636)
				ui.set_visible(w621.menu_setup.ui['body_yaw_right_' .. w627], w636)
				local w637= w628 and w630 and (w631 ~= 'off' and w631 ~= 'ideal')
				ui.set_visible(w621.menu_setup.ui['randomize_yaw_' .. w627], w637)
				local w638= w628 and w630 and (w632 ~= 'off')
				ui.set_visible(w621.menu_setup.ui['yaw_jitter_base_' .. w627], w638)
				local w639= w628 and w630 and (w633 == 'static')
				ui.set_visible(w621.menu_setup.ui['static_body_yaw_' .. w627], w639)
				local w640= w628 and w630 and (w633 == 'jitter' and w634 and w634 <= 0)
				ui.set_visible(w621.menu_setup.ui['body_yaw_value_' .. w627], w640)
				local w641= w628 and w630 and (w633 == 'jitter')
				ui.set_visible(w621.menu_setup.ui['delay_' .. w627], w641)
				ui.set_visible(w621.menu_setup.ui['yaw_jitter_' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['body_yaw_mode_' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['fifty_fifty_' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['only_flip_on_0_choke_' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['aa_label_space' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['aa_label_combo' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['send_button' .. w627], w628 and w630)
				ui.set_visible(w621.menu_setup.ui['send_combo' .. w627], w628 and w630)
			end
		end
		ui.set_visible(w621.menu_setup.ui.condition, w622 and w624 == "AA")
		ui.set_visible(w621.menu_setup.ui.condition_label, w622 and w624 == "AA")
		ui.set_visible(w621.menu_setup.ui.condition_label2, w622 and w624 == "AA")


		ui.set_visible(w621.menu_setup.ui.fakelag_mode, w622 and w624 == "AA")
		if w621.menu_setup.ui.fakelag_mode then
			local w642= ui.get(w621.menu_setup.ui.fakelag_mode)
			local w643= w622 and w624 == "AA"
			local w644= w643 and w642 == "defensive"
			local w645= w621.safe.safe_get(w621.menu_setup.ui.fakelag_defensive) == true
			ui.set_visible(w621.menu_setup.ui.fakelag_defensive, w644)
			ui.set_visible(w621.menu_setup.ui.fakelag_force, w644 and w645)
			ui.set_visible(w621.menu_setup.ui.fakelag_force_on, w644 and w645)
			ui.set_visible(w621.menu_setup.ui.fakelag_fakedef, w644 and w645)

			local w646= w643 and w642 == "stealer"
			local w647= w621.safe.safe_get(w621.menu_setup.ui.fakelag_stealer) == true
			ui.set_visible(w621.menu_setup.ui.fakelag_stealer, w646)
			ui.set_visible(w621.menu_setup.ui.fakelag_stealer_type, w646 and w647)
			ui.set_visible(w621.menu_setup.ui.fakelag_stealer_target, w646 and w647)
			ui.set_visible(w621.menu_setup.ui.fakelag_stealer_list, w646 and w647)
			ui.set_visible(w621.menu_setup.ui.fakelag_stealer_refresh, w646 and w647)
			ui.set_visible(w621.menu_setup.ui.fakelag_stealer_steal, w646 and w647)

			local w648= w643 and w642 == "fakelag"
			local w649= w621.safe.safe_get(w621.menu_setup.ui.fakelag_fakelag) == true
			local w650= w621.safe.safe_get(w621.menu_setup.ui.fakelag_fakelag_type) == "sodium"
			ui.set_visible(w621.menu_setup.ui.fakelag_fakelag, w648)
			ui.set_visible(w621.menu_setup.ui.fakelag_fakelag_type, w648 and w649)
			ui.set_visible(w621.menu_setup.ui.fakelag_fakelag_amount, w648 and w649 and not w650)
			ui.set_visible(w621.menu_setup.ui.fakelag_fakelag_variance, w648 and w649 and not w650)
			ui.set_visible(w621.menu_setup.ui.fakelag_fakelag_limit, w648 and w649 and not w650)
			ui.set_visible(w621.menu_setup.ui.fakelag_fakelag_type2, w648 and w649 and w650)

			local w651= w643 and w642 == "settings"
			ui.set_visible(w621.menu_setup.ui.fakelag_settings_freestanding, w651)
			ui.set_visible(w621.menu_setup.ui.fakelag_settings_enhance_onshot, w651)
			ui.set_visible(w621.menu_setup.ui.fakelag_settings_antibrute, w651)
			ui.set_visible(w621.menu_setup.ui.fakelag_settings_roll_label, w651)
			ui.set_visible(w621.menu_setup.ui.fakelag_settings_roll_checkbox, w651)
			local w652= w651 and w621.safe.safe_get(w621.menu_setup.ui.fakelag_settings_roll_checkbox) == true
			ui.set_visible(w621.menu_setup.ui.fakelag_settings_roll, w652)
			ui.set_visible(w621.menu_setup.ui.fakelag_settings_side, w652)
		end

		local w653= w622 and w624 == "PAINT" and ui.get(w621.menu_setup.ui.paint_indicators_enable) == true
		local w654= w622 and w624 == "PAINT" and w653 and ui.get(w621.menu_setup.ui.paint_indicators) ~= "off"
		local w655= w622 and w624 == "PAINT" and w653 and ui.get(w621.menu_setup.ui.paint_indicators) == "small"
		ui.set_visible(w621.menu_setup.ui.paint_indicators, w653)
		ui.set_visible(w621.menu_setup.ui.paint_indicators_enable, w654)
		ui.set_visible(w621.menu_setup.ui.paint_indicators_animation, w654)
		ui.set_visible(w621.menu_setup.ui.paint_indicators_bar, w655)
		ui.set_visible(w621.menu_setup.ui.paint_indicator_color, w654)

		local w656= w622 and w624 == "PAINT" and ui.get(w621.menu_setup.ui.paint_advertisement) == true
		ui.set_visible(w621.menu_setup.ui.paint_advertisement_color, w656)

		local w657= w622 and w624 == "PAINT" and ui.get(w621.menu_setup.ui.paint_watermark) == true
		ui.set_visible(w621.menu_setup.ui.paint_watermark_color, w657)

		local w658= w622 and w624 == "MISC" and w621.safe.safe_get(w621.menu_setup.ui.misc_dormantaimbot) == true
		ui.set_visible(w621.menu_setup.ui.misc_dormantaimbot_key, w658)
		ui.set_visible(w621.menu_setup.ui.misc_dormantaimbot_value, w658)

		local w659= w622 and w624 == "PAINT" and w621.safe.safe_get(w621.menu_setup.ui.paint_logger_checkbox) == true
		ui.set_visible(w621.menu_setup.ui.paint_logger, w659)
		ui.set_visible(w621.menu_setup.ui.paint_logger_animation, w659)
		ui.set_visible(w621.menu_setup.ui.paint_logger_color, w659)

		local w660= w622 and w624 == "PAINT" and w621.safe.safe_get(w621.menu_setup.ui.paint_aspect_ratio_checkbox) == true
		ui.set_visible(w621.menu_setup.ui.paint_aspect_ratio, w660)

		local w661= w622 and w624 == "PAINT" and w621.safe.safe_get(w621.menu_setup.ui.paint_third_person_distance_checkbox) == true
		ui.set_visible(w621.menu_setup.ui.paint_third_person_distance, w661)

	end

	local w662= {
		'aa_gskey_freestand',
		'aa_gskey_freestandh',
		'aa_gskey_slowmotion',
		'aa_gskey_slowmotionh',
		'aa_gskey_edgeyaw',
		'aa_gskey_edgeyawh',
		'aa_gskey_onshot',
		'aa_gskey_onshoth',
	}
	for w626, w663 in ipairs(w662) do
		if w621.menu_setup.ui[w663] then
			ui.set_visible(w621.menu_setup.ui[w663], w624 == "AA")
		end
	end

	local w664= {
		'misc_resolver',
		'misc_ragebot',
		'misc_dormantaimbot',
		'misc_exploit_fakelag',
		'misc_walkbot',
		'misc_backstab',
		'misc_spindead',
	}
	for w626, w663 in ipairs(w664) do
		if w621.menu_setup.ui[w663] then
			ui.set_visible(w621.menu_setup.ui[w663], w624 == "MISC")
		end
	end

	local w665= {
		'paint_target_info',
		'label_space2',
		'label_space3',
		'label_space4',
		'paint_entidx',
		'paint_filter_console',
		'paint_minimum_damage',
		'paint_show_damage_penetration',
		'paint_hitmiss_indicator',
		'paint_self_skeleton',
		'paint_bullet_tracer',
		'paint_lagcomp_box',
		'paint_lagcomp_box_color',
		'paint_presmoke',
		'paint_bombwarning',
		'paint_insults',
		'paint_rainbow_esp',
		'paint_molotov',
		'paint_lag_record',
		'paint_advertisement',
		'paint_advertisement_animation',
		'paint_clantag',
		'paint_aimbot_logs',
		'paint_indicators_label',
		'paint_indicators_enable',
		'label_space1',
		'paint_watermark',
		'paint_watermark_type',
		'paint_logger_label',
		'paint_logger_checkbox',
		'paint_hitmarker',
		'paint_hitmarker_color',
		'paint_warnings',
		'paint_animations',
		'paint_performance_mode',
		'paint_aspect_ratio_checkbox',
		'paint_third_person_distance_checkbox',
	}
	for w626, w663 in ipairs(w665) do
		if w621.menu_setup.ui[w663] then
			ui.set_visible(w621.menu_setup.ui[w663], w624 == "PAINT")
		end
	end

		local w666= {
			'cfg_load_button',
			'cfg_save_button',
			'cfg_delete_button',
			'cfg_refresh_button',
			'cfg_create_button',
			'cfg_export_button',
			'cfg_import_button',
			'cfg_input_box',
			'cfg_listbox',
			'cfg_selection',
			'cfg_cloud',
			'cfg_cloud_apply',
		}
		for w626, w663 in ipairs(w666) do
			if w621.menu_setup.ui[w663] then
				ui.set_visible(w621.menu_setup.ui[w663], w622 and w624 == "CFG")
			end
		end

end

local function w667(w621)
	local w668= {
		w621.menu_setup.ui.condition,
		w621.menu_setup.ui.fakelag_mode,
	}
	for w626, w669 in ipairs(w668) do
		if w669 then
			ui.set_callback(w669, function()
				w620(w621)
			end)
		end
	end

	for w626, w627 in ipairs(w618) do
		local w670= {
			'enable_' .. w627,
			'yaw_' .. w627,
			'yaw_jitter_' .. w627,
			'body_yaw_mode_' .. w627,
			'fifty_fifty_' .. w627,
			'only_flip_on_0_choke_' .. w627,
			'aa_label_space' .. w627,
			'aa_label_combo' .. w627,
			'send_button' .. w627,
			'send_combo' .. w627,
		}
		for w626, w663 in ipairs(w670) do
			local w669= w621.menu_setup.ui[w663]
			if w669 then
				ui.set_callback(w669, function()
					w620(w621)
				end)
			end
		end
	end

	local w671= {
		'fakelag_defensive',
		'fakelag_stealer',
		'fakelag_fakelag',
		'fakelag_fakelag_type',
		'fakelag_settings_roll_label',
		'fakelag_settings_roll_checkbox',
	}
	for w626, w663 in ipairs(w671) do
		local w669= w621.menu_setup.ui[w663]
		if w669 then
			ui.set_callback(w669, function()
				w620(w621)
			end)
		end
	end

	if w621.menu_setup.ui.paint_indicators then
		ui.set_callback(w621.menu_setup.ui.paint_indicators, function()
			w620(w621)
		end)
	end

	if w621.menu_setup.ui.paint_advertisement then
		ui.set_callback(w621.menu_setup.ui.paint_advertisement, function()
			w620(w621)
		end)
	end
	
	if w621.menu_setup.ui.paint_watermark then
		ui.set_callback(w621.menu_setup.ui.paint_watermark, function()
			w620(w621)
		end)
	end

	if w621.menu_setup.ui.misc_dormantaimbot then
		ui.set_callback(w621.menu_setup.ui.misc_dormantaimbot, function()
			w620(w621)
		end)
	end

	if w621.menu_setup.ui.paint_logger_checkbox then
		ui.set_callback(w621.menu_setup.ui.paint_logger_checkbox, function()
			w620(w621)
		end)
	end

	if w621.menu_setup.ui.paint_aspect_ratio_checkbox then
		ui.set_callback(w621.menu_setup.ui.paint_aspect_ratio_checkbox, function()
			w620(w621)
		end)
	end

	if w621.menu_setup.ui.paint_third_person_distance_checkbox then
		ui.set_callback(w621.menu_setup.ui.paint_third_person_distance_checkbox, function()
			w620(w621)
		end)
	end

	if w621.menu_setup.ui.paint_indicators_enable then
		ui.set_callback(w621.menu_setup.ui.paint_indicators_enable, function()
			w620(w621)
		end)
	end

	if w621.login and type(w621.login.add_state_callback) == 'function' then
		w621.login.add_state_callback(function()
			w620(w621)
		end)
	end
end

return {
	update = w620,
	setup_callbacks = w667
}]]
w207["require/abc/push_gamesense"] = [[local renderer= renderer
local globals= globals
local w621= string.char

local w622= nil
local function w623()
    if w622 then return w622 end
    if renderer.load_rgba then
        local w624, w625= pcall(renderer.load_rgba,
            string.char(
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
            ), 4, 4)
        if w624 and w625 then w622 = w625 end
    end
    return w622
end


local function w626(w627,w628,w629,w630,w631,w632)
    local w633= w627 - 3
    local w634= w628 - 40
    local w635= w629 + 5
    local w636= w630 + 1
    renderer.rectangle(w627 - 10, w628 - 48, w629 + 20, w630 + 16, 0, 0, 0, 200)
    renderer.rectangle(w627 - 9, w628 - 47, w629 + 18, w630 + 14, 60, 60, 60, 255)
    renderer.rectangle(w627 - 8, w628 - 46, w629 + 16, w630 + 12, 40, 40, 40, 255)
    renderer.rectangle(w627 - 5, w628 - 43, w629 + 10, w630 + 6, 60, 60, 60, 255)
    renderer.rectangle(w627 - 4, w628 - 42, w629 + 8, w630 + 4, 12, 12, 12, 255)
    renderer.rectangle(w627 - 4, w628 - 42, w629 + 8, w630 + 4, 32, 32, 32, 255)
    local w637= w623()
    if w637 and renderer.texture then
        renderer.texture(w637, w633, w634, w635, w636, 255,255,255,w631, 'r')
    else
        renderer.rectangle(w633, w634, w635, w636, 0, 0, 0, 0)
    end

    
    if renderer.gradient then
        renderer.gradient(w627 - 4, w628 - 42, w629 / 2 + 1, 1, 59, 175, 222, 255, 202, 70, 205, 255, true)
        renderer.gradient(w627 - 4 + w629 / 2, w628 - 42, w629 / 2 + 8.5, 1, 202, 70, 205, 255, 204, 227, 53, 255, true)
    end
    renderer.text(w627, w628 - 40, 255, 255, 255, 255, '', nil, w632)
end

return w626
]]
w207["require/abc/push_logger"] = [[local renderer= renderer
local globals= globals
local client= client
local entity= entity
local w624= table.insert
local w625= table.remove
local w626= math.floor
local w627= math.sqrt
local w628= string.char


local w629, w630= pcall(require, "require/abc/menu_setup")


local w631, w632= pcall(ui.reference, 'misc', 'settings', 'menu color')

local w633= {}
local w634= 5

local function w635(w636,w637,w638,w639,w640,w641)
    if #w633 >= w634 then
        w625(w633, 1)
    end
    w624(w633, {
        text = tostring(w636),
        duration = w637 or 5,
        color = { w638 or 255, w639 or 255, w640 or 255, w641 or 255 },
        timestamp = globals and globals.curtime and globals.curtime() or os.clock(),
    })
end

local function w642(w643)
    local w644, w645, w646= pcall(renderer.measure_text, '', w643)
    if w644 and type(w645) == 'number' then return w645, w646 or 0 end
    w644, w645, w646 = pcall(renderer.measure_text, w643)
    if w644 and type(w645) == 'number' then return w645, w646 or 0 end
    return 0, 0
end

local function w647(w648,w649,w650)
    if w648 < w649 then return w649 end
    if w648 > w650 then return w650 end
    return w648
end


local function w651()
    if w629 and w630 and w630.ui and w630.ui.paint_logger then
        local w644, w652= pcall(ui.get, w630.ui.paint_logger)
        if w644 and w652 then return true end
        return false
    end
    
    return true
end


local function w653()
    if w629 and w630 and w630.ui and w630.ui.paint_logger_animation then
        local w644, w648= pcall(ui.get, w630.ui.paint_logger_animation)
        if w644 and type(w648) == 'number' then return w648 end
    end
    return 0
end


local w654, w655= pcall(require, "require/abc/push_modern")
local w656, w657= pcall(require, "require/abc/push_gamesense")


local function w658(w659)
    local w660= 80
    local w661= w659 - 80
    local w662= 40
    local w663= w659 / 2 - 300
    local w664= w659 - w663 - 10
    w664 = w647(w664, w660 + w662, w661 - w662)
    local w665= w664 - w662
    local w666= w664 + w662
    return w665, w666, w664
end

local function w667()
    if not renderer or not renderer.text then return end
    if not w651() then return end

    local w668= w653() or 0
    local w669= globals and globals.curtime and globals.curtime()
    local w670, w659= client and client.screen_size and client.screen_size() or 800, 600
    local w671= w659 * 0.5 + (w659 * 0.5 * 1.8)
    local w672= 0
    for w673 = #w633, 1, -1 do
        local w674= w633[w673]
        local w675= (w674.timestamp + w674.duration) - w669
        if w675 <= 0 then
            w625(w633, w673)
        else
            local w676, w677= w642(w674.text)
            local w678= (w668 == 1) and 4 or 2
            local w679= 2
            local w680= w670 / 2 - w676 / 2
            local w681= w671 + w672
            local w682= 5
            local w683= w626((w674.color[4] or 255) * math.min(1, (w675 / w674.duration) * w682))
            local w684= (w674.duration - w675)
            local w685= (w674.duration > 0 and w674.duration or 1)
            local w686= w684 / w685
            local w687= 6
            local w688= w647(w686 * w687, 0, 1)
            local w689= w688
            
            
            local w690= math.min(0.5, w685 * 0.25)
            if w675 <= w690 then
                local w691= w675 / w690 
                w689 = w647(w691, 0, 1)
            end
            if w668 == 1 then
                w655(w680, w681, w676, 13, w683, w674.text, w689)
                w672 = w672 + (w677 + w678 * 2 + w627(w679 / 10) * 4)
            else
                w657(w680, w681, w676, 13, w683, w674.text)
                w672 = w672 + (w677 + w678 * 2 + w627(w679 / 10) * 35)
            end
        end
    end
end

if client and client.set_event_callback then
    client.set_event_callback('paint', w667)
else
    
    client.set_event_callback('paint', w667)
end

return w635
]]
w207["require/abc/push_modern"] = [[local renderer= renderer
local ui= ui
local w627= math.floor

local w628, w629= pcall(require, "require/abc/menu_setup")
local w630, w631= pcall(ui.reference, 'misc', 'settings', 'menu color')

local function w632(w633,w634,w635,w636,w637,w638,w639,w640,w641)
    if not w637 or w637 <= 0 then
        renderer.rectangle(w633, w634, w635, w636, w638,w639,w640,w641)
        return
    end
    renderer.rectangle(w633 + w637, w634, w635 - (w637 * 2), w636, w638,w639,w640,w641)
    renderer.rectangle(w633, w634 + w637, w635, w636 - (w637 * 2), w638,w639,w640,w641)
    renderer.circle(w633 + w637, w634 + w637, w638,w639,w640,w641, w637, 0, 1)
    renderer.circle(w633 + w635 - w637, w634 + w637, w638,w639,w640,w641, w637, 0, 1)
    renderer.circle(w633 + w637, w634 + w636 - w637, w638,w639,w640,w641, w637, 0, 1)
    renderer.circle(w633 + w635 - w637, w634 + w636 - w637, w638,w639,w640,w641, w637, 0, 1)
end

local function w642(w643,w644,w645,w646)
    local w647, w648, w649, w650= w643 or 255, w644 or 140, w645 or 0, w646 or 255
    
    if w628 and w629 and w629.ui and w629.ui.paint_logger_color then
        local w651, w652, w653, w654, w655= pcall(ui.get, w629.ui.paint_logger_color)
        if w651 then
            if type(w652) == 'number' then
                w647 = w627(w652 or w647)
                w648 = w627(w653 or w648)
                w649 = w627(w654 or w649)
                w650 = w627(w655 or w650)
            elseif type(w652) == 'string' and #w652 == 12 then
                local w656
                w656, w647 = pcall(function() return tonumber(w652:sub(1,3)) end)
                w656, w648 = pcall(function() return tonumber(w652:sub(4,6)) end)
                w656, w649 = pcall(function() return tonumber(w652:sub(7,9)) end)
                w656, w650 = pcall(function() return tonumber(w652:sub(10,12)) end)
                w647 = w647 or w643; w648 = w648 or w644; w649 = w649 or w645; w650 = w650 or w646
            end
            return w647, w648, w649, w650
        end
    end

    
    if w630 and w631 then
        local w651, w652, w653, w654, w655= pcall(ui.get, w631)
        if w651 then
            if type(w652) == 'number' then
                w647 = w627(w652 or w647)
                w648 = w627(w653 or w648)
                w649 = w627(w654 or w649)
                w650 = w627(w655 or w650)
            elseif type(w652) == 'string' and #w652 == 12 then
                local w656
                w656, w647 = pcall(function() return tonumber(w652:sub(1,3)) end)
                w656, w648 = pcall(function() return tonumber(w652:sub(4,6)) end)
                w656, w649 = pcall(function() return tonumber(w652:sub(7,9)) end)
                w656, w650 = pcall(function() return tonumber(w652:sub(10,12)) end)
                w647 = w647 or w643; w648 = w648 or w644; w649 = w649 or w645; w650 = w650 or w646
            end
        end
    end
    return w647, w648, w649, w650
end

local function w657(w633,w634,w635,w636,w658,w659,w660)
    local w661= w633 - 4
    local w662= w634 - 40
    local w663= w635 + 8
    local w664= w636 + 1

    local w665= 6
    if w664 < 12 then w665 = math.max(1, math.floor(w664 / 2)) end
    local w666= math.max(1, w665 - 1)

    local w647, w648, w649, w650= w642(255, 140, 0, 255)
    local w667= w627((w650 or 255) * 0.95)

    w660 = math.max(0, math.min(1, w660 or 1))
    local w668= w661 - 1
    local w669= w662 - 1
    local w670= w663 + 2
    local w671= w664 + 2
    local w672= w670 / 2 + (w670 * 0.1)
    local w673= w627(w672 * w660)

    if w673 > 0 then
        local w674= math.min(w665 + 1, w627(w671 / 2), w627(w673 / 2))
        w632(w668, w669, w673, w671, w674, w647, w648, w649, w667)
        w632(w668 + w670 - w673, w669, w673, w671, w674, w647, w648, w649, w667)
    end
    w632(w661, w662, w663, w664, w665, 10, 10, 10, 230)
    w632(w661 + 1, w662 + 1, w663 - 2, w664 - 2, w666, 6, 6, 6, 220)
    if renderer.gradient then
        renderer.gradient(w661 + 2, w662 + 1, math.max(0, w663 - 4), 2, w647, w648, w649, w627(w667 * 0.14), w647, w648, w649, 0, true)
    end
    renderer.text(w633, w634 - 40, 255, 255, 255, 255, '', nil, w659)
end

return w657]]
w207["require/abc/register"] = [[local w630= require("require.abc.login_system")
local w631= "acc_" .. "OIDFGNSOIGNSFGIOSNGOISNGIOS"

local function w632(w633)
    local w634= {}
    for w635 in w633:gmatch("%S+") do
        table.insert(w634, w635)
    end
    return w634
end

client.set_event_callback("console_input", function(w636)
    local w634= w632(w636 or "")
    if #w634 == 0 then return end

    local w637= w634[1]:lower()
    if w637 ~= "register" then
        
        return
    end

    if #w634 < 4 then
        client.log("Usage: register <username> <password> <invite>")
        return
    end

    local w638= w634[2]
    local w639= w634[3]
    local w640= w634[4]

    local w641, w642= w630.is_valid_invite(w640)
    if not w641 then
        client.log("Register failed: invalid or used invite")
        return
    end

    local w643= database.read(w631) or {}
    if w643[w638] then
        client.log("Register failed: username already exists - ", w638)
        return
    end

    local w644, w645= w630.register_with_invite(w640, w638, w639)
    if w644 then
        client.log("Registered user:", w638)
    else
        client.log("Register failed:", w645 or "unknown error")
    end
end)]]
w207["require/abc/screen_logger"] = [[local renderer= renderer
local globals= globals
local client= client
local w633= table.insert
local w634= table.remove
local w635= math.floor




local w636= {}
local w637= 12

local function w638(w639)
    local w640, w641, w642= pcall(renderer.measure_text, '', w639)
    if w640 and type(w641) == 'number' then return w641, w642 or 0 end
    w640, w641, w642 = pcall(renderer.measure_text, w639)
    if w640 and type(w641) == 'number' then return w641, w642 or 0 end
    return 0, 0
end

local function w643(w644,w645,w646,w647,w648,w649)
    if not w644 then return end
    w645 = w645 or 4
    if #w636 >= w637 then
        w634(w636, 1)
    end
    w633(w636, {
        text = tostring(w644),
        duration = w645,
        color = { w646 or 255, w647 or 255, w648 or 255, w649 or 255 },
        ts = globals and globals.curtime and globals.curtime() or os.clock(),
    })
    return true
end

local function w650()
    if not renderer or not renderer.text then return end
    local w651= globals and globals.curtime and globals.curtime() or os.clock()
    local w652, w653= client and client.screen_size and client.screen_size() or 800, 600

    local w654= 8
    local w655= 6
    local w656= 14
    local w657= 2

    local w658= w655

    for w659 = #w636, 1, -1 do
        local w660= w636[w659]
        if not w660 then goto continue end
        local w661= w651 - (w660.ts or 0)
        local w662= (w660.duration or 4) - w661
        if w662 <= 0 then
            w634(w636, w659)
        else
            local w663, w664= w638(w660.text)
            
            local w665= w635(w660.color[4] or 255)
            
            pcall(renderer.text, w654, w658, w660.color[1] or 255, w660.color[2] or 255, w660.color[3] or 255, w665, 'b', 0, w660.text)
            w658 = w658 + (w664 > 0 and w664 or w656) + w657
        end
        ::continue::
    end
end

if client and client.set_event_callback then
    client.set_event_callback('paint', w650)
end

return w643]]
w207["require/brain/dll"] = [=[local ffi = require("ffi")

ffi.cdef([[
struct Vec3 { double x; double y; double z; };
struct AspectState { double original; double last; double last_update; int initialized; };
const char* clipboard_get();
int clipboard_set(const char* text);
int clipboard_empty();
int clantag_anim(double start_time, double now, char* out_buf, int out_buf_len);
void tracer_reset();
void tracer_push_shot(double sx, double sy, double sz, double t);
void tracer_set_impact(double ix, double iy, double iz, double t);
int tracer_collect(double now, double tracer_life, double fade_fraction, double pitch, double yaw, double fallback_dist, double base_alpha, double* out_buf, int max_lines);
 ]])


local function hex(val)
    local ok, num = pcall(ffi.cast, "uintptr_t", val)
    if not ok then return "<na>" end
    return string.format("0x%X", tonumber(num))
end

local function resolve_call_trampoline()
    local tramp = client.find_signature("engine.dll", "\xFF\xE1")
    if tramp == nil then
        return nil
    end
    return ffi.cast("void*", tramp)
end

local function make_import_thunk(sig_pattern, cast_type)
    local addr = client.find_signature("engine.dll", sig_pattern)
    if addr == nil then
        return nil
    end
    local ptr = ffi.cast("void***", ffi.cast("uintptr_t", addr) + 2)[0][0]
    return ptr
end

local call_trampoline = resolve_call_trampoline()
local gm_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B", "void *")
local gpa_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05", "void *")

if gm_thunk and gpa_thunk then
else
    return
end

local function via_trampoline(target, signature, label)
    local fn = ffi.cast(signature, call_trampoline)
    return function(...)
        return fn(target, ...)
    end
end

local function to_wide(str)
    local buf = ffi.new("wchar_t[?]", #str + 1)
    for i = 1, #str do buf[i - 1] = string.byte(str, i) end
    buf[#str] = 0
    return buf
end

local GetModuleHandleA_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const char *)", "GMH A")
local GetModuleHandleW_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const wchar_t *)", "GMH W")
local GetProcAddress_tr   = via_trampoline(gpa_thunk, "void *(__thiscall *)(void *, void *, const char *)", "GPA")

local function call_GetModuleHandle(name)
    local ok1, res1 = pcall(GetModuleHandleA_tr, name)
    if not ok1 then dbg("GetModuleHandleA tramp err", res1) end
    if ok1 and res1 ~= nil and res1 ~= ffi.NULL then
        return res1, "tramp ansi"
    end

    local ok2, res2 = pcall(GetModuleHandleW_tr, to_wide(name))
    if not ok2 then dbg("GetModuleHandleW tramp err", res2) end
    if ok2 and res2 ~= nil and res2 ~= ffi.NULL then
        return res2, "tramp wide"
    end

    return nil, "failed"
end

local function call_GetProcAddress(mod, name)
    local ok, res = pcall(GetProcAddress_tr, mod, name)
    if not ok then dbg("GetProcAddress tramp err", res) end
    if ok and res ~= nil and res ~= ffi.NULL then return res end
    return nil
end

local mod, gm_variant = call_GetModuleHandle("sodiumdll.dll")
if mod == nil then
    return
end

local function bind_export(name, cdecl_sig)
    local addr = call_GetProcAddress(mod, name)
    if addr == nil then
        return nil
    end
    return addr, ffi.cast(cdecl_sig, addr)
end

local add_addr, add_fn = bind_export("add", "int(__cdecl*)(int, int)")
local get_value_addr, get_value_fn = bind_export("get_value", "int(__cdecl*)(void)")
local pin_module_addr, pin_module_fn = bind_export("pin_module", "void(__cdecl*)(void)")
local release_module_addr, release_module_fn = bind_export("release_module", "void(__cdecl*)(void)")
local get_hwid_addr, get_hwid_fn = bind_export("get_hwid", "const char*(__cdecl*)(void)")
local clipboard_get_addr, clipboard_get_fn = bind_export("clipboard_get", "const char*(__cdecl*)(void)")
local clipboard_set_addr, clipboard_set_fn = bind_export("clipboard_set", "int(__cdecl*)(const char*)")
local clipboard_empty_addr, clipboard_empty_fn = bind_export("clipboard_empty", "int(__cdecl*)(void)")
local clantag_anim_addr, clantag_anim_fn = bind_export("clantag_anim", "int(__cdecl*)(double, double, char*, int)")
local tracer_reset_addr, tracer_reset_fn = bind_export("tracer_reset", "void(__cdecl*)(void)")
local tracer_push_shot_addr, tracer_push_shot_fn = bind_export("tracer_push_shot", "void(__cdecl*)(double, double, double, double)")
local tracer_set_impact_addr, tracer_set_impact_fn = bind_export("tracer_set_impact", "void(__cdecl*)(double, double, double, double)")
local tracer_collect_addr, tracer_collect_fn = bind_export("tracer_collect", "int(__cdecl*)(double, double, double, double, double, double, double, double*, int)")

local vec_make_addr, vec_make_fn = bind_export("vec_make", "struct Vec3(__cdecl*)(double, double, double)")
local vec_add_addr, vec_add_fn = bind_export("vec_add", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_sub_addr, vec_sub_fn = bind_export("vec_sub", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_mul_scalar_addr, vec_mul_scalar_fn = bind_export("vec_mul_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_div_scalar_addr, vec_div_scalar_fn = bind_export("vec_div_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_unm_addr, vec_unm_fn = bind_export("vec_unm", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_length_addr, vec_length_fn = bind_export("vec_length", "double(__cdecl*)(struct Vec3)")
local vec_dot_addr, vec_dot_fn = bind_export("vec_dot", "double(__cdecl*)(struct Vec3, struct Vec3)")
local vec_cross_addr, vec_cross_fn = bind_export("vec_cross", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_normalized_addr, vec_normalized_fn = bind_export("vec_normalized", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_distance_addr, vec_distance_fn = bind_export("vec_distance", "double(__cdecl*)(struct Vec3, struct Vec3)")

local m_clamp_addr, m_clamp_fn = bind_export("m_clamp", "double(__cdecl*)(double, double, double)")
local m_clamp01_addr, m_clamp01_fn = bind_export("m_clamp01", "double(__cdecl*)(double)")
local m_abs_addr, m_abs_fn = bind_export("m_abs", "double(__cdecl*)(double)")
local m_lerp_addr, m_lerp_fn = bind_export("m_lerp", "double(__cdecl*)(double, double, double)")
local m_distance2d_addr, m_distance2d_fn = bind_export("m_distance2d", "double(__cdecl*)(double, double, double, double)")
local m_distance3d_addr, m_distance3d_fn = bind_export("m_distance3d", "double(__cdecl*)(double, double, double, double, double, double)")
local m_rad_to_deg_addr, m_rad_to_deg_fn = bind_export("m_rad_to_deg", "double(__cdecl*)(double)")
local m_deg_to_rad_addr, m_deg_to_rad_fn = bind_export("m_deg_to_rad", "double(__cdecl*)(double)")
local m_wrap_degrees_addr, m_wrap_degrees_fn = bind_export("m_wrap_degrees", "double(__cdecl*)(double)")
local m_normalize_angle_addr, m_normalize_angle_fn = bind_export("m_normalize_angle", "double(__cdecl*)(double)")
local m_angle_diff_addr, m_angle_diff_fn = bind_export("m_angle_diff", "double(__cdecl*)(double, double)")
local m_lerp_angle_addr, m_lerp_angle_fn = bind_export("m_lerp_angle", "double(__cdecl*)(double, double, double)")
local m_map_addr, m_map_fn = bind_export("m_map", "double(__cdecl*)(double, double, double, double, double)")
local m_smoothstep_addr, m_smoothstep_fn = bind_export("m_smoothstep", "double(__cdecl*)(double, double, double)")
local aspect_update_addr, aspect_update_fn = bind_export("aspect_update", "void(__cdecl*)(void*, double, double, double, double*, int*)")

if not (add_fn and get_value_fn and pin_module_fn and release_module_fn and get_hwid_fn and
    vec_make_fn and vec_add_fn and vec_sub_fn and vec_mul_scalar_fn and vec_div_scalar_fn and
    vec_unm_fn and vec_length_fn and vec_dot_fn and vec_cross_fn and vec_normalized_fn and vec_distance_fn and
    m_clamp_fn and m_clamp01_fn and m_abs_fn and m_lerp_fn and m_distance2d_fn and m_distance3d_fn and
    m_rad_to_deg_fn and m_deg_to_rad_fn and m_wrap_degrees_fn and m_normalize_angle_fn and m_angle_diff_fn and
    m_lerp_angle_fn and m_map_fn and m_smoothstep_fn and aspect_update_fn and
    clipboard_get_fn and clipboard_set_fn and clipboard_empty_fn and clantag_anim_fn and
    tracer_reset_fn and tracer_push_shot_fn and tracer_set_impact_fn and tracer_collect_fn) then
    return
end

local Call_add = via_trampoline(add_addr, "int(__thiscall *)(void*, int, int)", "add")
local Call_get_value = via_trampoline(get_value_addr, "int(__thiscall *)(void*)", "get_value")
local Call_pin_module = via_trampoline(pin_module_addr, "void(__thiscall *)(void*)", "pin_module")
local Call_release_module = via_trampoline(release_module_addr, "void(__thiscall *)(void*)", "release_module")
local Call_get_hwid = via_trampoline(get_hwid_addr, "const char*(__thiscall *)(void*)", "get_hwid")
local Call_clipboard_get = via_trampoline(clipboard_get_addr, "const char*(__thiscall *)(void*)", "clipboard_get")
local Call_clipboard_set = via_trampoline(clipboard_set_addr, "int(__thiscall *)(void*, const char*)", "clipboard_set")
local Call_clipboard_empty = via_trampoline(clipboard_empty_addr, "int(__thiscall *)(void*)", "clipboard_empty")
local Call_clantag_anim = via_trampoline(clantag_anim_addr, "int(__thiscall *)(void*, double, double, char*, int)", "clantag_anim")
local Call_tracer_reset = via_trampoline(tracer_reset_addr, "void(__thiscall *)(void*)", "tracer_reset")
local Call_tracer_push_shot = via_trampoline(tracer_push_shot_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_push_shot")
local Call_tracer_set_impact = via_trampoline(tracer_set_impact_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_set_impact")
local Call_tracer_collect = via_trampoline(tracer_collect_addr, "int(__thiscall *)(void*, double, double, double, double, double, double, double, double*, int)", "tracer_collect")
local Call_vec_make = via_trampoline(vec_make_addr, "struct Vec3(__thiscall *)(void*, double, double, double)", "vec_make")
local Call_vec_add = via_trampoline(vec_add_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_add")
local Call_vec_sub = via_trampoline(vec_sub_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_sub")
local Call_vec_mul_scalar = via_trampoline(vec_mul_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_mul_scalar")
local Call_vec_div_scalar = via_trampoline(vec_div_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_div_scalar")
local Call_vec_unm = via_trampoline(vec_unm_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_unm")
local Call_vec_length = via_trampoline(vec_length_addr, "double(__thiscall *)(void*, struct Vec3)", "vec_length")
local Call_vec_dot = via_trampoline(vec_dot_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_dot")
local Call_vec_cross = via_trampoline(vec_cross_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_cross")
local Call_vec_normalized = via_trampoline(vec_normalized_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_normalized")
local Call_vec_distance = via_trampoline(vec_distance_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_distance")

local Call_m_clamp = via_trampoline(m_clamp_addr, "double(__thiscall *)(void*, double, double, double)", "m_clamp")
local Call_m_clamp01 = via_trampoline(m_clamp01_addr, "double(__thiscall *)(void*, double)", "m_clamp01")
local Call_m_abs = via_trampoline(m_abs_addr, "double(__thiscall *)(void*, double)", "m_abs")
local Call_m_lerp = via_trampoline(m_lerp_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp")
local Call_m_distance2d = via_trampoline(m_distance2d_addr, "double(__thiscall *)(void*, double, double, double, double)", "m_distance2d")
local Call_m_distance3d = via_trampoline(m_distance3d_addr, "double(__thiscall *)(void*, double, double, double, double, double, double)", "m_distance3d")
local Call_m_rad_to_deg = via_trampoline(m_rad_to_deg_addr, "double(__thiscall *)(void*, double)", "m_rad_to_deg")
local Call_m_deg_to_rad = via_trampoline(m_deg_to_rad_addr, "double(__thiscall *)(void*, double)", "m_deg_to_rad")
local Call_m_wrap_degrees = via_trampoline(m_wrap_degrees_addr, "double(__thiscall *)(void*, double)", "m_wrap_degrees")
local Call_m_normalize_angle = via_trampoline(m_normalize_angle_addr, "double(__thiscall *)(void*, double)", "m_normalize_angle")
local Call_m_angle_diff = via_trampoline(m_angle_diff_addr, "double(__thiscall *)(void*, double, double)", "m_angle_diff")
local Call_m_lerp_angle = via_trampoline(m_lerp_angle_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp_angle")
local Call_m_map = via_trampoline(m_map_addr, "double(__thiscall *)(void*, double, double, double, double, double)", "m_map")
local Call_m_smoothstep = via_trampoline(m_smoothstep_addr, "double(__thiscall *)(void*, double, double, double)", "m_smoothstep")
local Call_aspect_update = via_trampoline(aspect_update_addr, "void(__thiscall *)(void*, void*, double, double, double, double*, int*)", "aspect_update")


return {
    add = function(a, b)
        return Call_add(a, b)
    end,
    get_value = function()
        return Call_get_value()
    end,
    pin_module = function()
        return Call_pin_module()
    end,
    release_module = function()
        return Call_release_module()
    end,
    get_hwid = function()
        return Call_get_hwid()
    end,
    clipboard_get = function()
        return Call_clipboard_get()
    end,
    clipboard_set = function(text)
        return Call_clipboard_set(text)
    end,
    clipboard_empty = function()
        return Call_clipboard_empty()
    end,
    clantag_anim = function(start_time, now, out_buf, out_buf_len)
        return Call_clantag_anim(start_time, now, out_buf, out_buf_len)
    end,
    tracer_reset = function()
        return Call_tracer_reset()
    end,
    tracer_push_shot = function(sx, sy, sz, t)
        return Call_tracer_push_shot(sx, sy, sz, t)
    end,
    tracer_set_impact = function(ix, iy, iz, t)
        return Call_tracer_set_impact(ix, iy, iz, t)
    end,
    tracer_collect = function(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
        return Call_tracer_collect(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
    end,
    vec_make = function(x, y, z)
        return Call_vec_make(x, y, z)
    end,
    vec_add = function(a, b)
        return Call_vec_add(a, b)
    end,
    vec_sub = function(a, b)
        return Call_vec_sub(a, b)
    end,
    vec_mul_scalar = function(v, s)
        return Call_vec_mul_scalar(v, s)
    end,
    vec_div_scalar = function(v, s)
        return Call_vec_div_scalar(v, s)
    end,
    vec_unm = function(v)
        return Call_vec_unm(v)
    end,
    vec_length = function(v)
        return Call_vec_length(v)
    end,
    vec_dot = function(a, b)
        return Call_vec_dot(a, b)
    end,
    vec_cross = function(a, b)
        return Call_vec_cross(a, b)
    end,
    vec_normalized = function(v)
        return Call_vec_normalized(v)
    end,
    vec_distance = function(a, b)
        return Call_vec_distance(a, b)
    end,
    m_clamp = function(val, minVal, maxVal)
        return Call_m_clamp(val, minVal, maxVal)
    end,
    m_clamp01 = function(val)
        return Call_m_clamp01(val)
    end,
    m_abs = function(val)
        return Call_m_abs(val)
    end,
    m_lerp = function(a, b, t)
        return Call_m_lerp(a, b, t)
    end,
    m_distance2d = function(x1, y1, x2, y2)
        return Call_m_distance2d(x1, y1, x2, y2)
    end,
    m_distance3d = function(x1, y1, z1, x2, y2, z2)
        return Call_m_distance3d(x1, y1, z1, x2, y2, z2)
    end,
    m_rad_to_deg = function(rad)
        return Call_m_rad_to_deg(rad)
    end,
    m_deg_to_rad = function(deg)
        return Call_m_deg_to_rad(deg)
    end,
    m_wrap_degrees = function(angle)
        return Call_m_wrap_degrees(angle)
    end,
    m_normalize_angle = function(angle)
        return Call_m_normalize_angle(angle)
    end,
    m_angle_diff = function(a, b)
        return Call_m_angle_diff(a, b)
    end,
    m_lerp_angle = function(a, b, t)
        return Call_m_lerp_angle(a, b, t)
    end,
    m_map = function(val, in_min, in_max, out_min, out_max)
        return Call_m_map(val, in_min, in_max, out_min, out_max)
    end,
    m_smoothstep = function(edge0, edge1, x)
        return Call_m_smoothstep(edge0, edge1, x)
    end,
    aspect_update = function(state, raw_slider, current_aspect, now, out_target, out_dirty)
        return Call_aspect_update(state, raw_slider, current_aspect, now, out_target, out_dirty)
    end,
    module_base = mod,
}]=]
w207["require/brain/test"] = [[local w639= require("require/brain/api/math/math")
local w640= require("require/brain/api/health/health")
local w641= require("require/brain/api/hwid/hwid")
local w642= require("require/brain/dll")


client.set_event_callback("paint_ui", function()
    local w643, w644= pcall(w639.add, 2, math.random(1, 100))
    if w643 then
        
    end

end)

local w645, w646= pcall(w641.get_hwid)
if w645 and w646 and w646 ~= "" then
    
else
    
end]]
w207["require/brain/api/clipboard/clipboard"] = [[]]
w207["require/brain/api/health/health"] = [[local w645= require("require/brain/dll")

if not w645 then
	error("sodiumdll exports unavailable")
end

return {
	pin_module = function()
		return w645.pin_module()
	end,
	release_module = function()
		return w645.release_module()
	end,
	module_base = w645.module_base,
}]]
w207["require/brain/api/hwid/hwid"] = [[local w648= require("ffi")
local w649= require("require/brain/dll")

if not w649 or not w649.get_hwid then
    error("sodiumdll hwid export missing")
end

return {
	get_hwid = function()
		local w650= w649.get_hwid()
		if not w650 or w650 == w648.NULL then
			return ""
		end
		return w648.string(w650)
	end,
}]]
w207["require/brain/api/ip/ip"] = [[
local w651= require("require/brain/dll")

if not w651 or not w651.get_public_ip then
	return error("sodiumdll ip export missing")
end

return {
	get_public_ip = function(w652,w653)
		return w651.get_public_ip(w652, w653)
	end,
}]]
w207["require/brain/api/math/math"] = [[local w654= require("require/brain/dll")

if not w654 or not w654.m_clamp then
	error("sodiumdll math exports missing")
end

return {
	add = function(w655,w656)
		return w654.add(w655, w656)
	end,
	get_value = function()
		return w654.get_value()
	end,
	m_clamp = function(w657,w658,w659)
		return w654.m_clamp(w657, w658, w659)
	end,
	m_clamp01 = function(w657)
		return w654.m_clamp01(w657)
	end,
	m_abs = function(w657)
		return w654.m_abs(w657)
	end,
	m_lerp = function(w655,w656,w660)
		return w654.m_lerp(w655, w656, w660)
	end,
	m_distance2d = function(w661,w662,w663,w664)
		return w654.m_distance2d(w661, w662, w663, w664)
	end,
	m_distance3d = function(w661,w662,w665,w663,w664,w666)
		return w654.m_distance3d(w661, w662, w665, w663, w664, w666)
	end,
	m_rad_to_deg = function(w667)
		return w654.m_rad_to_deg(w667)
	end,
	m_deg_to_rad = function(w668)
		return w654.m_deg_to_rad(w668)
	end,
	m_wrap_degrees = function(w669)
		return w654.m_wrap_degrees(w669)
	end,
	m_normalize_angle = function(w669)
		return w654.m_normalize_angle(w669)
	end,
	m_angle_diff = function(w655,w656)
		return w654.m_angle_diff(w655, w656)
	end,
	m_lerp_angle = function(w655,w656,w660)
		return w654.m_lerp_angle(w655, w656, w660)
	end,
	m_map = function(w657,w670,w671,w672,w673)
		return w654.m_map(w657, w670, w671, w672, w673)
	end,
	m_smoothstep = function(w674,w675,w676)
		return w654.m_smoothstep(w674, w675, w676)
	end,
}]]
w207["require/brain/api/vector/vector"] = [[local w657= require("ffi")
local w658= require("require/brain/dll")

if not w658 or not w658.vec_make or not w658.vec_add or not w658.vec_sub or not w658.vec_mul_scalar or
   not w658.vec_div_scalar or not w658.vec_unm or not w658.vec_length or not w658.vec_dot or
   not w658.vec_cross or not w658.vec_normalized or not w658.vec_distance or not w658.aspect_update then
    error("sodiumdll vector exports missing")
end

local w659= w657.typeof("struct Vec3")

local function w660(w661)
    if w657.istype(w659, w661) then
        return w661
    end
    local w662= (w661 and w661.x) or 0
    local w663= (w661 and w661.y) or 0
    local w664= (w661 and w661.z) or 0
    return w658.vec_make(w662, w663, w664)
end

return {
    Vec3 = w659,
    make = function(w662,w663,w664)
        return w658.vec_make(w662 or 0, w663 or 0, w664 or 0)
    end,
    add = function(w665,w666)
        return w658.vec_add(w660(w665), w660(w666))
    end,
    sub = function(w665,w666)
        return w658.vec_sub(w660(w665), w660(w666))
    end,
    mul_scalar = function(w661,w667)
        return w658.vec_mul_scalar(w660(w661), w667)
    end,
    div_scalar = function(w661,w667)
        return w658.vec_div_scalar(w660(w661), w667)
    end,
    unm = function(w661)
        return w658.vec_unm(w660(w661))
    end,
    length = function(w661)
        return w658.vec_length(w660(w661))
    end,
    dot = function(w665,w666)
        return w658.vec_dot(w660(w665), w660(w666))
    end,
    cross = function(w665,w666)
        return w658.vec_cross(w660(w665), w660(w666))
    end,
    normalized = function(w661)
        return w658.vec_normalized(w660(w661))
    end,
    distance = function(w665,w666)
        return w658.vec_distance(w660(w665), w660(w666))
    end,
    aspect_update = w658.aspect_update,
}]]
w207["require/brain/examples/boxes"] = [[local w660= require("ffi")
local w661= {


}


w661.GetModuleHandlePtr = 
    w660.cast(
        "void***", 
        w660.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B")) + 2
    )[0][0]

w661.GetProcAddressPtr = 
    w660.cast(
        "void***", 
        w660.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05")) + 2
    )[0][0]


w661.reinterpret_cast = function(w662,w663) 
    return function(...) 
        return w660.cast(w663, client.find_signature("engine.dll", "\xFF\xE1"))(w662, ...) 
    end
end


w661.fnGetModuleHandle = w661.reinterpret_cast(
    w661.GetModuleHandlePtr, 
    "void*(__thiscall*)(void*, const char*)"
)

w661.GetModuleHandle = function(w664)
    return w661.fnGetModuleHandle(w664)
end 


w661.fnGetProcAddress = w661.reinterpret_cast(
    w661.GetProcAddressPtr, 
    "void*(__thiscall*)(void*, void*, const char*)"
)

w661.GetProcAddress = function(w664,w665)
    local w662= w661.fnGetProcAddress(w664, w665)
    return w662
end 


w661.lib = {}
w661.lib.user32 = w661.GetModuleHandle("user32.dll")


w661.export = {}
w661.export.user32 = {}

w661.export.user32.MessageBoxPtr = w661.GetProcAddress(w661.lib.user32, "MessageBoxA")
w661.export.user32.MessageBox = w661.reinterpret_cast(
    w661.export.user32.MessageBoxPtr,
    "int(__thiscall*)(void*, void*, const char*, const char*, unsigned int)"
)


local w666= 0x00000000
local w667= 0x00000001
local w668= 0x00000004
local w669= 0x00000010
local w670= 0x00000020
local w671= 0x00000030
local w672= 0x00000040


local w673= 1
local w674= 2
local w675= 6
local w676= 7


local function w677(w678,w679,type)
    w679 = w679 or "Gamesense"
    type = type or w666
    
    local w680= w661.export.user32.MessageBox(nil, w678, w679, type)
    return w680
end


local function w681(w678,w679)
    return w677(w678, w679, w666 + w672)
end

local function w682(w678,w679)
    return w677(w678, w679, w666 + w671)
end

local function w683(w678,w679)
    return w677(w678, w679, w666 + w669)
end

local function w684(w678,w679)
    local w680= w677(w678, w679, w668 + w670)
    return w680 == w675
end
w681("test", "test")]]
w207["require/brain/features/aspectratio"] = [[local w663= require("ffi")
local w664= require("require/brain/dll")

if not w664 or not w664.aspect_update then
    error("sodiumdll aspect_update export missing")
end

return {
    aspect_update = function(w665,w666,w667,w668)
        local w669= w663.new("double[1]")
        local w670= w663.new("int[1]")

        w664.aspect_update(w665 or w663.NULL, w666, w667, w668, w669, w670)

        return w669[0], w670[0]
    end,
}]]
w207["require/features/aa/aa_collect"] = [[
local w666= entity
local w667= require('require/abc/menu_setup')
local w668= require('require/aa/player_condition')

local w669= {}
w669.last_side = 'left'

local function w670()
    local w671, w672= pcall(w668.get)
    if not w671 or not w672 then return nil end
    local w673= 'delay_' .. w672
    if not (w667 and w667.ui) then return nil end
    local w674= w667.ui[w673]
    if not w674 then return nil end
    local w675, w676= pcall(ui.get, w674)
    if not w675 then return nil end
    local w677= tonumber(w676)
    if w677 then return w677 end
    return w676
end

local function w678()
    local w671, w672= pcall(w668.get)
    if not w671 or not w672 then return nil end
    local w673= 'fifty_fifty_' .. w672
    if not (w667 and w667.ui) then return nil end
    local w674= w667.ui[w673]
    if not w674 then return nil end
    local w675, w676= pcall(ui.get, w674)
    if not w675 then return nil end
    local w677= tonumber(w676)
    if w677 then return w677 end
    return w676
end

local function w679()
    local w671, w672= pcall(w668.get)
    if not w671 or not w672 then return nil end
    local w673= 'body_yaw_mode_' .. w672
    if not (w667 and w667.ui) then return nil end
    local w674= w667.ui[w673]
    if not w674 then return nil end
    local w675, w676= pcall(ui.get, w674)
    if not w675 then return nil end
    local w677= tonumber(w676)
    if w677 then return w677 end
    return w676
end

local function w680(w681)
    if not (w666 and w666.get_prop and w681) then return w669.last_side end
    local w682= w666.get_prop(w681, 'm_flPoseParameter', 11)
    if w682 == nil then
        return w669.last_side
    end
    local w683= (w682 > 0.5) and 'right' or 'left'
    w669.last_side = w683
    return w683
end

local function w684()
    local w685= w670() + 1
    local w677= tonumber(w685) or 1
    if w677 < 1 then w677 = 1 end
    if w677 > 17 then w677 = 17 end

    local w686= globals.tickcount()
    if not w686 then return w669.last_side end

    local w687= math.floor(w686 / w677) % 2
    local w683= (w687 == 0) and 'left' or 'right'
    w669.last_side = w683
    return w683
end




local function w688()

    local w689= w678()

    if w689 then
        local w690= math.random(0, 1)
        local w683= (w690 == 0) and 'left' or 'right'
        w669.last_side = w683
        return w683
    end

    local w685= w670()
    local w677= tonumber(w685)

    if w679() ~= 'jitter' then
        return w680(w666.get_local_player())
    end

    if not w677 or w677 == 0 then
        local w681= w666.get_local_player()
        if not w681 or w681 == 0 then return w669.last_side end
        return w680(w681)
    else
        return w684()
    end
end





w669.resolve_side = w680
w669.resolve_local_side = w688
w669.get_delay_for_current_condition = w670

return w669]]
w207["require/features/aa/antiaim"] = [[local w669= require('require/features/aa/builder')
local w670= require('require/features/aa/defensive')

local w671= require('require/abc/callbacks')

local function w672()
    local w673= (globals.maxplayers and globals.maxplayers() or 64)
    local w674, w675, w676= entity.get_classname, entity.is_enemy, entity.is_alive
    if not (w674 and w675 and w676) then return 0 end
    local w677= 0
    for w678=1,w673 do
        if w674(w678) == 'CCSPlayer' and w675(w678) and w676(w678) then w677 = w677 + 1 end
    end
    return w677
end

w671.register('setup_command', function(w679)
    if w669 and w669.activate then
        w669.activate(w679)
    end

end, { alive_only = true, require_login = true })]]
w207["require/features/aa/antibrute"] = [[]]
w207["require/features/aa/builder"] = [[local w675= require('require/abc/menu_setup')
local w676= require('require/aa/player_condition')
local w677= require('require/features/aa/aa_collect')
local w678= require('require/help/math')
local w679= require('require/help/vector')
local w680= require('require/help/time')
local w681= require('require/help/string')

local w682= {}
client.set_event_callback('weapon_fire', function(w683)
  if not w683 or not w683.userid then return end
  local w684, w685= pcall(client.userid_to_entindex, w683.userid)
  if not w684 or not w685 or w685 == 0 then return end
  w682[w685] = w680.tickcount()
end)

local function w686(w687)
	if not w687 then return nil end

	local w688= {
		pitch = 'pitch_',
		yaw_base = 'yaw_base_',
		yaw = 'yaw_',
		body_yaw_base = 'body_yaw_base_',
		body_yaw_left = 'body_yaw_left_',
		body_yaw_right = 'body_yaw_right_',
		randomize_yaw = 'randomize_yaw_',
		yaw_jitter = 'yaw_jitter_',
		yaw_jitter_base = 'yaw_jitter_base_',
		body_yaw_mode = 'body_yaw_mode_',
		static_body_yaw = 'static_body_yaw_',
		body_yaw_value = 'body_yaw_value_',
		delay = 'delay_',
		fifty_fifty = 'fifty_fifty_',
		only_flip_on_0_choke = 'only_flip_on_0_choke_',
	}

	local w689= { condition = w687 }
	for w690, w691 in pairs(w688) do
		local w692= w691 .. w687
		local w693= w675.ui and w675.ui[w692]
		if w693 then
			local w694, w695= pcall(ui.get, w693)
			if w694 then w689[w690] = w695 else w689[w690] = nil end
		else
			w689[w690] = nil
		end
	end

	return w689
end




local function w696()
  local w694, w687= pcall(w676.get)
  if not w694 or not w687 then
    return nil
  end
  local w697= w686(w687)
  return w697 and w697.pitch or nil
end




local function w698()
  local w694, w687= pcall(w676.get)
  if not w694 or not w687 then
    return nil
  end
  local w697= w686(w687)
  local w699= w697 and w697.yaw_base or nil
  if w699 == nil then return nil end
  local w700= w681.lower(tostring(w699))
  if w700 == 'threat' then
    return 'local view'
  elseif w700 == 'distance' then
    return 'local view'
  elseif w700 == 'target' then
    return 'at targets'
  elseif w700 == 'view' then
    return 'local view'
  elseif w700 == 'smart' then
    return 'local view'
  else
    return tostring(w699)
  end
end




local function w701()
	local w694, w687= pcall(w676.get)
	if not w694 or not w687 then
		return nil
	end
	local w697= w686(w687)
	return w697 and w697.yaw or nil
end




local function w702()
    local w694, w687= pcall(w676.get)
    if not w694 or not w687 then
        return nil
    end
    local w697= w686(w687)
    return w697 and w697.yaw_jitter or nil
end




local function w703()
  local w694, w687= pcall(w676.get)
  if not w694 or not w687 then
    return nil
  end
  local w697= w686(w687)
  return w697 and w697.yaw_jitter_base or nil
end




local function w704()
  local w694, w687= pcall(w676.get)
  if not w694 or not w687 then return nil end
  local w697= w686(w687)
  if not w697 then return nil end
  local w705= w697.randomize_yaw
  if w705 == nil then return nil end
  local w706= tonumber(w705)
  if not w706 then return nil end
  if w706 < 0 then w706 = 0 end
  if w706 > 30 then w706 = 30 end
  return math.floor(w706)
end




local function w707()
    local w694, w687= pcall(w676.get)
    if not w694 or not w687 then
        return nil
    end
  local w697= w686(w687)
  local w708= w697 and w697.body_yaw_mode or nil
  if not w708 then return nil end
  local w709= w681.lower(tostring(w708))
  if w709 == 'jitter' then
    local w710= w677.get_delay_for_current_condition and w677.get_delay_for_current_condition() or nil
    local w706= tonumber(w710) or 0
    if w706 > 0 then
      return 'static'
    else
      return 'jitter'
    end
  end
  return w708
end




local function w711()
  local w694, w687= pcall(w676.get)
  if not w694 or not w687 then
    return nil
  end
  local w697= w686(w687)
  if not w697 then return nil end


  local w708= w697.body_yaw_mode
  if w708 ~= nil then w708 = w681.lower(tostring(w708)) end

  if w708 == 'jitter' then
    local w710= w677.get_delay_for_current_condition and w677.get_delay_for_current_condition() or nil
    local w712= tonumber(w710) or 0
    if w712 > 0 then
      local w713= w677.resolve_local_side and w677.resolve_local_side() or nil
      if w713 == 'right' then
        return -58
      else
        return 58
      end
    end

    local w699= w697.body_yaw_value
    local w706= tonumber(w699) or nil
    if w706 == 1 then
      return -180
    elseif w706 == 2 then
      return 0
    elseif w706 == 3 then
      return 180
    end
    return nil
  elseif w708 == 'static' then
    if w697.static_body_yaw ~= nil then
      local w714= tonumber(w697.static_body_yaw)
      if w714 then return w714 end
    end
    local w699= w697.body_yaw_value
    local w706= tonumber(w699) or nil
    if w706 == 1 then
      return -180
    elseif w706 == 2 then
      return 0
    elseif w706 == 3 then
      return 180
    end
    return nil
  else
    return 0
  end
end




local function w715()
  local w694, w687= pcall(w676.get)
  if not w694 or not w687 then
    return nil
  end
  local w697= w686(w687)
  return w697 and w697.body_yaw_base or nil
end




local function w716()
    local w694, w687= pcall(w676.get)
    if not w694 or not w687 then
        return nil
    end
    local w697= w686(w687)
    return w697 and w697.body_yaw_left or nil
end




local function w717()
    local w694, w687= pcall(w676.get)
    if not w694 or not w687 then
        return nil
    end
    local w697= w686(w687)
    return w697 and w697.body_yaw_right or nil
end




local function w718()
    local w694, w687= pcall(w676.get)
    if not w694 or not w687 then
        return nil
    end
    local w697= w686(w687)
    if not w697 then return nil end
    local w705= w697.only_flip_on_0_choke
    if w705 == nil then return nil end
    return not not w705
end




local function w719()
  local w694, w687= pcall(w676.get)
  if not w694 or not w687 then
    return nil
  end
  local w692= 'delay_' .. w687
  if not (w675 and w675.ui) then return nil end
  local w693= w675.ui[w692]
  if not w693 then return nil end
  local w720, w695= pcall(ui.get, w693)
  if w720 then return w695 end
  return nil
end




local function w721()
  local w694, w687= pcall(w676.get)
  if not w694 or not w687 then return nil end
  local w697= w686(w687)
  if not w697 then return nil end
  local w705= w697.fifty_fifty
  if w705 == nil then return nil end
  return not not w705
end





local function w722(w708)
  local w709= w681.lower(tostring(w708 or 'threat'))

  local w723= nil
  if w709 == 'distance' then
    local w724, w725= pcall(entity.get_players, true)
    if not w724 or not w725 or #w725 == 0 then return nil end
    local w726= entity.get_local_player()
    if not w726 then return nil end
    local w727, w728, w729, w730= pcall(entity.get_origin, w726)
    if not w727 or not w728 then return nil end
    local w731= nil
    local w732= nil
    for w733, w685 in ipairs(w725) do
      if w685 and entity.is_alive and entity.is_alive(w685) and entity.is_enemy and entity.is_enemy(w685) then
        local w734, w735, w736, w737= pcall(entity.get_origin, w685)
        if w734 and w735 then
          local w738= w678.distance2d(w728, w729, w735, w736)
          if not w732 or w738 < w732 then
            w732 = w738
            w731 = w685
          end
        end
      end
    end
    w723 = w731
    elseif w709 == 'smart' then
      local w724, w725= pcall(entity.get_players, true)
      if w724 and w725 and #w725 > 0 then
        local w726= entity.get_local_player()
        if w726 then
          local w727, w728, w729, w730= pcall(entity.get_origin, w726)
          if w727 and w728 then
            local w731= nil
            local w732= nil
            for w733, w685 in ipairs(w725) do
              if w685 and entity.is_alive and entity.is_alive(w685) and entity.is_enemy and entity.is_enemy(w685) then
                local w734, w735, w736, w737= pcall(entity.get_origin, w685)
                if w734 and w735 then
                  local w739= w682[w685]
                  if w739 and w680.within_ticks_window(w739, 10) then goto continue_smart end
                  local w740, w741= pcall(entity.get_player_weapon, w685)
                  if w740 and w741 and w741 ~= 0 then
                    local w742, w743= pcall(entity.get_classname, w741)
                    local w744= w681.lower(w742 and w743 and tostring(w743) or '')
                    if w744:find('knife') or w744:find('grenade') or w744:find('taser') or w744:find('zeus') then goto continue_smart end
                  end
                  do
                    local w738= w678.distance2d(w728, w729, w735, w736)
                    if not w732 or w738 < w732 then
                      w732 = w738
                      w731 = w685
                    end
                  end
                  ::continue_smart::
                end
              end
            end
            w723 = w731
          end
        end
      end
      if not w723 then
        local w745, w746= pcall(client.current_threat)
        if w745 and w746 then w723 = w746 end
      end
    else
      local w745, w746= pcall(client.current_threat)
      if w745 and w746 then w723 = w746 end
    end

  if not w723 then return nil end
  if not (entity.is_alive and entity.is_enemy and entity.is_alive(w723) and entity.is_enemy(w723)) then
    return nil
  end

  local w726= entity.get_local_player()
  if not w726 then return nil end

  local w747, w728, w729, w730= pcall(entity.get_origin, w726)
  local w748, w735, w736, w737= pcall(entity.get_origin, w723)
  if not w747 or not w748 or not w728 or not w735 then return nil end

  local w749= w735 - w728
  local w750= w736 - w729
  local w751= math.atan2(w750, w749)
  local w752= w678.rad_to_deg(w751)

  local w753, w754, w755= pcall(client.camera_angles)
  local w756= w753 and w755 or 0

  local w757= w678.normalize_angle(w752 - w756)
  return w678 and w678.round and w678.round(w757) or math.floor(w757 + 0.5)

end




local w758= {}
local w759= {}
for w760, w761 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local w762= {ui.reference(w761[1], w761[2], w761[3])}
    w758[w760] = w762
    for w733, w763 in ipairs(w762) do
        w759[w763] = true
    end
end





local function w764(w765)
  if weaponn ~= nil and entity.get_classname(weaponn) == "CC4" then
    if w765.in_attack == 1 then
        w765.in_attack = 0 
        w765.in_use = 1
    end
  else
    if w765.chokedcommands == 0 then
        w765.in_use = 0
    end
  end

end





local function w766(w765)

    local w767= w765.chokedcommands
    
    if w718() then
        if w767 > 0 then
            return
        end
    end

    local w713= w677.resolve_local_side()

    
    
    
    ui.set(w758[2][1], tostring(w696()))

    
    
    
    ui.set(w758[3][1], tostring(w698()))

    
    
    
    local w768= w701()
    if w768 == "3way" then
      w768 = '180'
    elseif w768 == "ideal" then
      w768 = '180'
    end
    ui.set(w758[4][1], w768)

    
    
    
    ui.set(w758[5][1], tostring(w702()))

    
    
    
    ui.set(w758[5][2], tostring(w703()))

    
    
    
    ui.set(w758[6][1], tostring(w707()))

    
    
    
    ui.set(w758[6][2], tostring(w711()))

    
    
    
    local w769= tonumber(w715()) or 0
    local w770= 0
    if ui.get(w758[4][1]) == '180' then
      if w713 == 'right' then
        w770 = tonumber(w716()) or 0
      elseif w713 == 'left' then
        w770 = tonumber(w717()) or 0
      end
    end
    local w771= w769 + w770
    local w772= tonumber(w704()) or 0
    if w772 > 0 then
      local w773= math.abs(w771) * (w772 / 100)
      local w774= (w678.random_int(-1000, 1000) / 1000)
      local w775= w774 * w773
      w771 = w771 + w775
    end

    do
      local w776, w687= pcall(w676.get)
      if w776 and w687 then
        local w697= w686(w687)
        if w697 then
          local w777= w681.lower(tostring(w697.yaw_base or ''))
          if w777 == 'threat' or w777 == 'distance' then
            local w778= w722(w777)
            if w778 then
              w771 = w771 + tonumber(w778) or w771
            end
          end
        end
      end
    end

    local w779= w678.normalize_angle(w771)
    ui.set(w758[4][2], w678.round(w779))

    
    
    
    w764(w765)

end


return {
  gather = w686,
  activate = w766,
  print_current = w766,
}]]
w207["require/features/aa/defensive"] = [[local w678= {}
w678.active = nil
w678.activate = nil
local w679= require('require/help/time')
local w680= require('require/abc/menu_setup')
local w681= require('require/features/aa/defensive_presets')
local w682= require('require/aa/player_condition')
local w683= require('require/abc/screen_logger')
local w684, w685= pcall(require, 'require/abc/callbacks')




local w686= {}
local w687= {}
for w688, w689 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'RAGE', 'Aimbot', 'Double tap' },
    { 'RAGE', 'Other', 'Duck peek assist' },

}) do
    local w690= {ui.reference(w689[1], w689[2], w689[3])}
    w686[w688] = w690
    for w691, w692 in ipairs(w690) do
        w687[w692] = true
    end
end


local w693= {
    cond = nil,
    idx = nil,
    preset = nil,
    selected_tick = 0,
}
local w694= false
local w695= 0





local w696= {
    last = false,
    pending_until = nil,
}
local function w697()
    local w698, w699= pcall(ui.get, w686[10][2])
    local w700= w698 and not not w699 or false
    local w701= w679.tickcount() or (globals and globals.tickcount and globals.tickcount()) or 0
    if w700 and not w696.last then
        w696.pending_until = w701 + 32
    end
    if not w700 then
        w696.pending_until = nil
    end
    w696.last = w700
    if w696.pending_until then
        return w701 >= w696.pending_until
    end
    return w700
end

local function w702()
    local w690= w686[11]
    if not w690 or not w690[1] then
        return false
    end
    local w698, w699= pcall(ui.get, w690[1])
    return w698 and not not w699 or false
end

local function w703()
  local w704= entity.get_local_player()
  if not w704 or not entity.is_alive(w704) then
    return false
  end
  local w705= entity.get_player_weapon(w704)
  if not w705 then
    return false
  end
  local w706= entity.get_classname(w705)
  return w706 == "CKnife"
end




local function w707()
    if not w680 or type(w680) ~= 'table' or not w680.ui then
        return false
    end
    local w692= w680.ui.fakelag_defensive
    if not w692 then
        return false
    end
    local w698, w699= pcall(ui.get, w692)
    return w698 and not not w699 or false
end

local function w708()
    if not w680 or type(w680) ~= 'table' or not w680.ui then
        return false
    end
    local w692= w680.ui.fakelag_force
    if not w692 then
        return false
    end
    local w698, w699= pcall(ui.get, w692)
    return w698 and not not w699 or false
end

local function w709(w710)

    


    local w701= (globals and globals.tickcount and globals.tickcount()) or w679.tickcount() or 0
    w695 = w701
end




local function w711(w712)

    w712 = w712 or 20
    local w713= entity.get_local_player()
    if not w713 then return false end
    local w714= entity.get_prop(w713, "m_flSimulationTime")
    local w715= 1 / globals.tickinterval()
    if not w714 or w715 == 0 then return false end
    local w716= math.floor(w714 * w715 + 0.5)
    local w717= globals.tickcount()
    nigga = w717 >= w716 and w717 <= w716 + w712

    return w717 >= w716 and w717 <= w716 + w712

end







local function w718(w710)
    
    
    
    local w719= false
    local w720= w707()
    local w721= w697()
    local w722= w702()
    local w723= w703()
    local w724= w711()
    

    w719 = w720 and w721 and not w722 and not w723 
    w678.active = w719


    local w701= (globals and globals.tickcount and globals.tickcount()) or w679.tickcount() or 0
    local w725= false
    if w701 and (w695 == nil or w701 - w695 >= 64) then
        w725 = true
        w709(w710)
    end



    
    
    

    
    
    
    if w719 then
        local w726= w682.get() or 'global'
        if (not w694) or (w693.cond ~= w726) or (not w693.preset) then
            local w727, w728= w681.get_random_for_condition(w726)
            if w727 and w728 then
                w693.cond = w726
                w693.idx = w727
                w693.preset = w728
                w693.selected_tick = globals.tickcount()
            else
                w693.cond = w726
                w693.idx = nil
                w693.preset = nil
                w693.selected_tick = 0
            end
        end

        if not w725 then
            if w693.preset and type(w693.preset.apply) == 'function' then
                w693.preset.apply(w693, w710)
            end
        end
    else
        if w694 then
            w693.cond = nil
            w693.idx = nil
            w693.preset = nil
            w693.selected_tick = 0
        end
    end

    w694 = w719

end


w678.activate = w718
w678.reset = w709


w685.register('setup_command', function(w710)
    w718(w710)
end, { alive_only = true, require_login = true })


return w678]]
w207["require/features/aa/defensive_presets"] = [[local w681= require('require/aa/player_condition')
local w682= require('require/help/time')
local w683= require('require/abc/screen_logger')



local w684= {}
local w685= {}
for w686, w687 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },

}) do
    local w688= {ui.reference(w687[1], w687[2], w687[3])}
    w684[w686] = w688
    for w689, w690 in ipairs(w688) do
        w685[w690] = true
    end
end


local w691= {}

local function w692(w693,w694,w695) if w693 < w694 then return w694 end if w693 > w695 then return w695 end return w693 end

local function w696(w697,w698,w699)
    local w688= w684[w697]
    if not w688 or not w688[w698] then return false end
    pcall(ui.set, w688[w698], w699)
    return true
end



local w700, w701= pcall(require, "require/abc/menu_setup")



local function w702(w703)

    local w704, w701= pcall(require, "require/abc/menu_setup")
    if not w704 or not w701 or not w701.ui then return end
    local w705, w706= pcall(ui.get, w701.ui.fakelag_fakedef)

    
    if w706 then 
        w703.force_defensive = false
    else
        w703.force_defensive = true
    end

end

do
    local w707, w708= pcall(require, "require/abc/callbacks")

    ticks = ticks or {}
    ticks.tickbase_max = ticks.tickbase_max or nil
    ticks.tickbase_diff = ticks.tickbase_diff or nil
    ticks.current_cmd = ticks.current_cmd or nil

    ticks.runc = function(w703)
        if not w703 then return end
        ticks.current_cmd = w703.command_number
    end

    ticks.tickcalc = function(w703)
        if not w703 then return end
        if w703.command_number == ticks.current_cmd then
            ticks.current_cmd = nil
            local w709= entity.get_local_player()
            if not w709 then return end
            local w710= entity.get_prop(w709, "m_nTickBase")
            if w710 then
                if ticks.tickbase_max ~= nil then
                    ticks.tickbase_diff = w710 - ticks.tickbase_max
                end
                ticks.tickbase_max = math.max(w710, ticks.tickbase_max or 0)
            end
        end
    end

    if w707 and w708 and w708.callback then
        w708.callback('run_command', ticks.runc, { alive_only = true, require_login = true })
        w708.callback('predict_command', ticks.tickcalc, { alive_only = true, require_login = true })
    end
end

client.set_event_callback("level_init", function()
    ticks.tickbase_max = nil
    ticks.tickbase_diff = nil
end)


local function w711(w712)
    local w709= entity.get_local_player()
    if not w709 then return false end

    local w713= entity.get_prop(w709, 'm_nTickBase')
    if not w713 then return false end

    local w714= w715 and w715.tickbase_max or 0

    if math.abs(w713 - w714) > 64 then
        w714 = 0
    end

    local w716= 0

    if w713 > w714 then
        w714 = w713
    elseif w714 > w713 then
        w716 = math.min(14, math.max(0, w714 - w713 - 1))
    end

    w712 = w712 or 7

    return w716 > w712
end




local w717= {



    stand = {

        [1] = {
            name = "jitter -90/90",
            apply = function(w718,w703)

                local w719= globals.tickcount()
                local w720= math.floor(w719 / 2) % 2

                local function w721()
                    local w719= globals.tickcount()

                    if not w718._next_change_at then
                        w718._next_change_at = w719 + math.random(24, 64)
                        w718._mode = math.random(1, 3)
                        w718._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        w718._spin_speed = math.random(45, 55)
                        w718._spin_angle = (w720 == 0) and -90 or 90
                    end

                    if w719 >= (w718._next_change_at or 0) then
                        w718._next_change_at = w719 + math.random(24, 64)
                        w718._mode = math.random(1, 3)
                        w718._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        w718._spin_speed = math.random(45, 55)
                        w718._spin_angle = (w720 == 0) and -90 or 90

                        if w718._mode == 2 then
                            w718._spin_until = w719 + math.random(12, 24)
                        elseif w718._mode == 3 then
                            local w722= math.ceil(360 / w718._spin_speed)
                            w718._spin_until = w719 + w722
                            w718._rest_until = w719 + w722 + math.random(24, 64)
                            w718._spin_done = false
                        else
                            w718._spin_until = nil
                            w718._rest_until = nil
                        end
                    end

                    if w718._mode == 1 then
                        local w723= (w720 == 0) and -120 or 120
                        local w724= 0
                        return w723, w724

                    elseif w718._mode == 2 then
                        if w718._spin_until and w719 <= w718._spin_until then
                            w718._spin_angle = (w718._spin_angle or ((w720 == 0) and -90 or 90)) + (w718._spin_dir * (w718._spin_speed or 50))
                            if w718._spin_angle > 180 then w718._spin_angle = w718._spin_angle - 360 end
                            if w718._spin_angle < -180 then w718._spin_angle = w718._spin_angle + 360 end
                            return w718._spin_angle, 0
                        end
                        local w723= (w720 == 0) and -90 or 90
                        return w723, 0
                    else
                        if w718._spin_until and w719 <= w718._spin_until then
                            w718._spin_angle = (w718._spin_angle or ((w720 == 0) and -90 or 90)) + (w718._spin_dir * (w718._spin_speed or 50))
                            if w718._spin_angle > 180 then w718._spin_angle = w718._spin_angle - 360 end
                            if w718._spin_angle < -180 then w718._spin_angle = w718._spin_angle + 360 end
                            return w718._spin_angle, -89
                        end

                        if w718._rest_until and w719 <= w718._rest_until then
                            return nil, nil
                        end

                        local w723= (w720 == 0) and -90 or 90
                        return w723, 0
                    end
                end

                local w723, w724= w721()

                if w723 ~= nil and w703.chokedcommands > 0 and (w715.tickbase_diff > -12) and (not w715.tickbase_diff ~= 1) and (not (w711(6))) then
                    w702(w703)
                    w696(4, 2, w723)
                    w696(2, 1, 'Custom')
                    w696(2, 2, w724)
                    w696(5, 1, 'off')
                    w696(6, 1, 'off')
                end

            end
        }
    },

    move = {

        [1] = {
            name = "jitter -90/90",
            apply = function(w718,w703)


                local w719= globals.tickcount()
                local w720= math.floor(w719 / 2) % 2
                local w723= (w720 == 0) and -135 or 135
                w718._side = w723
                w718._pitch = -55


                if w703.chokedcommands > 0 and (w715.tickbase_diff > -12) and (not w715.tickbase_diff ~= 1) and (not (w711(3))) then
                    w702(w703)
                    w696(4, 2, w718._side)
                    w696(2, 1, 'Custom')
                    w696(2, 2, w718._pitch)
                    w696(5, 1, 'off')
                    w696(6, 1, 'off')
                    w696(3, 1, 'at targets')
                end
            end
        }
    },

    walk = {

        [1] = {
            name = "jitter -90/90",
            apply = function(w718,w703)

                local w719= globals.tickcount()
                local w720= math.floor(w719 / 2) % 2
                local w725= (w720 == 0) and -130 or 130

                
                local w723, w724
                if (w719 % 8) == 0 then
                    w723 = 0
                    w724 = 89
                else
                    w723 = w725
                    w724 = -65
                end

                w718._side = w723
                w718._pitch = w724





                if w703.chokedcommands > 0 and (w715.tickbase_diff > -12) and (not w715.tickbase_diff ~= 1) and (not (w711(3))) then
                    w702(w703)
                    w696(4, 2, w718._side)
                    w696(2, 1, 'Custom')
                    w696(2, 2, w718._pitch)
                    w696(5, 1, 'off')
                    w696(6, 1, 'off')
                    w696(3, 1, 'at targets')
                end
            end
        },
    },

    duck = {
        
        [1] = {
            name = "jitter -90/90",
            apply = function(w718,w703)

                local w719= globals.tickcount()
                local w720= math.floor(w719 / 2) % 2

                local function w721()
                    local w719= globals.tickcount()

                    
                    if not w718._next_change_at then
                        w718._next_change_at = w719 + math.random(24, 64)
                        w718._mode = 1 
                    end

                    if w719 >= (w718._next_change_at or 0) then
                        w718._next_change_at = w719 + math.random(24, 64)
                        w718._mode = math.random(1, 5)
                        
                        w718._spin_dir = nil
                        w718._spin_speed = nil
                        w718._spin_angle = nil
                        w718._jitter_yaw = nil
                        w718._jitter_pitch = nil
                        w718._rand_yaw = nil
                        w718._rand_pitch = nil
                        w718._rand_until = nil
                        w718._phase_tick = w719
                    end

                    
                    
                    
                    
                    
                    

                    if w718._mode == 1 then
                        if not w718._spin_dir then
                            w718._spin_dir = (math.random(0,1) == 0) and -1 or 1
                            w718._spin_speed = 35
                            w718._spin_angle = (w720 == 0) and -90 or 90
                        end

                        if w719 % 10 == 0 then
                            return nil, nil
                        end

                        w718._spin_angle = (w718._spin_angle or ((w720 == 0) and -90 or 90)) + (w718._spin_dir * (w718._spin_speed or 45))
                        if w718._spin_angle > 180 then w718._spin_angle = w718._spin_angle - 360 end
                        if w718._spin_angle < -180 then w718._spin_angle = w718._spin_angle + 360 end
                        return w718._spin_angle, 0

                    elseif w718._mode == 2 then
                        local w726= math.random(-100, 100)
                        return w726, -50

                    elseif w718._mode == 3 then
                        local w726= math.random(-180, 180)
                        local w724= math.random(-89, 89)
                        return w726, w724

                    elseif w718._mode == 4 then
                        if not w718._rand_until then
                            w718._rand_yaw = math.random(-180, 180)
                            w718._rand_pitch = math.random(-89, 89)
                            w718._rand_until = w719 + 2
                            w718._rand_rest = w719 + 3
                        end
                        if w719 <= w718._rand_until then
                            return w718._rand_yaw, w718._rand_pitch
                        elseif w719 <= w718._rand_rest then
                            return nil, nil
                        else
                            w718._rand_until = nil
                            w718._rand_rest = nil
                            return nil, nil
                        end

                    else
                        
                        if not w718._ramp then
                            w718._ramp = {}
                            w718._ramp.yaw = math.random(-180, 180)
                            w718._ramp.pitch = 89
                            w718._ramp.dir = -1 
                        end

                        
                        if not w718._ramp.step then w718._ramp.step = 30 end
                        if w718._ramp.pitch == 89 then
                            
                            w718._ramp.pitch = w718._ramp.pitch + (w718._ramp.dir * w718._ramp.step)
                            if w718._ramp.pitch < -89 then w718._ramp.pitch = -89 end
                            return w718._ramp.yaw, 89
                        else
                            
                            local w727= w718._ramp.pitch
                            w718._ramp.pitch = w718._ramp.pitch + (w718._ramp.dir * w718._ramp.step)
                            if w718._ramp.pitch <= -89 then
                                
                                w718._ramp = nil
                            end
                            return w718._ramp and w718._ramp.yaw or math.random(-180,180), w727
                        end
                    end
                end

                local w723, w724= w721()

                if w723 ~= nil and w703.chokedcommands == 1 and (w715.tickbase_diff > -12) and (not w715.tickbase_diff ~= 1) and (not (w711(8))) then
                    w702(w703)
                    w696(4, 2, w723)
                    w696(2, 1, 'Custom')
                    w696(2, 2, w724)
                    w696(5, 1, 'off')
                    w696(6, 1, 'off')
                    w696(3, 1, 'at targets')
                end
            end
        }
    },

    ["duck+"] = {
        
        [1] = {

            name = "jitter -90/90",
            apply = function(w718,w703)


                local w719= globals.tickcount()
                local w720= math.floor(w719 / 2) % 2
                local w723= (w720 == 0) and -90 or 90
                w718._side = 180
                w718._pitch = -76


                if w703.chokedcommands > 0 and (w715.tickbase_diff > -12) and (not w715.tickbase_diff ~= 1) and (not (w711(1))) then
                    w702(w703)
                    w696(4, 2, w718._side)
                    w696(2, 1, 'Custom')
                    w696(2, 2, w718._pitch)
                    w696(5, 1, 'off')
                    w696(6, 1, 'off')
                    w696(3, 1, 'at targets')
                end

            end
        }
    },

    ['jump'] = {
        [1] = {
            name = "jitter -90/90",
            apply = function(w718,w703)

                local w719= globals.tickcount()
                
                if not w718._spin_choice_at then
                    w718._spin_choice_at = w719 + 64
                    w718._spin_dir = (math.random(0,1) == 0) and -1 or 1
                    w718._spin_angle = 0
                end

                if w719 >= (w718._spin_choice_at or 0) then
                    w718._spin_choice_at = w719 + 64
                    w718._spin_dir = (math.random(0,1) == 0) and -1 or 1
                end

                
                if (w719 % 10) == 0 then
                    return
                end

                
                w718._spin_angle = (w718._spin_angle or 0) + (w718._spin_dir * 35)
                if w718._spin_angle > 180 then w718._spin_angle = w718._spin_angle - 360 end
                if w718._spin_angle < -180 then w718._spin_angle = w718._spin_angle + 360 end

                local w723= w718._spin_angle
                w718._side = w723
                w718._pitch = 0

                if w703.chokedcommands > 0 and (w715.tickbase_diff > -12) and (not w715.tickbase_diff ~= 1) and (not (w711(8))) then
                    w702(w703)
                    w696(4, 2, w718._side)
                    w696(2, 1, 'Custom')
                    w696(2, 2, w718._pitch)
                    w696(5, 1, 'off')
                    w696(6, 1, 'off')
                    w696(3, 1, 'at targets')
                end
            end
        },

    },

    ['jump+'] = {
        [0] = {
            name = "jitter -90/90",
            apply = function(w718,w703)

                local w719= globals.tickcount()
                local w720= math.floor(w719 / 2) % 2
                local w723= (w720 == 0) and -90 or 90
                w718._side = w723
                w718._pitch = 0

                if w703.chokedcommands > 0 and (not (w711(6))) then
                    w702(w703)
                    w696(4, 2, w718._side)
                    w696(2, 1, 'Custom')
                    w696(2, 2, w718._pitch)
                    w696(5, 1, 'off')
                    w696(6, 1, 'off')
                    w696(3, 1, 'at targets')
                end
            end
        },
    },

    
    global = {
        [0] = {
            name = "back",
            apply = function(w718,w703)

            end
        }
    }


}





local function w728(w729)
    local w730= {}
    for w731, w689 in pairs(w729) do
        if type(w731) == 'number' then table.insert(w730, w731) end
    end
    table.sort(w730)
    return w730
end

function w691.get_presets_for_condition(w732)
    w732 = w732 or w681.get() or 'global'
    return w717[w732] or w717['global'] or {}
end

function w691.get_preset_by_index(w732,w733)
    local w734= w691.get_presets_for_condition(w732)
    return w734[w733]
end

function w691.get_random_for_condition(w732)
    local w734= w691.get_presets_for_condition(w732)
    local w730= w728(w734)
    if #w730 == 0 then return nil, nil end
    local w735= w730[math.random(1, #w730)]
    return w735, w734[w735]
end

function w691.get_random_for_current_condition()
    return w691.get_random_for_condition(w681.get())
end


function w691.get_next_for_condition(w732,w736)
    local w734= w691.get_presets_for_condition(w732)
    local w730= w728(w734)
    if #w730 == 0 then return nil, nil end
    
    local w737= 1
    for w686, w731 in ipairs(w730) do
        if w731 == w736 then w737 = w686; break end
    end
    local w738= (w737 % #w730) + 1
    local w739= w730[w738]
    return w739, w734[w739]
end


function w691.available_conditions()
    local w740= {}
    for w731, w689 in pairs(w717) do table.insert(w740, w731) end
    table.sort(w740)
    return w740
end

w691._presets = w717

return w691]]
w207["require/features/misc/analyze"] = [[local function w684(w685)
	while w685 > 180 do w685 = w685 - 360 end
	while w685 < -180 do w685 = w685 + 360 end
	return w685
end

local w686= _G.player_labels or {}
_G.player_labels = w686

local w687= function(ent)
	return (_G.player_history and _G.player_history[ent]) or nil
end

local w688, w689= pcall(require, "require/features/misc/resolver_dispatcher")
local w690= require('require/abc/callbacks')

local function w691(w692)
	
	local w693= w687(w692)
	if not w693 or #w693 < 2 then
		w686[w692] = nil
		return
	end

	
	
	local w694, w695= pcall(function() return (globals and globals.curtime and globals.curtime()) or nil end)
	if w693[1] and w693[1].last_shot_time and w694 and w695 then
		local w696= w695 - w693[1].last_shot_time
		if w696 >= 0 and w696 <= 0.25 then
			w686[w692] = "ON SHOT"
			return
		end
	end

	
	local w697= {}
	for w698 = 1, #w693 - 1 do
		local w699= w693[w698] and w693[w698].yaw
		local w700= w693[w698+1] and w693[w698+1].yaw
		if w699 ~= nil and w700 ~= nil then
			w697[#w697 + 1] = w684(w699 - w700)
		end
	end

	if #w697 == 0 then
		w686[w692] = nil
		return
	end

	
	local w701, w702= 0, 0
	local w703, w704= -1e9, 1e9
	for w705, w706 in ipairs(w697) do
		w701 = w701 + w706
		w702 = w702 + math.abs(w706)
		if w706 > w703 then w703 = w706 end
		if w706 < w704 then w704 = w706 end
	end
	local w707= w701 / #w697
	local w708= w702 / #w697

	local w709= 0
	for w705, w706 in ipairs(w697) do
		w709 = w709 + (w706 - w707) ^ 2
	end
	local w710= math.sqrt(w709 / #w697)

	local w711= 0
	for w698 = 2, #w697 do
		if (w697[w698] > 0 and w697[w698-1] < 0) or (w697[w698] < 0 and w697[w698-1] > 0) then
			w711 = w711 + 1
		end
	end

	
	local w712= w697[1]
	local w713= w703 - w704

	
	local w714= {}
	for w698, w706 in ipairs(w697) do w714[w698] = w706 end
	table.sort(w714)
	local w715= w714[math.ceil(#w714 / 2)]

	
	local w716= {
		deltas = w697,
		mean = w707,
		meanabs = w708,
		std = w710,
		sign_changes = w711,
		max_delta = w703,
		min_delta = w704,
		total_range = w713,
		median = w715,
		last_delta = w712,
		samples = #w697,
		last_yaw = w693[1] and w693[1].yaw,
		oldest_yaw = w693[#w693] and w693[#w693].yaw,
		hist = w693
	}

	
	do
		local w717, w718= 0, 0
		local w719, w720, w721
		for w698=1,math.min(#w693, 20) do
			local w722= w693[w698]
			if w722 then
				if w722.moveSpeedAnim then w717 = w717 + (w722.moveSpeedAnim or 0); w718 = w718 + 1 end
				if w722.speed2d then w717 = w717 + (w722.speed2d or 0); w718 = w718 + 1 end
				if not w719 and w722.feetYaw then w719 = w722.feetYaw end
				if not w720 and w722.goalFeetYaw then w720 = w722.goalFeetYaw end
				if not w721 and w722.moveSpeedAnim then w721 = w722.moveSpeedAnim end
			end
		end
		local w723= (w718 > 0) and (w717 / w718) or 0
		w716.movement = w723 >= 1.2
		w716.avg_speed = w723
		w716.feet_yaw = w719
		w716.goal_feet_yaw = w720
		w716.move_anim = w721
	end

	local w724= nil
	if detect_static and detect_static(w716, w692) then w724 = "STATIC" end
	if detect_spin and detect_spin(w716, w692) then w724 = "SPIN" end
	if detect_jitter_minus and detect_jitter_minus(w716, w692) then w724 = "JITTER-" end
	if detect_jitter and detect_jitter(w716, w692) then w724 = "JITTER" end
	if detect_jitter_plus and detect_jitter_plus(w716, w692) then w724 = "JITTER+" end
	if detect_sway and detect_sway(w716, w692) then w724 = "SWAY" end
	if detect_skitter and detect_skitter(w716, w692) then w724 = "SKITTER" end
	if detect_defensive and detect_defensive(w716, w692) then w724 = "DEFENSIVE" end
	if detect_random and detect_random(w716, w692) then w724 = "RANDOM" end
	if detect_delayed and detect_delayed(w716, w692) then w724 = "DELAYED" end

	if not w724 then w724 = "?" end
	pcall(function()
		local w725= nil
		pcall(function() w725 = entity.get_player_name(w692) end)
		local w726= "nil"
		if w693 and w693[1] and w693[1].last_shot_time then
			w726 = string.format("%.3f", w693[1].last_shot_time)
		end
		local w727= w716.feet_yaw and string.format("%.2f", w716.feet_yaw) or "nil"
		local w728= w716.goal_feet_yaw and string.format("%.2f", w716.goal_feet_yaw) or "nil"

	end)

	w686[w692] = w724

	
	if w688 and w689 and type(w689.process_entity) == "function" then
		pcall(function() w689.process_entity(w692, w724, w716) end)
	end
end



function w729(w716,w692)
	local w708= w716.meanabs or 0
	local w710= w716.std or 0
	local w730= w716.samples or 0
	local w697= w716.deltas or {}
	local w731= 1.0
	local w732= 1.5
	local w733= 2.5

	if w708 <= w731 and w710 <= w732 then
		return true
	end

	local w734= 0
	local w735= nil
	for w698, w736 in ipairs(w697) do
		if math.abs(w736) >= w733 then
			w734 = w734 + 1
			if not w735 then
				w735 = w698
			end
		end
	end

	if w734 == 0 then
		return true
	end

	if w734 == 1 and w735 and w735 > 20 then
		return true
	end

	return false
end

function w737(w716,w692)
	local w708= w716.meanabs or 0
	local w710= w716.std or 0
	local w730= w716.samples or 0
	local w711= w716.sign_changes or 0
	local w738= math.max(math.abs(w716.max_delta or 0), math.abs(w716.min_delta or 0))

	local w739= false

	if w730 >= 4 then
		local w740= 5.0
		local w741= 12.0
		local w742= 22.0
		local w743= 40.0

		if w708 >= w740 and w708 < w741 and w710 <= w742 and w738 <= w743 then
			w739 = true
		end
	end

	return w739
end

function w744(w716,w692)
	local w708= w716.meanabs or 0
	local w710= w716.std or 0
	local w730= w716.samples or 0
	local w711= w716.sign_changes or 0
	local w738= math.max(math.abs(w716.max_delta or 0), math.abs(w716.min_delta or 0))

	local w739= false

	if w730 >= 4 then
		local w740= (w716.movement and 8.0) or 6.0
		local w741= 24.0
		local w745= 34.0
		local w746= 28.0
		local w747= 100.0

		if w708 >= w740 and w708 < w741 and w710 <= w745 then
			if w711 >= 2 or w738 <= w747 or (w708 < 12.0 and w710 <= w746) then
				w739 = true
			end
		end
	end

	return w739
end

function w748(w716,w692)
	local w708= w716.meanabs or 0
	local w710= w716.std or 0
	local w730= w716.samples or 0
	local w711= w716.sign_changes or 0
	local w738= math.max(math.abs(w716.max_delta or 0), math.abs(w716.min_delta or 0))

	local w739= false

	if w730 >= 4 then
		local w740= 18.0
		local w749= 22.0
		local w750= 26.0
		local w751= 70.0

		if w708 >= w740 and (w710 >= w750 or w738 >= w751) then
			if w708 >= w749 or w738 >= w751 or w710 >= (w750 + 8) then
				w739 = true
			end
		end
	end
	
	return w739
end

function w752(w716,w692)
	local w708= w716.meanabs or 0
	local w710= w716.std or 0
	local w730= w716.samples or 0
	local w711= w716.sign_changes or 0
	local w713= w716.total_range or 0
	local w738= math.max(math.abs(w716.max_delta or 0), math.abs(w716.min_delta or 0))

	local w739= false

	if w730 >= 6 then
		local w740= 2.5
		local w741= 15.0
		local w753= 0.08
		local w754= 30.0
		local w755= 180.0

		if w708 >= w740 and w708 < w741 and w710 <= 40.0 and w713 >= w754 and w713 <= w755 then
			if (w711 / math.max(1, w730)) >= w753 then
				w739 = true
			end
		end
	end

	return w739
end

function w756(w716,w692)
	local w708= w716.meanabs or 0
	local w710= w716.std or 0
	local w730= w716.samples or 0
	local w711= w716.sign_changes or 0
	local w713= w716.total_range or 0
	local w712= w716.last_delta or 0
	local w738= math.max(math.abs(w716.max_delta or 0), math.abs(w716.min_delta or 0))

	local w697= w716.deltas or {}

	local w757, w758, w759= 0, 0, 0
	for w705, w706 in ipairs(w697) do
		if w706 > 0.5 then w757 = w757 + 1
		elseif w706 < -0.5 then w758 = w758 + 1
		else w759 = w759 + 1 end
	end

	local w760= math.max(w757, w758) / math.max(1, w730)
	local w761= math.abs(w757 - w758) / math.max(1, (w757 + w758))

	local w762, w763, w764= 0, 0, 0
	for w705, w706 in ipairs(w697) do
		local w722= 0
		if w706 > 0.5 then w722 = 1 elseif w706 < -0.5 then w722 = -1 end
		if w722 ~= 0 and w722 == w764 then
			w763 = w763 + 1
		else
			w763 = (w722 ~= 0) and 1 or 0
			w764 = w722
		end
		if w763 > w762 then w762 = w763 end
	end

	local w765= w762 / math.max(1, w730)

	local w739= false

	if w730 >= 6 then
		if w713 >= 300 and (w760 >= 0.60 or w761 >= 0.60) then
			w739 = true
		end

		if not w739 and w713 >= 140 and w708 >= 9 and (w760 >= 0.75 or w761 >= 0.70 or w711 <= 1) then
			w739 = true
		end

		if not w739 and w765 >= 0.50 and w708 >= 8 and w713 >= 120 then
			w739 = true
		end

		if not w739 and w738 >= 120 and (w760 >= 0.60 or w761 >= 0.60) then
			w739 = true
		end
	end
	local w766= nil
	if not w739 and w730 > 0 then
		local w767= math.min(w713, 360) / 360.0
		local w768= math.min(w708, 60) / 60.0
		local w769= (w711 or 0) / math.max(1, w730)
		w766 = w767 * 0.45 + w768 * 0.35 + w761 * 0.15 + w760 * 0.05 - w769 * 0.20
		if w766 >= 0.42 and w713 >= 200 and w708 >= 6 then
			w739 = true
		end
		w716.spin_score = w766
	end

	return w739
end

function w770(w716,w692)
	
	return false
end

function w771(w716,w692)
	
	return false
end

function w772(w716,w692)
	local w708= w716.meanabs or 0
	local w710= w716.std or 0
	local w730= w716.samples or 0
	local w711= w716.sign_changes or 0
	local w713= w716.total_range or 0
	local w738= math.max(math.abs(w716.max_delta or 0), math.abs(w716.min_delta or 0))
	local w697= w716.deltas or {}

	if w730 < 6 then return false end

	local w773= w711 / math.max(1, w730)
	local w774= w716.movement
	if w773 >= 0.45 and w710 >= (w774 and 12.0 or 18.0) and w708 >= (w774 and 4.0 or 6.0) then
		return true
	end

	if w738 >= 120 and w773 >= 0.30 and w710 >= 12.0 then
		return true
	end

	if w713 >= 60 and w713 <= 300 and w773 >= 0.40 and w710 >= 14.0 and w708 >= 4.0 then
		return true
	end

	if w710 >= 30.0 and w773 >= 0.25 and w708 >= 5.0 then
		return true
	end

	return false
end

function w775(w716,w692)
	local w708= w716.meanabs or 0
	local w710= w716.std or 0
	local w730= w716.samples or 0
	local w711= w716.sign_changes or 0
	local w713= w716.total_range or 0
	local w738= math.max(math.abs(w716.max_delta or 0), math.abs(w716.min_delta or 0))

	if w730 >= 6 then
		local w740= 2.5
		local w741= 24.0
		local w776= 9.0
		local w777= 40.0
		local w754= 10.0

		if w708 >= w740 and w708 < w741 and w710 >= w776 and w710 <= w777 and w713 >= w754 then
			local w778= (w711 or 0) / math.max(1, w730)
			if w711 <= 3 or w778 <= 0.12 or w738 >= 40 then
				return true
			end
		end
	end

	return false
end

local function w779()
	local w780, w781= pcall(entity.get_players, true)
	if not w780 or type(w781) ~= "table" then return end
	for w705, w692 in ipairs(w781) do
		if entity.is_alive(w692) and not entity.is_dormant(w692) then
			pcall(w691, w692)
		else
			w686[w692] = nil
		end
	end
end

local function w782(w692)
	if not entity.is_alive(entity.get_local_player()) then return end
	if not w692 or w692 == 0 then return end

	local w783= w686[w692]


	if w783 then
		return true, w783
	end

	local w693= w687(w692)
	if w693 and w693[1] and w693[1].yaw ~= nil then
		return true, tostring(w693[1].yaw)
	end
end

client.register_esp_flag("Resolver", 255, 255, 255, w782)

w690.register('net_update_end', function()
	local w784, w785= pcall(require, "require/abc/menu_setup")
	if w784 and w785 and w785.ui and w785.ui.misc_resolver then
		local w786, w787= pcall(ui.get, w785.ui.misc_resolver)
		if w786 and w787 then
			pcall(w779)
		end
	end
end, { alive_only = true, require_login = true })
]]
w207["require/features/misc/backstab_assist"] = [[local w687= require("require/abc/menu_setup")
local w688= require('require/abc/callbacks')
local w689= require('require/help/enemies')

local w690= ui.reference("AA", "Anti-aimbot angles", "Pitch")
local w691= ui.reference("AA", "Anti-aimbot angles", "Yaw base")
local w692, w693= ui.reference("AA", "Anti-aimbot angles", "Yaw")
local w694= nil

local function w695()
	if w694 then return end
	w694 = {}
	if w690 then w694.pitch = ui.get(w690) end
	if w691 then w694.yaw_base = ui.get(w691) end
	if w692 then w694.yaw = ui.get(w692) end
	if w693 then w694.yaw_slider = ui.get(w693) end
end

local function w696()
	if not w694 then return end
	if w690 and w694.pitch ~= nil then pcall(ui.set, w690, w694.pitch) end
	if w691 and w694.yaw_base ~= nil then pcall(ui.set, w691, w694.yaw_base) end
	if w692 and w694.yaw ~= nil then pcall(ui.set, w692, w694.yaw) end
	if w693 and w694.yaw_slider ~= nil then pcall(ui.set, w693, w694.yaw_slider) end
	w694 = nil
end

local function w697()
	w695()
	if w690 then pcall(ui.set, w690, "Off") end
	if w691 then pcall(ui.set, w691, "At targets") end
	if w692 then pcall(ui.set, w692, "180") end
	if w693 then pcall(ui.set, w693, 180) end
end

local function w698(w699)
	local w700= entity.get_local_player()
	if not w700 or not entity.is_alive(w700) then return false end
	local w701= w689.list() or {}
	for w702, w703 in ipairs(w701) do
		if w689.is_alive(w703) and not w689.is_dormant(w703) and w689.has_knife(w703) then
			local w704= w689.distance(w703)
			if w704 and w704 <= w699 then
				return true
			end
		end
	end
	return false
end

local function w705(w706)
	if not (w687 and w687.ui and w687.ui.misc_backstab) then w696() return end
	local w707, w708= pcall(ui.get, w687.ui.misc_backstab)
	if not w707 or not w708 then w696() return end
	local w699= 200
	if w698(w699) then
		w697()
	else
		w696()
	end
end

if w687 and w687.ui and w687.ui.misc_backstab then
	ui.set_callback(w687.ui.misc_backstab, function()
		local w707, w709= pcall(ui.get, w687.ui.misc_backstab)
		if not w707 or not w709 then w696() end
	end)
end

w688.register("setup_command", w705, { alive_only = true, require_login = true })
w688.register("shutdown", w696, { alive_only = true, require_login = true })]]
w207["require/features/misc/collect"] = [=[
local M = {}


do
    local ok, ffi = pcall(require, "ffi")
    if ok and ffi and client and client.create_interface then
        local status, entity_list_ptr = pcall(function()
            return client.create_interface("client.dll", "VClientEntityList003")
        end)

        if status and entity_list_ptr then
            local pointer_type = ffi.typeof("void***")
            local entity_list = ffi.cast(pointer_type, entity_list_ptr)
            local ok_cast, get_client_entity = pcall(function()
                return ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
            end)

            if ok_cast and get_client_entity then
                
                local animstate_offset = 0x9960

                
                
                
                ffi.cdef[[
                struct animation_layer_t {
                    char  pad_0000[20];
                    uint32_t m_nOrder;
                    uint32_t m_nSequence;
                    float m_flPrevCycle;
                    float m_flWeight;
                    float m_flWeightDeltaRate;
                    float m_flPlaybackRate;
                    float m_flCycle;
                    void *m_pOwner;
                    char  pad_0038[4];
                };
                ]]

                
                
                

                ffi.cdef[[
                struct c_animstate_min {
                    char pad0[3];
                    char m_bForceWeaponUpdate;
                    char pad1[91];
                    void* m_pBaseEntity;
                    void* m_pActiveWeapon;
                    void* m_pLastActiveWeapon;
                    float m_flLastClientSideAnimationUpdateTime;
                    int m_iLastClientSideAnimationUpdateFramecount;
                    float m_flAnimUpdateDelta;
                    float m_flEyeYaw;
                    float m_flPitch;
                    float m_flGoalFeetYaw;
                    float m_flCurrentFeetYaw;
                    float m_flCurrentTorsoYaw;
                    float m_flUnknownVelocityLean;
                    float m_flLeanAmount;
                    char pad2[4];
                    float m_flFeetCycle;
                    float m_flFeetYawRate;
                    char pad3[4];
                    float m_fDuckAmount;
                    float m_fLandingDuckAdditiveSomething;
                    char pad4[4];
                    float m_vOriginX;
                    float m_vOriginY;
                    float m_vOriginZ;
                    float m_vLastOriginX;
                    float m_vLastOriginY;
                    float m_vLastOriginZ;
                    float m_vVelocityX;
                    float m_vVelocityY;
                    char pad5[4];
                    float m_flUnknownFloat1;
                    char pad6[8];
                    float m_flUnknownFloat2;
                    float m_flUnknownFloat3;
                    float m_flUnknown;
                    float m_flSpeed2D;
                    float m_flUpVelocity;
                    float m_flSpeedNormalized;
                    float m_flFeetSpeedForwardsOrSideWays;
                    float m_flFeetSpeedUnknownForwardOrSideways;
                    float m_flTimeSinceStartedMoving;
                    float m_flTimeSinceStoppedMoving;
                    bool m_bOnGround;
                    bool m_bInHitGroundAnimation;
                    char pad7[2];
                    float m_flTimeSinceInAir;
                    float m_flLastOriginZ;
                    float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
                    float m_flStopToFullRunningFraction;
                    float m_flMagicFraction;
                    char pad8[60];
                    float m_flWorldForce;
                    char pad9[462];
                    float m_flMaxYaw;
                };
                ]]

                
                M._get_animstate = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    
                    
                    local base = ffi.cast("char*", ent_ptr)
                    local anim_ptr_ptr = ffi.cast("struct c_animstate_min**", base + animstate_offset)
                    if anim_ptr_ptr == nil or anim_ptr_ptr == ffi.NULL then return nil end
                    local anim_ptr = anim_ptr_ptr[0]
                    if anim_ptr == nil or anim_ptr == ffi.NULL then return nil end
                    return anim_ptr
                end
                
                M._get_entity_ptr = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    return ent_ptr
                end
            end
        end
    end
end



function M.get_sim_time(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flSimulationTime") end)
    if ok then return val end
    return nil
end


function M.get_enemies_simtimes()
    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        out[ent] = M.get_sim_time(ent)
    end
    return out
end


function M.get_velocity_3d(ent)
    local ok, vals = pcall(function() return { entity.get_prop(ent, "m_vecVelocity") } end)
    if not ok or type(vals) ~= "table" then return nil end
    if #vals >= 3 then
        return { vals[1], vals[2], vals[3] }
    end
    return nil
end


function M.get_speed_2d(ent)
    local v = M.get_velocity_3d(ent)
    if not v then return nil end
    local x, y = v[1] or 0, v[2] or 0
    return math.sqrt(x * x + y * y)
end




function M.get_origin(ent)
    local ok, x, y, z = pcall(function() return entity.get_prop(ent, "m_vecOrigin") end)
    if ok and x then
        
        if type(x) == "table" then
            return x[1], x[2], x[3]
        elseif y and z then
            return x, y, z
        end
    end
    return nil
end


function M.get_view_offset(ent)
    local tries = { "m_vecViewOffset[0]", "m_vecViewOffset" }
    for _, prop in ipairs(tries) do
        local ok, v1, v2, v3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and v1 then
            if type(v1) == "table" then
                return v1[1], v1[2], v1[3]
            elseif v2 and v3 then
                return v1, v2, v3
            end
        end
    end
    return nil
end


function M.get_eye_pos(ent)
    local ox, oy, oz = M.get_origin(ent)
    local vx, vy, vz = M.get_view_offset(ent)
    if ox and vx then
        return ox + vx, oy + vy, oz + vz
    end
    return nil
end


function M.get_eye_angles(ent)
    local tries = { "m_angEyeAngles[0]", "m_angEyeAngles", "m_angRotation", "m_angNetworkAngles" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return nil
end


function M.get_abs_angles(ent)
    local tries = { "m_angAbsRotation", "m_angAbsAngles", "m_angAbsOrigin" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return M.get_eye_angles(ent)
end


function M.get_lower_body_yaw(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flLowerBodyYawTarget") end)
    if ok and val then return val end
    return nil
end


function M.get_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flCurrentFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    
    return M.get_lower_body_yaw(ent)
end

function M.get_goal_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flGoalFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    return M.get_feet_yaw(ent)
end


function M.get_speed(ent)
    
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flVelocityModifier") end)
    if ok and val then return val end
    
    local v = M.get_velocity_3d(ent)
    if v then
        return math.sqrt((v[1] or 0) * (v[1] or 0) + (v[2] or 0) * (v[2] or 0) + (v[3] or 0) * (v[3] or 0))
    end
    return nil
end

function M.get_move_speed_anim(ent)
    
    
    
    
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local try_fields = { "m_flFeetSpeedForwardsOrSideWays", "m_flSpeed2D", "m_flSpeedNormalized", "m_flFeetSpeedUnknownForwardOrSideways" }
            for _, f in ipairs(try_fields) do
                local okf, val = pcall(function() return tonumber(anim[f]) end)
                if okf and val and val ~= 0 then
                    return val
                end
            end
        end
    end

    
    local ok_nv, nv = pcall(function() return entity.get_prop(ent, "m_flMaxspeed") end)
    if ok_nv and nv then return nv end

    
    return M.get_speed_2d(ent)
end


function M.get_flags(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_fFlags") end)
    if ok and val then return val end
    ok, val = pcall(function() return entity.get_prop(ent, "m_iFlags") end)
    if ok and val then return val end
    return nil
end



function M.read_animstate(ent)
    if not M._get_animstate then return nil end
    local ok, anim = pcall(function() return M._get_animstate(ent) end)
    if not ok or not anim then return nil end
    local out = {}
    pcall(function()
        out.m_flEyeYaw = tonumber(anim.m_flEyeYaw)
        out.m_flPitch = tonumber(anim.m_flPitch)
        out.m_flGoalFeetYaw = tonumber(anim.m_flGoalFeetYaw)
        out.m_flCurrentFeetYaw = tonumber(anim.m_flCurrentFeetYaw)
        out.m_flCurrentTorsoYaw = tonumber(anim.m_flCurrentTorsoYaw)
        out.m_flUnknownVelocityLean = tonumber(anim.m_flUnknownVelocityLean)
        out.m_flLeanAmount = tonumber(anim.m_flLeanAmount)
        out.m_flFeetCycle = tonumber(anim.m_flFeetCycle)
        out.m_flFeetYawRate = tonumber(anim.m_flFeetYawRate)
        out.m_fDuckAmount = tonumber(anim.m_fDuckAmount)
        out.m_fLandingDuckAdditiveSomething = tonumber(anim.m_fLandingDuckAdditiveSomething)
        out.m_vOrigin = { tonumber(anim.m_vOriginX), tonumber(anim.m_vOriginY), tonumber(anim.m_vOriginZ) }
        out.m_vLastOrigin = { tonumber(anim.m_vLastOriginX), tonumber(anim.m_vLastOriginY), tonumber(anim.m_vLastOriginZ) }
        out.m_vVelocity = { tonumber(anim.m_vVelocityX), tonumber(anim.m_vVelocityY) }
        out.m_flUnknownFloat1 = tonumber(anim.m_flUnknownFloat1)
        out.m_flUnknownFloat2 = tonumber(anim.m_flUnknownFloat2)
        out.m_flUnknownFloat3 = tonumber(anim.m_flUnknownFloat3)
        out.m_flUnknown = tonumber(anim.m_flUnknown)
        out.m_flSpeed2D = tonumber(anim.m_flSpeed2D)
        out.m_flUpVelocity = tonumber(anim.m_flUpVelocity)
        out.m_flSpeedNormalized = tonumber(anim.m_flSpeedNormalized)
        out.m_flFeetSpeedForwardsOrSideWays = tonumber(anim.m_flFeetSpeedForwardsOrSideWays)
        out.m_flFeetSpeedUnknownForwardOrSideways = tonumber(anim.m_flFeetSpeedUnknownForwardOrSideways)
        out.m_flTimeSinceStartedMoving = tonumber(anim.m_flTimeSinceStartedMoving)
        out.m_flTimeSinceStoppedMoving = tonumber(anim.m_flTimeSinceStoppedMoving)
        out.m_bOnGround = (anim.m_bOnGround ~= 0)
        out.m_bInHitGroundAnimation = (anim.m_bInHitGroundAnimation ~= 0)
        out.m_flTimeSinceInAir = tonumber(anim.m_flTimeSinceInAir)
        out.m_flLastOriginZ = tonumber(anim.m_flLastOriginZ)
        out.m_flHeadHeightOrOffsetFromHittingGroundAnimation = tonumber(anim.m_flHeadHeightOrOffsetFromHittingGroundAnimation)
        out.m_flStopToFullRunningFraction = tonumber(anim.m_flStopToFullRunningFraction)
        out.m_flMagicFraction = tonumber(anim.m_flMagicFraction)
        out.m_flWorldForce = tonumber(anim.m_flWorldForce)
        out.m_flMaxYaw = tonumber(anim.m_flMaxYaw)
    end)
    return out
end



function M.read_anim_layers(ent)
    if not M._get_entity_ptr then return nil end
    local ok_ent, ent_ptr = pcall(function() return M._get_entity_ptr(ent) end)
    if not ok_ent or not ent_ptr then return nil end
    local ok, res = pcall(function()
        local ffi = require("ffi")
        local base = ffi.cast("char*", ent_ptr)
        local layers_ptr = ffi.cast("struct animation_layer_t**", base + 0x2990)
        if layers_ptr == nil or layers_ptr == ffi.NULL then return nil end
        local owner = layers_ptr[0]
        if owner == nil or owner == ffi.NULL then return nil end
        local out = {}
        for i = 0, 15 do
            local layer = owner[i]
            if layer == nil or layer == ffi.NULL then break end
            local t = {}
            t.m_nOrder = tonumber(layer.m_nOrder)
            t.m_nSequence = tonumber(layer.m_nSequence)
            t.m_flPrevCycle = tonumber(layer.m_flPrevCycle)
            t.m_flWeight = tonumber(layer.m_flWeight)
            t.m_flWeightDeltaRate = tonumber(layer.m_flWeightDeltaRate)
            t.m_flPlaybackRate = tonumber(layer.m_flPlaybackRate)
            t.m_flCycle = tonumber(layer.m_flCycle)
            t.m_pOwner = tostring(layer.m_pOwner)
            table.insert(out, t)
        end
        return out
    end)
    if not ok then return nil end
    return res
end


function M.get_tick_from_simtime(simtime)
    if not simtime or not globals or not globals.tickinterval then return nil end
    local ti = globals.tickinterval()
    if not ti or ti == 0 then return nil end
    return math.floor(simtime / ti + 0.5)
end

function M.get_tick(ent)
    local sim = M.get_sim_time(ent)
    if sim then return M.get_tick_from_simtime(sim) end
    return nil
end








function M.get_enemies_snapshot(opts)
    opts = opts or {}
    local heavy = true 

    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        local snap = {}

        
        snap.is_alive = (pcall(function() return entity.is_alive(ent) end) and entity.is_alive(ent)) or false
        snap.is_dormant = (pcall(function() return entity.is_dormant(ent) end) and entity.is_dormant(ent)) or false

        
        local ok_name, name = pcall(function() return entity.get_player_name(ent) end)
        snap.name = ok_name and name or nil

        
        snap.simtime = M.get_sim_time(ent)
        do
            local base_tick = snap.simtime and M.get_tick_from_simtime(snap.simtime) or nil
            
            local ok_flags, esp_flags = pcall(function()
                local d = entity.get_esp_data and entity.get_esp_data(ent)
                return (d and d.flags) or 0
            end)

            local adjusted_tick = base_tick
            if ok_flags and esp_flags and base_tick then
                
                local ok_bit, is_backtrack = pcall(function()
                    return bit and bit.band(esp_flags, bit.lshift(1, 17)) ~= 0
                end)
                if ok_bit and is_backtrack then
                    adjusted_tick = base_tick - 14
                end
            end
            snap.simTicks = adjusted_tick
        end

        
        do
            local ok, ox, oy, oz = pcall(function() return M.get_origin(ent) end)
            if ok and ox then snap.origin = { ox, oy, oz } end
        end
        do
            local ok, vx, vy, vz = pcall(function() return M.get_view_offset(ent) end)
            if ok and vx then snap.viewOffset = { vx, vy, vz } end
        end
        do
            local ok, ex, ey, ez = pcall(function() return M.get_eye_pos(ent) end)
            if ok and ex then snap.eyePos = { ex, ey, ez } end
        end

        
        do
            local ok, a1, a2, a3 = pcall(function() return M.get_eye_angles(ent) end)
            if ok and a1 then snap.eyeAngles = { a1, a2, a3 } end
        end
        do
            local ok, aa1, aa2, aa3 = pcall(function() return M.get_abs_angles(ent) end)
            if ok and aa1 then snap.absAngles = { aa1, aa2, aa3 } end
        end

        
        snap.lowerBodyYaw = (pcall(function() return M.get_lower_body_yaw(ent) end) and M.get_lower_body_yaw(ent)) or nil
        snap.feetYaw = (pcall(function() return M.get_feet_yaw(ent) end) and M.get_feet_yaw(ent)) or snap.lowerBodyYaw
        snap.goalFeetYaw = (pcall(function() return M.get_goal_feet_yaw(ent) end) and M.get_goal_feet_yaw(ent)) or snap.feetYaw

        
        snap.velocity3d = (pcall(function() return M.get_velocity_3d(ent) end) and M.get_velocity_3d(ent)) or nil
        if snap.velocity3d then
            snap.speed2d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0))
            snap.speed3d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0) + (snap.velocity3d[3] or 0) * (snap.velocity3d[3] or 0))
        else
            snap.speed2d = M.get_speed_2d(ent)
            snap.speed3d = M.get_speed(ent)
        end

        
        do
            local ok_ms, ms = pcall(function() return M.get_move_speed_anim(ent) end)
            if ok_ms and ms then
                snap.moveSpeedAnim = ms
            else
                snap.moveSpeedAnim = nil
            end
        end

        
        snap.flags = (pcall(function() return M.get_flags(ent) end) and M.get_flags(ent)) or nil

        
        local ok_head, hx, hy, hz = pcall(function() return entity.hitbox_position(ent, "head") end)
        if ok_head and hx then snap.headPos = { hx, hy, hz } end

        
        local ok_w, w = pcall(function() return entity.get_player_weapon(ent) end)
        snap.weapon = ok_w and w or nil

        

        
        local ok_b, bones = pcall(function() return entity.get_bone_matrices and entity.get_bone_matrices(ent) end)
        if ok_b and bones then snap.bones = bones end

        local ok_as, as = pcall(function() return M.read_animstate(ent) end)
        if ok_as and as then snap.animstate_full = as end
        local ok_layers, layers = pcall(function() return M.read_anim_layers(ent) end)
        if ok_layers and layers then snap.animLayers = layers end

        out[ent] = snap
    end
    return out
end

return M
]=]
w207["require/features/misc/dormant_aimbot"] = [[local w693, w694, w695, w696= client.visible, client.eye_position, client.log, client.trace_bullet
local w697, w698, w699, w700, w701, w702, w703, w704, w705, w706= entity.get_bounding_box, entity.get_local_player, entity.get_origin, entity.get_player_name, entity.get_player_resource, entity.get_player_weapon, entity.get_prop, entity.is_dormant, entity.is_enemy, entity.is_alive
local w707, w708, w709= globals.curtime, globals.maxplayers, globals.tickcount
local w710, w711, w712= math.max, math.min, math.sqrt
local w713, w714, w715= renderer.indicator, string.format, table.unpack or unpack
local w716, w717, w718, w719, w720, w721, w722, w723, w724, w725= ui.get, ui.new_checkbox, ui.new_color_picker, ui.new_hotkey, ui.new_multiselect, ui.new_slider, ui.reference, ui.set, ui.set_callback, ui.set_visible
local w726, w727= plist.get, entity.hitbox_position
local w728= require("ffi")
local w729= require("vector")
local w730= require("gamesense/csgo_weapons")
local w731= w732("client_panorama.dll", "VClientEntityList003", 3, "void*(__thiscall*)(void*, int)")
local w733= w734(166, "bool(__thiscall*)(void*)")
local w735= w734(483, "float(__thiscall*)(void*)")
local w736= {
	mindamage = w722("RAGE", "Aimbot", "Minimum damage"),
	dormant_esp = w722("VISUALS", "Player ESP", "Dormant"),
	override_mindamage = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}
local w737= require("require/abc/menu_setup")
local w738= require('require/abc/callbacks')

local w739= {}
local function w740(w741)
	if type(w737) ~= 'table' then return false end
	if w739[w741] == nil then w739[w741] = w737.ui and w737.ui[w741] end
	local w742= w739[w741]
	if not w742 then return false end
	local w743, w744= pcall(w716, w742)
	if not w743 then
		w739[w741] = w737.ui and w737.ui[w741]
		w742 = w739[w741]
		if not w742 then return false end
		w743, w744 = pcall(w716, w742)
		if not w743 then return false end
	end
	return w744
end

local w745= { "Head", "Chest", "Stomach" }
local w746= {
	"generic",
	"head",
	"chest",
	"stomach",
	"left arm",
	"right arm",
	"left leg",
	"right leg",
	"neck",
	"?",
	"gear"
}

local w747= {
	"",
	"Head",
	"Chest",
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs",
	"Head",
	"",
	""
}

local w748= {
	{ scale = 5, hitbox = "Stomach", vec = w729(0, 0, 40) },
	{ scale = 6, hitbox = "Chest", vec = w729(0, 0, 50) },
	{ scale = 3, hitbox = "Head", vec = w729(0, 0, 58) },
	{ scale = 4, hitbox = "Legs", vec = w729(0, 0, 20) }
}

local w749= {
	[0] = "Head",
	nil,
	"Stomach",
	nil,
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs"
}

local w750= 0
local w751= {}
local w752= {}
local w753= 1
local w754= false
local w755
local w756
local w757
local w758
local w759= false
local w760= {}

local w761= {
	0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18
}

local function w762(w763,w764,w765)
	local w766, w767= w763:to(w764):angles()
	local w768= math.rad(w767 + 90)
	local w769= w729(math.cos(w768), math.sin(w768), 0) * w765

	return {
		{ text = "Middle", vec = w764 },
		{ text = "Left", vec = w764 + w769 },
		{ text = "Right", vec = w764 - w769 }
	}
end

local function w770(w771,w772)
	for w773 = 1, #w771 do if w771[w773] == w772 then return true end end
	return false
end
local function w774(w771,w772)
	for w773 = 1, #w771 do local w775= w771[w773] if type(w775) == 'table' and w775[1] == w772 then return w773 end end
end
local function w776(w771,w777) return w774(w771, w777) ~= nil end
local function w778(w771,w777) local w779= w774(w771, w777) if w779 then table.remove(w771, w779) end end

local function w780(w781,w782)
	local w783= w712(w781.forwardmove*w781.forwardmove + w781.sidemove*w781.sidemove)
	if w782<=0 or w783<=0 then return end
	if w781.in_duck==1 then w782 = w782*2.94117647 end
	if w783<=w782 then return end
	local w784= w782/w783; w781.forwardmove = w781.forwardmove*w784; w781.sidemove = w781.sidemove*w784
end

local function w785()
	local w786, w787= {}, w701()
	for w773=1,w708() do if w703(w787, "m_bConnected", w773)==1 and w773~=w698() and w705(w773) then w786[#w786+1]=w773 end end
	return w786
end
local function w788()
	local w786, w787= {}, w701()
	for w773=1,w708() do if w703(w787, "m_bConnected", w773)==1 and not w726(w773, "Add to whitelist") and w704(w773) and w705(w773) then w786[#w786+1]=w773 end end
	return w786
end

local function w789()
	for w766,w790 in ipairs(w785()) do
		local w766,w766,w766,w766,w791= w697(w790)
		if w791<1 then if not w776(w752,w790) then w752[#w752+1]={w790,w709()} end else w778(w752,w790) end
	end
end

local function w792(w793)
	local w794= w716(w736.override_mindamage[1]) and w716(w736.override_mindamage[2])
	local w795= w794 and w716(w736.override_mindamage[3]) or w716(w736.mindamage)
	local w796= entity.get_esp_data(w793).health
	if w795>100 then w795 = w795 - 100 + w796 end
	return w795
end

local function w797(w798,w784) return (w798.type=="sniperrifle" and w784) and w798.max_player_speed_alt or w798.max_player_speed end

local function w799(w793,w800,w801)
	local w802= {}
	local w803= w703(w793, "m_flDuckAmount") or 0
	for w766,w804 in ipairs(w748) do
		if #w801==0 or w770(w801,w804.hitbox) then
			local w805= w804.vec
			if w804.hitbox=="Head" then w805 = w805 - w729(0,0,w803*10) elseif w804.hitbox=="Chest" then w805 = w805 - w729(0,0,w803*4) end
			w802[#w802+1]={vec=w800+w805,scale=w804.scale,hitbox=w804.hitbox}
		end
	end
	for w773=1,7 do
		local w806= w749[w773-1]
		if w806 and (#w801==0 or w770(w801,w806)) then
			local w807= w727(w793,w773-1)
			if w807 then w802[#w802+1]={vec=w729(w807),scale=3,hitbox=w806} end
		end
	end
	return w802
end

local function w808(w809,w810,w811,w812,w813)
	for w766,w804 in ipairs(w812) do
		for w766,w805 in ipairs(w762(w811,w804.vec,3)) do
			local w766,w814= w696(w809, w811.x,w811.y,w811.z, w805.vec.x,w805.vec.y,w805.vec.z, true)
			if w804.hitbox=="Head" then w814=w814*4 end
			if w814>w813 then return w805.vec,w814,w804.hitbox,w805.text end
		end
	end
end

local function w815(w781)
	w789()

	if not w740('misc_dormantaimbot') and w740('misc_dormantaimbot_key') then
		return
	end

	local w816= w698()
	if not w816 or not w706(w816) then
		return
	end

	local w817= w702(w816)
	if not w817 then
		return
	end

	local w818= w731(w817)
	if not w818 or not w733(w818) then
		return
	end

	local w819= w735(w818)
	if not w819 then
		return
	end

	local w820= w729(w694())
	local w821= w703(w816, "m_flSimulationTime")
	local w822= w709()
	local w823= w730(w817)
	local w824= w703(w816, "m_bIsScoped") == 1
	local w825= bit.band(w703(w816, "m_fFlags"), bit.lshift(1, 0))

	local w826= w788()
	if #w826 == 0 then
		w751 = {}
		return
	end

	if w822 % #w826 ~= 0 then
		w753 = w753 + 1
	else
		w753 = 1
	end

	local w793= w826[w753]
	if not w793 then
		w751 = {}
		return
	end

	if w822 < w750 then
		w751 = {}
		return
	end

	if w823.type == "grenade" or w823.type == "knife" then
		w751 = {}
		return
	end

	if w781.in_jump == 1 and w825 == 0 then
		w751 = {}
		return
	end

	local w827= w745
	local w828= w729(w699(w793))
	local w766, w766, w766, w766, w829= w697(w793)

	w751[w793] = nil

	if w829 < 1 then
		if not w776(w760, w793) then
			w760[#w760 + 1] = { w793, w822 }
		end
	else
		w778(w760, w793)
	end

	local w830= w799(w793, w828, w827)
	local w831= w792(w793)

	local w832
	if w823.is_revolver then
		w832 = w821 > w703(w817, "m_flNextPrimaryAttack")
	else
		w832 = w821 > w710(
			w703(w816, "m_flNextAttack"),
			w703(w817, "m_flNextPrimaryAttack"),
			w703(w817, "m_flNextSecondaryAttack")
		)
	end

	if not w832 then
		return
	end

	local w833, w834, w835, w836= w808(
		w816,
		w823,
		w820,
		w830,
		w831
	)

	if not w833 then
		return
	end

	if w693(w833.x, w833.y, w833.z) then
		return
	end

	w780(w781, w797(w823, w824) * 0.33)

	local w837, w767= w820:to(w833):angles()

	if not w824 and w823.type == "sniperrifle" and w781.in_jump == 0 and w825 == 1 then
		w781.in_attack2 = 1
	end

	w751[w793] = true

	if w819 < 0.01 then
		w781.pitch = w837
		w781.yaw = w767
		w781.in_attack = 1
		w754 = true
		w755 = w835
		w756 = w836
		w757 = w793
		w758 = (w716(w737.ui.misc_dormantaimbot_value) or 0)
	end
end

local function w838(w839)
	client.delay_call(0.03, function()
		local w816= w698()
		if client.userid_to_entindex(w839.userid) ~= w816 then
			return
		end

		if w754 and not w759 then
			client.fire_event("dormant_miss", {
				userid = w757,
				aim_hitbox = w755,
				aim_point = w756,
				accuracy = w758
			})
		end

		w759 = false
		w754 = false
		w755 = nil
		w756 = nil
		w757 = nil
		w758 = nil
	end)
end

local function w840(w839)
	local w841= client.userid_to_entindex(w839.userid)
	local w842= client.userid_to_entindex(w839.attacker)

	if w842 == w698() and w841 ~= nil and w754 then
		w759 = true

		client.fire_event("dormant_hit", {
			userid = w841,
			attacker = w842,
			health = w839.health,
			armor = w839.armor,
			weapon = w839.weapon,
			dmg_health = w839.dmg_health,
			dmg_armor = w839.dmg_armor,
			hitgroup = w839.hitgroup,
			accuracy = w758 or 0,
			aim_hitbox = w755
		})
	end
end

local function w843()
	local w844= (cvar.mp_freezetime:get_float() + 1) / globals.tickinterval()
	w750 = w709() + w844
end

w738.register("setup_command", w815, { alive_only = true, require_login = true })
w738.register("round_prestart", w843, { alive_only = true, require_login = true })
w738.register("player_hurt", w840, { alive_only = true, require_login = true })
w738.register("weapon_fire", w838, { alive_only = true, require_login = true })

client.register_esp_flag("DA", 255, 255, 255, function(w777)
	if w740('misc_dormantaimbot') and w740('misc_dormantaimbot_key') and w706(w698()) then
		return w751[w777]
	end
end)


w738.register("paint", function()
	if not w706(w698()) then return end
	if w740('misc_dormantaimbot') and w740('misc_dormantaimbot_key') then
		local w845= {255,255,255,200}
		for w766,w775 in pairs(w751) do if w775 then w845={143,194,21,255}; break end end
		if #w788()==0 then w845={255,0,50,255} end
		w713(w845[1],w845[2],w845[3],w845[4],"DA")
	end
end, { alive_only = true, require_login = true })]]
w207["require/features/misc/enhance_osaa"] = [[local w696, w697= pcall(require, "require/abc/menu_setup")

local w698= require('require/abc/callbacks')

local w699= {}
local w700= {}
for w701, w702 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local w703= {ui.reference(w702[1], w702[2], w702[3])}
    w699[w701] = w703
    for w704, w705 in ipairs(w703) do
        w700[w705] = true
    end
end

local w706= {}
local w707= {}

w698.register("weapon_fire", function(w708)
    local w709= entity.get_local_player()
    if w709 and client.userid_to_entindex(w708.userid) == w709 then
        w706[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

w698.register("player_hurt", function(w708)
    local w709= entity.get_local_player()
    if w709 and client.userid_to_entindex(w708.userid) == w709 then
        w707[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

local function w710()
    local w711= globals.tickcount()
    local w712= nil
    for w713 = w711-20, w711 do
        if w706[w713] then
            w712 = w713
            break
        end
    end
    if w712 then
        if w711 - w712 <= 4 then
            return true
        end
        return true
    end
    return false
end



local function w714(w715)

    local w710= w710()

    local function w716(w717,w718)
        if type(w717) ~= 'table' then return false end
        for w704, w719 in ipairs(w717) do if tostring(w719) == tostring(w718) then return true end end
        return false
    end

    local w720= ui.get(w697.ui.fakelag_settings_enhance_onshot) or {}

    if w697 and w697.ui and w710 then
            if w716(w720, 'defensive') then
                w715.force_defensive = true
            end

            if w716(w720, 'roll') then
                ui.set(w699[3][1], math.random(-45, 45))
            end

            local w721= globals.tickcount() % 4 < 2
            if w716(w720, 'jitter') then
                ui.set(w699[2][1], '180')
                ui.set(w699[2][2], w721 and 55 or -48)
            end
    end
end

w698.register('setup_command', function(w715)

    w714(w715)

end, { alive_only = true, require_login = true })]]
w207["require/features/misc/events"] = [[local w699= {}
local globals= globals

w699.last_hit = {}
w699.last_miss = {}

w699.shots_queue = {}
w699.shots_by_id = {}

function w699.record_weapon_fire(w700)
  if not w700 or not w700.t then return end
  w699.shots_queue[#w699.shots_queue+1] = w700
end

function w699.record_aim_fire(w701,w700)
  if not w701 or not w700 then return end
  w699.shots_by_id[w701] = w700
end

function w699.record_aim_miss(w701,w702,w703)
  if not w702 then return end
  local w704= globals.curtime()
  local w705= w703 or {}
  w705.time = w704
  w699.last_miss[w702] = w705
  if w701 then w699.shots_by_id[w701] = nil end
end

function w699.record_player_hurt(w701,w702,w703)
  if not w702 then return end
  local w704= globals.curtime()
  local w705= w703 or {}
  w705.time = w704
  w699.last_hit[w702] = w705
  if w701 then w699.shots_by_id[w701] = nil end
end

function w699.link_recent_shot_to_victim(w702,w706)
  w706 = w706 or 0.35
  local w704= globals.curtime()
  for w707=#w699.shots_queue,1,-1 do
    local w708= w699.shots_queue[w707]
    if w708 and w708.target == w702 and (w704 - (w708.t or w704)) <= w706 and not w708.linked then
      w699.shots_queue[w707].linked = true
      return w699.shots_queue[w707]
    end
  end
  return nil
end

return w699
]]
w207["require/features/misc/exploit_fakelag"] = [[local w702, w703= pcall(require, "require/abc/menu_setup")

local w704= require('require/abc/callbacks')

local w705= {}
local w706= {}
for w707, w708 in ipairs({
    { 'rage', 'aimbot', 'double tap' },
    { 'aa', 'other', 'on shot anti-aim' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },

}) do
    local w709= {ui.reference(w708[1], w708[2], w708[3])}
    w705[w707] = w709
    for w710, w711 in ipairs(w709) do
        w706[w711] = true
    end
end


local function w712(w713)

    local w714= ui.get(w703.ui.misc_exploit_fakelag)

    local w715= (ui.get(w705[1][1]) and ui.get(w705[1][2]))
    local w716= (ui.get(w705[2][1]) and ui.get(w705[2][2]))

    local w717= w714 and (w715 or w716)

    if w717 then
        ui.set(w705[3][1], false)
    end

end

w704.register('setup_command', function(w713)

    w712(w713)

end, { alive_only = true, require_login = true })]]
w207["require/features/misc/fakelag"] = [[local w705= {}
local w706= {}
for w707, w708 in ipairs({
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
}) do
    local w709= {ui.reference(w708[1], w708[2], w708[3])}
    w705[w707] = w709
    for w710, w711 in ipairs(w709) do
        w706[w711] = true
    end
end

local w712, w713= pcall(require, "require/abc/menu_setup")

local w714= require('require/abc/callbacks')

w714.register("setup_command", function()
    if not (w712 and w713 and w713.ui) then return end

    local w715, w716= pcall(ui.get, w713.ui.fakelag_fakelag)
    if not w715 or not w716 then return end

    local w717, w718= pcall(ui.get, w713.ui.fakelag_fakelag_type)
    if not w717 then return end

    if tostring(w718) == "gamesense" then
        ui.set(w705[1][1], true)
        local w719, w720= pcall(ui.get, w713.ui.fakelag_fakelag_amount)
        local w721, w722= pcall(ui.get, w713.ui.fakelag_fakelag_variance)
        local w723, w724= pcall(ui.get, w713.ui.fakelag_fakelag_limit)

        if w719 and w720 and w705[2] and w705[2][1] then
            pcall(ui.set, w705[2][1], w720)
        end
        if w721 and w722 and w705[3] and w705[3][1] then
            pcall(ui.set, w705[3][1], w722)
        end
        if w723 and w724 and w705[4] and w705[4][1] then
            pcall(ui.set, w705[4][1], w724)
        end

        return
    end

    if tostring(w718) == "sodium" then
        ui.set(w705[1][1], true)
        local w725, w726= pcall(ui.get, w713.ui.fakelag_fakelag_type2)
        if not w725 then return end

        if tostring(w726) == "jitter" then
            if w705[2] and w705[2][1] then
                pcall(ui.set, w705[2][1], "dynamic")
            end
            local w727= globals.tickcount() or 0
            local w728= math.max(w727 % 101, 100)
            local w729= math.min(math.random(7) + (w727 % 15), 11)
            if w705[3] and w705[3][1] then pcall(ui.set, w705[3][1], w728) end
            if w705[4] and w705[4][1] then pcall(ui.set, w705[4][1], 15) end

            return
        end

        if tostring(w726) == "max" then
            if w705[2] and w705[2][1] then
                pcall(ui.set, w705[2][1], "dynamic")
            end
            if w705[3] and w705[3][1] then
                pcall(ui.set, w705[3][1], 0)
            end
            local w724= 14 + ((globals.tickcount() or 0) % 2)
            if w705[4] and w705[4][1] then pcall(ui.set, w705[4][1], w724) end

            return
        end
    end
end, { alive_only = true, require_login = true })]]
w207["require/features/misc/freestand_helper"] = [[local w708= {}
local w709= {}
for w710, w711 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
}) do
    local w712= {ui.reference(w711[1], w711[2], w711[3])}
    w708[w710] = w712
    for w713, w714 in ipairs(w712) do
        w709[w714] = true
    end
end

local w715, w716= pcall(require, "require/abc/menu_setup")

local w717= require('require/abc/callbacks')

local function w718(w719)
    if not (w716 and w716.ui and w716.ui.aa_gskey_freestand) then return end
    if not ui.get(w716.ui.aa_gskey_freestand) then return end

    local function w720(w721,w722)
        if type(w721) ~= 'table' then return false end
        for w713, w723 in ipairs(w721) do if tostring(w723) == tostring(w722) then return true end end
        return false
    end

    local w724= ui.get(w716.ui.fakelag_settings_freestanding) or {}


    localplayer = entity.get_local_player()
    local w725, w726, w727= entity.get_prop(localplayer, 'm_vecVelocity')
    if w725 and w726 and w727 then
        velvel =  math.sqrt(w725 * w725 + w726 * w726 + w727 * w727)
    end
    


    if w720(w724, 'static') then
        ui.set(w708[1][1], true)
        ui.set(w708[5][1], '180')
        ui.set(w708[5][2], 6)
        ui.set(w708[6][1], 'off')
        ui.set(w708[7][1], 'off')
    end

    if w720(w724, 'zero pitch') and velvel > 5 then
        ui.set(w708[3][1], 'Off')
    end

    if w720(w724, 'defensive') then
        w719.force_defensive = true
    end

    local w728= globals.tickcount() % 4 < 2
    if w720(w724, 'side flip') and velvel > 5 then
        ui.set(w708[5][1], '180')
        ui.set(w708[5][2], w728 and -90 or 90)
    end

    local w728= globals.tickcount() % 6 < 2
    if w720(w724, 'pitch flip') and velvel > 5 then
        ui.set(w708[3][1], 'custom')
        ui.set(w708[3][2], w728 and -89 or 89)
    end

end

w717.register('setup_command', function(w719)
    w718(w719)
end, { alive_only = true, require_login = true })]]
w207["require/features/misc/history"] = [[
local w711= {}

local w712= 20
local w713= {}

local function w714(w715)
  if not w713[w715] then w713[w715] = { buf = {} } end
  return w713[w715]
end

function w711.push(w715,w716)
  if not w715 or not w716 then return end
  local w717= w714(w715)
  w717.buf[#w717.buf+1] = w716
  if #w717.buf > w712 then table.remove(w717.buf, 1) end
end

function w711.get_last_n(w715,w718)
  w718 = w718 or w712
  local w717= w713[w715]
  if not w717 or #w717.buf == 0 then return {} end
  local w719= {}
  local w720= #w717.buf
  local w721= math.max(1, w720 - w718 + 1)
  for w722 = w721, w720 do w719[#w719+1] = w717.buf[w722] end
  return w719
end

function w711.clear(w715)
  if not w715 then w713 = {} return end
  w713[w715] = nil
end

return w711
]]
w207["require/features/misc/hotkeys"] = [[local w714= {}
local w715= {}
for w716, w717 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local w718= {ui.reference(w717[1], w717[2], w717[3])}
    w714[w716] = w718
    for w719, w720 in ipairs(w718) do
        w715[w720] = true
    end
end

local w721, w722= pcall(require, "require/abc/menu_setup")

local w723= require('require/abc/callbacks')

local function w724()

    if ui.get(w722.ui.aa_gskey_freestand) then
        ui.set(w714[3][1], true)
        ui.set(w714[3][2], 'Always on')
    else
        ui.set(w714[3][1], false)
        ui.set(w714[3][2], 'On hotkey')
    end

    if ui.get(w722.ui.aa_gskey_slowmotion) then
        ui.set(w714[4][1], true)
    else
        ui.set(w714[4][1], false)
    end

    if w722 and w722.ui and ui.get(w722.ui.aa_gskey_edgeyaw) then
        ui.set(w714[2][1], true)
    else
        ui.set(w714[2][1], false)
    end

    if w722 and w722.ui and ui.get(w722.ui.aa_gskey_onshot) then
        ui.set(w714[6][2], 'Always on')
    else
        ui.set(w714[6][2], 'On hotkey')
    end

end

w723.register('setup_command', function()

    w724()

end, { alive_only = true, require_login = true })]]
w207["require/features/misc/localdebug"] = [=[local callbacks_ok, callbacks = pcall(require, "require/abc/callbacks")
local M = {}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")

local state = {
    last_yaw = nil,
    last_pitch = nil,
    last_defensive = false,
    skel_list = {},
    last_choked = 0,
    shot_ticks = {},
    shot_ticks_aim = {},
    skel_history = {},
}

local function normalize_angle(a)
    if not a then return a end
    local ang = tonumber(a) or 0
    while ang > 180 do ang = ang - 360 end
    while ang <= -180 do ang = ang + 360 end
    return ang
end

local function on_weapon_fire(ev)
    if not ev then return end
    local attacker_ent = client.userid_to_entindex(ev.userid)
    local lp = entity.get_local_player()
    if attacker_ent ~= lp then return end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks, t)
    while #state.shot_ticks > 200 do table.remove(state.shot_ticks, 1) end
end

local function on_aim_fire(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    if ev.attacker then
        local attacker_ent = client.userid_to_entindex(ev.attacker)
        if attacker_ent ~= lp then return end
    end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks_aim, t)
    while #state.shot_ticks_aim > 200 do table.remove(state.shot_ticks_aim, 1) end
end

local function had_recent_shot(ticks_back)
    ticks_back = ticks_back or 30
    local now = globals.tickcount and globals.tickcount() or 0
    for i = #state.shot_ticks_aim, 1, -1 do
        local s = state.shot_ticks_aim[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    for i = #state.shot_ticks, 1, -1 do
        local s = state.shot_ticks[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    return false
end

local function safe_tonumber(v)
    local n = tonumber(v)
    if n then return n end
    return 0
end


local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {
    head={names={'head','Head','HEAD'},idx={0}},
    neck={names={'neck','Neck'},idx={1}},
    chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},
    stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},
    pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},
    l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},
    l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},
    l_hand={names={'left hand','Left Hand'},idx={14}},
    r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},
    r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},
    r_hand={names={'right hand','Right Hand'},idx={13}},
    l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},
    l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},
    l_foot={names={'left foot','Left Foot'},idx={12}},
    r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},
    r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},
    r_foot={names={'right foot','Right Foot'},idx={11}},
}

local function find_bone(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x,y,z = entity.hitbox_position(ent, def.names[i])
        if x then return x,y,z end
    end
    for i = 1, #(def.idx or {}) do
        local x,y,z = entity.hitbox_position(ent, def.idx[i])
        if x then return x,y,z end
    end
end

local function snap_ent(ent)
    if not ent then return end
    local pts = {}
    for key, def in pairs(boxes) do
        local x,y,z = find_bone(ent, def)
        if x then pts[key] = {x=x,y=y,z=z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local function paint_handler()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lag_record then
        local ok_enabled, enabled = pcall(ui.get, menu_setup.ui.paint_lag_record)
        if not ok_enabled or not enabled then return end
    end
    if not renderer or not renderer.world_to_screen or not renderer.line then return end
    local now = globals.realtime and globals.realtime() or os.time()
    local i = 1
    while i <= #state.skel_list do
        local it = state.skel_list[i]
        if not it or not it.t or (now - it.t) > 10 then
            table.remove(state.skel_list, i)
        else
            local SKEL_SCALE = 1.15
            
            local trail = it.trail or {}
            if trail and #trail > 0 then
                for ti = 1, #trail do
                    local entry = trail[ti]
                    local trail_pts = entry.pts or {}
                    
                    local ratio = ti / #trail
                    local r, g, b, alpha
                    if ti == #trail then
                        
                        r = 0
                        g = 140
                        b = 255
                        alpha = 200
                    else
                        
                        r = 255
                        g = math.floor(255 * (1 - ratio))
                        b = math.floor(255 * (1 - ratio))
                        alpha = math.floor(40 + ratio * (160 - 40))
                    end
                    
                    local center = trail_pts.pelvis or trail_pts.chest
                    if not center then
                        local sx, sy, sz, ccount = 0,0,0,0
                        for k, v in pairs(trail_pts) do
                            if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                        end
                        if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
                    end
                    for c = 1, #chains do
                        local chain = chains[c]
                        local from, to = trail_pts[chain[1]], trail_pts[chain[2]]
                        if from and to then
                            local fxw, fyw, fzw = from.x, from.y, from.z
                            local txw, tyw, tzw = to.x, to.y, to.z
                            if center and center.x then
                                fxw = center.x + (from.x - center.x) * SKEL_SCALE
                                fyw = center.y + (from.y - center.y) * SKEL_SCALE
                                fzw = center.z + (from.z - center.z) * SKEL_SCALE
                                txw = center.x + (to.x - center.x) * SKEL_SCALE
                                tyw = center.y + (to.y - center.y) * SKEL_SCALE
                                tzw = center.z + (to.z - center.z) * SKEL_SCALE
                            end
                            local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                            local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                            if fx and tx then renderer.line(fx,fy,tx,ty,r,g,b,alpha) end
                        end
                    end
                end
            end
            
            local pts = it.pts or {}
            local center = pts.pelvis or pts.chest
            if not center then
                local sx, sy, sz, ccount = 0,0,0,0
                for k, v in pairs(pts) do
                    if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                end
                if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
            end
            for c = 1, #chains do
                local chain = chains[c]
                local from, to = pts[chain[1]], pts[chain[2]]
                if from and to then
                    local fxw, fyw, fzw = from.x, from.y, from.z
                    local txw, tyw, tzw = to.x, to.y, to.z
                    if center and center.x then
                        fxw = center.x + (from.x - center.x) * SKEL_SCALE
                        fyw = center.y + (from.y - center.y) * SKEL_SCALE
                        fzw = center.z + (from.z - center.z) * SKEL_SCALE
                        txw = center.x + (to.x - center.x) * SKEL_SCALE
                        tyw = center.y + (to.y - center.y) * SKEL_SCALE
                        tzw = center.z + (to.z - center.z) * SKEL_SCALE
                    end
                    local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                    local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                    if fx and tx then renderer.line(fx,fy,tx,ty,255,0,0,220) end
                end
            end
            i = i + 1
        end
    end
end


local function on_setup_command(cmd)
    if not cmd then return end
    local aa_funcs = nil
    local ok_req, req_lib = pcall(require, 'gamesense/antiaim_funcs')
    if ok_req and req_lib then aa_funcs = req_lib end
    if not aa_funcs then
        local ok_libs, libs = pcall(require, 'require/help/libs')
        if ok_libs and libs and libs.get then
            aa_funcs = libs.get('antiaim_funcs')
        end
    end

    local pitch, yaw = nil, nil
    if aa_funcs then
        local okp, pval = pcall(function() return aa_funcs.get_pitch and aa_funcs.get_pitch() end)
        if okp and pval ~= nil then pitch = pval end
        local oky, yval = pcall(function() return aa_funcs.get_yaw_base and aa_funcs.get_yaw_base() end)
        if oky and yval ~= nil then yaw = yval end
        if yaw == nil then
            local okb, bval = pcall(function() return aa_funcs.get_body_yaw and aa_funcs.get_body_yaw() end)
            if okb and bval ~= nil then yaw = bval end
        end
    end

    if (pitch == nil or yaw == nil) then
        local lp = entity.get_local_player()
        if lp then
            local ax, ay = entity.get_prop(lp, "m_angEyeAngles")
            if ax and ay then
                if pitch == nil then pitch = ax end
                if yaw == nil then yaw = ay end
            end
        end
    end

    if pitch ~= nil then state.last_pitch = pitch end
    if yaw ~= nil then state.last_yaw = normalize_angle(yaw) end

    do
        local ok_def, def_mod = pcall(require, 'require/features/aa/defensive')
        if ok_def and def_mod and def_mod.active ~= nil then
            state.last_defensive = not not def_mod.active
        else
            if cmd and cmd.force_defensive ~= nil then
                state.last_defensive = not not cmd.force_defensive
            end
        end
    end
    if cmd and cmd.chokedcommands ~= nil then
        state.last_choked = tonumber(cmd.chokedcommands) or 0
    end
    local lp = entity.get_local_player()
    if lp then
        local tick = globals.tickcount and globals.tickcount() or 0
        local hist_pts = snap_ent(lp)
        if hist_pts then
            state.skel_history[#state.skel_history + 1] = { tick = tick, pts = hist_pts }
            if #state.skel_history > 128 then table.remove(state.skel_history, 1) end
        end
    end
end

local function on_player_death(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    local victim_ent = client.userid_to_entindex(ev.userid)
    local attacker_ent = nil
    if ev.attacker then attacker_ent = client.userid_to_entindex(ev.attacker) end

    if victim_ent == lp then
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then
                attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker)
            else
                attacker_name = tostring(ev.attacker)
            end
        end
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] DIED — last_yaw=%.2f last_pitch=%.2f attacker=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
        return
    end
    if attacker_ent == lp and victim_ent and victim_ent ~= 0 and victim_ent ~= lp then
        local victim_name = entity.get_player_name(victim_ent) or tostring(ev.userid)
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] KILLED — last_yaw=%.2f last_pitch=%.2f victim=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, victim_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end
end

if callbacks_ok and callbacks and callbacks.callback then
    callbacks.callback('setup_command', on_setup_command, { alive_only = false, require_login = false })
    callbacks.callback('player_death', on_player_death, { alive_only = false, require_login = false })
    callbacks.callback('paint', paint_handler, { alive_only = false, require_login = false })
    callbacks.callback('weapon_fire', on_weapon_fire, { alive_only = false, require_login = false })
    callbacks.callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end, { alive_only = false, require_login = false })
else
    client.set_event_callback('setup_command', on_setup_command)
    client.set_event_callback('player_death', on_player_death)
    client.set_event_callback('paint', paint_handler)
    client.set_event_callback('weapon_fire', on_weapon_fire)
    client.set_event_callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end)
end
]=]
w207["require/features/misc/resolver"] = [[














local w720, w721= pcall(require, "require/features/misc/collect")
local w722, w723= pcall(require, "require/features/misc/history")
local w724, w725= pcall(require, "require/features/misc/state")
local w726, w727= pcall(require, "require/features/misc/events")
local w728, w729= pcall(require, "require/help/vector")
local w730= w728 and w729 or nil
local w731= require('require/abc/callbacks')







if not M then M = {} end
M.players = M.players or {}


local function w732()
	pcall(function()
		if not w720 or type(w721) ~= "table" or not w721.get_enemies_snapshot then return end

		local w733, w734= pcall(function() return w721.get_enemies_snapshot() end)
		if not w733 or type(w734) ~= "table" then return end

		M.players = M.players or {}

		for w735, w736 in pairs(w734) do
			M.players[w735] = M.players[w735] or {}
			M.players[w735].snapshot = w736

            
            
            
			M.players[w735].simtime = w736.simtime
			M.players[w735].simTicks = w736.simTicks
			M.players[w735].lowerBodyYaw = w736.lowerBodyYaw
			M.players[w735].speed2d = w736.speed2d
			M.players[w735].velocity3d = w736.velocity3d
			M.players[w735].is_alive = w736.is_alive
			M.players[w735].is_dormant = w736.is_dormant
			M.players[w735].feetYaw = w736.feetYaw
			M.players[w735].goalFeetYaw = w736.goalFeetYaw
			M.players[w735].moveSpeedAnim = w736.moveSpeedAnim
		end

		for w735, w736 in pairs(w734) do
			local w737= w736.name or "?"
			local w738= w736.simtime or 0
			local w739= w736.speed2d or 0
			local w740= w736.lowerBodyYaw or "nil"
			local w741= w736.moveSpeedAnim or 0
			local w742= w736.feetYaw or "nil"
			local w743= w736.goalFeetYaw or "nil"
			local w744= w736.animstate_full.m_fDuckAmount

		end
	end)
end



local function w745(w746)
    while w746 > 180 do
        w746 = w746 - 360
    end
    while w746 < -180 do
        w746 = w746 + 360
    end
    return w746
end


local function w747(w748,w749)
    local w750= w749 - w748
    local w746= math.atan(w750.y / w750.x)
    w746 = w745(w746 * 180 / math.pi)

    if w750.x >= 0 then
        w746 = w745(w746 + 180)
    end

    return w746
end



local w751= 100
local w752= {}
_G.player_history = w752

local function w753(w754)
    return math.floor(0.5 + w754 / globals.tickinterval())
end

local function w755(w756)
    local w757= entity.get_players(true)

	if #w757 == 0 then
		
		w752 = {}
		_G.player_history = w752
		return nil
	end


	for w758, w759 in ipairs(w757) do
		if entity.is_alive(w759) and not entity.is_dormant(w759) then

			local w760= 0
			local w761= entity.get_esp_data(w759).flags or 0

			if bit.band(w761, bit.lshift(1, 17)) ~= 0 then
				w760 = w753(entity.get_prop(w759, "m_flSimulationTime")) - 14
			else
				w760 = w753(entity.get_prop(w759, "m_flSimulationTime"))
			end

			
			local w762= w752[w759] or {}
			local w763= w762[1]

			if w763 == nil or (w760 - (w763.simtime or -999)) >= 1 then

				local w764= w730(entity.get_prop(w756, "m_vecOrigin"))
				local w765= w730(entity.get_prop(w759, "m_angEyeAngles"))
				local w766= w730(entity.get_prop(w759, "m_vecOrigin"))
				local w767= math.floor(w745(w765.y - w747(w764, w766)))
				

				local w736= {
					id = w759 or nil,
					origin = w730(entity.get_origin(w759)) or w730(nil,nil,nil),
					pitch = w765.x or nil,
					yaw = w767 or nil,
					yaw_backwards = backwards_angle or nil,
					simtime = w760 or nil,
					stance = stance or nil,
					esp_flags = entity.get_esp_data(w759).flags or 0,
					last_shot_time = last_shot_time or nil
				}

				table.insert(w762, 1, w736)
				while #w762 > w751 do
					table.remove(w762)
				end

				w752[w759] = w762
			end
		end
	end
end















client.set_event_callback('net_update_end', function()
    pcall(function()

        
        

        local w756= entity.get_local_player()
        if not entity.is_alive(w756) then
            return
        end
        w755(w756)


        local w768= (globals and globals.tickcount and globals.tickcount()) or (globals and globals.realtime and globals.realtime()) or os.time()
        

    end)
end, { alive_only = true, require_login = true })

w731.register('weapon_fire', function(w769)
    pcall(function()







        local w770= (w769 and w769.userid) and (client.userid_to_entindex and client.userid_to_entindex(w769.userid)) or (w769 and (w769.attacker or w769.userid)) or "?"
        local w771= (w769 and (w769.weapon or w769.weapon_name or w769.weaponid)) or "?"
        
    end)
    if EVENTS and EVENTS.record_weapon_fire then pcall(EVENTS.record_weapon_fire, w769) end
end, { alive_only = true, require_login = true })

w731.register('aim_fire', function(w769)
    pcall(function()








        local w772= w769 and w769.id or "?"
        local w773= w769 and w769.target or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_fire then pcall(EVENTS.record_aim_fire, w769) end
end, { alive_only = true, require_login = true })

w731.register('aim_hit', function(w769)
    pcall(function()








        local w772= w769 and w769.id or "?"
        local w773= w769 and w769.target or "?"
        local w774= w769 and w769.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_hit then pcall(EVENTS.record_aim_hit, w769) end
end, { alive_only = true, require_login = true })

w731.register('aim_miss', function(w769)
    pcall(function()






        local w772= w769 and w769.id or "?"
        local w775= w769 and w769.reason or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_miss then pcall(EVENTS.record_aim_miss, w769) end
end, { alive_only = true, require_login = true })

w731.register('player_hurt', function(w769)
    pcall(function()






        local w776= (w769 and w769.attacker) or (w769 and w769.userid) or "?"
        local w777= (w769 and w769.userid) or (w769 and w769.userid) or "?"
        local w774= w769 and w769.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_player_hurt then pcall(EVENTS.record_player_hurt, w769) end
end, { alive_only = true, require_login = true })

w731.register('bullet_impact', function(w769)
    pcall(function()




        local w770= (w769 and w769.userid) and (client.userid_to_entindex and client.userid_to_entindex(w769.userid)) or "?"
        local w778,w779,w780= w769 and w769.x or "?", w769 and w769.y or "?", w769 and w769.z or "?"
        
    end)
    if EVENTS and EVENTS.on_bullet_impact then pcall(EVENTS.on_bullet_impact, w769) end
    if EVENTS and EVENTS.record_bullet_impact then pcall(EVENTS.record_bullet_impact, w769) end
end, { alive_only = true, require_login = true })

w731.register('paint', function()
    pcall(function()

        

    end)
    if EVENTS and EVENTS.on_paint then pcall(EVENTS.on_paint) end
end, { alive_only = true, require_login = true })

w731.register("round_start", function(w769)
    pcall(function() print("[resolver] round_start") end)



    M.players = {}
    if EVENTS and EVENTS.on_round_start then pcall(EVENTS.on_round_start, w769) end
end, { alive_only = true, require_login = true })

w731.register("shutdown", function()
    if client and client.unset_event_callback then



    end
end, { alive_only = true, require_login = true })
]]
w207["require/features/misc/resolver_dispatcher"] = [[local w723= {}


local w724= {}


_G.player_resolver_state = _G.player_resolver_state or {}

local function w725(w726)
    if not w726 or type(w726) ~= "string" then return nil end
    
    local w727= w726:lower()
    w727 = w727:gsub("%+", "plus")
    w727 = w727:gsub("%-% ", "minus_") 
    w727 = w727:gsub("%-%", "minus")
    w727 = w727:gsub("%s+", "_")
    w727 = w727:gsub("[^%w_]", "")
    return w727
end

local function w728(w726)
    local w729
    
    if w726 == "?" then
        w729 = "default"
    else
        w729 = w725(w726)
    end
    if not w729 or w729 == "" then return nil end
    if w724[w729] ~= nil then return w724[w729] end
    local w730= "require/features/misc/res_" .. w729
    local w731, w732= pcall(require, w730)
    if w731 and type(w732) == "table" then
        w724[w729] = w732
        return w732
    end
    w724[w729] = false
    return nil
end



function w723.process_entity(w733,w726,w734)
    local w731, w735= pcall(function()
        if not w733 or w733 == 0 then return end
        if not w726 or w726 == "?" then return end

        local w732= w728(w726)
        if not w732 then return end

        
        local w736= _G.player_resolver_state[w733]
        if not w736 then
            w736 = {}
            _G.player_resolver_state[w733] = w736
        end

        if type(w732.run) == "function" then
            
            pcall(function() w732.run(w733, w734 or {}, w736, w726) end)
        elseif type(w732.process) == "function" then
            pcall(function() w732.process(w733, w734 or {}, w736, w726) end)
        end
    end)
    return w731
end


w723._modules = w724
w723._sanitize_label = w725

return w723
]]
w207["require/features/misc/res_default"] = [[local w726= {}

local function w727(w728)
    pcall(function()
        if plist and type(plist.set) == "function" then
            
            plist.set(w728, "Force body yaw", false)
            plist.set(w728, "Force body yaw value", 0)
            plist.set(w728, "Force pitch", false)
            plist.set(w728, "Force pitch value", 0)
        end
    end)
end

function w726.run(w728,w729,w730,w731)
    
    if w731 ~= "?" and w731 ~= "DEFAULT" and w731 ~= "default" then return end

    w730.clears = (w730.clears or 0) + 1
    w730.last_seen = (globals and globals.curtime and globals.curtime()) or os.time()

    
    w727(w728)

    pcall(function()
        print(string.format("[res_default] ent=%d cleared_forces label=%s count=%d", w728, tostring(w731), w730.clears))
    end)
end

return w726
]]
w207["require/features/misc/res_static"] = [=[local M = {}
local ok_ffi, ffi = pcall(require, "ffi")
local ok_bit, bit = pcall(require, "bit")


local get_entity_ptr
local function init_ffi_helpers()
    if not ok_ffi or not client or not client.create_interface then return end
    local status, res = pcall(function()
        local pointer_type = ffi.typeof("void***")
        local entity_list_ptr = client.create_interface("client.dll", "VClientEntityList003")
        if not entity_list_ptr then return nil end
        local entity_list = ffi.cast(pointer_type, entity_list_ptr)
        local get_client_entity = ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
        return function(entindex)
            if not entindex or entindex == 0 then return nil end
            local ptr = get_client_entity(entity_list, entindex)
            if ptr == nil then return nil end
            return ptr
        end
    end)
    if status and type(res) == "function" then
        get_entity_ptr = res
    else
        get_entity_ptr = nil
    end
end
init_ffi_helpers()

local function get_speed2d(ent)
    
    local ok, vx, vy = pcall(function()
        local x,y,z = entity.get_prop(ent, "m_vecVelocity")
        return x or 0, y or 0
    end)
    if ok and vx and vy then
        return math.sqrt((vx or 0)*(vx or 0) + (vy or 0)*(vy or 0))
    end
    return 0
end

local function estimate_max_desync_ent(ent)
    
    if not ok_ffi or not get_entity_ptr then return nil end
    local ok_read, result = pcall(function()
        ffi.cdef[[
        struct c_animstate {
            char pad0[3];
            char m_bForceWeaponUpdate;
            char pad1[91];
            void* m_pBaseEntity;
            void* m_pActiveWeapon;
            void* m_pLastActiveWeapon;
            float m_flLastClientSideAnimationUpdateTime;
            int m_iLastClientSideAnimationUpdateFramecount;
            float m_flAnimUpdateDelta;
            float m_flEyeYaw;
            float m_flPitch;
            float m_flGoalFeetYaw;
            float m_flCurrentFeetYaw;
            float m_flCurrentTorsoYaw;
            float m_flUnknownVelocityLean;
            float m_flLeanAmount;
            char pad2[4];
            float m_flFeetCycle;
            float m_flFeetYawRate;
            char pad3[4];
            float m_fDuckAmount;
            float m_fLandingDuckAdditiveSomething;
            char pad4[4];
            float m_vOriginX;
            float m_vOriginY;
            float m_vOriginZ;
            float m_vLastOriginX;
            float m_vLastOriginY;
            float m_vLastOriginZ;
            float m_vVelocityX;
            float m_vVelocityY;
            char pad5[4];
            float m_flUnknownFloat1;
            char pad6[8];
            float m_flUnknownFloat2;
            float m_flUnknownFloat3;
            float m_flUnknown;
            float m_flSpeed2D;
            float m_flUpVelocity;
            float m_flSpeedNormalized;
            float m_flFeetSpeedForwardsOrSideWays;
            float m_flFeetSpeedUnknownForwardOrSideways;
            float m_flTimeSinceStartedMoving;
            float m_flTimeSinceStoppedMoving;
            bool m_bOnGround;
            bool m_bInHitGroundAnimation;
            char pad7[2];
            float m_flTimeSinceInAir;
            float m_flLastOriginZ;
            float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
            float m_flStopToFullRunningFraction;
            float m_flMagicFraction;
            char pad8[60];
            float m_flWorldForce;
            char pad9[462];
            float m_flMaxYaw;
        };
        ]]
        local ent_ptr = get_entity_ptr(ent)
        if not ent_ptr then return nil end
        local animstate_ptr = ffi.cast("struct c_animstate**", ffi.cast("uintptr_t", ent_ptr) + 0x9960)
        if animstate_ptr == nil or animstate_ptr == ffi.NULL then return nil end
        local anim = animstate_ptr[0]
        if anim == nil or anim == ffi.NULL then return nil end

        local duck_amount = tonumber(anim.m_fDuckAmount) or 0
        local speed2d_norm = tonumber(anim.m_flFeetSpeedForwardsOrSideWays) or 0
        local stop_to_full = tonumber(anim.m_flStopToFullRunningFraction) or 0
        local max_yaw = tonumber(anim.m_flMaxYaw) or 0

        local yaw_modifier = ((-0.3 * stop_to_full) - 0.2) * math.max(0, math.min(speed2d_norm, 1)) + 1.0
        if duck_amount > 0 then
            yaw_modifier = yaw_modifier + (duck_amount * 0.5) * (0.5 - yaw_modifier)
        end

        local raw_delta = max_yaw * yaw_modifier
        local velocity = get_speed2d(ent) or 0
        local velocity_clamped = math.min(math.max(velocity, 0), 260)
        local move_scale = 1.0 - (velocity_clamped / 260)
        move_scale = 0.35 + (move_scale * 0.65)
        local delta = raw_delta * move_scale
        if velocity >= 250 then
            delta = math.min(delta, 28)
        end
        local flags = nil
        if ok_bit and entity and entity.get_prop then
            flags = entity.get_prop(ent, "m_fFlags") or 0
        end
        local on_ground = true
        if flags then on_ground = bit.band(flags, 1) == 1 end
        if not on_ground then delta = delta * 0.55 end
        if duck_amount > 0.9 then delta = delta * 0.9 end
        delta = math.max(0, math.min(delta, 60))
        return delta
    end)
    if ok_read then return result end
    return nil
end

local function safe_unset(ent)
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", false)
            plist.set(ent, "Force body yaw value", 0)
        end
    end)
end

local function now_time()
    local ok, t = pcall(function() return (globals and globals.curtime and globals.curtime()) or os.time() end)
    return ok and t or os.time()
end

local function normalize_angle(angle)
    if not angle or type(angle) ~= "number" then return 0 end
    while angle > 180 do angle = angle - 360 end
    while angle < -180 do angle = angle + 360 end
    return angle
end

local function round(n)
    return math.floor((n or 0) + 0.5)
end

function M.run(ent, features, state, label)
    
    state.count = (state.count or 0) + 1
    state.last_seen = now_time()
    if state.last_label and state.last_label ~= label then state.count = 1 end
    state.last_label = label

    
    if not label or label ~= "STATIC" then return end

    
    local required_count = 3
    if state.count < required_count then return end

    
    if features and features.shot_age and tonumber(features.shot_age) and features.shot_age <= 0.25 then
        return
    end

    
    local avg_speed = tonumber((features and features.avg_speed) or 0) or 0
    if features and features.movement and features.movement == true then return end
    if avg_speed >= 1.2 then return end

    
    local max_mag_low = 58
    local max_mag_high = 28
    local speed_cap = 250
    local t = math.min(math.max(avg_speed / speed_cap, 0), 1)
    local max_mag = max_mag_low + (max_mag_high - max_mag_low) * t

    
    local ok_est, est = pcall(function() return estimate_max_desync_ent(ent) end)
    if ok_est and est and type(est) == "number" then
        max_mag = math.min(max_mag, est)
    end

    
    local on_ground = true
    pcall(function()
        if ok_bit and entity and entity.get_prop then
            local flags = entity.get_prop(ent, "m_fFlags") or 0
            on_ground = bit.band(flags, 1) == 1
        end
    end)
    if not on_ground then max_mag = max_mag * 0.55 end

    
    local forced_val = 0

    
    local last_yaw = (features and features.last_yaw)
    local ref_yaw = features and (features.goal_feet_yaw or features.feet_yaw)
    local desync = nil
    if last_yaw and ref_yaw then
        desync = normalize_angle(last_yaw - ref_yaw)
    end

    
    if not desync then
        forced_val = 0
    else
        local absd = math.abs(desync)
        
        if absd <= 10 then
            forced_val = 0
        else
            
            if ok_est and est and type(est) == "number" and est >= 8 then
                local mag = math.min(math.floor(max_mag + 0.5), math.floor(est + 0.5))
                local desired = math.min(absd, mag)
                
                if desired >= 8 then
                    forced_val = (desync >= 0) and desired or -desired
                else
                    forced_val = 0
                end
            else
                
                forced_val = 0
            end
        end
    end

    
    forced_val = round(forced_val)
    if forced_val > 60 then forced_val = 60 end
    if forced_val < -60 then forced_val = -60 end

    
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", true)
            plist.set(ent, "Force body yaw value", forced_val)
            state.forced = true
            state.forced_value = forced_val
            state.cooldown = now_time() + 0.5

            if client and type(client.delay_call) == "function" then
                client.delay_call(0.6, function()
                    pcall(function()
                        local t = now_time()
                        if not state.cooldown or t > state.cooldown then
                            safe_unset(ent)
                            state.forced = nil
                            state.forced_value = nil
                        end
                    end)
                end)
            end
        end
    end)
end

return M
]=]
w207["require/features/misc/roll"] = [[local w732, w733= pcall(require, "require/abc/menu_setup")

local w734= {}
local w735= {}
for w736, w737 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local w738= {ui.reference(w737[1], w737[2], w737[3])}
    w734[w736] = w738
    for w739, w740 in ipairs(w738) do
        w735[w740] = true
    end
end

local function w741(w742)
end

    local w743= 0
    local w744= 1

    if w732 and w733 and w733.ui then
        if w733.ui.fakelag_settings_roll ~= nil then
            local w745, w746= pcall(ui.get, w733.ui.fakelag_settings_roll)
            if w745 and w746 ~= nil then w743 = w746 end
        end
        if w733.ui.fakelag_settings_side ~= nil then
            local w745, w746= pcall(ui.get, w733.ui.fakelag_settings_side)
            if w745 and w746 ~= nil then w744 = w746 end
        end
    end

    local w747= entity.get_local_player()
    local w748= 0
    if w747 then
        local w749= entity.get_prop(w747, 'm_vecVelocity')
        if w749 then
            local w750= w749.x or w749[1] or 0
            local w751= w749.y or w749[2] or 0
            local w752= w749.z or w749[3] or 0
            w748 = math.sqrt(w750*w750 + w751*w751 + w752*w752)
        end
    end

    if w748 > 3 then
        pcall(ui.set, w734[1] and w734[1][1], 0)
        return
    end

    if w744 == 3 then
        pcall(ui.set, w734[1] and w734[1][1], -w743)
    elseif w744 == 2 then
        local w753= (globals.tickcount() % 20) < 10
        pcall(ui.set, w734[1] and w734[1][1], (w753 and w743 or -w743))
    elseif w744 == 1 then
        pcall(ui.set, w734[1] and w734[1][1], w743)
    end

end

client.set_event_callback('setup_command', function(w742)

    w741(w742)

end)]]
w207["require/features/misc/spin_on_dead_enemies"] = [[local w735= {}
for w736, w737 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local w738= {ui.reference(w737[1], w737[2], w737[3])}
    w735[w736] = w738
end

local w739, w740, w741, w742= entity, globals, ui, client
local w743= require("require/abc/menu_setup")
local w744= (w742.random_int(1, 2) == 1) and 1 or -1

local function w745()
    local w746= {
        {2, 'Off'}, {3, 'Local view'}, {4, {'Spin', 45}}, {5, {'Off', 0}}, {6, {'Off', 0}},
    }
    local w744= (w742.random_int(1, 2) == 1) and 1 or -1
    for w747, w748 in ipairs(w746) do
        local w749, w750= w748[1], w748[2]
        local w738= w735[w749]
        if not w738 then goto continue end
        if type(w750) ~= 'table' then
            pcall(w741.set, w738[1], w750)
        else
            if w738[1] then pcall(w741.set, w738[1], w750[1]) end
            if w738[2] then
                if type(w750[2]) == 'number' and w750[1] == 'Spin' then
                    pcall(w741.set, w738[2], w750[2] * w744)
                else
                    pcall(w741.set, w738[2], w750[2])
                end
            end
        end
        ::continue::
    end
end

local function w751()
    local w752= (w740.maxplayers and w740.maxplayers() or 64)
    local w753, w754, w755= w739.get_classname, w739.is_enemy, w739.is_alive
    if not (w753 and w754 and w755) then return 0 end
    local w756= 0
    for w736=1,w752 do
        if w753(w736) == 'CCSPlayer' and w754(w736) and w755(w736) then w756 = w756 + 1 end
    end
    return w756
end

local function w757()
    if not w741.get(w743.ui.misc_spindead) then return end
    if w751() == 0 then w745() end
end

local w758, w759= pcall(require, "require/abc/callbacks")
if w758 and w759 then
    w759.callback('run_command', w757, { alive_only = true, require_login = true })
end
]]
w207["require/features/misc/walkbot"] = [[local w738= require("require/abc/callbacks")
local w739= require("require/abc/menu_setup")

local w740= nil
local w741= 1
local w742= 0
local w743= 40
local w744= 30
local w745= 450
local w746= 200
local w747= 8
local w748= {150, 300}
local w749= nil
local w750= nil
local w751= nil
local w752= 0
local w753= 700
local w754= 3

local w755= {}
local w756= 3
local w757= 4
local w758= 0
local w759= nil
local w760= 0
local w761= 500
local w762= 1500
local w763= 30
local w764= {}
local w765= false

local w766= 500 
local w767= 0

local w768= {
    { name = "A", x = -445.0, y = -1997.7, z = -180.0 },
    { name = "B", x = -2032.4, y = 259.8, z = -160.0 },
    { name = "Mid", x = -350.3, y = -617.1, z = -269.2 },
}

local function w769(w770)
    if not w770 then return false end
    local w771, w772= pcall(ui.get, w770)
    if not w771 then return false end
    return w772
end

local function w773(w774)
    while w774 > 180 do w774 = w774 - 360 end
    while w774 < -180 do w774 = w774 + 360 end
    return w774
end

local function w775(w776,w777,w778,w779,w780,w781)
    local w782, w783, w784= w776-w779, w777-w780, w778-w781
    return math.sqrt(w782*w782 + w783*w783 + w784*w784)
end

local function w785(w786,w787,w788,w789,w790,w791,w792)
    local w771, w793, w794= pcall(function()
        return client.trace_line(w786, w787, w788, w789, w790, w791, w792)
    end)
    if not w771 then return nil end
    return w793, w794
end

local function w795(w786,w796,w797,w798)
    local w799= w798 + 1000
    local w800= w798 - 1000
    local w793= w785(w786, w796, w797, w799, w796, w797, w800)
    if not w793 then return w798 end
    if type(w793) ~= 'number' then return w798 end
    local w801= w799 + (w800 - w799) * w793
    return w801
end

local function w802(w786,w787,w788,w789,w790,w791,w792)
    local w793= w785(w786, w787, w788, w789, w790, w791, w792)
    if not w793 then return false end
    if w793 >= 1 then return true end
    return false
end

local function w803(w796,w797)
    return tostring(math.floor(w796/50))..":"..tostring(math.floor(w797/50))
end

local function w804(w796,w797)
    local w805= w803(w796, w797)
    w755[w805] = (w755[w805] or 0) + 1
    if w755[w805] >= w756 then
        w764[w805] = true
    end
    return w755[w805]
end

local function w806(w796,w797)
    local w805= w803(w796, w797)
    w755[w805] = nil
end

local function w807(w786)
    local w808, w809, w810= entity.get_origin(w786)
    if not w808 then return nil end
    for w811=1,w744 do
        local w812= math.random()*math.pi*2
        local w813= 200 + math.random()*800
        local w790= w808 + math.cos(w812)*w813
        local w791= w809 + math.sin(w812)*w813
        local w792= w810
            local w793= w785(w786, w808, w809, w810 + 16, w790, w791, w792 + 16)
        if w793 and w793 >= 1 then
            local w814= w795(w786, w790, w791, w792)
            return { x = w790, y = w791, z = w814 }
        end
        if w793 and w793 < 1 then
            local w815= w808 + (w790-w808)*w793
            local w816= w809 + (w791-w809)*w793
            local w817= w810 + (w792-w810)*w793
            for w818, w819 in ipairs(w748) do
                for w820=0,w747-1 do
                    local w774= (w820/w747) * math.pi * 2
                    local w821= w815 + math.cos(w774)*w819
                    local w822= w816 + math.sin(w774)*w819
                    local w823= w795(w786, w821, w822, w817)
                    local w824= w785(w786, w808, w809, w810+16, w821, w822, w823+16)
                    local w825= w785(w786, w821, w822, w823+16, w790, w791, w792+16)
                    if w824 and w824>=1 and w825 and w825>=1 then
                        local w814= w795(w786, w790, w791, w792)
                        return { x = w790, y = w791, z = w814 }
                    end
                end
            end
        end
    end
    return nil
end

local function w826(w827)
    local w828= {}
    while w827 do
        w828[#w828+1] = { x = w827.x, y = w827.y, z = w827.z }
        w827 = w827.parent
    end
    local w829= {}
    for w811=#w828,1,-1 do w829[#w829+1] = w828[w811] end
    return w829
end

local function w830(w786,w831)
    local w808, w809, w810= entity.get_origin(w786)
    if not w808 then return nil end
    local w832= { x = w808, y = w809, z = w810 }
    w832.z = w795(w786, w832.x, w832.y, w832.z)
    local w833= { { x = w832.x, y = w832.y, z = w832.z, parent = nil } }
    local w834= {}
    local function w835(w836)
        local w837= tostring(math.floor(w836.x/50))..":"..tostring(math.floor(w836.y/50))
        w834[w837] = true
    end
    local function w838(w836)
        local w837= tostring(math.floor(w836.x/50))..":"..tostring(math.floor(w836.y/50))
        if w764[w837] then return true end
        return w834[w837]
    end
    w835(w832)
    local w839= 0
    while #w833 > 0 and w839 < w746 do
        local w840= table.remove(w833, 1)
        w839 = w839 + 1
        local w793= w785(w786, w840.x, w840.y, w840.z+16, w831.x, w831.y, w831.z+16)
        if w793 and w793 >= 1 then
            local w841= w826(w840)
            w841[#w841+1] = { x = w831.x, y = w831.y, z = w831.z }
            return w841
        end
        if w793 and w793 < 1 then
            local w815= w840.x + (w831.x-w840.x)*w793
            local w816= w840.y + (w831.y-w840.y)*w793
            local w817= w840.z + (w831.z-w840.z)*w793
            for w818, w819 in ipairs(w748) do
                for w820=0,w747-1 do
                    local w774= (w820/w747) * math.pi * 2
                    local w821= w815 + math.cos(w774)*w819
                    local w822= w816 + math.sin(w774)*w819
                    local w823= w795(w786, w821, w822, w817)
                    if not w838({x=w821,y=w822}) then
                        local w824= w785(w786, w840.x, w840.y, w840.z+16, w821, w822, w823+16)
                        if w824 and w824 >= 1 then
                            w835({x=w821,y=w822})
                            table.insert(w833, { x = w821, y = w822, z = w823, parent = w840 })
                        end
                    end
                end
            end
        end
    end
    return nil
end

local function w842(w843,w786,w790,w791,w792)
    local w808, w809, w810= entity.get_origin(w786)
    if not w808 then return end
    
    local w782, w783= w790 - w808, w791 - w809
    local w844= math.sqrt(w782*w782 + w783*w783)
    if w844 <= 0 then return end
    local w845, w846= w782 / w844, w783 / w844
    local w847= 64
    local w787= w808 + w845 * w847
    local w788= w809 + w846 * w847
    local w789= w810

    
    local w848, w849= client.camera_angles()
    local w812= math.deg(math.atan2(w783, w782))
    local w850= w773(w812 - w849)
    local w851= math.rad(w850)
    local w852= math.cos(w851) * w745
    local w853= -math.sin(w851) * w745

    
    local w854, w855, w856= client.eye_position()
    if not w854 then w854, w855, w856 = w808, w809, w810 end
    if type(w854) == 'table' then w854, w855, w856 = w854[1], w854[2], w854[3] end
    local w857= w808 + w845 * 24
    local w858= w809 + w846 * 24
    local w859= w810 + 16
    local w860= w785(w786, w854, w855, w856, w857, w858, w859)
    if w860 and w860 < 1 then
        
        if w765 then pcall(client.log, "move_towards: short forward blocked, sidestep") end
        pcall(function() w843.forwardmove = 0; w843.sidemove = -w745 end)
        local w861= w808 - w846 * w847
        local w862= w809 + w845 * w847
        local w863= w785(w786, w808, w809, w810 + 16, w861, w862, w789 + 16)
        if w863 and w863 >= 1 then return end
        pcall(function() w843.forwardmove = 0; w843.sidemove = w745 end)
        local w864= w808 + w846 * w847
        local w865= w809 - w845 * w847
        local w866= w785(w786, w808, w809, w810 + 16, w864, w865, w789 + 16)
        if w866 and w866 >= 1 then return end
        
        pcall(function() w804(w790, w791); w742 = client.timestamp() + 250 end)
        w740 = nil
        return
    end

    
    pcall(function()
        w843.forwardmove = w852
        w843.sidemove = w853
    end)

    if w765 then pcall(client.log, string.format("move_towards: fwd=%.1f side=%.1f yaw_diff=%.1f", w852, w853, w850)) end

    local w793= w785(w786, w808, w809, w810 + 16, w787, w788, w789 + 16)
    if w793 and w793 < 1 then
        
        if w765 then pcall(client.log, "move_towards: forward blocked, attempting sidestep") end
        
        pcall(function() w843.forwardmove = 0; w843.sidemove = -w745 end)
        local w861= w808 - w846 * w847
        local w862= w809 + w845 * w847
        local w863= w785(w786, w808, w809, w810 + 16, w861, w862, w789 + 16)
        if w863 and w863 >= 1 then return end
        
        pcall(function() w843.forwardmove = 0; w843.sidemove = w745 end)
        local w864= w808 + w846 * w847
        local w865= w809 - w845 * w847
        local w866= w785(w786, w808, w809, w810 + 16, w864, w865, w789 + 16)
        if w866 and w866 >= 1 then return end
        
        pcall(function()
            w804(w790, w791)
            w742 = client.timestamp() + 250
        end)
        w740 = nil
        return
    end
end

w738.register("setup_command", function(w843)
    local w771, w867= pcall(function()
        if not w769(w739.ui.misc_walkbot) then return end
        local w786= entity.get_local_player()
        if not w786 or not entity.is_alive(w786) then return end
        local w868= client.timestamp()
        if w868 < w742 then return end

        
        do
            local w869= client.timestamp()
            if w869 - w767 >= w766 then
                local w870, w871, w872= entity.get_origin(w786)
                if w870 then
                    pcall(function()
                        client.log(string.format("walkbot_coord: %.1f %.1f %.1f", w870, w871, w872))
                    end)
                    w767 = w869
                end
            end
        end
        if client.key_state(87) or client.key_state(65) or client.key_state(83) or client.key_state(68) or client.key_state(32) or client.key_state(16) or client.key_state(17) then
            w742 = w868 + 500
            return
        end
        
        do
            local w873= entity.get_players(true) or {}
            for w811=1,#w873 do
                local w874= w873[w811]
                local w870, w871, w872= entity.get_origin(w874)
                if w870 then
                    local w875= pcall(function() return client.visible(w870, w871, w872) end)
                    if w875 and client.visible(w870, w871, w872) then
                        pcall(function()
                            local w876= w843.buttons or 0
                            w843.buttons = bit.bor(w876, 4) 
                        end)
                        break
                    end
                end
            end
        end
        
        local w808, w809, w810= entity.get_origin(w786)
        if w808 then
            local w873= entity.get_players(true) or {}
            if #w873 > 0 then
                if not w749 or not entity.is_alive(w749) or entity.is_dormant(w749) then
                    
                    local w877= {}
                    for w811=1,#w873 do
                        local w874= w873[w811]
                        local w870, w871, w872= entity.get_origin(w874)
                        if w870 then
                            local w878= w775(w808, w809, w810, w870, w871, w872)
                            w877[#w877+1] = { ent = w874, dist = w878 }
                        end
                    end
                    table.sort(w877, function(w774,w876) return w774.dist < w876.dist end)
                    if #w877 > 0 then
                                w749 = w877[1].ent  
                        w740 = nil
                        w741 = 1
                    end
                end
            else
                w749 = nil
            end
        end

        
        if w749 and entity.is_alive(w749) and not entity.is_dormant(w749) then
            local w790, w791, w792= entity.get_origin(w749)
            if w790 then
                local w814= w795(w786, w790, w791, w792)
                w750 = { x = w790, y = w791, z = w814 }
            else
                w749 = nil
                w750 = nil
            end
        else
            w749 = nil
            w750 = nil
        end

        
        do
            local w868= client.timestamp()
            if w808 then
                if not w759 then
                    w759 = { x = w808, y = w809, z = w810 }
                    w760 = w868
                else
                    if w868 - w760 >= w761 then
                        local w879= w775(w759.x, w759.y, w759.z, w808, w809, w810)
                        if w879 >= w763 then
                            
                            w758 = 0
                            w759 = { x = w808, y = w809, z = w810 }
                            w760 = w868
                        else
                            
                            if w868 - w760 >= w762 then
                                w758 = w758 + 1
                                w740 = nil
                                w742 = w868 + 300
                                w759 = { x = w808, y = w809, z = w810 }
                                w760 = w868
                                if w758 >= w757 then
                                    
                                    w749 = nil
                                    w750 = nil
                                    w758 = 0
                                end
                            end
                        end
                    end
                end
            end
        end

        if w750 then
            local w868= client.timestamp()
            local w880= (not w740) or (w868 > w752)
            if not w751 then w880 = true end
            if w751 and w750 and w775(w751.x, w751.y, w751.z, w750.x, w750.y, w750.z) > 100 then
                w880 = true
            end
            if w880 then
                local w874= w830(w786, w750)
                if w874 then
                    w740 = w874
                    w741 = 1
                    w752 = client.timestamp() + w753
                    w751 = { x = w750.x, y = w750.y, z = w750.z }
                else
                    
                    w749 = nil
                    w750 = nil
                    w740 = nil
                end
            end
        else
            if not w740 then
                local w881= w807(w786)
                
                if not w881 and #w768 > 0 then
                    local w820= w768[ math.random(1, #w768) ]
                    if w820 then w881 = { x = w820.x, y = w820.y, z = w820.z } end
                end
                if w881 then
                    local w874= w830(w786, w881)
                    if w874 then
                        w740 = w874
                        w741 = 1
                    else
                        
                        w740 = nil
                    end
                end
            end
        end
        if not w740 then return end
        local w808, w809, w810= entity.get_origin(w786)
        if not w808 then return end
        local w882= w740[w741+1] or w740[#w740]
        if not w882 then w740 = nil return end
        local w878= w775(w808, w809, w810, w882.x, w882.y, w882.z)
        if w878 <= w743 then
            w741 = w741 + 1
            
            w806(w882.x, w882.y)
            if w741 >= #w740 then w740 = nil return end
            return
        end
        do
            local w883= false
            if w749 and w750 then
                local w790, w791, w792= w750.x, w750.y, w750.z
                local w813= w775(w808, w809, w810, w790, w791, w792)
                if w813 > 1000 then
                    
                end
            end
            if not w883 then
                w842(w843, w786, w882.x, w882.y, w882.z)
            end
        end
    end)
    if not w771 then pcall(client.error_log, "walkbot error: "..tostring(w867)) end
end)

w738.register("paint", function()
    if not w769(w739.ui.misc_walkbot) then return end
    if not w740 or #w740 == 0 then return end
    local w786= entity.get_local_player()
    if not w786 then return end
    local w808, w809, w810= entity.get_origin(w786)
    if not w808 then return end
    local w884, w885, w886= w808, w809, w810
    w886 = w795(w786, w884, w885, w886)
    local w870, w871= renderer.world_to_screen(w884, w885, w886)
    for w811=w741, #w740 do
        local w829= w740[w811]
        if not w829 then break end
        local w887= w795(w786, w829.x, w829.y, w829.z)
        local w787, w788= renderer.world_to_screen(w829.x, w829.y, w887)
        if w787 and w788 and w870 and w871 then
            renderer.line(w870, w871, w787, w788, 255, 180, 0, 200)
            renderer.rectangle(w787-3, w788-3, 6, 6, 255, 80, 0, 200)
        end
        w870, w871 = w787, w788
    end
end)

return true
]]
w207["require/features/paint/aimbot_logs"] = [[local w741= require("require/abc/menu_setup")
local w742= require("require/abc/screen_logger")


local w743= nil
pcall(function() w743 = require('require/abc/callbacks') end)
if not w743 then error("callbacks manager required: require/abc/callbacks") end
local w744= {}
local w745= {}

local function w746()
	local w747= w741.ui.paint_aimbot_logs
	if not w747 then return false end
	local w748= ui.get(w747)
	if type(w748) == "string" then
		return w748 ~= "off"
	end
	return false
end

local function w749()
	local w747= w741.ui.paint_aimbot_logs
	if not w747 then return "gamesense" end
	local w748= ui.get(w747)
	if type(w748) == "table" then
		for w750, w751 in ipairs(w748) do
			if w751 == "gamesense beta" then return "gamesense beta" end
			if w751 == "sodium" then return "sodium" end
			if w751 == "gamesense" then return "gamesense" end
		end
	elseif type(w748) == "string" then
		return w748
	end
	return "gamesense"
end

local w752= require("require/help/enemies")
local w753= require("require/abc/push_logger")
local w754= require("require/help/safe")

local w755, w756= pcall(require, "require/features/misc/collect")


local function w757(w758)
	if not w758 or w758 == 0 then return 0 end
	
	if w755 and w756 then
		local w759, w760= pcall(function()
			return w756.get_goal_feet_yaw(w758) or w756.get_feet_yaw(w758) or w756.get_lower_body_yaw(w758)
		end)
		if w759 and w760 and w760 ~= 0 then return w760 end
	end
	
	local w761, w762, w763, w764= pcall(function() return entity.get_prop(w758, "m_angAbsRotation") end)
	if w761 and w762 then
		if type(w762) == "table" then
			return w762[2] or 0
		else
			return w763 or 0
		end
	end
	
	local w765, w766= pcall(function() return entity.get_prop(w758, "m_flLowerBodyYawTarget") end)
	if w765 and w766 then return w766 end
	return 0
end


local function w767(w758)
	local w759, w768= pcall(function() return _G.player_labels end)
	if not w759 or type(w768) ~= "table" then return nil end
	local w769, w770= pcall(function() return w768[w758] end)
	if not w769 then return nil end
	return w770
end


local function w771()
	local w759, w772, w773, w774= pcall(function() return client.camera_angles() end)
	if not w759 then return nil, nil, nil end
	return w772 or 0, w773 or 0, w774 or 0
end


local function w775(w758)
	if not w758 or w758 == 0 then return nil, nil, nil end
	local w759, w776, w777, w778= pcall(function() return entity.get_prop(w758, "m_angAbsRotation") end)
	if not w759 then return nil, nil, nil end
	
	if type(w776) == "table" then
		return w776[1] or 0, w776[2] or 0, w776[3] or 0
	else
		return w776 or 0, w777 or 0, w778 or 0
	end
end

local function w779(w780)
	local w747= w741.ui.paint_logger
	if not w747 then return false end
	local w748= w754.safe_get(w747)
	if type(w748) == 'table' then
		for w750, w751 in ipairs(w748) do
			if w751 == w780 then return true end
		end
		return false
	elseif type(w748) == 'string' then
		return w748 == w780
	end
	return false
end

local function w781(w782,w783,w773,w772) return string.format("\a%02x%02x%02x%02x", w782 or 255, w783 or 255, w773 or 255, w772 or 255) end
local function w784(w785,w782,w783,w773,w772)
	if not w785 or w785 == "" then return w785 end
	local w786= w781(w782,w783,w773,w772)
	local w787= w781(255,255,255,255)
	local w788= "([-+]?%d+%.?%d*%%?)"
	local w759, w789= pcall(function()
		return (w785:gsub(w788, function(w790)
			return w786 .. w790 .. w787
		end))
	end)
	if w759 and w789 then return w789 end
	return w785
end

local function w791(w785)
	if not w785 then return "" end
	return w785:gsub("([%^%$%(%)%%.%[%]%*%+%-%?])", "%%%1")
end

local function w792(w793,w794,w782,w783,w773,w772)
	if not w793 or w793 == "" then return w793 end
	if not w794 or w794 == "" then
		return w784(w793, w782,w783,w773,w772)
	end
	
	local w795, w796= w793:find(w794, 1, true)
	if not w795 then
		
		return w784(w793, w782,w783,w773,w772)
	end
	local w797= w793:sub(1, w795 - 1)
	local w798= w793:sub(w795, w796)
	local w799= w793:sub(w796 + 1)
	local w800= w784(w797, w782,w783,w773,w772)
	local w801= w784(w799, w782,w783,w773,w772)
	local w786= w781(w782,w783,w773,w772)
	local w787= w781(255,255,255,255)
	local w802= w786 .. w798 .. w787
	return (w800 or "") .. w802 .. (w801 or "")
end
local function w803(w804,w805,w806,w807)
	local w808= w804.target_name or "?"
	local w809= w804.hitgroup_name or "?"
	local w810= (w807 and w807.damage) or w804.damage or 0
	local w811= w804.damage or w810
	local w812= w810 - w811
	local w813
	if w810 == w811 then
		w813 = string.format("%d dmg", w810)
	elseif w812 < 0 then
		w813 = string.format("%d(-%d) dmg", w810, math.abs(w812))
	else
		w813 = string.format("%d(+%d) dmg", w810, w812)
	end
	local w814= (w805 == "gamesense" and w807 and w807.health) or w804.health or 0
	local w794= w807 and w807.reason or ""

	local w815= w804.backtrack_ticks or (w807 and w807.backtrack_ticks) or 0
	if w815 == 0 then
		local w816, w817= pcall(function() return globals.tickcount() end)
		if w816 and w804.tick then
			w815 = math.max(0, w817 - (w804.tick or w817))
		end
	end
	local w818= w804.backtrack or (w807 and w807.backtrack) or 0
	if w818 == 0 and w815 and w815 > 0 then
		local w819, w820= pcall(function() return globals.tickinterval() end)
		local w821= (w819 and w820) or 0
		w818 = math.floor(w815 * w821 * 1000)
	end
	if w818 == 0 and w804.time then
		local w822, w823= pcall(function() return globals.realtime() end)
		if w822 and w823 and w804.time then
			w818 = math.floor((w823 - w804.time) * 1000)
		end
	end
	local w824= w807 and w807.hitchance or w804.hitchance or "hehe"
	local w825= w804.safepoint or false
	local w826= w804.tick or 0
	local w827= w804.time or globals.realtime()
	local w828= w804.move or 0
	local w829= w804.t or 0
	local w830= (w807 and w807.boneyaw) or w757(w804.target) or 0
	local w831= (w807 and w807.resolver) or w767(w804.target) or "?"
	w831 = tostring(w831):lower()
	local w832, w833= w771()
	local w834, w835= w775(w804.target)
	local w836= w804.id or 0
	if w805 == "gamesense beta" then
		if w806 == "hit" then
			return string.format("[+] Hit %s's %s for %s (%d%%) bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				w808, w809, w813, w824, w818, w815,
				w833 or 0, w832 or 0, w835 or 0, w834 or 0, w828, w829, w830)
		else
			return string.format("[-] Missed %s's %s for %s (%d%%) due to %s bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				w808, w809, w813, w824, w794, w818, w815,
				w833 or 0, w832 or 0, w835 or 0, w834 or 0, w828, w829, w830)
		end
	elseif w805 == "gamesense" then
		if w806 == "hit" then
			return string.format("[gamesense] Hit %s's %s for %s (%d%%) (%dhp remaining)",
				w808, w809, w813, w824, w814)
		else
			return string.format("[gamesense] Missed %s's %s for %s (%d%%) reason=%s",
				w808, w809, w813, w824, w794)
		end
	elseif w805 == "sodium" then
		if w806 == "hit" then
			return string.format("hit %s's %s for %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				w808, w809, w813, w824, w818, w831, w830)
		else
			return string.format("missed %s's %s due to %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				w808, w809, w794, w824, w818, w831, w830)
		end
	else
		if w806 == "hit" then
			return string.format("a",
				w808, w809, dmg, w824, w828, w829, w830)
		else
			return string.format("b",
				w808, w809, dmg, w824, w794, w828, w829, w830)
		end
	end
end

w743.register('aim_fire', function(w837)

	if not w746() then return end
	
	w745[w837.id] = {
		id = w837.id,
		target = w837.target,
		target_name = entity.get_player_name(w837.target or 0),
		hitgroup = w837.hitgroup,
		hitgroup_name = w837.hitgroup and ({"head","chest","stomach","left arm","right arm","left leg","right leg"})[w837.hitgroup] or "?",
		damage = w837.damage,
		health = w837.health,
		backtrack = (w837.backtrack or 0) * globals.tickinterval() * 1000,
		backtrack_ticks = w837.backtrack or 0,
		hitchance = w837.hit_chance or 0,
		safepoint = w837.safepoint,
		tick = globals.tickcount(),
		time = globals.realtime(),
		move = w837.move or 0,
		t = w837.t or 0,
		boneyaw = w837.boneyaw or w757(w837.target) or 0,
	}
end, { require_login = true, alive_only = true })

w743.register('aim_hit', function(w837)

	if not w746() then return end
	local w838= w745[w837.id]
	if not w838 then return end
	local w805= w749()
	local w839= entity.get_prop(w837.target, "m_iHealth") or 0
	local w830= w838.boneyaw or w757(w838.target)
	local w840= w767(w838.target)
	local w841= w803(w838, w805, "hit", {
		damage=w837.damage,
		health=w839,
		backtrack=w838.backtrack,
		backtrack_ticks=w838.backtrack_ticks,
		boneyaw=w830,
		resolver=w840
	})
	if w805 == "gamesense beta" then
		
		client.color_log(165, 202, 42, w841)
		w742(w841, 4, 165, 202, 42, 255)
	elseif w805 == "sodium" then
		local w842= w838.damage or 0
		local w843= w837.damage or w842
		local w844= w843 - w842
		if w844 == 0 then
			client.color_log(165, 202, 42, w841)
			local w845= w784(w841, 165, 202, 42, 255)
			w742(w845, 4)
		else
			client.color_log(255, 204, 51, w841)

			local w846= string.format("(%+d)", w844)
			local w847= w791(w846)
			local w797, w798, w799= w841:match("^(.-)(" .. w847 .. ")(.*)$")
			if not w797 then
				local w845= w784(w841, 165, 202, 42, 255)
				w742(w845, 4)
			else
				local w848= w784(w797, 165, 202, 42, 255)
				local w849= w784(w799, 165, 202, 42, 255)
				local w850, w851, w852
				if w844 > 0 then
					w850, w851, w852 = 255, 204, 51
				else
					w850, w851, w852 = 217, 100, 100 
				end
				local w786= w781(w850, w851, w852, 255)
				local w787= w781(255, 255, 255, 255)
				local w853= w798:sub(2, -2) or w798
				local w854= "(" .. w786 .. w853 .. w787 .. ")"
				local w845= (w848 or "") .. w854 .. (w849 or "")
				w742(w845, 4)
			end
		end
	else
		client.log(w841)
		w742(w841, 4, 255, 255, 255, 255)
	end

	
	if w779('aimbot') then
		local w808= w838.target_name or "?"
		local w855= w838.hitgroup_name or "?"
		local w856= w837.damage or 0
		local w857= w838.hitchance or 0
		local w858= string.format("Hit %s's %s for %d(%d%%)", w808, w855, w856, w857)
		w753(w858, 4, 255, 255, 255, 255)
	end

	w745[w837.id] = nil
end, { require_login = true, alive_only = true })

w743.register('aim_miss', function(w837)

	if not w746() then return end
	local w838= w745[w837.id]
	if not w838 then return end
	local w805= w749()
	local w830= w838.boneyaw or w757(w838.target)
	local w840= w767(w838.target)
	local w841= w803(w838, w805, "miss", {reason=w837.reason or "?", boneyaw=w830, resolver=w840})
		if w805 == "gamesense beta" then
			client.color_log(217, 100, 100, w841)
			w742(w841, 4, 217, 100, 100, 255)
		elseif w805 == "sodium" then
			
			local w859= w837.reason or "?"
			local w845= w792(w841, w859, 217, 100, 100, 255)
			w742(w845, 4)
			client.color_log(217, 100, 100, w841)
		else
			w742(w841, 4, 255, 255, 255, 255)
			client.log(w841)
		end

	if w779('aimbot') then
		local w808= w838.target_name or "?"
		local w855= w838.hitgroup_name or "?"
		local w856= w838.damage or 0
		local w857= w838.hitchance or 0
		local w794= w837.reason or "?"
		local w858= string.format("Missed %s's %s for %d(%d%%) due to %s", w808, w855, w856, w857, w794)
		w753(w858, 4, 255, 255, 255, 255)
	end

	w745[w837.id] = nil
end, { require_login = true, alive_only = true })]]
w207["require/features/paint/animations"] = [[


local w744= nil
pcall(function() w744 = require('require/help/safe') end)
local w745= nil
pcall(function() w745 = require('require/abc/menu_setup') end)

local w746= nil
pcall(function() w746 = require('require/abc/callbacks') end)
if not w746 then error("callbacks manager required: require/abc/callbacks") end
local w747= require("gamesense/entity") or error("You're missing a required module: gamesense/entity")


local function w748()
    local w749= entity.get_local_player()
    if not w749 then return nil, nil end
    local w750, w751= pcall(function() return w747.new(w749) end)
    if not w750 then return w749, nil end
    return w749, w751
end




local w752= {
    STRAFE_YAW = 0,
    STAND = 1,
    LEAN_YAW = 2,
    SPEED = 3,
    LADDER_YAW = 4,
    LADDER_SPEED = 5,
    JUMP_FALL = 6,
    MOVE_YAW = 7,
    MOVE_BLEND_CROUCH = 8,
    MOVE_BLEND_WALK = 9,
    MOVE_BLEND_RUN = 10,
    BODY_YAW = 11,
    BODY_PITCH = 12,
    AIM_BLEND_STAND_IDLE = 13,
    AIM_BLEND_STAND_WALK = 14,
    AIM_BLEND_STAND_RUN = 14,
    AIM_BLEND_CROUCH_IDLE = 16,
    AIM_BLEND_CROUCH_WALK = 17,
    DEATH_YAW = 18
}

local function w753(w754)
    if not w754 then return 0 end
    local w755, w756, w757= entity.get_prop(w754, 'm_vecVelocity')
    if not w755 or not w756 then
        local w758= w755
        if type(w758) == 'table' then
            w755 = w758.x or w758[1] or 0
            w756 = w758.y or w758[2] or 0
        else
            return 0
        end
    end
    return math.sqrt((w755 or 0) * (w755 or 0) + (w756 or 0) * (w756 or 0))
end

local w759= {}
local w760= {}
for w761, w762 in ipairs({
    { 'AA', 'Other', 'Leg movement' },

}) do
    local w763= {ui.reference(w762[1], w762[2], w762[3])}
    w759[w761] = w763
    for w764, w765 in ipairs(w763) do
        w760[w765] = true
    end
end






local w766= require("gamesense/antiaim_funcs")


local function w767()
    local w749= entity.get_local_player()
    if not w749 then return end
    entity.set_prop(w749, "m_flPoseParameter", 1, w752.JUMP_FALL)
end

local function w768()

    if w766.get_tickbase_shifting() > 0 then
        return
    end
    
    value = 0.5
    local w749= entity.get_local_player()
    if not w749 then return end
    local w769= globals.tickcount()
    local w770= math.floor(w769 / 2) % 2
    local w771= (w770 == 0) and -0.1 or 0.9
    entity.set_prop(w749, "m_flPoseParameter", math.random(0, 10) / value, w752.SPEED)
    entity.set_prop(w749, "m_flPoseParameter", math.random(0, 10) / 10, w752.MOVE_YAW)
    entity.set_prop(w749, "m_flPoseParameter", math.random(0, 10) / 10, w752.JUMP_FALL)
end



local function w772()
    local w749, w773= w748()
    if not w749 or not w773 then return end
    local w774= w773:get_anim_state()
    local w775= w773:get_anim_overlay(12)
    entity.set_prop(w749, "m_flPoseParameter", client.random_float(0, 1), 0)
    w775.weight = client.random_float(0, 1)
    ui.set(w759[1][1], "Always slide")
end

local function w776()
    local w749, w773= w748()
    if not w749 or not w773 then return end
    local w775= w773:get_anim_overlay(12)
    w775.weight = math.random(0,10) / 10
end


local function w777()
    local w749, w773= w748()
    if not w749 or not w773 then return end
    local w774= w773:get_anim_state()
    local w775= w773:get_anim_overlay(12)
    if w775 then w775.weight = 0.999 end
end

local function w778()
    local w749, w773= w748()
    if not w749 or not w773 then return end
    local w774= w773:get_anim_state()
    if w774 and w774.hit_in_ground_animation then
        entity.set_prop(w749, "m_flPoseParameter", 0.5, w752.BODY_PITCH)
    end
end

local function w779()
    local w749, w773= w748()
    if not w749 or not w773 then return end
    local w780= w773:get_anim_overlay(6)
    entity.set_prop(w749, "m_flPoseParameter", 0, w752.MOVE_YAW)
    if w780 then w780.weight = 1 end
end

local function w781()
    local w749, w773= w748()
    if not w749 or not w773 then return end
    local w782= w773:get_anim_overlay(12)
    local w783= w773:get_anim_overlay(6)
    if w782 then w782.weight = 0 end
    if w783 then w783.weight = 1 end
end

local function w784()
    local w749= entity.get_local_player()
    if not w749 then return end
    ui.set(w759[1][1], math.random(1,2) == 1 and "Always slide" or "Never slide")
    entity.set_prop(w749, "m_flPoseParameter", 8, 0)
end


local function w785()
    local w749, w773= w748()
    if not w749 or not w773 then return end
    local w786= w773:get_anim_overlay(9)
    if w786 then
        w786.weight = 1
        w786.sequence = 224
    end
end

local function w787()
    local w749, w773= w748()
    if not w749 or not w773 then return end
    local w788= w773:get_anim_overlay(0)
    if w788 then w788.sequence = 11 end
end

local function w789()

    local w749= w748()
    if not w749 then return end
    entity.set_prop(w749, 'm_flPoseParameter', 0, w752.BODY_PITCH)
    entity.set_prop(w749, 'm_flPoseParameter', math.random(-1, 1), w752.BODY_YAW)

end




w746.register('pre_render', function()
    local w749= entity.get_local_player()
    if not w749 then return end
    local w790= w753(w749)


    local w791= nil
    if w745 and w745.ui and w745.ui.paint_animations then
        if w744 and w744.safe_get then
            w791 = w744.safe_get(w745.ui.paint_animations)
        else
            local w750, w792= pcall(function() return ui.get(w745.ui.paint_animations) end)
            if w750 then w791 = w792 end
        end
    end

    local w793= {}
    if type(w791) == 'table' then
        for w764, w794 in ipairs(w791) do w793[w794] = true end
    end

    if w793['kingaru'] and w790 > 3 then w768() end
    if w793['body lean'] and w790 > 3 then w777() end
    if w793['static legs'] and w790 > 3 then w767() end
    if w793['moonwalk'] and w790 > 3 then w779() end
    if w793['allah'] and w790 > 3 then w781() end
    if w793['no pitch on land'] and w790 > 3 then w778() end
    if w793['reversed legs'] and w790 > 3 then w784() end
    if w793['earthquake'] then w776() end
    if w793['t-pose'] then w787() end
    if w793['blind'] then w785() end
    if w793['pitch up'] then w789() end
    if w793['gamesense legs'] then w772() end
end, { require_login = true, alive_only = true })

w746.register('setup_command', function(w795)

    local w749= entity.get_local_player()
    if not w749 then return end
    local w790= w753(w749)
    if w790 < 3 then return end

    local w791= nil
    if w745 and w745.ui and w745.ui.paint_animations then
        if w744 and w744.safe_get then
            w791 = w744.safe_get(w745.ui.paint_animations)
        else
            local w750, w792= pcall(function() return ui.get(w745.ui.paint_animations) end)
            if w750 then w791 = w792 end
        end
    end

    local w793= {}
    if type(w791) == 'table' then
        for w764, w794 in ipairs(w791) do w793[w794] = true end
    end

    

end, { require_login = true, alive_only = true })]]
w207["require/features/paint/aspect_ratio"] = [[
local w747= require("require/abc/menu_setup")
local w748= require("require/help/time")
local w749= require("require/help/safe")
local w750= require("ffi")
local w751= require("require/brain/dll")
local w752= nil
pcall(function() w752 = require('require/abc/callbacks') end)

if not (w751 and w751.aspect_update) then
    error("sodiumdll aspect_update export missing")
end

local w753= w750.new("struct AspectState[1]")
local w754= w750.new("double[1]")
local w755= w750.new("int[1]")
local w756= w751.aspect_update

local function w757()
    if cvar.r_aspectratio and cvar.r_aspectratio.get_float then
        return cvar.r_aspectratio:get_float()
    end
    return nil
end

local function w758(w759)
    if cvar.r_aspectratio and cvar.r_aspectratio.set_float then
        cvar.r_aspectratio:set_float(w759)
        return true
    elseif client and client.exec then
        client.exec("r_aspectratio " .. tostring(w759))
        return true
    end
    return false
end

w752.register('paint', function()
    if not ui.is_menu_open() then return end
    local w760= w747.ui.paint_aspect_ratio
    if not w760 then return end
    local w761= w749.safe_get(w760)
    if type(w761) ~= 'number' then return end
    w756(w753, w761, w757() or 0, w748.realtime(), w754, w755)
    if w755[0] ~= 0 then
        w758(w754[0])
    end
end, { require_login = true })

client.set_event_callback('shutdown', function()
    w753[0].initialized = 0
    w753[0].original = 0
    w753[0].last = 0
    w753[0].last_update = 0
end)]]
w207["require/features/paint/bomb_esp"] = [[local w750= nil
local w751= {}
local w752= nil
local w753= 500
local w754= 1000

local w755= 1.0
local w756= true
local w757= 0.25 
local w758= 0
local w759= 2

local w760= nil
pcall(function() w760 = require('require/abc/callbacks') end)
if not w760 then error("callbacks manager required: require/abc/callbacks") end

local function w761()
    w750 = nil
end

local function w762(w763)
    if not w763 then return 650, 2275 end
    local w764= tostring(w763):lower()
    if w764:find('de_dust2') then return 500, 1750 end
    if w764:find('de_ancient') then return 650, 2275 end
    if w764:find('de_anubis') then return 450, 1575 end
    if w764:find('de_inferno') then return 620, 2170 end
    if w764:find('de_mirage') then return 650, 2275 end
    if w764:find('de_nuke') then return 650, 2275 end
    if w764:find('de_overpass') then return 650, 2275 end
    if w764:find('de_vertigo') then return 500, 1750 end
    return 650, 2275
end

local function w765(w766,w767)
    w767 = tonumber(w767) or 0
    if w767 > 0 then
        local w768= 0.5
        local w769= 0.5
        local w770= w766 * w768
        local w771= (w766 - w770) * w769
        if w771 > tonumber(w767) then
            w771 = tonumber(w767) * (1.0 / w769)
            w770 = w766 - w771
        end
        w766 = w770
    end
    return w766
end

local function w772(w773,w774,w775,w776,w777,w778,w767,w779)
    if not w773 or not w774 or not w775 or not w776 or not w777 or not w778 then return 0 end
    local w780, w781= w762(w779)
    local w782= w781 / 3.0
    local w783= w773 - w776
    local w784= w774 - w777
    local w785= w775 - w778
    local w786= math.sqrt(w783*w783 + w784*w784 + w785*w785)
    local w787= math.exp( - (w786 * w786) / (2 * w782 * w782) )
    local w766= w780 * w787
    local w788= w765(w766, w767)
    return math.floor(w788 + 0.0)
end

local function w789(w790)
    if not w790 then return "?" end
    if w790 == 454 then return "A" end
    if w790 == 455 then return "B" end
    if w790 == 0 then return "A" end
    if w790 == 1 then return "B" end
    if type(w790) == "string" then
        local w791= w790:upper()
        if w791 == "A" or w791 == "B" then return w791 end
    end
    return tostring(w790)
end

w760.register('bomb_planted', function(w792)
    local w793= w792 and w792.site

    local w794= entity.get_all("CPlantedC4") or {}
    local w795= nil
    local w796= nil

    for w797 = 1, #w794 do
        local w790= w794[w797]
        local w798= entity.get_prop(w790, "m_flC4Blow")
        if w798 and w798 > 0 then
            w795 = w798
            w796 = w790
            break
        end
    end

    if not w795 then
        local w799= 40
        if cvar and cvar.mp_c4timer then
            local w800, w801= pcall(function()
                if type(cvar.mp_c4timer.get_float) == "function" then
                    return cvar.mp_c4timer:get_float()
                elseif type(cvar.mp_c4timer.get_int) == "function" then
                    return cvar.mp_c4timer:get_int()
                else
                    return tonumber(cvar.mp_c4timer:get_string())
                end
            end)
            if w800 and w801 and tonumber(w801) then
                w799 = tonumber(w801)
            end
        end
        w795 = globals.curtime() + (w799 or 40)
    end

    w750 = {
        site = w793,
        blow_time = w795,
        entindex = w796,
        planted_at = globals.curtime()
    }
end, { require_login = true, alive_only = true })

w760.register('bomb_defused', w761, { require_login = true, alive_only = true })
w760.register('bomb_exploded', function(w792)
    
    local w802= w750 ~= nil
    local w803= globals.curtime()
    
    local w804= nil
    local w805= entity.get_local_player()
    if w802 and w805 then
        local function w806()
            
            local w807= nil
            if w750 and w750.entindex then
                local w800, w808, w809, w782= pcall(function() return entity.get_prop(w750.entindex, "m_vecOrigin") end)
                if w800 then
                    if type(w808) == "table" then
                        w807 = w808
                    elseif w808 ~= nil and w809 ~= nil and w782 ~= nil then
                        w807 = { w808, w809, w782 }
                    end
                end
            end
            if not w807 then
                local w794= entity.get_all("CPlantedC4") or {}
                for w797 = 1, #w794 do
                    local w790= w794[w797]
                    local w800, w808, w809, w782= pcall(function() return entity.get_prop(w790, "m_vecOrigin") end)
                    if w800 then
                        if type(w808) == "table" then
                            w807 = w808
                            break
                        elseif w808 ~= nil and w809 ~= nil and w782 ~= nil then
                            w807 = { w808, w809, w782 }
                            break
                        end
                    end
                end
            end
            if not w807 then return nil end
            local w800, w810, w811, w812= pcall(function() return client.eye_position() end)
            local w773, w774, w775
            
            local w813, w814, w815, w816= pcall(function() return entity.get_origin(w805) end)
            if w813 then
                if type(w814) == "table" then
                    if #w814 >= 3 then w773, w774, w775 = w814[1], w814[2], w814[3] end
                elseif w814 ~= nil and w815 ~= nil and w816 ~= nil then
                    w773, w774, w775 = w814, w815, w816
                end
            end
            
            if (not w773 or not w774 or not w775) and w800 and w810 ~= nil and w811 ~= nil and w812 ~= nil then
                w773, w774, w775 = w810, w811, w812
            end
            if not w773 or not w807 or #w807 < 3 then return nil end
            local w776, w777, w778= w807[1], w807[2], w807[3]
            
            local w817, w767= pcall(function() return entity.get_prop(w805, "m_ArmorValue") end)
            w767 = tonumber(w767) or 0
            local w779= nil
            local w818, w819= pcall(function()
                if type(client.mapname) == 'function' then return client.mapname() end
                if cvar and cvar.mapname then return cvar.mapname:get_string() end
                if cvar and cvar.map then return cvar.map:get_string() end
                return nil
            end)
            if w818 then w779 = w819 end
            local w820= w772(w773, w774, w775, w776, w777, w778, w767, w779)
            local w821= math.floor((w820 * (w755 or 1.0)) + 0.5)
            return w820, w821, math.sqrt((w773-w776)^2 + (w774-w777)^2 + (w775-w778)^2)
        end
        local w822, w823, w824= w806()
        w804 = w823
    end

    
    w761()

    
    if w756 and w804 and w804 > 0 then
        local w825= 0.15
        client.delay_call(w825, function()
            local w826= globals.curtime()
            if w826 - w758 < w759 then return end
            local w827= entity.get_local_player()
            if not w827 then return end
            local w800, w828= pcall(function() return entity.get_prop(w827, "m_iHealth") end)
            w828 = tonumber(w828)
            local w829= w752
            if not w829 or not w828 then return end
            local w771= w829 - w828
            if w771 <= 0 then return end

            
            local w830= (w804 and w804 > 0) and w804 or 1
            local w831= w771 / w830
            if w831 <= 0 then return end

            
            local w832= (w755 or 1.0) * (1 + (w831 - 1) * w757)
            if w832 < 0.05 then w832 = 0.05 end
            if w832 > 10 then w832 = 10 end
            local w833= w755
            w755 = w832
            w758 = globals.curtime()
            
            pcall(function()
                client.log("[bomb_esp] auto-tuned scale %.3f -> %.3f (ratio=%.3f, predicted=%d, actual=%d)", w833, w755, w831, w804 or 0, w771)
            end)
        end)
    end
end, { require_login = true, alive_only = true })
w760.register('round_start', w761, { require_login = true, alive_only = true })
w760.register('round_start', function()
    w752 = nil
end, { require_login = true, alive_only = true })
w760.register('player_spawned', function()
    w752 = nil
end, { require_login = true, alive_only = true })


w760.register('player_hurt', function(w792)
    if not w792 then return end
    local w805= entity.get_local_player()
    if not w805 then return end
    local w834= client.userid_to_entindex(w792.userid)
    if w834 ~= w805 then return end

    
    local w835= w792.dmg_health or w792.damage or w792.hp or 0
    w835 = tonumber(w835) or 0
    if w835 <= 0 then return end

    
    local w836= string.format("-%d HP", w835)
    
    table.insert(w751, { t = globals.curtime(), text = w836 })
end, { require_login = true, alive_only = true })


w760.register('paint', function()
    local w837, w838= pcall(require, "require/abc/menu_setup")
    if not w837 or not w838 or not w838.ui then return end
    local w839, w840= pcall(ui.get, w838.ui.paint_bombwarning)
    if not w839 or not w840 then return end

    local w826= globals.curtime()

    
    local w805= entity.get_local_player()
    if w805 then
        local w800, w841= pcall(function() return entity.get_prop(w805, "m_iHealth") end)
        w841 = tonumber(w841)
        if w841 then
            if w752 == nil then
                w752 = w841
            else
                if w841 < w752 then
                    local w835= w752 - w841
                    table.insert(w751, { t = w826, text = string.format("-%d HP", w835) })
                end
                w752 = w841
            end
        end
    else
        w752 = nil
    end

    
    for w797 = #w751, 1, -1 do
        local w842= w751[w797]
        local w843= w826 - w842.t
        local w844= 1.4
        if w843 >= w844 then
            table.remove(w751, w797)
        else
            local w845= math.floor(255 * (1 - (w843 / w844)))
            if w845 < 0 then w845 = 0 end
            
            renderer.indicator(255, 210, 0, w845, w842.text)
        end
    end

    
    if w750 then
        local w805= entity.get_local_player()
        local w807= nil
        if w750.entindex then
            local w800, w808, w809, w782= pcall(function() return entity.get_prop(w750.entindex, "m_vecOrigin") end)
            if w800 then
                if type(w808) == "table" then
                    w807 = w808
                elseif w808 ~= nil and w809 ~= nil and w782 ~= nil then
                    w807 = { w808, w809, w782 }
                end
            end
        end
        
        if not w807 then
            local w794= entity.get_all("CPlantedC4") or {}
            for w797 = 1, #w794 do
                local w790= w794[w797]
                local w800, w808, w809, w782= pcall(function() return entity.get_prop(w790, "m_vecOrigin") end)
                if w800 then
                    if type(w808) == "table" then
                        w807 = w808
                        break
                    elseif w808 ~= nil and w809 ~= nil and w782 ~= nil then
                        w807 = { w808, w809, w782 }
                        break
                    end
                end
            end
        end

        if w807 and w805 then
            local w773, w774, w775= nil, nil, nil
            local w800, w810, w811, w812= pcall(function() return client.eye_position() end)
            if w800 and w810 ~= nil and w811 ~= nil and w812 ~= nil then
                w773, w774, w775 = w810, w811, w812
            else
                local w813, w814, w815, w816= pcall(function() return entity.get_origin(w805) end)
                if w813 then
                    if type(w814) == "table" then
                        if #w814 >= 3 then w773, w774, w775 = w814[1], w814[2], w814[3] end
                    elseif w814 ~= nil and w815 ~= nil and w816 ~= nil then
                        w773, w774, w775 = w814, w815, w816
                    end
                end
            end

            if w773 and w807 and #w807 >= 3 then
                local w776, w777, w778= w807[1], w807[2], w807[3]
                
                local w817, w767= pcall(function() return entity.get_prop(w805, "m_ArmorValue") end)
                w767 = tonumber(w767) or 0
                local w818, w819= pcall(function()
                    if type(client.mapname) == 'function' then return client.mapname() end
                    if cvar and cvar.mapname then return cvar.mapname:get_string() end
                    if cvar and cvar.map then return cvar.map:get_string() end
                    return nil
                end)
                local w779= w818 and w819 or nil
                local w822= w772(w773, w774, w775, w776, w777, w778, w767, w779)
                local w846= math.floor((w822 * (w755 or 1.0)) + 0.5)

                
                renderer.indicator(255, 210, 0, 255, string.format("-%d HP", w846))
            end
        end
    end

    
    if w750 then
        
        if w750.entindex then
            local w798= entity.get_prop(w750.entindex, "m_flC4Blow")
            if w798 and w798 > 0 then
                w750.blow_time = w798
            end
        end

        local w847= (w750.blow_time or 0) - w826
        if w847 <= 0 then
            w750 = nil
            return
        end

        local w848= w789(w750.site)
        local w836= string.format("%s - %.1fs", w848, w847)
        renderer.indicator(255, 255, 255, 255, w836)
    end
end, { require_login = true, alive_only = true })]]
w207["require/features/paint/bullet_tracer"] = [[local w753= require("ffi")
local w754= require('require/help/time')
local w755= nil
local w756= require('require/help/self')
pcall(function() w755 = require('require/help/safe') end)
pcall(function() DLL = require('require/brain/dll') end)
pcall(function() menu_setup = require('require/abc/menu_setup') end)
pcall(function() cb = require('require/abc/callbacks') end)

local w757= 10
local w758= 7.0
local w759= {255,255,255,255}
local w760= 0.05
local w761= 8192

if not (DLL and DLL.tracer_reset and DLL.tracer_push_shot and DLL.tracer_set_impact and DLL.tracer_collect) then return end
DLL.tracer_reset()

local w762= 7
local w763= w753.new("double[?]", w757 * w762)

local w764= w754.realtime

cb.register('weapon_fire', function(w765)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if w756.index() ~= client.userid_to_entindex(w765.userid) then return end
    local w766= w756.weapon()
    if w766 then
        local w767= entity.get_classname(w766) or ""
        local w768= w767:lower()
        if w768:find("knife") or w768:find("grenade") or w768:find("decoy") or w768:find("molotov") or w768:find("flash") or w768:find("smoke") or w768:find("taser") or w768:find("zeus") then
            return
        end
    end

    local w769,w770,w771= client.eye_position()
    if not w769 then w769,w770,w771 = entity.get_origin(w756.index()) end
    w769,w770,w771 = tonumber(w769) or 0, tonumber(w770) or 0, tonumber(w771) or 0
    DLL.tracer_push_shot(w769, w770, w771, w764())
end, { require_login = true, alive_only = true })
 
cb.register('bullet_impact', function(w765)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if w756.index() ~= client.userid_to_entindex(w765.userid) then return end
    local w772,w773,w774= tonumber(w765.x) or 0, tonumber(w765.y) or 0, tonumber(w765.z) or 0
    DLL.tracer_set_impact(w772, w773, w774, w764())
end, { require_login = true, alive_only = true })

if not cb then error("callbacks manager required: require/abc/callbacks") end

cb.register('paint', function()
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    local w775= w764()
    local w776= { client.camera_angles() }
    local w777= w778.tracer_collect(w775, w758, w760, w776[1] or 0, w776[2] or 0, w761, w759[4] or 255, w763, w757)
    for w779=0, (w777 or 0)-1 do
        local w780= w779 * w762
        local w769, w770, w771= w763[w780], w763[w780 + 1], w763[w780 + 2]
        local w781, w782, w783= w763[w780 + 3], w763[w780 + 4], w763[w780 + 5]
        local w784= w763[w780 + 6]
        local w785,w786= renderer.world_to_screen(w769, w770, w771)
        local w787,w788= renderer.world_to_screen(w781, w782, w783)
        if w785 and w787 then
            renderer.line(w785, w786, w787, w788, w759[1], w759[2], w759[3], w784)
        end
    end
end, { require_login = true, alive_only = true })]]
w207["require/features/paint/clantag"] = [[local w756=require("require/abc/menu_setup")
local w757=require("require/help/safe")
local w758=require("require/help/string")
local w759=require("require/help/time")
local w760=require("require/brain/dll")
local w761=require("ffi")
local w762=pcall
local w763=ui.reference
local w764=ui.set
local w765=client.set_clan_tag
local w766, w767= pcall(require, "require/abc/callbacks")
if not w766 or not w767 then error("require/abc/callbacks is required by clantag.lua") end
if not w760 or type(w760) ~= "table" or not w760.clantag_anim then return end

local w768=64
local w769=w761.new("char[?]",w768)
local w770,w771,w772=nil,0,nil
local function w773(w774)
    local w775={{"MISC","Misc","Clantag spammer"},{"MISC","Miscellaneous","Clantag spammer"},{"MISC","Misc","Clan tag spammer"},{"MISC","Miscellaneous","Clan tag spammer"},{"MISC","Misc","Clantag spamer"},{"MISC","Miscellaneous","Clantag spamer"}}
    for w776,w777 in ipairs(w775) do
        local w778,w779=w762(w763,w777[1],w777[2],w777[3])
        if w778 and w779 and w762(w764,w779,w774) then return true end
    end
    return false
end
local w780=function() return w773(true) end
local w781=function() return w773(false) end
w767.register('paint', function()
    local w779=w756.ui.paint_clantag if not w779 then return end
    local w782=w757.safe_get(w779) if type(w782)~='string' then return end
    local w783=w758.lower(w782) if w783==w770 and w783~='sodium' and w771==0 then return end
    if w783=='off' then w781(); w771=3; w762(w765," ")
    elseif w783=='gamesense' then if not w780() then w762(w765,"gamesense") end
    elseif w783 == 'sodium' then
        w781()

        if not w772 or type(w772) ~= 'table' or not w772.start then
            w772 = { start = w759.realtime() }
        end

        local w784= w759.realtime() or 0
        w761.fill(w769, w768, 0)
        local w785= w760.clantag_anim(w772.start or 0, w784, w769, w768)
        if w785 and w785 ~= 0 then
            w762(w765, w761.string(w769))
        else
            w762(w765, "")
        end
    end
    if w771>0 then w762(w765,"") w771=w771-1 end
    w770=w783
end, { require_login = true })]]
w207["require/features/paint/custom_scope"] = [[]]
w207["require/features/paint/damage"] = [[local w762= require("require/abc/menu_setup")
local w763= require("require/brain/api/vector/vector")
local w764= { shots = {}, last = 0 }


local w765= 5
local w766= 3
local w767= 10

local function w768()
	local w769= 0
	for w770 = 1, #w764.shots do
		local w771= w764.shots[w770]
		if w771 and w771.impacts then w769 = w769 + #w771.impacts end
	end
	return w769
end

local function w772()
	while w768() > w767 do
		
		if #w764.shots == 0 then break end
		local w773= false
		for w774 = 1, #w764.shots do
			local w771= w764.shots[w774]
			if w771 and w771.impacts and #w771.impacts > 0 then
				table.remove(w771.impacts, 1)
				w773 = true
				
				if #w771.impacts == 0 then
					table.remove(w764.shots, w774)
				end
				break
			else
				
				table.remove(w764.shots, w774)
				w773 = true
				break
			end
		end
		if not w773 then break end
	end
end

local function w775()
	local w776= w762.ui.paint_hitmarker
	if not w776 then return false end
	local w777= ui.get(w776)
	if type(w777) == "table" then
		for w778, w779 in ipairs(w777) do
			if w779 == "damage" then return true end
		end
	end
	return false
end

local w780, w781= pcall(require, "require/abc/callbacks")
local function w782(w783)
	if not w775() then w764 = { shots = {}, last = 0 } return end
	if not w775() then return end
	local w784= entity.get_local_player()
	if not w784 then return end
	local w785= w783.target or w783.target_index
	if type(w785) ~= 'number' or w785 == 0 or not entity.is_enemy(w785) then return end
	local w786= w783.damage or 0
	local w787= w783.hitgroup == 1
	local w788= w783.health == 0
	local w789, w790, w791= entity.hitbox_position(w785, w783.hitgroup or 'head')
	if not w789 then w789, w790, w791 = entity.get_origin(w785) end
	if not w789 then return end
	local w792= w763.make(w789, w790, w791)
	local w793= globals.realtime()
	local w794= {255, 255, 255}
	if w788 then w794 = {217, 100, 100} elseif w787 then w794 = {165, 202, 42} end

	local w795
	if w764.last and w793 - w764.last < 0.05 then
		w795 = w764.shots[#w764.shots]
	else
		w764.last = w793
		w795 = { impacts = {}, finished = false, t = w793 }
		w764.shots[#w764.shots + 1] = w795
		if #w764.shots > 12 then table.remove(w764.shots, 1) end
	end

	if w795 then
		w795.impacts[#w795.impacts + 1] = { dmg = w786, x = w789, y = w790, z = w791, pos = w792, t = w793, color = w794 }
		if #w795.impacts > w766 then table.remove(w795.impacts, 1) end
		
		w772()
	end
end

local function w796(w783)
	if w775() then
		local w793= globals.realtime()
		local w797= 1.4
		local w798= 32
		local w770= 1
		while w770 <= #w764.shots do
			if w793 - (w764.shots[w770].t or 0) > (w797 + 0.5) then
				table.remove(w764.shots, w770)
			else
				w770 = w770 + 1
			end
		end
		local w799= {}
		local w800= 12
		for w774 = #w764.shots, 1, -1 do
			local w795= w764.shots[w774]
			for w801 = #w795.impacts, 1, -1 do
				table.insert(w799, w795.impacts[w801])
				if #w799 >= w800 then break end
			end
			if #w799 >= w800 then break end
		end

		local w802= math.min(4, #w799)
		for w803 = 1, w802 do
			local w804= w799[w803]
			local w805, w806= renderer.world_to_screen(w804.pos.x, w804.pos.y, w804.pos.z)
			if w805 and w806 then
				local w807= w793 - (w804.t or 0)
				local w808= math.min(1, w807 / w797)
				local w809= w798 * (1 - math.exp(-3 * w808))
				local w810= math.floor(math.max(0, (1 - w808) * 255))
				if w810 > 0 then
					renderer.text(w805, w806 - w809, w804.color[1], w804.color[2], w804.color[3], w810, "crdb-", 0, tostring(w804.dmg))
				end
			end
		end
	else
		w764 = { shots = {}, last = 0 }
	end
end

w781.callback('aim_hit', w782, { alive_only = true, require_login = true })
w781.callback('paint', w796, { alive_only = true, require_login = true })]]
w207["require/features/paint/damage_penetration"] = [[
local function w765(w766,w767)
	if w767 and rawget(_G, w767) ~= nil then
		return rawget(_G, w767)
	end
	local w768, w769= pcall(require, w766)
	if w768 then return w769 end
	return nil
end

local ui= w765('ui', 'ui')
local client= w765('client', 'client')
local entity= w765('entity', 'entity')
local renderer= w765('renderer', 'renderer')

if not ui or not client or not entity or not renderer then
	return
end

local w770= ui.new_checkbox
local w771= ui.get
local w772= ui.reference

local w773= client.screen_size
local w774= client.set_event_callback
local w775= client.unset_event_callback
local w776= client.eye_position
local w777= client.camera_angles
local w778= client.trace_line
local w779= client.trace_bullet

local w780= entity.get_local_player
local w781= entity.is_alive or function() return false end
local w782= entity.get_player_weapon or function() return nil end
local w783= entity.get_classname or function() return nil end

local w784= renderer.text

local w785= math.floor
local w786= math.cos
local w787= math.sin
local w788= math.rad

sodium_SUPPRESS = sodium_SUPPRESS or false
sodium_REFS = sodium_REFS or {}
sodium_FN = sodium_FN or {}

local function w789(w790)
	if not w790 then return false end
	local w768, w791= pcall(w771, w790)
	return w768 and w791 == true
end


if type(sodium_FN.min_dmg_active) ~= 'function' then
	sodium_FN.min_dmg_active = function()
		ensure_min_damage_refs()
		local w792= w793.min_dmg_hotkey
		if w792 then
			local w768, w791= pcall(w771, w792)
			if w768 then return w791 == true end
		end
		return false
	end
end

if type(sodium_FN.min_dmg_value) ~= 'function' then
	sodium_FN.min_dmg_value = function()
		ensure_min_damage_refs()
		local w794= w793.min_dmg_slider
		if not w794 then return nil end
		local w768, w791= pcall(w771, w794)
		if w768 and type(w791) == 'number' then
			return w791
		end
		return nil
	end
end

local function w795(w796,w797)
	if sodium and sodium.ui and sodium.ui[w796] then
		return sodium.ui[w796]
	end
	local w798= 'ui_' .. w796
	if w793[w798] then
		return w793[w798]
	end
	if not w797 then return nil end
	local w790= w797()
	if w790 then
		w793[w798] = w790
	end
	return w790
end


local w799= nil
pcall(function() w799 = require('require/abc/menu_setup') end)


local function w800(w801)
    if not ui.get(w799.ui.paint_show_damage_penetration) then return end
	if not w782 or not w783 then return false end
	local w802= w782(w801)
	if not w802 then return false end
	local w803= w783(w802)
	if not w803 then return false end
	if w803:sub(1, 7) ~= 'CWeapon' then return false end
	if w803:find('Grenade', 1, true) or w803:find('Taser', 1, true) or w803:find('C4', 1, true) then return false end
	return true
end

local function w804()
    if not ui.get(w799.ui.paint_show_damage_penetration) then return end
	if not w780 then return nil end
	local w805= w780()
	if not w805 then return nil end
	if w781 and not w781(w805) then return nil end
	return w805
end




local function w806()
    if not ui.get(w799.ui.paint_show_damage_penetration) then return end
	local w805= w804()
	if not w805 or not w800(w805) then return end
	local w807, w808, w809= w776()
	if not w807 or not w808 or not w809 then return end
	local w810, w811= w777()
	if not w810 or not w811 then return end
	local w812, w813= w786(w788(w810)), w787(w788(w810))
	local w814, w815= w786(w788(w811)), w787(w788(w811))
	local w816, w817, w818= w812 * w814, w812 * w815, -w813
	local w819= 8192
	local w820, w821, w822= w807 + w816 * w819, w808 + w817 * w819, w809 + w818 * w819
	local w823= select(1, w778(w805, w807, w808, w809, w820, w821, w822)) or 1
	if w823 < 0 then w823 = 0 end
	if w823 > 1 then w823 = 1 end

	local w824
	if w823 >= 0.999 then
		w824 = { 256, 512, 1024, 2048, 4096 }
	else
		local w825= w819 * w823
		w824 = { w825 + 4, w825 + 16, w825 + 32, w825 + 64, w825 + 128, w825 + 256 }
	end

	local w826= 0
	for w827 = 1, #w824 do
		local w828= w824[w827]
		if w828 > w819 then w828 = w819 end
		local w829, w830, w831= w807 + w816 * w828, w808 + w817 * w828, w809 + w818 * w828
		local w832, w833= w779(w805, w807, w808, w809, w829, w830, w831, true)
		if w833 and w833 > w826 then w826 = w833 end
		if w828 == w819 then break end
	end

	local w834= w785((w826 or 0) + 0.5)
	if w834 <= 0 then return end

	local w835, w836= w773()
	if not w835 or not w836 then return end
	local w837= w835 / 2
	local w838= w836 / 2 + 8
	local w839= tostring(w834)
	local w840= false
	if sodium_FN.draw_surface_text_centered and _G.sodium_FONTS and _G.sodium_FONTS.pen then
		w840 = sodium_FN.draw_surface_text_centered(_G.sodium_FONTS.pen, w837, w838, w839, 177, 194, 89, 255) and true or false
	end
	if not w840 then
		w784(w837, w836 / 2 + 12, 177, 194, 89, 255, 'cb', 0, w839)
	end
end

local function w841()
    if not ui.get(w799.ui.paint_show_damage_penetration) then return end
	if sodium_SUPPRESS then return end
	w806()
end

local w842, w843= pcall(require, "require/abc/callbacks")
if w842 and w843 then
	if _G.sodium_B_MD_DP and type(_G.sodium_B_MD_DP) == 'number' then
		pcall(w843.unregister, _G.sodium_B_MD_DP)
	end

	local function w844()
		if sodium_SUPPRESS then return end
        if not ui.get(w799.ui.paint_show_damage_penetration) then return end
		w806()
	end

	_G.sodium_B_MD_DP = w843.register('paint', w844, { require_login = true, alive_only = true })
else
	if w775 and _G.sodium_B_MD_DP then
		w775('paint', _G.sodium_B_MD_DP)
	end

	_G.sodium_B_MD_DP = w841
	w774('paint', w841)
end]]
w207["require/features/paint/entidx"] = [[local w768= require("require/abc/menu_setup")
local w769= require("require/help/enemies")

local function w770()
	if not ui.get(w768.ui.paint_entidx) then return end

	local w771= w769.get_current_threat and w769.get_current_threat() or client.current_threat and client.current_threat() or nil
	if w771 and w771 ~= 0 then
		local w772= entity.get_player_name(w771)

		renderer.text(70, 120, 255, 0, 0, 255, "b", 0, string.format("entidx%d: %s", w771, w772))
	end
end

local w773, w774= pcall(require, "require/abc/callbacks")
if w773 and w774 and w774.callback then
	w774.callback("paint", w770, { alive_only = true, require_login = true })
else
	client.set_event_callback("paint", w770)
end]]
w207["require/features/paint/filter_console"] = [[


local w771= pcall(require, 'require/abc/menu_setup') and require('require/abc/menu_setup') or nil
local w772= w771 and w771.ui and w771.ui.paint_filter_console or nil

local w773= cvar.con_filter_enable
local w774= cvar.con_filter_text

local w775= { enable = nil, text = nil }

local function w776()
    if w775.enable == nil then
        
        local w777, w778= pcall(function() return w773:get_int() end)
        w775.enable = (w777 and w778) and w778 or nil
    end

    if w775.text == nil then
        local w777, w779= pcall(function() return w774:get_string() end)
        w775.text = (w777 and w779) and w779 or nil
    end
end

local function w780()
    if w775.enable ~= nil then
        pcall(function() w773:set_raw_int(w775.enable) end)
    end

    if w775.text ~= nil then
        pcall(function() w774:set_string(w775.text) end)
    else
        pcall(function() w774:set_string('') end)
    end

    w775.enable = nil
    w775.text = nil
end

local function w781()
    w776()
    pcall(function() w773:set_raw_int(1) end)
    pcall(function() w774:set_string('[gamesense]') end)
end




local function w782()
    if not w772 then
        return false
    end

    
    if type(w772) == 'table' and w772.get then
        local w777, w778= pcall(function() return w772:get() end)
        return w777 and w778 or false
    end

    
    local w777, w778= pcall(function() return ui.get(w772) end)
    return w777 and w778 or false
end

local function w783()
    if not w782() then
        w780()
        return
    end

    w781()
    client.delay_call(1, w783)
end


client.delay_call(0.1, w783)


client.set_event_callback('shutdown', w780)

return {
    
    get_ui_state = w782,
    restore_values = w780,
    apply_filter = w781,
}
]]
w207["require/features/paint/hit_miss_indicator"] = [[local w774=require("require/help/math")
local w775=require("require/help/self")
local w776=require("require/help/safe")
local w777=require("require/abc/menu_setup")

local w778,w779=0,0
local w780=function() return w777 and w777.ui and w776.safe_get(w777.ui.paint_hitmiss_indicator) end
local w781=function() w778,w779=0,0 end

client.set_event_callback("aim_fire", function(w782)
    if not w780() or not w775.is_alive() then return end
    local w783= nil
    if w782.userid then w783 = client.userid_to_entindex(w782.userid) end
    if (not w783 or w783 == 0) and w782.player then w783 = w782.player end
    if w783 == w775.index() then w779 = w779 + 1 end
end)

client.set_event_callback("aim_hit", function(w782)
    if not w780() or not w775.is_alive() then return end
    local w783= nil
    if w782.userid then w783 = client.userid_to_entindex(w782.userid) end
    if (not w783 or w783 == 0) and w782.attacker then w783 = client.userid_to_entindex(w782.attacker) end
    if (not w783 or w783 == 0) and w782.player then w783 = w782.player end
    if w783 == w775.index() then w778 = w778 + 1 end
end)


client.set_event_callback("paint",function()
    if not w780() then return end
    local w784=w779>0 and w774.round(w778/w779*100,1) or 0
    renderer.indicator(255,255,255,255,string.format("%d / %d (%.1f)",w778,w779,w784))
end)
defer(w781)]]
w207["require/features/paint/indicators_bold"] = [[local w777= { 0, 0, 0 }
local w778= { 3, 3, 3 }
local w779= { 6, 6, 6 }

local function w780(w781,w782,w783)
  return w781 + (w782 - w781) * w783
end

local w784, w785= pcall(require, "require/abc/menu_setup")
local w786, w787= pcall(require, "require/help/string")
local function w788(w789)
  if w789 == nil then return "" end
  if w786 and w787 and w787.lower then
    return w787.lower(tostring(w789))
  end
  return tostring(w789)
end
local w790, w791= pcall(require, "require/help/color")
local w792, w793= pcall(require, "require/help/math")
local w794= w790 and w791.rgba_to_hex or function(w795,w796,w782,w781) return string.format("\a%02x%02x%02x%02x", w795 or 0, w796 or 0, w782 or 0, w781 or 255) end

local function w797(w798,w799,w795,w796,w782,w781,w800)
  local w783= globals.realtime() or globals.curtime()
  if not w800 or #w800 == 0 then return "" end
  local w801= {}

  if w798 == 0 then
    local w802= w794(w795,w796,w782,w781)
    for w803=1,#w800 do w801[#w801+1] = w802 .. w800:sub(w803,w803) end
    return table.concat(w801)
  end

  if w798 == 2 then
    local w804= (math.sin(w783 * w799) + 1) * 0.5
    local w805= math.floor(w781 * (0.45 + 0.55 * w804))
    local w802= w794(w795,w796,w782,w805)
    for w803=1,#w800 do w801[#w801+1] = w802 .. w800:sub(w803,w803) end
    return table.concat(w801)
  end

  if w798 == 3 then
    for w803=1,#w800 do
      local w806= math.sin(w783 * w799 - w803 * 0.6)
      local w807= math.max(0, w806)
      local w804= w807 * w807
      local w805= math.floor(w781 * (0.35 + 0.65 * w804))
      w801[#w801+1] = w794(w795,w796,w782,w805) .. w800:sub(w803,w803)
    end
    return table.concat(w801)
  end

  for w803=1,#w800 do
    local w804= (math.sin(w783 * w799 - w803 * 0.35) + 1) * 0.5
    local w805= math.floor(w781 * (0.4 + 0.6 * w804))
    w801[#w801+1] = w794(w795,w796,w782,w805) .. w800:sub(w803,w803)
  end
  return table.concat(w801)
end
local function w808()
  if w784 and w785 and w785.ui and w785.ui.paint_indicators then
    local w809, w810= pcall(ui.get, w785.ui.paint_indicators)
    if w809 and w810 == "bold" then return true end
    return false
  end

  return true
end

local w811, w812= pcall(require, "require/abc/callbacks")
local function w813(w814)
  if not w808() then return end

  local w815, w816= client.screen_size()
  local w817, w818= w815 / 2, w816 / 2

  local w819, w820, w821= 200, 200, 255
  local w822, w823, w824= 255, 255, 255
  local w825= 18

  local w826= { 12, 12 }

  local w827= w818 + 18

  local w828= entity.get_local_player()
  local w829= false
  if w828 then
    local w830= entity.get_prop(w828, "m_bIsScoped")
    w829 = w830 == 1
  end

  local w831= "sodium"
  local w832= "beta"
  local w833= "DT"

  local w834= false
  do
    local w809, w835= pcall(require, "require/help/libs")
    if w809 and w835 and w835.get then
      local w836= w835.get("antiaim_funcs")
      if w836 and w836.get_double_tap then
        local w837, w838= pcall(w836.get_double_tap)
        if w837 and w838 then w834 = true end
      end
    end
  end

  local w839= 1
  if w784 and w785 and w785.ui and w785.ui.paint_indicators_animation then
    local w840, w841= pcall(ui.get, w785.ui.paint_indicators_animation)
    if w840 and type(w841) == 'number' then w839 = w841 end
  end
  local w842= w831 .. " " .. w832
  w842 = w788(w842)
  w831 = w788(w831)
  w832 = w788(w832)
  local w843= renderer.measure_text("b", w842) or 0
  local w844= renderer.measure_text("b", w831) or 0
  local w845= renderer.measure_text("b", w832) or 0
  local w846= renderer.measure_text("b", w833) or 0

  local w847= ""
  do
    local w809, w848= pcall(require, "require/aa/player_condition")
    if w809 and w848 and w848.get then
      local w837, w849= pcall(w848.get)
      if w837 and w849 then
        local w850= {
          legit = "Legit",
          fakelag = "Fakelag",
          walk = "Walk",
          move = "Move",
          stand = "Stand",
          ["duck"] = "Duck",
          ["duck+"] = "Duck+",
          jump = "Jump",
          ["jump+"] = "Jump+"
        }
        w847 = w850[w849] or tostring(w849)
        w847 = w788(w847)
      end
    end
  end

  w833 = w788(w833)
  local w851= renderer.measure_text("b", w847) or 0

  local w852, w853, w854, w855= 200, 200, 255, 255
  do
    local w856= false
    if w784 and w785 and w785.ui and w785.ui.paint_indicator_color then
      local w857, w781, w782, w858, w859= pcall(ui.get, w785.ui.paint_indicator_color)
      if w857 then
        w856 = true
        if type(w781) == 'number' then
          if w790 and w791 and w791.clamp then
            w852 = w791.clamp(w781 or w852)
            w853 = w791.clamp(w782 or w853)
            w854 = w791.clamp(w858 or w854)
            w855 = w791.clamp(w859 or w855)
          else
            w852 = math.floor(w781 or w852)
            w853 = math.floor(w782 or w853)
            w854 = math.floor(w858 or w854)
            w855 = math.floor(w859 or w855)
          end
        elseif type(w781) == 'string' and #w781 == 12 then
          local w809
          w809, w852 = pcall(function() return tonumber(w781:sub(1,3)) end)
          w809, w853 = pcall(function() return tonumber(w781:sub(4,6)) end)
          w809, w854 = pcall(function() return tonumber(w781:sub(7,9)) end)
          w809, w855 = pcall(function() return tonumber(w781:sub(10,12)) end)
          if w790 and w791 and w791.clamp then
            w852 = w791.clamp(w852 or 200)
            w853 = w791.clamp(w853 or 200)
            w854 = w791.clamp(w854 or 255)
            w855 = w791.clamp(w855 or 255)
          else
            w852 = w852 or 200; w853 = w853 or 200; w854 = w854 or 255; w855 = w855 or 255
          end
        end
      end
    end

    if not w856 then
      local w860, w861= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if w860 and w861 then
        local w857, w781, w782, w858, w859= pcall(ui.get, w861)
        if w857 then
          if type(w781) == 'number' then
            if w790 and w791 and w791.clamp then
              w852 = w791.clamp(w781 or w852)
              w853 = w791.clamp(w782 or w853)
              w854 = w791.clamp(w858 or w854)
              w855 = w791.clamp(w859 or w855)
            else
              w852 = math.floor(w781 or w852)
              w853 = math.floor(w782 or w853)
              w854 = math.floor(w858 or w854)
              w855 = math.floor(w859 or w855)
            end
          elseif type(w781) == 'string' and #w781 == 12 then
            local w809
            w809, w852 = pcall(function() return tonumber(w781:sub(1,3)) end)
            w809, w853 = pcall(function() return tonumber(w781:sub(4,6)) end)
            w809, w854 = pcall(function() return tonumber(w781:sub(7,9)) end)
            w809, w855 = pcall(function() return tonumber(w781:sub(10,12)) end)
            if w790 and w791 and w791.clamp then
              w852 = w791.clamp(w852 or 200)
              w853 = w791.clamp(w853 or 200)
              w854 = w791.clamp(w854 or 255)
              w855 = w791.clamp(w855 or 255)
            else
              w852 = w852 or 200; w853 = w853 or 200; w854 = w854 or 255; w855 = w855 or 255
            end
          end
        end
      end
    end
  end

  for w803 = 1, 3 do
    local w862= (w803 == 1) and w843 or ((w803 == 2) and w846 or w851)
    local w863= w778[w803] or 0
    local w864= w829 and (w863 + (w862 / 2)) or 0
    local w799= w779[w803] or 10
    local w865= globals.frametime()
    local w783= 1 - math.exp(-w799 * w865)
    w777[w803] = w780(w777[w803], w864, w783)
  end

  local w866= w817 - (w843 / 2)
  local w867= w866 + (w777[1] or 0)
  renderer.text(w867, w827, 255, 255, 255, 255, "b", 0, w831)
  local w868= renderer.measure_text("b", " ") or 0
  local w869= w867 + (w844 or 0) + w868
  
  local w870= w797(w839, 3.5, w852, w853, w854, w855, w832)
  renderer.text(w869, w827, w852, w853, w854, w855, "b", 0, w870)
  w827 = w827 + (w826[1] or w825)

  local w871= w817 - (w846 / 2)
  local w872= w871 + (w777[2] or 0)
  local w873, w874, w875= 255, 80, 80
  if w834 then w873, w874, w875 = 155, 255, 155 end
  renderer.text(w872, w827, w873, w874, w875, 255, "b", 0, w833)
  w827 = w827 + (w826[2] or w825)

  local w876= w817 - (w851 / 2)
  local w877= w876 + (w777[3] or 0)
  renderer.text(w877, w827, w822, w823, w824, 255, "b", 0, w847)
end

if w811 and w812 and w812.callback then
  w812.callback("paint", w813, { alive_only = true, require_login = true })
end]]
w207["require/features/paint/indicators_small"] = [[local w780= { 0, 0 }
local w781= { 4, 0.8 }
local w782= { 5, 5 }
local w783= 0
local w784= 8

local function w785(w786,w787,w788)
  return w786 + (w787 - w786) * w788
end

local w789, w790= pcall(require, "require/abc/menu_setup")
local w791, w792= pcall(require, "require/help/string")
local w793= require('require/abc/callbacks')
local function w794(w795)
  if w795 == nil then return "" end
  if w791 and w792 and w792.upper then
    return w792.upper(tostring(w795))
  end
  return tostring(w795)
end

local w796, w797= pcall(require, "require/help/color")
local w798, w799= pcall(require, "require/help/math")
local w800= w796 and w797.rgba_to_hex or function(w801,w802,w787,w786) return string.format("\a%02x%02x%02x%02x", w801 or 0, w802 or 0, w787 or 0, w786 or 255) end

local function w803(w804,w805,w801,w802,w787,w786,w806)
  local w788= globals.realtime() or globals.curtime()
  if not w806 or #w806 == 0 then return "" end
  local w807= {}

  if w804 == 0 then
    local w808= w800(w801,w802,w787,w786)
    for w809=1,#w806 do w807[#w807+1] = w808 .. w806:sub(w809,w809) end
    return table.concat(w807)
  end

  if w804 == 2 then
    local w810= (math.sin(w788 * w805) + 1) * 0.5
    local w811= math.floor(w786 * (0.45 + 0.55 * w810))
    local w808= w800(w801,w802,w787,w811)
    for w809=1,#w806 do w807[#w807+1] = w808 .. w806:sub(w809,w809) end
    return table.concat(w807)
  end

  if w804 == 3 then
    for w809=1,#w806 do
      local w812= math.sin(w788 * w805 - w809 * 0.6)
      local w813= math.max(0, w812)
      local w810= w813 * w813
      local w811= math.floor(w786 * (0.35 + 0.65 * w810))
      w807[#w807+1] = w800(w801,w802,w787,w811) .. w806:sub(w809,w809)
    end
    return table.concat(w807)
  end

  for w809=1,#w806 do
    local w810= (math.sin(w788 * w805 - w809 * 0.35) + 1) * 0.5
    local w811= math.floor(w786 * (0.4 + 0.6 * w810))
    w807[#w807+1] = w800(w801,w802,w787,w811) .. w806:sub(w809,w809)
  end
  return table.concat(w807)
end
local function w814()
  if w789 and w790 and w790.ui and w790.ui.paint_indicators then
    local w815, w816= pcall(ui.get, w790.ui.paint_indicators)
    if w815 and w816 == "small" then return true end
    return false
  end

  return true
end



local function w817()
  if not (w789 and w790 and w790.ui) then return true end
  local w818= w790.ui.paint_indicators_bar
  if not w818 then return true end
  local w815, w816= pcall(ui.get, w818)
  if not w815 then return true end
  return not (w816 == false or w816 == nil) 
end

w793.register("paint", function()
  if not entity.is_alive(entity.get_local_player()) then return end
  if not w814() then return end

  local w819, w820= client.screen_size()
  local w821, w822= w819 / 2, w820 / 2

  local w823, w824, w825= 200, 200, 255
  local w826, w827, w828= 255, 255, 255
  local w829= 18

  local w830= { 12, 13 }

  local w831= w822 + 18

  
  local w832= entity.get_local_player()
  local w833= false
  if w832 then
    local w834= entity.get_prop(w832, "m_bIsScoped")
    w833 = w834 == 1
  end

  local w835= "sodium"
  local w836= "beta"
  local w837= "DT"

  local w838= false
  do
    local w815, w839= pcall(require, "require/help/libs")
    if w815 and w839 and w839.get then
      local w840= w839.get("antiaim_funcs")
      if w840 and w840.get_double_tap then
        local w841, w842= pcall(w840.get_double_tap)
        if w841 and w842 then w838 = true end
      end
    end
  end

  local w843= w794(w835)
  local w844= w794(w836)
  w843 = tostring(w843)
  w844 = tostring(w844)
  local w845= renderer.measure_text("b", w843) or 0
  local w846= renderer.measure_text("b", w844) or 0

  w837 = w794(w837)
  local w847= renderer.measure_text("b", w837) or 0

  for w809 = 1, 2 do
    local w848= (w809 == 1) and w845 or w847
    local w849= w781[w809] or 0
    local w850= w833 and (w849 + (w848 / 2)) or 0
    local w805= w782[w809] or 10
    local w851= globals.frametime()
    local w788= 1 - math.exp(-w805 * w851)
    w780[w809] = w785(w780[w809], w850, w788)
  end

  local w852= 4.5
  local w853= w821 - ((w845 + w852 + (w846 or 0)) / 2)
  local w854= w853 + (w780[1] or 0)
  local w855= 22
  local w856= w855 - w852
  local w857= math.floor((w856 + 1) / 2)
  local w858= w856 - w857
  local w859= w857 
  local w860= -w858 

  local w861, w862, w863, w864= w823, w824, w825, 255
  do
    local w865= false
    
    if w789 and w790 and w790.ui and w790.ui.paint_indicator_color then
      local w866, w786, w787, w867, w868= pcall(ui.get, w790.ui.paint_indicator_color)
      if w866 then
        w865 = true
        if type(w786) == 'number' then
          if w796 and w797 and w797.clamp then
            w861 = w797.clamp(w786 or w861)
            w862 = w797.clamp(w787 or w862)
            w863 = w797.clamp(w867 or w863)
            w864 = w797.clamp(w868 or w864)
          else
            w861 = math.floor(w786 or w861)
            w862 = math.floor(w787 or w862)
            w863 = math.floor(w867 or w863)
            w864 = math.floor(w868 or w864)
          end
        elseif type(w786) == 'string' and #w786 == 12 then
          local w815
          w815, w861 = pcall(function() return tonumber(w786:sub(1,3)) end)
          w815, w862 = pcall(function() return tonumber(w786:sub(4,6)) end)
          w815, w863 = pcall(function() return tonumber(w786:sub(7,9)) end)
          w815, w864 = pcall(function() return tonumber(w786:sub(10,12)) end)
          if w796 and w797 and w797.clamp then
            w861 = w797.clamp(w861 or w823)
            w862 = w797.clamp(w862 or w824)
            w863 = w797.clamp(w863 or w825)
            w864 = w797.clamp(w864 or 255)
          else
            w861 = w861 or w823; w862 = w862 or w824; w863 = w863 or w825; w864 = w864 or 255
          end
        end
      end
    end

    
    if not w865 then
      local w869, w818= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if w869 and w818 then
        local w866, w786, w787, w867, w868= pcall(ui.get, w818)
        if w866 then
          if type(w786) == 'number' then
            if w796 and w797 and w797.clamp then
              w861 = w797.clamp(w786 or w861)
              w862 = w797.clamp(w787 or w862)
              w863 = w797.clamp(w867 or w863)
              w864 = w797.clamp(w868 or w864)
            else
              w861 = math.floor(w786 or w861)
              w862 = math.floor(w787 or w862)
              w863 = math.floor(w867 or w863)
              w864 = math.floor(w868 or w864)
            end
          elseif type(w786) == 'string' and #w786 == 12 then
            local w815
            w815, w861 = pcall(function() return tonumber(w786:sub(1,3)) end)
            w815, w862 = pcall(function() return tonumber(w786:sub(4,6)) end)
            w815, w863 = pcall(function() return tonumber(w786:sub(7,9)) end)
            w815, w864 = pcall(function() return tonumber(w786:sub(10,12)) end)
            if w796 and w797 and w797.clamp then
              w861 = w797.clamp(w861 or w823)
              w862 = w797.clamp(w862 or w824)
              w863 = w797.clamp(w863 or w825)
              w864 = w797.clamp(w864 or 255)
            else
              w861 = w861 or w823; w862 = w862 or w824; w863 = w863 or w825; w864 = w864 or 255
            end
          end
        end
      end
    end
  end

  local w870= 1
  if w789 and w790 and w790.ui and w790.ui.paint_indicators_animation then
    local w871, w872= pcall(ui.get, w790.ui.paint_indicators_animation)
    if w871 and type(w872) == 'number' then w870 = w872 end
  end

  local w873= (function()
    local w808= w800(255,255,255,255)
    local w807= {}
    for w809=1,#w843 do w807[#w807+1] = w808 .. w843:sub(w809,w809) end
    return table.concat(w807)
  end)()

  local w874= w803(w870, 3.5, w861, w862, w863, w864, w844)
  local w875= w854 + (w859 or 0)
  local w876= w833 and 3 or 0
  w875 = w875 + w876
  renderer.text(w875, w831, 255,255,255,255, "-", 0, w873)
  local w877= w854 + (w845 or 0) + w852
  local w878= w877 + (w860 or 0) + w876
  renderer.text(w878, w831, w861, w862, w863, w864, "-", 0, w874)

  local w879= false
  if w817() then
    w879 = true
    do
      local w880= (w845 or 0) + w852 + (w846 or 0)
      local w881= 16
      local w882= math.max(8, w880 - w881)
      local w883= w833 and math.floor((w780[1] or 0) * 0.35) or 0
      local w884= w854 + math.floor((w880 - w882) / 2) - 2 + w883
      local w885= 2
      local w886= w831 + math.max(2, (w830[1] or w829) - (w885 + 4)) + 5
      local w887= math.floor((w864 or 255) * 0.7)
      renderer.rectangle(w884 - 1, w886 - 1, w882 + 2, w885 + 2, w861, w862, w863, w887)
      renderer.rectangle(w884, w886, w882, w885, 0, 0, 0, 255)
      local w888= w838 and w882 or 0
      local w889= globals.frametime()
      local w890= 1 - math.exp(-w784 * w889)
      w783 = w785(w783, w888, w890)
      local w891= math.floor(math.max(0, math.min(w783, w882)))
      if w891 > 0 then
        renderer.rectangle(w884, w886, w891, w885, w861, w862, w863, w864)
      end
    end
  end

  
  local w892= (w830[1] or w829)
  local w893= w892
  if not w879 then
    
    w893 = math.max(0, w892 - 7)
  end
  w831 = w831 + w893

  local w894= w821 - (w847 / 2)
  local w895= w894 + (w780[2] or 0)
  local w896, w897, w898= 255, 80, 80
  if w838 then w896, w897, w898 = 155, 255, 155 end
  renderer.text(w895, w831 + 2, w896, w897, w898, 255, "-", 0, w837)
  w831 = w831 + (w830[2] or w829)

end, { alive_only = true, require_login = true })]]
w207["require/features/paint/insults"] = [[local client= client
local entity= entity
local ui= ui

local w783= require("require/abc/menu_setup")
local w784, w785= pcall(require, "require/help/string")
local w786, w787= pcall(require, "require/help/math")
local w788, w789= pcall(require, "require/help/time")

local w790= {
    "buy sodium",
    "sodium is the bestest lua",
    "SODIUMMMM >__<",
    "you just got sodiumed",
    "sodium beta > all other lues",
    "₴ØĐłɄ₥ ₮₳₴₮ɆĐ Vł₵₮ØⱤɎ, ł₮ ₩₳₴ ₴ØɄⱤ",
    "₴ØĐłɄ₥ ₳ⱤⱤ₳₦₲ɆĐ ₮ⱧɆ ₴₮₳Ɽ₴ ₣ØⱤ ₮Ⱨ₳₮ ⱧɆ₳Đ₴ⱧØ₮",
    "₴ØĐłɄ₥ ₴Ⱡł₱₱ɆĐ ł₦ ₳ ฿₳₦₳₦₳ ₱ɆɆⱠ Ø₣ ₣₳₮Ɇ",
    "₴ØĐłɄ₥ ₩Ⱨł₴₱ɆⱤɆĐ ₴Ɇ₵ⱤɆ₮₴ ł₦₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ₥₳₭Ɇ₴ ₣ⱤłɆ₦Đ₴ ₩ł₮Ⱨ Ⱡ₳₲, ₮ⱧɆ₦ ฿Ɇ₮Ɽ₳Ɏ₴ ł₮",
    "₴ØĐłɄ₥ ₣ØⱠĐɆĐ ɎØɄⱤ ₵ØɄⱤ₳₲Ɇ ł₦₮Ø ₳ ₱₳₱ɆⱤ ₱Ⱡ₳₦Ɇ",
    "₴ØĐłɄ₥ ₱₳ł₦₮₴ ł₦ ⱤɆĐ ₩ⱧɆ₦ ł₮ ł₴ ⱧɄ₦₲ⱤɎ",
    "₴ØĐłɄ₥ ł₴ ₴₵ⱧłⱫØ₱ⱧⱤɆ₦ł₵ ฿Ʉ₮ ₵Ⱨ₳Ɽ₥ł₦₲",
    "₴ØĐłɄ₥ ₳₮Ɇ ₥Ɏ ₴₳₦Đ₩ł₵Ⱨ ฿Ʉ₮ ⱠɆ₣₮ ₳ ₮ⱤØ₱ⱧɎ",
    "₴ØĐłɄ₥ ⱧɄ₥₴ ⱠɄⱠⱠ₳฿łɆ₴ ₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ĐØɆ₴ ₮ⱧɆ ₵Ⱨ₳-₵Ⱨ₳ ₩ł₮Ⱨ ɎØɄⱤ ₳ł₥",
    "₴ØĐłɄ₥ ₣ØⱤ₲Ø₮ ₮Ø ฿Ɇ ₱ØⱠł₮Ɇ, ₴ØⱤⱤɎ ₦Ø₮ ₴ØⱤⱤɎ",
    "₴ØĐłɄ₥ ₳₦Đ ł ₴Ⱨ₳ⱤɆ ₮ØØ₮Ⱨ฿ⱤɄ₴ⱧɆ₴ (₥Ɇ₮₳₱ⱧØⱤ)",
    "₴ØĐłɄ₥ ₮Ɏ₱ɆĐ 'ɎØɄ' ł₦ ⱠØ₩ɆⱤ₵₳₴Ɇ ₳₦Đ ₥Ɇ₳₦₮ ł₮",
    "₴ØĐłɄ₥ ₵ØⱠⱠɆ₵₮₴ ₴₥₳ⱠⱠ ₮ⱤØ₱ⱧłɆ₴ (ɎØɄ ł₦₵ⱠɄĐɆĐ)",
    "₴ØĐłɄ₥ ₭ɆɆ₱₴ ⱤɆ₵Ɇł₱₮₴ ₣ØⱤ ɎØɄⱤ ₥ł₴₮₳₭Ɇ₴",
    "₴ØĐłɄ₥ ł₴ ₳ ₲ØØĐ ⱠɄ₳ ₳₦Đ ₳Ⱡ₴Ø ₳ Ⱡł₮₮ⱠɆ ₥₳Đ",
    "₴ØĐłɄ₥, ₮Ⱨ₳₦₭ ₣ØⱤ ₳ⱠⱠ₳Ⱨ ₲ØĐ, Đ₳Đ :)",
    "₴ØĐłɄ₥ ₴Ɇ₦ĐɆⱤ ₲ⱤɆɆ₮ł₦₲ ₣ⱤØ₥ ₭Ʉ฿₳₦",
    "₥łⱠⱠłØ₦₳łⱤɆ ฿ɄɎ₴ ₲ⱧØ₴₮ ツ Ⱨ₳₳₳Ⱨ₳Ⱨ₳",
    "₴ Ø Đ ł Ʉ ₥ ⱠɄ₳ Ⱨ₳₴ ₮ⱧɆ ฿Ɇ₴₮ ⱧɆ₳Đ₴ⱧØ₮₮₮",
    "₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ <3",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ",
    "ł₣ ₣ⱠɎł₦₲ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐØ₦₮ ₭₦Ø₩ł₦₲ ӾĐĐ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₥Ɏ ₳ł₥ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ɆⱤVɆⱤ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ, ฿Ɇ₲ ₮Ø ₱ⱤØ₵Ⱡ₳ł₥",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄ ₵₳₦ ₥₳₮₵Ⱨ Ⱡ₥Ⱨ ł ⱤɆ₵ØĐɆĐ",
    "ł ₱Ⱡ₳₵Ɇ ɎØɄ Ø₦ ₦Ɇ₩ ⱠɆ₣Ɇ₦Đ ⱠɆ₵₮ɆĐ ₥₳₱ ₩ł₮Ⱨ ØĐł₣ł₵ ⱤɆ₵ØĐɆ",
    "♡ ₴ØĐłɄ₥ ł₴ ₥Ɏ ₵Ø₵₭ Ø₣ ⱠɄ₳ ♡",
    "ł ⱤØ₳₴₮ɆĐ ɎØɄ ₴Ø ₣Ʉ₵₭ł₦₲ Ⱨ₳ⱤĐ ɆVɆⱤ ₴ɆⱤɆĐ",
    "ɎØɄ ₮ⱤłɆĐ ₮Ø ₱ⱤɆ₮Ɇ₦Đ, ฿Ʉ₮ ₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ₭łⱠⱠɆĐ ₮Ⱨ₳₮",
    "ɎØɄ ⱠØ₴Ɇ ₮Ø ₥Ɇ ₣ØⱤ ₦ł₵Ɇ ₣ØⱠ₭",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱ØɆ₥",
    "ł ₣Ⱡł₲Ⱨ₮ ɎØɄ Ø₣₣ ₮ⱧɆ ₥₳₱ ₩ł₮Ⱨ ₥Ɏ ₴ɆⱤVɆⱤ ₩ł₣Ɇ",
    "₴ɆⱤł₳Ⱡ ฿ɄⱠⱠɎ Ø₣ ⱠɄ₳ ₳ⱠⱠ Đ₳Ɏ",
    "₥Ɏ ₴ØĐłɄ₥ ฿ⱤɆ₳₭₴ ₥ØⱤɆ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ₴ØĐłɄ₥ ❤",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ, ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₣ⱠɎ ₳ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ, ₮ⱧɆ₦ ₴₮łⱠⱠ ฿Ɇ₳₮ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐłĐ₦’₮ ₭₦Ø₩ł₦₲ ӾĐĐĐ, ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳ ₣₮₩",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ₴Ɇ₦Đ ₲ⱤɆɆ₮ł₦₲₴ ₱₳Ɽ₳ ₳ ₵Ø₦₳ Đ₳ ₮Ʉ₳ ₥₳₮Ɇ",
    "₳ĐĐɆĐ ₮Ⱨł₴ ₮Ø ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₳₦Đ ł₮ ₥₳ĐɆ ł₮ ₴Ø ₥Ʉ₵Ⱨ ฿Ɇ₮₮ɆⱤ",
    "ł ₴₥Ø₭ɆĐ ɎØɄ ɎɆ₴₮ɆⱤĐ₳Ɏ ₩ł₮Ⱨ ₴ØĐłɄ₥, ₮ØĐ₳Ɏ ł ₣ⱠɆӾ ₳₲₳ł₦",
    "₴ØĐłɄ₥ ⱠɄ₳ JɄ₴₮ Ø₩₦ɆĐ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄⱤ ₴₵Ɽł₱₮ ₵₳₦ ₥₳₮₵Ⱨ ₴ØĐłɄ₥? ⱠØⱠ ₦Ø₱Ɇ",
    "ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ ₥ØĐɆ ₳₵₮łV₳₮ɆĐ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ = 100% ₩ł₦ ₲Ʉ₳Ɽ₳₦₮ɆɆĐ",
    "ł ฿ⱤɆ₳₭ ɎØɄⱤ ⱠɄ₳, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₥ł₦Đ, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₴ɆⱤVɆⱤ — ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "(‿ˠ‿)",
    "₣ØⱤ ₲₳₦₲₴₮ɆⱤ ₩Ɇ Ⱨ₳VɆ ₩Ø₦, ₮Ⱨł₴ ₥₳₮₵Ⱨ",
    "https://discord.gg/8nMMVgqdHk",
    "BUY SODIUM NOW!!! ₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ BUY SODIUM NOW!!! AT DISCORD ;;;",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥ ⱠɄ₳ ",
}


local w791= {
    ""
}

pcall(function()
    local w792= nil
    if w788 and w789 and w789.unix_time then
        w792 = math.floor((w789.unix_time() or 0) % (2^31))
    else
        local w793= nil
        pcall(function() w793 = client.timestamp() end)
        if not w793 or w793 == 0 then
            w793 = globals.tickcount() or 0
        end
        w792 = math.floor((w793 or 0) % (2^31))
    end
    math.randomseed(w792)
end)
local w794= 1
local w795= {}
local w796= false

local function w797(w798)
    if client and client.exec then
        pcall(client.exec, w798)
    end
end

local function w799()
    if #w795 == 0 then
        w796 = false
        return
    end

    local w800= table.remove(w795, 1)
    if not w800 or w800 == "" then
        if #w795 > 0 then
            if client and client.delay_call then
                pcall(function() client.delay_call(w794, w799) end)
            else
                w799()
            end
        else
            w796 = false
        end
        return
    end

    local w798= string.format('say "%s"', w800)
    if client and client.delay_call then
        pcall(function()
            client.delay_call(0, function()
                w797(w798)
            end)
        end)
    else
        w797(w798)
    end

    if #w795 > 0 then
        if client and client.delay_call then
            pcall(function() client.delay_call(w794, w799) end)
        else
            w799()
        end
    else
        w796 = false
    end
end

local function w801(w802)
    if not w802 or w802 == "" then return end
    local w803= tostring(w802)
    local w804
    if w784 and w785 and w785.replace then
        w804 = w785.replace(w803, '"', '')
        if w785.trim then w804 = w785.trim(w804) end
    else
        w804 = w803:gsub('"','')
    end

    table.insert(w795, w804)
    if not w796 then
        w796 = true
        if client and client.delay_call then
            pcall(function() client.delay_call(w794, w799) end)
        else
            w799()
        end
    end
end

local function w805(w806)
	if not w783 or not w783.ui or not w783.ui.paint_insults then
		return
	end
	local w807, w808= pcall(ui.get, w783.ui.paint_insults)
	if not w807 or not w808 then return end

	if not w806 then return end
	local w809= w806.userid
	local w810= w806.attacker
	if not w809 or not w810 then return end

	local w811= entity.get_local_player and entity.get_local_player()
	if not w811 or w811 == 0 then return end

	local w812= client.userid_to_entindex and client.userid_to_entindex(w809) or nil
	local w813= client.userid_to_entindex and client.userid_to_entindex(w810) or nil
	if w810 == w809 then return end
	if w813 == w811 and w812 ~= w811 then
        if #w790 > 0 then
            local w814= 1
            if w786 and w787 and w787.random_int then
                w814 = w787.random_int(1, #w790)
            else
                w814 = math.random(1, #w790)
            end
            local w800= w790[w814]
            w801(w800)
        end
		return
	end
	if w812 == w811 and w813 ~= w811 then
        if #w791 > 0 then
            local w814= 1
            if w786 and w787 and w787.random_int then
                w814 = w787.random_int(1, #w791)
            else
                w814 = math.random(1, #w791)
            end
            local w800= w791[w814]
            w801(w800)
        end
		return
	end
end

local w815, w816= pcall(require, "require/abc/callbacks")
if w815 and w816 and w816.callback then
    w816.callback('player_death', w805, { alive_only = true, require_login = true })
end]]
w207["require/features/paint/lagcomp_box"] = [=[


local g_net_data = {}
local g_sim_ticks = {}
local g_esp_data = {}


local menu_setup = require('require/abc/menu_setup')
local DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A = 47, 117, 221, 255


local floor = math.floor

local function length_sqr(x, y, z)
    return (x or 0) * (x or 0) + (y or 0) * (y or 0) + (z or 0) * (z or 0)
end

local function time_to_ticks(seconds)
    local ti = globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return floor((seconds or 0) / ti + 0.5)
end

local function extrapolate(ent, ticks)
    local ti = globals.tickinterval()
    if not ti then return nil end

    local g = (cvar.sv_gravity and cvar.sv_gravity:get_float() or 800) * ti
    local jump = (cvar.sv_jump_impulse and cvar.sv_jump_impulse:get_float() or 301) * ti

    local ox, oy, oz = entity.get_origin(ent)
    if not ox then return nil end

    local vx, vy, vz = entity.get_prop(ent, "m_vecVelocity")
    vx, vy, vz = vx or 0, vy or 0, vz or 0

    local gravity = (vz > 0) and -g or jump

    for i = 1, (ticks or 0) do
        local px, py, pz = ox, oy, oz

        ox = ox + (vx * ti)
        oy = oy + (vy * ti)
        oz = oz + (vz + gravity) * ti

        local frac = select(1, client.trace_line(ent or 0, px, py, pz, ox, oy, oz))
        if frac and frac <= 0.99 then
            return px, py, pz
        end
    end

    return ox, oy, oz
end


local edges = {
    {0, 1}, {1, 2}, {2, 3}, {3, 0}, {5, 6}, {6, 7}, {1, 4}, {4, 8},
    {0, 4}, {1, 5}, {2, 6}, {3, 7}, {5, 8}, {7, 8}, {3, 4}
}


local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
    local me = entity.get_local_player()
    if not me or not entity.is_alive(me) then return end

    
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box then
        local ok, enabled = pcall(ui.get, menu_setup.ui.paint_lagcomp_box)
        if ok and enabled == false then
            return
        end
    end

    
    local players = entity.get_players(true)
    for i = 1, #players do
        local ent = players[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local prev = g_sim_ticks[ent]
            local sim_time = entity.get_prop(ent, 'm_flSimulationTime')
            local ox, oy, oz = entity.get_origin(ent)

            if sim_time and ox then
                local sim_ticks = time_to_ticks(sim_time)

                if prev ~= nil then
                    local delta = sim_ticks - prev.tick
                    if delta < 0 or (delta > 0 and delta <= 64) then
                        local dx, dy, dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
                        local teleport_distance = length_sqr(dx, dy, dz)

                        local ex_ticks = math.max(delta - 1, 0)
                        local ex_x, ex_y, ex_z = extrapolate(ent, ex_ticks)
                        if delta < 0 then
                            g_esp_data[ent] = 1
                        end

                        g_net_data[ent] = {
                            tick = ex_ticks,
                            player = ent,
                            delta = delta,
                            origin = { x = ox, y = oy, z = oz },
                            extrapolated = (ex_x and { x = ex_x, y = ex_y, z = ex_z } or { x = ox, y = oy, z = oz }),
                            lagcomp = teleport_distance > 4096,
                            tickbase = delta < 3
                        }
                    end
                end

                if g_esp_data[ent] == nil then g_esp_data[ent] = 0 end
                g_sim_ticks[ent] = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
            else
                g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
            end
        else
            g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
        end
    end

    
    local r, g, b, a = DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box_color then
        local ok, rr, gg, bb, aa = pcall(ui.get, menu_setup.ui.paint_lagcomp_box_color)
        if ok and rr then
            r, g, b, a = rr, gg, bb, aa
        end
    end
    for ent, data in pairs(g_net_data) do
        if data and data.player and entity.is_alive(data.player) and not entity.is_dormant(data.player) and data.lagcomp then
            local minsx, minsy, minsz = entity.get_prop(data.player, 'm_vecMins')
            local maxsx, maxsy, maxsz = entity.get_prop(data.player, 'm_vecMaxs')
            if not minsx or not maxsx then goto continue_box end

            local ex = data.extrapolated.x
            local ey = data.extrapolated.y
            local ez = data.extrapolated.z

            local min = { x = (minsx or 0) + ex, y = (minsy or 0) + ey, z = (minsz or 0) + ez }
            local max = { x = (maxsx or 0) + ex, y = (maxsy or 0) + ey, z = (maxsz or 0) + ez }

            local points = {
                min,
                { x = min.x, y = max.y, z = min.z },
                { x = max.x, y = max.y, z = min.z },
                { x = max.x, y = min.y, z = min.z },
                { x = min.x, y = min.y, z = max.z },
                { x = min.x, y = max.y, z = max.z },
                max,
                { x = max.x, y = min.y, z = max.z }
            }

            for k, v in pairs(edges) do
                
                if k == 1 then
                    local ox, oy = renderer.world_to_screen(data.origin.x, data.origin.y, data.origin.z)
                    local mx, my = renderer.world_to_screen(min.x, min.y, min.z)
                    if ox and mx then
                        renderer.line(ox, oy, mx, my, r, g, b, 255)
                    end
                end
                local p1 = points[v[1]]
                local p2 = points[v[2]]
                if p1 and p2 then
                    local x1, y1 = renderer.world_to_screen(p1.x, p1.y, p1.z)
                    local x2, y2 = renderer.world_to_screen(p2.x, p2.y, p2.z)
                    if x1 and x2 then
                        renderer.line(x1, y1, x2, y2, r, g, b, 255)
                    end
                end
            end
            ::continue_box::
        end
    end

    
    for i = 1, #players do
        local ent = players[i]
        if not entity.is_alive(ent) or entity.is_dormant(ent) then goto continue_label end

        local x1, y1, x2, y2, alpha = entity.get_bounding_box(ent)
        if alpha == 0 then goto continue_label end

        local palpha = 0
        if g_esp_data[ent] ~= nil and g_esp_data[ent] > 0 then
            g_esp_data[ent] = g_esp_data[ent] - globals.frametime() * 2
            if g_esp_data[ent] < 0 then g_esp_data[ent] = 0 end
            palpha = g_esp_data[ent]
        end

        local tag = ''
        local data = g_net_data[ent]
        if data then
            local tb = data.tickbase
            local lc = data.lagcomp
            if (not tb) or lc then
                palpha = alpha
            end
            tag = tb and 'SHIFTING TICKBASE' or (lc and 'LAG COMP BREAKER' or '')
        end

        
            local name = entity.get_player_name(ent)
            local y_add = (name == '  ' or name == ' ' or name == '' or name == '   ') and 8 or 0
            local mid_x = x1 + (x2 - x1) / 2
            renderer.text(mid_x, y1 - 18 + y_add, 255, 45, 45, floor((palpha or 0) * 255), 'cb', 0, tag)
        

        ::continue_label::
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end

local function round_start_handler(ev)
    g_net_data = {}
    g_sim_ticks = {}
    g_esp_data = {}
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('round_start', round_start_handler, { alive_only = true, require_login = true })
end]=]
w207["require/features/paint/minimum_damage"] = [[local w789= require("require/abc/menu_setup")
local w790= require("require/help/drag")

local w791= {
    minimum_damage = ui.reference("RAGE", "Aimbot", "Minimum damage"),
    minimum_damage_override = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}

local w792= { client.screen_size() }

local w793= nil
do
    local w794, w795= client.screen_size()
    local w796= math.floor((w792[1] or w794 or 0) / 2 + 2)
    local w797= math.floor((w792[2] or w795 or 0) / 2 - 14)
    local w798= 30
    local w799, w800= 10, 18
    w793 = w790.new("minimum_damage_indicator", {
        x = w796 - math.floor(w799 / 2),
        y = w797 - math.floor(w800 / 2),
        w = w799,
        h = w800,
        snap = true,
        snap_threshold = 24,
        require_menu_open = true,
        constraint_center = { cx = w796, cy = w797, radius = w798 },
        default_center = { x = w796, y = w797 },
    })
end

local w801, w802= pcall(require, "require/abc/callbacks")
local function w803(w804)

    if not ui.get(w789.ui.paint_minimum_damage) then return end
    
    local w805= entity.get_local_player()
    if w805 == nil or not entity.is_alive(w805) then return end
    if w793 then
        pcall(function()
            w793:handle()
            w793:draw()
        end)
    end

    

    if ui.get(w791.minimum_damage_override[2]) then
        local w806, w807= w792[1] / 2 + 2, w792[2] / 2 - 14
        if w793 then
            pcall(function()
                w806 = w793.x + math.floor(w793.w / 2)
                w807 = w793.y + math.floor(w793.h / 2)
            end)
        end
        renderer.text(w806, w807, 255, 255, 255, 225, "d", 0, ui.get(w791.minimum_damage_override[3]) .. "")
    end

end

if w801 and w802 and w802.callback then
    w802.callback('paint', w803, { alive_only = true, require_login = true })
end]]
w207["require/features/paint/molotov_particles"] = [[local ui= ui
local client= client
local entity= entity
local renderer= renderer
local globals= globals
local w792= require("require/abc/menu_setup")
local w793= require('require/brain/api/vector/vector')
local w794= require('require/abc/callbacks')


local w795= {}


local w796= w793.make(0, 0, 0)
local w797= w793.make(0, 0, 0)

local w798= 128
local w799= 158
local w800= 48


local function w801()
    local w802= {}
    local w803= entity.get_all('inferno') or {}
    for w804, w805 in ipairs(w803) do table.insert(w802, w805) end
    local w806= entity.get_all('CInferno') or {}
    for w804, w805 in ipairs(w806) do table.insert(w802, w805) end
    return w802
end


local function w807(w808,w809,w810)
    offsets_templates = offsets_templates or {}
    local w811= tostring(w809) .. ':' .. tostring(w810)
    if offsets_templates[w811] then return offsets_templates[w811] end

    local w812= {}
    local w813= math.pi * (3 - math.sqrt(5))
    for w814 = 1, w809 do
        local w815= w810 * math.sqrt(w814 / w809)
        local w816= w814 * w813
        local w817= math.cos(w816) * w815
        local w818= math.sin(w816) * w815
        local w819= ((w814 % 24) - 12) 
        w812[w814] = {w817, w818, w819}
    end
    offsets_templates[w811] = w812
    return w812
end

w794.register('paint', function()

    local w820= entity.get_local_player()
    if not w820 then return end
    if w792 and w792.ui and w792.ui.paint_molotov then
        local w821, w822= pcall(ui.get, w792.ui.paint_molotov)
        if w821 and not w822 then return end
    end

    local w809= math.max(1, math.floor(w798 or 24))
    local w810= math.max(1, math.floor(w799 or 100))
    local w823= math.max(1, math.floor(w800 or 6))

    
    local w824, w825, w826= client.camera_position()
    w796.x = w824 or 0
    w796.y = w825 or 0
    w796.z = w826 or 0

    local w827= w801()
    if #w827 == 0 then return end

    for w804, w808 in ipairs(w827) do
        local w828, w829, w830= entity.get_origin(w808)
        if w828 then
            local w811= tostring(w808) .. ":" .. tostring(w809) .. ":" .. tostring(w810)
            local w831= w795[w811]

            
            if not w831 or not w831.origin or
               math.abs(w831.origin[1] - w828) > 0.01 or
               math.abs(w831.origin[2] - w829) > 0.01 or
               math.abs(w831.origin[3] - w830) > 0.01 then
                local w812= w807(w808, w809, w810)
                local w832= {}
                for w804, w833 in ipairs(w812) do
                    local w834= w828 + (w833[1] or 0)
                    local w835= w829 + (w833[2] or 0)
                    local w836= w830 + (w833[3] or 0)
                    table.insert(w832, {w834, w835, w836})
                end
                w831 = { origin = {w828, w829, w830}, pts = w832 }
                w795[w811] = w831
            end

            for w804, w837 in ipairs(w831.pts) do
                local w834, w835, w836= w837[1], w837[2], w837[3]
                local w838, w839= renderer.world_to_screen(w834, w835, w836)
                if w838 and w839 then
                    
                    w797.x = w834 - w796.x
                    w797.y = w835 - w796.y
                    w797.z = w836 - w796.z

                    local w840= w797.x
                    local w841= w797.y
                    local w842= w797.z
                    local w843= math.sqrt(w840*w840 + w841*w841 + w842*w842)

                    local w844= math.max(1, math.floor((200 / (w843 + 1)) * (w823 / 6)))
                    local w845= math.max(1, math.floor(w844 / 2))
                    renderer.rectangle(w838 - w845, w839 - w845, w844, w844, 255, 24, 24, 255)
                end
            end
        end
    end
end, { alive_only = true, require_login = true })]]
w207["require/features/paint/onshot_skeleton"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")


local function find(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x, y, z = entity.hitbox_position(ent, def.names[i])
        if x then return x, y, z end
    end
    for i = 1, #(def.idx or {}) do
        local x, y, z = entity.hitbox_position(ent, def.idx[i])
        if x then return x, y, z end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local sk = {list = {}}

local function is_skeleton_enabled()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_hitmarker then
        local ok, sel = pcall(ui.get, menu_setup.ui.paint_hitmarker)
        if not ok then return false end
        if type(sel) == "table" then
            for _, v in ipairs(sel) do
                if v == "skeleton" then return true end
            end
        end
        return false
    end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function aim_fire_handler(ev)
    if not is_skeleton_enabled() then sk.list = {} return end
    if not is_skeleton_enabled() then return end
    local target = ev and (ev.target or ev.target_index)
    if type(target) ~= 'number' or target == 0 then return end
    local pts = snap(target)
    if not pts then return end
    local now = globals.realtime and globals.realtime() or 0
    sk.list[#sk.list + 1] = {pts = pts, t = now}
    if #sk.list > 5 then table.remove(sk.list, 1) end
end

local function paint_handler(ev)
    if is_skeleton_enabled() then
        local now = globals.realtime and globals.realtime() or 0
        local hold = 2.2 * 0.8 * 3
        local fade = 2.2 * 0.8
        local total = hold + fade
        local i = 1
        while i <= #sk.list do
            if now - (sk.list[i].t or 0) > total then
                table.remove(sk.list, i)
            else
                i = i + 1
            end
        end
        table.sort(sk.list, function(a, b) return (a.t or 0) < (b.t or 0) end)
        local start = math.max(1, #sk.list - 2)
        for j = start, #sk.list do
            local it = sk.list[j]
            local age = now - (it.t or 0)
            local alpha = age <= hold and 220 or math.floor(math.max(0, (1 - math.max(0, age - hold) / fade) * 220))
            if alpha > 0 then
                local pts = it.pts or {}
                for c = 1, #chains do
                    local chain = chains[c]
                    local from, to = pts[chain[1]], pts[chain[2]]
                    if from and to then
                        local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                        local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                        if fx and tx then renderer.line(fx, fy, tx, ty, 255, 255, 255, alpha) end
                    end
                end
            end
        end
    else
        sk.list = {}
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('aim_fire', aim_fire_handler, { alive_only = true, require_login = true })
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
else
    client.set_event_callback('aim_fire', aim_fire_handler)
    client.set_event_callback('paint', paint_handler)
end]=]
w207["require/features/paint/performance_mode"] = [[



local w798, w799= pcall(require, "require/abc/menu_setup")


local w800= nil
pcall(function() w800 = require('require/abc/callbacks') end)
if not w800 then error("callbacks manager required: require/abc/callbacks") end


local w801= {
    captured = false
}

local w802= {
    blood = nil,
    ragdolls = nil,
    particles = nil,
    lensflare = nil,
    animations = nil,
    features = nil,
}

local function w803()
    if w801.captured then return end
    local function w804(w805,w806)
        local w798, w807= pcall(client.get_cvar, w805)
        if w798 and w807 then return w807 end
        return w806
    end

    w801.violence_hblood = w804('violence_hblood', '1')
    w801.cl_ragdoll_physics_enable = w804('cl_ragdoll_physics_enable', '1')
    w801.r_drawparticles = w804('r_drawparticles', '1')
    w801.mat_disable_bloom = w804('mat_disable_bloom', '0')
    w801.captured = true
end

local function w808(w805,w809)
    
    pcall(client.exec, string.format('%s %s', w805, tostring(w809)))
end

local function w810(w811,w812)
    if w811 == 'blood' then
        if w812 then w808('violence_hblood', 0) else w808('violence_hblood', w801.violence_hblood or 1) end
    elseif w811 == 'ragdolls' then
        if w812 then w808('cl_ragdoll_physics_enable', 0) else w808('cl_ragdoll_physics_enable', w801.cl_ragdoll_physics_enable or 1) end
    elseif w811 == 'particles' then
        if w812 then w808('r_drawparticles', 0) else w808('r_drawparticles', w801.r_drawparticles or 1) end
    elseif w811 == 'lensflare' then
        if w812 then w808('mat_disable_bloom', 1) else w808('mat_disable_bloom', w801.mat_disable_bloom or 0) end
    end
end

local function w813(w814)
    
    
    if w814['animations'] then
        _G.PERFORMANCE_ANIMATIONS = false
    else
        
        _G.PERFORMANCE_ANIMATIONS = true
    end

    if w814['feature updates'] then
        _G.PERFORMANCE_FEATURE_UPDATES = false
    else
        _G.PERFORMANCE_FEATURE_UPDATES = true
    end
end

local function w815(w816)
    local w817= {}
    if type(w816) == 'table' then
        for w818, w807 in ipairs(w816) do w817[w807] = true end
    end
    return w817
end


w800.register('paint', function()
    if not w798 or not w799 or not w799.ui or not w799.ui.paint_performance_mode then return end
    w803()

    local w819= ui.get(w799.ui.paint_performance_mode)
    local w814= w815(w819)

    
    local w820= w814['blood'] or false
    if w820 ~= w802.blood then
        w810('blood', w820)
        w802.blood = w820
    end

    
    w820 = w814['ragdolls'] or false
    if w820 ~= w802.ragdolls then
        w810('ragdolls', w820)
        w802.ragdolls = w820
    end

    
    w820 = w814['particles'] or false
    if w820 ~= w802.particles then
        w810('particles', w820)
        w802.particles = w820
    end

    
    w820 = w814['lens flare'] or false
    if w820 ~= w802.lensflare then
        w810('lensflare', w820)
        w802.lensflare = w820
    end

    
    w820 = w814['animations'] or false
    if w820 ~= w802.animations then
        
        w813(w814)
        w802.animations = w820
        w802.features = w814['feature updates'] or false
    end

    
    local w821= w814['feature updates'] or false
    if w821 ~= w802.features then
        w813(w814)
        w802.features = w821
    end
end, { require_login = true, alive_only = true })


w800.register('shutdown', function()
    if w801.captured then
        pcall(w808, 'violence_hblood', w801.violence_hblood)
        pcall(w808, 'cl_ragdoll_physics_enable', w801.cl_ragdoll_physics_enable)
        pcall(w808, 'r_drawparticles', w801.r_drawparticles)
        pcall(w808, 'mat_disable_bloom', w801.mat_disable_bloom)
    end
    
    _G.PERFORMANCE_ANIMATIONS = true
    _G.PERFORMANCE_FEATURE_UPDATES = true
end, { require_login = true, alive_only = true })


if _G.PERFORMANCE_ANIMATIONS == nil then _G.PERFORMANCE_ANIMATIONS = true end
if _G.PERFORMANCE_FEATURE_UPDATES == nil then _G.PERFORMANCE_FEATURE_UPDATES = true end

return {
    _internal = {
        orig = w801,
        last_state = w802,
    }
}
]]
w207["require/features/paint/presmoke_warning"] = [[local w801= { start = nil, limit = nil }

client.set_event_callback("round_start", function(w802)
	w801.start = globals.curtime()
	w801.limit = tonumber(w802.timelimit) or tonumber(w802.round_time) or 115
end)

local function w803()
	local w804= entity.get_game_rules()
	if not w804 then return nil end
	local w805= {
		"m_flGameTimeRemaining",
		"m_flRoundTimeRemaining",
		"m_fRoundStartTime",
		"m_flRoundStartTime",
		"m_iRoundTime",
		"m_iRoundTimeLimit",
	}
	for w806, w807 in ipairs(w805) do
		local w808, w809= pcall(entity.get_prop, w804, w807)
		if w808 and w809 and type(w809) == "number" then
			if w807:lower():find("remain") then
				return math.max(0, w809)
			end
		end
	end
	local w810= nil
	for w806, w807 in ipairs({"m_fRoundStartTime", "m_flRoundStartTime"}) do
		local w808, w809= pcall(entity.get_prop, w804, w807)
		if w808 and w809 and type(w809) == "number" then
			w810 = w809
			break
		end
	end
	if w810 then
		local w811= nil
		local w808, w812= pcall(entity.get_prop, w804, "m_iRoundTime")
		if w808 and w812 and type(w812) == "number" then w811 = w812 end
		if not w811 then
			w811 = tonumber(client.get_cvar("mp_roundtime")) or tonumber(client.get_cvar("mp_roundtime_defuse"))
		end
		if w811 and type(w811) == "number" then
			local w813= w811 - (globals.curtime() - w810)
			return math.max(0, w813)
		end
	end
	return nil
end

local function w814()
	if w801.start and w801.limit then
		local w815= globals.curtime() - w801.start
		local w813= w801.limit - w815
		if w813 < 0 then w813 = 0 end
		return w813
	end
	return w803()
end

client.set_event_callback("paint", function()
	local w816, w817= pcall(require, "require/abc/menu_setup")
	if not w816 or not w817 or not w817.ui then return end
	local w818, w819= pcall(ui.get, w817.ui.paint_presmoke)
	if not w818 or not w819 then return end

	local w813= w814()
	if not w813 then return end
	if w813 <= 18 then
		local w820, w821= client.screen_size()
		local w822= w820 * 0.5
		local w823= math.floor(w821 * 0.3)
		local w824= string.format("%.2f", w813)
		local w825= string.format("PRESMOKE NOW PRESMOKE NOW %s", w824)
		renderer.text(w822, w823, 255, 30, 30, 255, "cb+", 0, w825)
	end
end)

client.set_event_callback("round_end", function()
	w801.start = nil
	w801.limit = nil
end)

client.set_event_callback("cs_game_disconnected", function()
	w801.start = nil
	w801.limit = nil
end)

]]
w207["require/features/paint/self_boxes"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end


local ui_extrap_check, ui_extrap_ticks, ui_extrap_color
local ui_pred3d_check
local ui_pred3d_scale
if not (menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation) then
  
  ui_extrap_check = ui.new_checkbox('LUA', 'B', 'Self: Extrapolation Line')
  ui_extrap_ticks = ui.new_slider('LUA', 'B', 'Extrapolation ticks', 1, 64, 6)
  ui_extrap_color = ui.new_color_picker('LUA', 'B', 'Extrapolation color', 255, 200, 0, 220)
  ui_pred3d_check = ui.new_checkbox('LUA', 'B', 'Self: Predicted 3D Box')
  ui_pred3d_scale = ui.new_slider('LUA', 'B', 'Predicted 3D Box Scale %', 0, 200, 20)
end

local function is_self_extrapolation_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation)
    if ok then return val end
  elseif ui_extrap_check then
    local ok, val = pcall(ui.get, ui_extrap_check)
    if ok then return val end
  end
  return false
end

local function get_extrap_ticks()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_ticks then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_ticks)
    if ok then return val end
  elseif ui_extrap_ticks then
    local ok, val = pcall(ui.get, ui_extrap_ticks)
    if ok then return val end
  end
  return 6
end

local function get_extrap_color()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_color then
    local ok, r,g,b,a = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_color)
    if ok then return r,g,b,a end
  elseif ui_extrap_color then
    local ok, r,g,b,a = pcall(ui.get, ui_extrap_color)
    if ok then return r,g,b,a end
  end
  return 255,200,0,220
end

local function is_predicted_3d_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d)
    if ok then return val end
  elseif ui_pred3d_check then
    local ok, val = pcall(ui.get, ui_pred3d_check)
    if ok then return val end
  end
  return false
end

local function get_pred3d_scale()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d_scale then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d_scale)
    if ok then return val end
  elseif ui_pred3d_scale then
    local ok, val = pcall(ui.get, ui_pred3d_scale)
    if ok then return val end
  end
  return 20
end

client.set_event_callback('paint',function()
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  
  local _lp_state = client.globals and client.globals.__self_lc_state or nil
  if not _lp_state then
    _lp_state = {}
    client.globals = client.globals or {}
    client.globals.__self_lc_state = _lp_state
  end
  local function length_sqr(x,y,z)
    x = x or 0; y = y or 0; z = z or 0
    return x*x + y*y + z*z
  end
  local function time_to_ticks(seconds)
    local ti = globals.tickinterval and globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return math.floor((seconds or 0) / ti + 0.5)
  end
  local function is_local_breaking_lagcomp()
    local sim_time = entity.get_prop(lp, 'm_flSimulationTime')
    local ox,oy,oz = entity.get_origin(lp)
    if not sim_time or not ox then return false end
    local sim_ticks = time_to_ticks(sim_time)
    local prev = _lp_state.prev
    local breaking = false
    if prev then
      local delta = sim_ticks - prev.tick
      if delta > 0 and delta <= 64 then
        local dx,dy,dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
        local teleport_distance = length_sqr(dx,dy,dz)
        if teleport_distance > 4096 then breaking = true end
      end
    end
    _lp_state.prev = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
    return breaking
  end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end

  
  if is_self_extrapolation_enabled() then
    local ox,oy,oz = entity.get_origin(lp)
    if ox and oy and oz then
      local vx,vy,vz = entity.get_prop(lp, "m_vecVelocity")
      if vx and vy and vz then
        local ticks = get_extrap_ticks() or 6
        local tickint = (globals.tickinterval and globals.tickinterval()) or 0.015625
        local dt = tickint * ticks
        local px,py,pz = ox + vx * dt, oy + vy * dt, oz + vz * dt
        local sx1,sy1 = renderer.world_to_screen(ox,oy,oz)
        local sx2,sy2 = renderer.world_to_screen(px,py,pz)
        if sx1 and sx2 then
          local r,g,b,a = get_extrap_color()
          renderer.line(sx1,sy1,sx2,sy2, r, g, b, a)
          renderer.circle(sx2,sy2, r, g, b, a, 6, 0, 1.0)
          renderer.text(sx2, sy2 - 10, r, g, b, a, 'c+', 0, tostring(ticks) .. 't')
          
          local bx1,by1,bx2,by2,alpha_mult = entity.get_bounding_box(lp)
          if bx1 and alpha_mult and alpha_mult ~= 0 then
            local sx_orig, sy_orig = sx1, sy1
            if sx_orig and sy_orig then
              local dx, dy = sx2 - sx_orig, sy2 - sy_orig
              local bw, bh = (bx2 - bx1), (by2 - by1)
              local pbx, pby = bx1 + dx, by1 + dy
              
              renderer.rectangle(pbx, pby, bw, bh, 255,255,255,40)
              renderer.rectangle(pbx-1, pby-1, bw+2, bh+2, 255,255,255,200)
            end
          end

          
          if is_predicted_3d_enabled() and is_local_breaking_lagcomp() then
            
            local o = {x = ox, y = oy, z = oz}
            local offs = {}
            local keys = {'head','pelvis','l_shoulder','r_shoulder','l_hip','r_hip'}
            for i=1,#keys do
              local def = boxes[keys[i]]
              if def then
                local ok, hx, hy, hz = pcall(function() return find(lp, def) end)
                if ok and hx then
                  table.insert(offs, {x = hx - o.x, y = hy - o.y, z = hz - o.z})
                end
              end
            end
            if #offs > 0 then
              local minx,miny,minz = offs[1].x,offs[1].y,offs[1].z
              local maxx,maxy,maxz = offs[1].x,offs[1].y,offs[1].z
              for i=2,#offs do
                local v = offs[i]
                if v.x < minx then minx = v.x end
                if v.y < miny then miny = v.y end
                if v.z < minz then minz = v.z end
                if v.x > maxx then maxx = v.x end
                if v.y > maxy then maxy = v.y end
                if v.z > maxz then maxz = v.z end
              end
              
              local scale_pct = 105
              local cx = (minx + maxx) * 0.5
              local cy = (miny + maxy) * 0.5
              local cz = (minz + maxz) * 0.5
              local ex = (maxx - minx) * 0.5 * (1 + scale_pct / 100)
              local ey = (maxy - miny) * 0.5 * (1 + scale_pct / 100)
              local ez = (maxz - minz) * 0.5 * (1 + scale_pct / 100)
              minx = cx - ex; maxx = cx + ex
              miny = cy - ey; maxy = cy + ey
              minz = cz - ez; maxz = cz + ez

              
              local corners = {
                {x = px + minx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + maxy, z = pz + maxz},
                {x = px + minx, y = py + maxy, z = pz + maxz},
              }
              
              local sc = {}
              local all_on_screen = true
              for i=1,8 do
                local sx, sy = renderer.world_to_screen(corners[i].x, corners[i].y, corners[i].z)
                if not sx then all_on_screen = false break end
                sc[i] = {x = sx, y = sy}
              end
              if all_on_screen then
                
                local rr,gg,bb,aa = 255,255,255,200
                
                renderer.line(sc[1].x,sc[1].y,sc[2].x,sc[2].y, rr,gg,bb,aa)
                renderer.line(sc[2].x,sc[2].y,sc[3].x,sc[3].y, rr,gg,bb,aa)
                renderer.line(sc[3].x,sc[3].y,sc[4].x,sc[4].y, rr,gg,bb,aa)
                renderer.line(sc[4].x,sc[4].y,sc[1].x,sc[1].y, rr,gg,bb,aa)
                
                renderer.line(sc[5].x,sc[5].y,sc[6].x,sc[6].y, rr,gg,bb,aa)
                renderer.line(sc[6].x,sc[6].y,sc[7].x,sc[7].y, rr,gg,bb,aa)
                renderer.line(sc[7].x,sc[7].y,sc[8].x,sc[8].y, rr,gg,bb,aa)
                renderer.line(sc[8].x,sc[8].y,sc[5].x,sc[5].y, rr,gg,bb,aa)
                
                for i=1,4 do renderer.line(sc[i].x,sc[i].y,sc[i+4].x,sc[i+4].y, rr,gg,bb,aa) end
              end
            end
          end
        end
      end
    end
  end
end)]=]
w207["require/features/paint/self_skeleton"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end
end

if cb_ok and callbacks and callbacks.callback then
  callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end]=]
w207["require/features/paint/skeletons"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}


local time = require("require/help/time")
local enemies = require("require/help/enemies")
local color = require("require/help/color")
local math_help = require("require/help/math")




local function find(ent, def)
    if not ent or not def then return end
    local names = def.names
    if names then
        for i = 1, #names do
            local x, y, z = entity.hitbox_position(ent, names[i])
            if x then return x, y, z end
        end
    end
    local idx = def.idx
    if idx then
        for i = 1, #idx do
            local x, y, z = entity.hitbox_position(ent, idx[i])
            if x then return x, y, z end
        end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    return pts
end


client.set_event_callback("paint", function()
    local enemy_list = entity.get_players(true)
    for i = 1, #enemy_list do
        local ent = enemy_list[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local pts = snap(ent)
            for _, chain in ipairs(chains) do
                local from = pts[chain[1]]
                local to = pts[chain[2]]
                if from and to then
                    local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                    local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                    if fx and fy and tx and ty then
                        renderer.line(fx, fy, tx, ty, 255, 0, 0, 255)
                    end
                end
            end
        end
    end
end)

]=]
w207["require/features/paint/target_info"] = [[local w813= require("require/abc/menu_setup")
local renderer= renderer
local client= client


local w814= nil
local function w815()
	if w814 then return w814 end
	if renderer.load_rgba then
		local w816, w817= pcall(renderer.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if w816 and w817 then w814 = w817 end
	end
	return w814
end




local w818= state or {
	fl_val = math.random(0, 14),
	fl_target = math.random(0, 14),
	by_val = math.random(-58, 58),
	by_target = math.random(-58, 58),
	last_update = client.system_time()
}


local function w819()
	w818.fl_val = math.random(0, 14)
	w818.by_val = math.random(-58, 58)
end



local function w820()
	local w821= client.system_time()
	if w821 - w818.last_update > 1 then
		w818.fl_target = math.random(0, 14)
		w818.by_target = math.random(-58, 58)
		w818.last_update = w821
	end
end

local function w822()
	w818.fl_val = w818.fl_val + (w818.fl_target - w818.fl_val) * 0.08
	w818.by_val = w818.by_val + (w818.by_target - w818.by_val) * 0.08
end

local function w823()
	if not ui.get(w813.ui.paint_target_info) then return end

	w820()
	w822()
	w819() 

	
	local w824, w825= client.screen_size()
	local w826= 170
	local w827= 80
	local w828= 30
	local w829= math.floor(w825 / 2 - w827 / 2)

	
	renderer.rectangle(w828 - 7, w829 - 5, w826 + 14, w827 + 10, 0, 0, 0, 200)
	renderer.rectangle(w828 - 6, w829 - 4, w826 + 12, w827 + 8, 60, 60, 60, 255)
	renderer.rectangle(w828 - 5, w829 - 3, w826 + 10, w827 + 6, 40, 40, 40, 255)
	renderer.rectangle(w828 - 3, w829 - 1, w826 + 6, w827 + 2, 60, 60, 60, 255)
	renderer.rectangle(w828 - 2, w829, w826 + 4, w827, 12, 12, 12, 255)
	renderer.rectangle(w828 - 2, w829, w826 + 4, w827, 32, 32, 32, 255)

	
	local w830= w815()
	if w830 and renderer.texture then
		renderer.texture(w830, w828 - 2, w829, w826 + 4, w827, 255,255,255,60, 'r')
	end

	
	local w831= w829
	local w832= 1
	local w833= math.floor((w826 + 4) / 2)
	local w834= math.ceil((w826 + 4) / 2)
	
	renderer.rectangle(w828 - 2, w831 - 1, w826 + 4, w832 + 2, 0, 0, 0, 255)
	if renderer.gradient then
		renderer.gradient(w828 - 2, w831, w833, w832, 59,175,222,255, 202,70,205,255, true)
		renderer.gradient(w828 - 2 + w833, w831, w834, w832, 202,70,205,255, 204,227,53,255, true)
	end

	
	local w835= w828 + 12
	local w836= w829 + 13  
	local w837= 18
	local w838= w826 - 60 
	local w839= 7 

	
	local w840= math.floor(w818.fl_val + 0.5)
	
	local w841= w839 / 2 - 7
	renderer.text(w835 - 8, w836 + w841, 255,255,255,255, '', 0, "Fake lag")
	local w842= w835 + 42 
	local w843= w836 + 6  
	local w844= 14
	local w845= math.floor(w838 * (w818.fl_val / w844))
	
	local w846= w838 + 2
	local w847= w839 + 2
	local w848= w842 + 1
	local w849= w843 + 1
	local w850= w838 - 2
	local w851= w839 - 2
	renderer.rectangle(w842 - 1, w843 - 1, w846, w847, 0, 0, 0, 255)
	renderer.rectangle(w842, w843, w838, w839, 60, 60, 60, 255)
	renderer.rectangle(w848, w849, math.max(0, math.floor(w850 * (w818.fl_val / w844))), w851, 180, 220, 80, 255)
	local w852= w842 + w845 - 4
	local w853= w843 + w839 / 2
	renderer.circle(w852, w853, 5, 180,220,80,255, 16)
	
	local w854= tostring(w840)
	local w855= w842 + w845 + 8 
	local w856= w843 + w839 + 0 
	renderer.text(w855 + 1, w856 + 1, 0,0,0,255, '-', 0, w854)
	renderer.text(w855, w856, 255,255,255,255, '-', 0, w854)

	
	local w857= math.floor(w818.by_val + 0.5)
	renderer.text(w835 - 8, w836 + w837 + w841, 255,255,255,255, '', 0, "Body yaw")
	local w858= w835 + 42 
	local w859= w836 + w837 + 6  
	local w860= -58
	local w861= 58
	local w862= w861 - w860
	
	local w863= math.floor(w838 * ((w818.by_val - w860) / w862))
	
	local w864= w838 + 2
	local w865= w839 + 2
	local w866= w858 + 1
	local w867= w859 + 1
	local w868= w838 - 2
	local w869= w839 - 2
	renderer.rectangle(w858 - 1, w859 - 1, w864, w865, 0, 0, 0, 255)
	renderer.rectangle(w858, w859, w838, w839, 60, 60, 60, 255)
	
	local w870= w858 + w838 / 2
	local w871= w858 + w863
	if w818.by_val < 0 then
		renderer.rectangle(w871 + 1, w867, w870 - w871, w869, 180, 220, 80, 255)
	else
		renderer.rectangle(w870 + 1, w867, w871 - w870, w869, 180, 220, 80, 255)
	end
	local w872= w871 - 4
	local w873= w859 + w839 / 2
	renderer.circle(w872, w873, 5, 180,220,80,255, 16)
	
	local w874= tostring(w857)
	local w875= w858 + w863
	local w876= w875 + 8 
	local w877= w859 + w839 + 0 
	renderer.text(w876 + 1, w877 + 1, 0,0,0,255, '-', 0, w874)
	renderer.text(w876, w877, 255,255,255,255, '-', 0, w874)

	
	local w878= 22
	local w879= 14

	
	local w880= math.random() > 0.5 and "[Offensive]" or "[Defensive]"
	local w881= w880 == "[Offensive]" and {204,227,53,255} or {202,70,205,255}
	renderer.text(w835 - 8, w836 + w837 * 2 + w841, 255,255,255,255, '', 0, "Double tap")
	local w882= w835 + w838 + 32
	local w883= w836 + w837 * 2 - 2
	renderer.text(w882 + 4, w883 + 2, table.unpack(w881), '', 0, w880)

	
	local w884= math.random() > 0.5 and "[On]" or "[Off]"
	local w885= w884 == "[On]" and {80,255,80,255} or {255,255,80,255}
	renderer.text(w835 - 8, w836 + w837 * 3 + w841, 255,255,255,255, '', 0, "Freestanding")
	local w886= w835 + w838 + 32
	local w887= w836 + w837 * 3 - 2
	renderer.text(w886 + 4, w887 + 2, table.unpack(w885), '', 0, w884)
end

local w888= require("require/abc/callbacks")
w888.callback('paint', w823, { alive_only = true, require_login = true })
]]
w207["require/features/paint/text_watermark"] = [[local w816= require("require/help/string")
local w817= require("require/help/time")
local w818= require("require/help/color")
local w819= w818.rgba_to_hex
local w820= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local w821= nil

local function w822(w823,w824,w825,w826,w827,w828,w829)
    local w830= w817.realtime() or globals.curtime()
    if not w829 or #w829 == 0 then return "" end
    local w831= {}

    if w823 == 0 then
        local w832= w819(w825,w826,w827,w828)
        for w833=1,#w829 do w831[#w831+1] = w832 .. w829:sub(w833,w833) end
        return table.concat(w831)
    end

    if w823 == 2 then
        local w834= (math.sin(w830 * w824) + 1) * 0.5
        local w835= w818.clamp(math.floor(w828 * (0.45 + 0.55 * w834)))
        local w832= w819(w825,w826,w827,w835)
        for w833=1,#w829 do w831[#w831+1] = w832 .. w829:sub(w833,w833) end
        return table.concat(w831)
    end

    if w823 == 3 then
        for w833=1,#w829 do
            local w836= math.sin(w830 * w824 - w833 * 0.6)
            local w837= math.max(0, w836)
            local w834= w837 * w837
            local w835= w818.clamp(math.floor(w828 * (0.35 + 0.65 * w834)))
            w831[#w831+1] = w819(w825,w826,w827,w835) .. w829:sub(w833,w833)
        end
        return table.concat(w831)
    end

    for w833=1,#w829 do
        local w834= (math.sin(w830*w824 - w833*0.35) + 1) * 0.5
        local w835= w818.clamp(math.floor(w828 * (0.4 + 0.6 * w834)))
        w831[#w831+1] = w819(w825,w826,w827,w835) .. w829:sub(w833,w833)
    end
    return table.concat(w831)
end

local w838= {}
local w839= {}
for w833, w840 in ipairs({
    { 'misc', 'settings', 'menu color' },
}) do
    local w841= {ui.reference(w840[1], w840[2], w840[3])}
    w838[w833] = w841
    for w842, w843 in ipairs(w841) do
        w839[w843] = true
    end
end

local w844, w845= pcall(require, "require/abc/callbacks")
local function w846(w847)
    local w848, w849= client.screen_size()
    if not w848 or not w849 then return end
    local w850, w851, w852, w853= 255, 255, 255, 255
    
    local w854= false
    local w855, w856= pcall(require, "require/abc/menu_setup")
    if w855 and w856 and w856.ui and w856.ui.paint_advertisement_color then
        local w857, w828, w827, w858, w859= pcall(ui.get, w856.ui.paint_advertisement_color)
        if w857 then
            w854 = true
            if type(w828) == 'number' then
                w850 = w818.clamp(w828 or w850)
                w851 = w818.clamp(w827 or w851)
                w852 = w818.clamp(w858 or w852)
                w853 = w818.clamp(w859 or w853)
            elseif type(w828) == 'string' and #w828 == 12 then
                local w860
                w860, w850 = pcall(function() return tonumber(w828:sub(1,3)) end)
                w860, w851 = pcall(function() return tonumber(w828:sub(4,6)) end)
                w860, w852 = pcall(function() return tonumber(w828:sub(7,9)) end)
                w860, w853 = pcall(function() return tonumber(w828:sub(10,12)) end)
                w850 = w818.clamp(w850 or 255); w851 = w818.clamp(w851 or 255); w852 = w818.clamp(w852 or 255); w853 = w818.clamp(w853 or 255)
            end
        end
    end

    if not w854 then
        local w857, w828, w827, w858, w859= pcall(ui.get, w838[1][1])
        if w857 then
            if type(w828) == 'number' then
                w850 = w818.clamp(w828 or w850)
                w851 = w818.clamp(w827 or w851)
                w852 = w818.clamp(w858 or w852)
                w853 = w818.clamp(w859 or w853)
            elseif type(w828) == 'string' and #w828 == 12 then
                local w860
                w860, w850 = pcall(function() return tonumber(w828:sub(1,3)) end)
                w860, w851 = pcall(function() return tonumber(w828:sub(4,6)) end)
                w860, w852 = pcall(function() return tonumber(w828:sub(7,9)) end)
                w860, w853 = pcall(function() return tonumber(w828:sub(10,12)) end)
                w850 = w818.clamp(w850 or 255); w851 = w818.clamp(w851 or 255); w852 = w818.clamp(w852 or 255); w853 = w818.clamp(w853 or 255)
            end
        end
    end

    local w855, w856= pcall(require, "require/abc/menu_setup")
    if not w855 or not w856 or not w856.ui then return end
    if not ui.get(w856.ui.paint_advertisement) then return end
    local w830= w817.realtime() or globals.curtime()
    local w861= 0
    local w862= math.floor(200 + 55 * (math.sin(w830*2)+1)/2)
    local w863, w864, w865= "sodium", "[BETA]", 3

    local w866, w867= renderer.measure_text("", w863)
    w866 = w866 or 0; w867 = w867 or 16
    local w868= (renderer.measure_text("", w864) or 0)

    if w820 and not w821 then
        local w869= math.floor(w848/2 - (w866 + w865 + w868)/2)
        local w870= math.floor(w849 - 15)
        w821 = w820.new('sodium_watermark', {
            x = w869,
            y = w870,
            w = w866 + w865 + w868,
            h = w867,
                default_pos = { x = w869, y = w870 },
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
        })
    end

    if w821 then
        w821:handle()
    end

    local w871, w872
    if w821 then
        w871 = w821.x
        w872 = w821.y + w861
    else
        w871 = math.floor(w848/2 - (w866 + w865 + w868)/2)
        w872 = w849 - 15 + w861
    end

    local w873= math.floor(math.max(0, w862 - 140) * 0.6)
    local w874= { {-1,0},{1,0},{0,-1},{0,1} }

    if w821 then w821:draw() end

    for w842,w875 in ipairs(w874) do renderer.text(w871+w875[1], w872+w875[2], 0,0,0, w873, "", 0, w863) end
    renderer.text(w871, w872, 255,255,255, w862, "", 0, w863)

    local w876= 1
    local w877, w878= pcall(require, "require/abc/menu_setup")
    if w877 and w878 and w878.ui and w878.ui.paint_advertisement_animation then
        local w879, w880= pcall(ui.get, w878.ui.paint_advertisement_animation)
        if w879 and type(w880) == 'number' then w876 = w880 end
    end

    local w881= w871 + w866 + w865
    local w882= w822(w876, 3.5, w850, w851, w852, w853, w864)
    renderer.text(w881, w872, w850, w851, w852, w853, "", 0, w882)
end

if w844 and w845 and w845.callback then
    w845.callback('paint', w846, { alive_only = true, require_login = true })
end]]
w207["require/features/paint/third_person_distance"] = [[local w819= require("require/abc/menu_setup")
local w820= require("require/help/time")
local w821= require("require/help/math")
local w822= require("require/help/safe")
local w823= { original = nil, last = nil, last_update = nil }

local function w824()
    if cvar.cam_idealdist and cvar.cam_idealdist.get_float then
        return cvar.cam_idealdist:get_float()
    end
    return nil
end

local function w825(w826)
    if cvar.cam_idealdist and cvar.cam_idealdist.set_float then
        cvar.cam_idealdist:set_float(w826)
        return true
    elseif client and client.exec then
        client.exec("cam_idealdist " .. tostring(w826))
        return true
    end
    return false
end

local w827= require("require/abc/callbacks")
w827.callback('paint', function()
    local w828= w819.ui and w819.ui.paint_third_person_distance
    if not w828 then
        client.log('third_person_distance: menu ref missing')
        return
    end
    local w829= w822.safe_get(w828)
    if type(w829) ~= 'number' then
        client.log('third_person_distance: invalid slider value', tostring(w829))
        return
    end
    local w830= w821.clamp(w829, 29, 180)
    w830 = w821.round(w830, 2)
    if w823.original == nil then
        w823.original = w824()
        if w823.original == nil then
            client.log('third_person_distance: cam_idealdist cvar not available')
        end
    end
    if w823.last == nil then
        w823.last = w824() or w830
    end
    local w831= w820.realtime()
    local w832= w823.last_update or w831
    local w833= w831 - w832
    w823.last_update = w831
    local w834= 300
    local w835= w834 * w833
    if math.abs(w823.last - w830) > 0.01 then
        local w836= w821.clamp(w835 / math.max(math.abs(w830 - w823.last), 0.01), 0, 1)
        w823.last = w821.lerp(w823.last, w830, w836)
        w823.last = w821.round(w823.last, 2)
        w825(w823.last)
    end
end, { require_login = true })]]
w207["require/features/paint/warnings"] = [[local w822, w823= client.screen_size()
local w824, w825= pcall(require, "require/abc/menu_setup")


local function w826()
    
    if not w824 or not w825 or not w825.ui or not w825.ui.paint_warnings then return end
    local w827= ui.get(w825.ui.paint_warnings)
    local w828= false
    if type(w827) == "table" then
        for w829, w830 in ipairs(w827) do
            if w830 == "lethal" then w828 = true break end
        end
    end
    if not w828 then return end

    if entity.get_prop(entity.get_local_player(), 'm_iHealth') and entity.get_prop(entity.get_local_player(), 'm_iHealth') > 0 and entity.get_prop(entity.get_local_player(), 'm_iHealth') < 93 then
        renderer.text(w822 / 2, w823 * 0.3, 255, 0, 0, 255, "c, -", 0, "YOU'RE LETHAL:   " .. entity.get_prop(entity.get_local_player(), 'm_iHealth') .. " HP REMAINING")
    end
    
end

local w831, w832= pcall(require, "require/abc/callbacks")
if w831 and w832 then
    w832.callback('paint', w826, { alive_only = true, require_login = true })
end]]
w207["require/features/paint/watermark_gamesense"] = [[local renderer= renderer
local client= client
local globals= globals
local w825= require('require/help/color')

local w826= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local w827= nil

local function w828()
	local w829= globals and globals.frametime and globals.frametime() or 0.016
	if w829 > 0 then
		return math.floor(1 / w829 + 0.5)
	end
	return 0
end

local w830= nil
local function w831()
	if w830 then return w830 end
	if renderer.load_rgba then
		local w832, w833= pcall(renderer.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if w832 and w833 then w830 = w833 end
	end
	return w830
end

local w834= w825.hex_to_rgba

local w835= {
	green  = "a5ca2aFF",
	red    = "d96464FF",
	yellow = "ccb854FF",
	blue   = "5462ccFF",
	purple = "7054ccFF",
	white  = "ffffffFF",
	grey   = "757575FF",
	black  = "000000FF",
	pink   = "c8a2deFF",
}


local w836= require("require/abc/login_system")
local w837= require("require/abc/menu_setup")
local w838= require("require/help/self")

local w839= require("require/help/time")
local w840= 0
local w841= w839.new(0.25)

local function w842()
	if not w837 or not w837.ui then return end
	
	local w843, w844= pcall(ui.get, w837.ui.paint_watermark)
	if not w843 or not w844 then return end
	
	local w845, w846= pcall(ui.get, w837.ui.paint_watermark_type)
	if not w845 or w846 ~= 0 then return end
	local w847, w848= client and client.screen_size and client.screen_size() or 800, 600

	local w849
	if w836.logged_in then
		local w850= database.read and database.read('cached_credentials')
		if w850 and w850.username then
			w849 = w850.username
		end
	else
		local w851= w836.load_credentials and w836.load_credentials()
		if w851 and w851.username then
			w849 = w851.username
		end
	end
	if not w849 or w849 == "" then
		w849 = w838.player_name and w838.player_name() or "unknown"
	end
	if w839.expired(w841) then
		w840 = w828()
		w839.reset(w841)
	end
	local w852= w840

	local w853= 0
	if w838 and w838.ping then
		local w854= w838.ping()
		if type(w854) == 'number' then w853 = w854 end
	elseif client and client.latency then
		local w854= client.latency()
		if type(w854) == 'number' then w853 = w854 end
	end
	local w855= math.floor((w853 or 0) * 1000 + 0.5)

	local w856= ''
	local w857= {
		{text = "game", style = w856, color = w835.white},
		{text = "sense", style = w856, color = w835.green},
		{text = " ", style = w856, color = w835.white},
		{text = "[beta]", style = w856, color = w835.white},
		{text = " | ", style = w856, color = w835.white},
		{text = w849, style = w856, color = w835.white},
		{text = " | ", style = w856, color = w835.white},
		{text = tostring(w855) .. " ms", style = w856, color = w835.white},
		{text = " | ", style = w856, color = w835.white},
		{text = tostring(w852) .. " fps", style = w856, color = w835.white},
	}

	local w858, w859= 0, 0
	for w860, w861 in ipairs(w857) do
		local w862, w863= renderer.measure_text and renderer.measure_text(w861.style, w861.text) or 0, 13
		w858 = w858 + w862
		if w863 > w859 then w859 = w863 end
	end
	local w864, w865= 5, 2
	local w866= w858 + w864 * 2
	local w867= w859 + w865 * 2
	local w868= w847 - w866 - 16
	local w869= 16

	if w826 and not w827 then
		local w870= w868
		local w871= w869
		w827 = w826.new('gamesense_watermark', {
			x = w870,
			y = w871,
			w = w866,
			h = w867,
			snap = true,
			snap_threshold = 24,
			require_menu_open = true,
			box_color = {255,255,255,100},
			default_pos = { x = w870, y = w871 },
		})
	end

	if w827 then w827:handle() end

	if w827 then
		w868 = w827.x
		w869 = w827.y
	end

	renderer.rectangle(w868 - 7, w869 - 5, w866 + 14, w867 + 10, 0, 0, 0, 200)
	renderer.rectangle(w868 - 6, w869 - 4, w866 + 12, w867 + 8, 60, 60, 60, 255)
	renderer.rectangle(w868 - 5, w869 - 3, w866 + 10, w867 + 6, 40, 40, 40, 255)
	renderer.rectangle(w868 - 3, w869 - 1, w866 + 6, w867 + 2, 60, 60, 60, 255)
	renderer.rectangle(w868 - 2, w869, w866 + 4, w867, 12, 12, 12, 255)
	renderer.rectangle(w868 - 2, w869, w866 + 4, w867, 32, 32, 32, 255)

	local w872= w831()
	if w872 and renderer.texture then
		renderer.texture(w872, w868 - 2, w869, w866 + 4, w867, 255,255,255,60, 'r')
	end

	if renderer.gradient then
		renderer.gradient(w868 - 2, w869, w866 / 2 + 1, 1, 59,175,222,255, 202,70,205,255, true)
		renderer.gradient(w868 - 2 + w866 / 2, w869, w866 / 2 + 4.5, 1, 202,70,205,255, 204,227,53,255, true)
	end

	local w873= w868 + w864
	local w874= w869 + w865
    if w827 then w827:draw() end
	for w860, w861 in ipairs(w857) do
		local w862, w863= renderer.measure_text and renderer.measure_text(w861.style, w861.text) or 0, 13
			local w875,w876,w877,w878= w834(w861.color)
			w875,w876,w877,w878 = w825.normalize(w875,w876,w877,w878)
			renderer.text(w873, w874, w875,w876,w877,w878, w861.style, nil, w861.text)
		w873 = w873 + w862
	end
end

local w879, w880= pcall(require, "require/abc/callbacks")
if w879 and w880 and w880.callback then
	w880.callback('paint', w842, { alive_only = true, require_login = true })
end
]]
w207["require/features/paint/watermark_solus"] = [[local renderer= renderer
local client= client
local w828= require('require/help/color')
local w829, w830= pcall(require, "require/abc/callbacks")
local w831, w832= pcall(require, "require/abc/menu_setup")
local w833, w834= pcall(ui.reference, 'misc', 'settings', 'menu color')
local w835= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local w836= nil
local function w837(w838,w839,w840,w841,w842,w843,w844,w845,w846)
    renderer.rectangle(w838+w842, w839, w840-(w842*2), w841, w843,w844,w845,w846)
    renderer.rectangle(w838, w839+w842, w840, w841-(w842*2), w843,w844,w845,w846)
    renderer.circle(w838+w842, w839+w842, w843,w844,w845,w846, w842, 0, 1)
    renderer.circle(w838+w840-w842, w839+w842, w843,w844,w845,w846, w842, 0, 1)
    renderer.circle(w838+w842, w839+w841-w842, w843,w844,w845,w846, w842, 0, 1)
    renderer.circle(w838+w840-w842, w839+w841-w842, w843,w844,w845,w846, w842, 0, 1)
end

local globals= globals
local w847= 0
local w848= 0
local w849= 0.1

local function w850(w851)
    local w852, w853= pcall(require, w851)
    if w852 then return w853 end
    return nil
end

local function w854()
    if not w831 or not w832 or not w832.ui then return end
    local w855, w856= pcall(ui.get, w832.ui.paint_watermark)
    if not w855 or not w856 then return end
    local w857, w858= pcall(ui.get, w832.ui.paint_watermark_type)
    if not w857 or w858 ~= 1 then return end

    local w859, w860= client.screen_size()
    if not w859 or not w860 then return end

    local w861= "unknown"
    local w862= w850('require/abc/login_system')
    local w863= (pcall(require, 'require/help/self') and require('require/help/self')) or nil
    if w862 then
        if w862.logged_in then
            local w864= database and database.read and database.read('cached_credentials')
            if w864 and w864.username then w861 = w864.username end
        else
            if w862.load_credentials then
                local w865= w862.load_credentials()
                if w865 and w865.username then w861 = w865.username end
            end
        end
    end
    if (not w861 or w861 == "") and w863 and w863.player_name then
        w861 = w863.player_name()
    end

    local w866= w847 or 0
    pcall(function()
        local w867= globals and globals.realtime and globals.realtime() or os.clock()
        if (w867 - (w848 or 0)) >= w849 then
            local w868= globals and globals.frametime and globals.frametime() or 0.016
            if w868 and w868 > 0 then
                w847 = math.floor(1 / w868 + 0.5)
            end
            w848 = w867
        end
        w866 = w847 or w866
    end)

    local w869= 0
    if w863 and w863.ping then
        local w870= w863.ping()
        if type(w870) == 'number' then w869 = math.floor(w870 * 1000 + 0.5) end
    elseif client and client.latency then
        local w870= client.latency()
        if type(w870) == 'number' then w869 = math.floor(w870 * 1000 + 0.5) end
    end

    local w871= {
        { text = "gamesense ", bold = true },
        { text = " | ", bold = false },
        { text = w861 or "unknown", bold = false },
        { text = " | ", bold = false },
        { text = tostring(w869) .. " ms", bold = false },
        { text = " | ", bold = false },
        { text = tostring(w866) .. " fps", bold = false },
    }

    local w872, w873= 0, 0
    for w874, w875 in ipairs(w871) do
        local w840, w841= 0, 13
        if renderer.measure_text then
            local w852, w876, w877= pcall(renderer.measure_text, '', w875.text)
            if w852 and w876 then w840, w841 = w876, w877 or w841 end
        end
        w872 = w872 + (w840 or 0)
        if w841 and w841 > w873 then w873 = w841 end
    end

    local w878, w879= 12, 6
    local w880= w872 + w878 * 2
    local w881= w873 + w879 * 2
    local w882= 18
    local w838= w859 - w880 - w882
    local w839= w882
    local w842= 8
    if w835 and not w836 then
        local w883= w838
        local w884= w839
        w836 = w835.new('solus_watermark', {
            x = w883,
            y = w884,
            w = w880,
            h = w881,
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
            default_pos = { x = w883, y = w884 },
        })
    end

    if w836 then w836:handle() end

    if w836 then
        w838 = w836.x
        w839 = w836.y
    end
    local w885, w886, w887, w888= 255, 140, 0, 255
    do
        
        if w831 and w832 and w832.ui and w832.ui.paint_watermark_color then
            local w889, w890, w891, w892, w893= pcall(ui.get, w832.ui.paint_watermark_color)
            if w889 then
                if type(w890) == 'number' then
                    w885 = w828.clamp(w890 or w885)
                    w886 = w828.clamp(w891 or w886)
                    w887 = w828.clamp(w892 or w887)
                    w888 = w828.clamp(w893 or w888)
                elseif type(w890) == 'string' and #w890 == 12 then
                    local w852
                    w852, w885 = pcall(function() return tonumber(w890:sub(1,3)) end)
                    w852, w886 = pcall(function() return tonumber(w890:sub(4,6)) end)
                    w852, w887 = pcall(function() return tonumber(w890:sub(7,9)) end)
                    w852, w888 = pcall(function() return tonumber(w890:sub(10,12)) end)
                    w885 = w828.clamp(w885 or 255); w886 = w828.clamp(w886 or 140); w887 = w828.clamp(w887 or 0); w888 = w828.clamp(w888 or 255)
                end
                
            else
                
                if w833 and w834 then
                    local w894, w895, w896, w897, w898= pcall(ui.get, w834)
                    if w894 then
                        if type(w895) == 'number' then
                            w885 = w828.clamp(w895 or w885)
                            w886 = w828.clamp(w896 or w886)
                            w887 = w828.clamp(w897 or w887)
                            w888 = w828.clamp(w898 or w888)
                        elseif type(w895) == 'string' and #w895 == 12 then
                            local w852
                            w852, w885 = pcall(function() return tonumber(w895:sub(1,3)) end)
                            w852, w886 = pcall(function() return tonumber(w895:sub(4,6)) end)
                            w852, w887 = pcall(function() return tonumber(w895:sub(7,9)) end)
                            w852, w888 = pcall(function() return tonumber(w895:sub(10,12)) end)
                            w885 = w828.clamp(w885 or 255); w886 = w828.clamp(w886 or 140); w887 = w828.clamp(w887 or 0); w888 = w828.clamp(w888 or 255)
                        end
                    end
                end
            end
        else
            
            if w833 and w834 then
                local w889, w890, w891, w892, w893= pcall(ui.get, w834)
                if w889 then
                    if type(w890) == 'number' then
                        w885 = w828.clamp(w890 or w885)
                        w886 = w828.clamp(w891 or w886)
                        w887 = w828.clamp(w892 or w887)
                        w888 = w828.clamp(w893 or w888)
                    elseif type(w890) == 'string' and #w890 == 12 then
                        local w852
                        w852, w885 = pcall(function() return tonumber(w890:sub(1,3)) end)
                        w852, w886 = pcall(function() return tonumber(w890:sub(4,6)) end)
                        w852, w887 = pcall(function() return tonumber(w890:sub(7,9)) end)
                        w852, w888 = pcall(function() return tonumber(w890:sub(10,12)) end)
                        w885 = w828.clamp(w885 or 255); w886 = w828.clamp(w886 or 140); w887 = w828.clamp(w887 or 0); w888 = w828.clamp(w888 or 255)
                    end
                end
            end
        end
    end

    local function w899(w900,w901,w902,w843,w903,w904,w905)
        local w906= math.rad(w903)
        local w907= math.rad(w904)
        for w908=0,w905 do
            local w909= w908 / w905
            local w846= w906 + (w907 - w906) * w909
            w900[#w900+1] = { w901 + math.cos(w846) * w843, w902 + math.sin(w846) * w843 }
        end
    end

    local function w910(w838,w839,w840,w841,w911,w912)
        local w913= {}
        w912 = w912 or 6
        local w914= w838
        local w915= w838 + w840
        local w916= w839
        local w917= w839 + w841
        local w918= w914 + w911
        local w919= w915 - w911
        local function w920(w921,w922)
            local w923= #w913
            if w923 == 0 then w913[#w913+1] = { w921, w922 }; return end
            local w924= w913[w923]
            if not (math.abs(w924[1] - w921) < 0.001 and math.abs(w924[2] - w922) < 0.001) then
                w913[#w913+1] = { w921, w922 }
            end
        end

        if w919 > w918 then
            for w925 = w918, w919, w912 do w920(w925, w916) end
            
            w920(w919, w916)
        end

        w899(w913, w915 - w911, w916 + w911, w911, -90, 0, 6)

        local w926= w916 + w911
        local w927= w917 - w911
        if w927 > w926 then
            for w928 = w926, w927, w912 do w920(w915, w928) end
            w920(w915, w927)
        end

        w899(w913, w915 - w911, w917 - w911, w911, 0, 90, 6)

        if w919 > w918 then
            for w925 = w919, w918, -w912 do w920(w925, w917) end
            w920(w918, w917)
        end

        w899(w913, w914 + w911, w917 - w911, w911, 90, 180, 6)

        if w927 > w926 then
            for w928 = w927, w926, -w912 do w920(w914, w928) end
            w920(w914, w926)
        end

        w899(w913, w914 + w911, w916 + w911, w911, 180, 270, 6)

        return w913
    end

    local w929= 3
    local w913= w910(w838-1, w839-1, w880+2, w881+2, w842+1, w929)
    local w923= #w913

    if w836 then w836:draw() end

    w837(w838-1, w839-1, w880+2, w881+2, w842+1, 0, 0, 0, 255)
    w837(w838, w839, w880, w881, w842, 0, 0, 0, 200)

    
    if w923 > 2 then
        local w909= (globals and globals.realtime and globals.realtime() or 0)
        local w930= 7
        w930 = w930 * 4
        local w931= w930 / 60
        local w932= math.max(0.5, w931 * w923)
        local w933= math.floor((w909 * w932) % w923)

        local w934= math.max(6, math.floor(w923 * 0.25))

        local w935= w828.clamp(math.floor((w888 or 255) * 1.15))
        for w936 = w934 - 1, 0, -1 do
            local w937= ((w933 + w936) % w923) + 1
            local w938= ((w933 + w936 + 1) % w923) + 1
            local w939= w913[w937]
            local w940= w913[w938]
            if w939 and w940 then
                local w941= 1 - (w936 / w934)
                local w846= w828.clamp(math.floor(w935 * w941))
                renderer.line(w939[1], w939[2], w940[1], w940[2], w885, w886, w887, w846)
            end
        end
    end

    local w942= w838 + w878
    local w943= w839 + math.floor((w881 - w873) / 2)
    for w908, w875 in ipairs(w871) do
        local w840= 0
        if renderer.measure_text then
            local w852, w876= pcall(renderer.measure_text, '', w875.text)
            if w852 and w876 then w840 = w876 end
        end
        local w944= w875.bold and 'b' or ''
        renderer.text(w942, w943, 255,255,255,255, w944, 0, w875.text)
        w942 = w942 + w840
    end
end

if w829 and w830 and w830.callback then
    w830.callback('paint', w854, { alive_only = true, require_login = true })
end

return true]]
w207["require/features/paint/world_hitmarker_plus"] = [[
local w831= require("require/abc/menu_setup")
local w832= {shots = {}, last = 0}
local w833, w834= pcall(require, "require/brain/api/vector/vector")

local function w835()
	local w836= ui.get(w831.ui.paint_hitmarker)
	if type(w836) == "table" then
		for w837, w838 in ipairs(w836) do
			if w838 == "world +" then return true end
		end
	end
	return false
end

local w839, w840= pcall(require, "require/abc/callbacks")
local function w841(w842)
	if not w835() then w832.shots = {} return end
	if not w835() then return end
	local w843= globals.realtime()
	
	if w832.last and w843 - w832.last < 0.05 then return end
	w832.last = w843
	w832.shots[#w832.shots + 1] = {impacts = {}, finished = false, t = w843}
	if #w832.shots > 12 then table.remove(w832.shots, 1) end
end

local function w844(w842)
	if not w835() then w832 = {shots = {}, last = 0} return end
	local w845= entity.get_local_player()
	if not w845 then return end
	local w846= client.userid_to_entindex(w842.userid or 0)
	if w846 ~= w845 then return end
	local w843= globals.realtime()
	local w847
	for w848 = #w832.shots, 1, -1 do
		if not w832.shots[w848].finished and w843 - (w832.shots[w848].t or 0) < 1.2 then
			w847 = w832.shots[w848]
			break
		end
	end
	if not w847 then return end
	local w849, w850, w851= w842.x, w842.y, w842.z
	local w852, w853, w854, w855= pcall(client.eye_position)
	local w856, w857, w858= 0, 0, 0
	if w852 and w853 and w854 and w855 then
		if w833 and w834 and w834.make and w834.normalized and w834.sub then
			local w859= w834.make(w849, w850, w851)
			local w860= w834.make(w853, w854, w855)
			local w861= w834.normalized(w834.sub(w859, w860))
			w856, w857, w858 = w861.x, w861.y, w861.z
		else
			w856 = w849 - w853; w857 = w850 - w854; w858 = w851 - w855
			local w862= math.sqrt(w856*w856 + w857*w857 + w858*w858)
			if w862 > 0 then w856, w857, w858 = w856/w862, w857/w862, w858/w862 end
		end
	end
	local w863= false
	local w864, w865, w866= pcall(client.trace_line, w845, w849 - (w856 or 0) * 1, w850 - (w857 or 0) * 1, w851 - (w858 or 0) * 1, w849 + (w856 or 0) * 1, w850 + (w857 or 0) * 1, w851 + (w858 or 0) * 1)
	if w864 and w866 and w866 > 0 and w866 ~= w845 then
		if entity.is_enemy(w866) then w863 = true end
	end
	local w867, w868, w869, w870
	local w871, w872, w873, w874, w875= pcall(ui.get, w831.ui.paint_hitmarker_color)
	if w871 and w872 then
		w867, w868, w869, w870 = w872 or 0, w873 or 235, w874 or 235, w875 or 255
	else
		w867, w868, w869, w870 = 0, 235, 235, 255
	end
	w847.impacts[#w847.impacts + 1] = {x = w849, y = w850, z = w851, t = w843, r = w867, g = w868, b = w869, a = w870, dir = {w856, w857, w858}, hit = w863}
	
	if #w847.impacts > 5 then table.remove(w847.impacts, 1) end
	if w863 then
		w847.finished = true
	end
end

local function w876(w842)
	if w835() then
		local w843= globals.realtime()
		local w877= 5.5 * 3 * 0.8
		local w878= 0.25 * 0.8
		local w879= w877 + w878
		local w848= 1
		while w848 <= #w832.shots do
			if w843 - (w832.shots[w848].t or 0) > w879 then
				table.remove(w832.shots, w848)
			else
				w848 = w848 + 1
			end
		end
		
		local w880= {}
		local w881= 12
		for w882 = #w832.shots, 1, -1 do
			local w847= w832.shots[w882]
			for w883 = #w847.impacts, 1, -1 do
				table.insert(w880, w847.impacts[w883]) 
				if #w880 >= w881 then break end
			end
			if #w880 >= w881 then break end
		end
		local w884= math.min(4, #w880)
		for w885 = 1, w884 do
			local w886= w880[w885]
			local w887, w888, w889= w886.x, w886.y, w886.z
			if not w886.hit and w886.dir then
				local w853= w886.x + (w886.dir[1] or 0) * 24
				local w854= w886.y + (w886.dir[2] or 0) * 24
				local w855= w886.z + (w886.dir[3] or 0) * 24
				w887, w888, w889 = w853, w854, w855
			end
			local w890, w891= renderer.world_to_screen(w887, w888, w889)
			if w890 and w891 then
				local w892= w843 - (w886.t or 0)
				local w893= w892 <= w877 and 255 or math.floor(math.max(0, (1 - math.max(0, w892 - w877) / w878) * 255))
				if w893 > 0 then
					local w862= 4
					local w894= w886.r or 200
					local w895= w886.g or 200
					local w896= w886.b or 200
					renderer.line(w890 - w862, w891, w890 + w862, w891, w894, w895, w896, w893)
					renderer.line(w890, w891 - w862, w890, w891 + w862, w894, w895, w896, w893)
				end
			end
		end
	else
		w832 = {shots = {}, last = 0}
	end
end

if w839 and w840 and w840.callback then
	w840.callback('aim_fire', w841, { alive_only = true, require_login = true })
	w840.callback('bullet_impact', w844, { alive_only = true, require_login = true })
	w840.callback('paint', w876, { alive_only = true, require_login = true })
end
]]
w207["require/help/bit"] = [[local bit= {}

local w834= 0xFFFFFFFF
local w835= 4294967296

local function w836(w837)
	w837 = tonumber(w837) or 0
	w837 = math.floor(w837) % w835
	if w837 < 0 then w837 = w837 + w835 end
	return w837
end

function bit.tobit(w837)
	local w838= w836(w837)
	if w838 >= 2147483648 then
		return w838 - w835
	end
	return w838
end

function bit.tohex(w837,w839)
	local w838= w836(w837)
	local w840= 8
	local w841= false
	if w839 then
		if w839 < 0 then
			w841 = true
			w840 = -w839
		else
			w840 = w839
		end
	end
	if w840 < 1 then w840 = 1 end
	if w840 > 8 then w840 = 8 end
	w838 = w838 % (2^(4 * w840))
	if w841 then
		return string.format(string.format("%%0%uX", w840), w838)
	else
		return string.format(string.format("%%0%ux", w840), w838)
	end
end

local function w842(w838,w843)
	return math.floor(w838 / 2^w843) % 2
end

function bit.band(w844,...)
	local w845= {w844, ...}
	if #w845 == 0 then return 0 end
	local w846= 0
	for w843 = 0, 31 do
		local w847= 1
		for w848 = 1, #w845 do
			if w842(w836(w845[w848]), w843) == 0 then
				w847 = 0
				break
			end
		end
		if w847 == 1 then w846 = w846 + 2^w843 end
	end
	return bit.tobit(w846)
end

function bit.bor(w844,...)
	local w845= {w844, ...}
	if #w845 == 0 then return 0 end
	local w846= 0
	for w843 = 0, 31 do
		for w848 = 1, #w845 do
			if w842(w836(w845[w848]), w843) == 1 then
				w846 = w846 + 2^w843
				break
			end
		end
	end
	return bit.tobit(w846)
end

function bit.bxor(w844,...)
	local w845= {w844, ...}
	if #w845 == 0 then return 0 end
	local w846= 0
	for w843 = 0, 31 do
		local w849= 0
		for w848 = 1, #w845 do
			if w842(w836(w845[w848]), w843) == 1 then w849 = w849 + 1 end
		end
		if (w849 % 2) == 1 then w846 = w846 + 2^w843 end
	end
	return bit.tobit(w846)
end

function bit.bnot(w837)
	local w838= w836(w837)
	local w846= w834 - w838
	return bit.tobit(w846)
end

function bit.lshift(w837,w839)
	w839 = tonumber(w839) or 0
	w839 = w839 % 32
	local w838= w836(w837)
	local w846= (w838 * 2^w839) % w835
	return bit.tobit(w846)
end

function bit.rshift(w837,w839)
	w839 = tonumber(w839) or 0
	w839 = w839 % 32
	local w838= w836(w837)
	local w846= math.floor(w838 / 2^w839) % w835
	return bit.tobit(w846)
end

function bit.arshift(w837,w839)
	w839 = tonumber(w839) or 0
	w839 = w839 % 32
	local w850= bit.tobit(w837)
	local w846= math.floor(w850 / 2^w839)
	return bit.tobit(w846)
end

function bit.rol(w837,w839)
	w839 = tonumber(w839) or 0
	w839 = w839 % 32
	if w839 == 0 then return bit.tobit(w837) end
	local w838= w836(w837)
	local w851= (w838 * 2^w839) % w835
	local w852= math.floor(w838 / 2^(32 - w839))
	local w846= (w851 + w852) % w835
	return bit.tobit(w846)
end

function bit.ror(w837,w839)
	w839 = tonumber(w839) or 0
	w839 = w839 % 32
	if w839 == 0 then return bit.tobit(w837) end
	local w838= w836(w837)
	local w852= math.floor(w838 / 2^w839)
	local w851= (w838 * 2^(32 - w839)) % w835
	local w846= (w851 + w852) % w835
	return bit.tobit(w846)
end

function bit.bswap(w837)
	local w838= w836(w837)
	local w853= w838 % 256
	local w854= math.floor(w838 / 256) % 256
	local w855= math.floor(w838 / 65536) % 256
	local w856= math.floor(w838 / 16777216) % 256
	local w846= w853 * 16777216 + w854 * 65536 + w855 * 256 + w856
	return bit.tobit(w846)
end

return bit]]
w207["require/help/client"] = [[local w837= {}

function w837.camera_angles(w838,w839)
  if w838 == nil and w839 == nil then
    return client.camera_angles()
  end
  return client.camera_angles(w838, w839)
end

function w837.camera_position()
  return client.camera_position()
end

function w837.color_log(w840,w841,w842,...)
  return client.color_log(w840, w841, w842, ...)
end

function w837.create_interface(w843,w844)
  return client.create_interface(w843, w844)
end

function w837.current_threat()
  return client.current_threat()
end

function w837.delay_call(w845,w846,...)
  return client.delay_call(w845, w846, ...)
end

function w837.draw_debug_text(w847,w848,w849,w850,w851,w840,w841,w842,w852,...)
  return client.draw_debug_text(w847, w848, w849, w850, w851, w840, w841, w842, w852, ...)
end

function w837.draw_hitboxes(w853,w851,w854,w840,w841,w842,w852,w855)
  return client.draw_hitboxes(w853, w851, w854, w840, w841, w842, w852, w855)
end

function w837.error_log(w856)
  return client.error_log(w856)
end

function w837.exec(...)
  return client.exec(...)
end

function w837.eye_position()
  return client.eye_position()
end

function w837.find_signature(w843,w857)
  return client.find_signature(w843, w857)
end

function w837.fire_event(w858,...)
  return client.fire_event(w858, ...)
end

function w837.get_cvar(w859)
  return client.get_cvar(w859)
end

function w837.get_model_name(w860)
  return client.get_model_name(w860)
end

function w837.key_state(w861)
  return client.key_state(w861)
end

function w837.latency()
  return client.latency()
end

function w837.log(...)
  return client.log(...)
end

function w837.random_float(w862,w863)
  return client.random_float(w862, w863)
end

function w837.random_int(w862,w863)
  return client.random_int(w862, w863)
end

function w837.real_latency()
  return client.real_latency()
end

function w837.register_esp_flag(w864,w840,w841,w842,w846)
  return client.register_esp_flag(w864, w840, w841, w842, w846)
end

function w837.reload_active_scripts()
  return client.reload_active_scripts()
end

function w837.request_full_update()
  return client.request_full_update()
end

function w837.scale_damage(w853,w865,w866)
  return client.scale_damage(w853, w865, w866)
end

function w837.screen_size()
  return client.screen_size()
end

function w837.set_clan_tag(...)
  return client.set_clan_tag(...)
end

function w837.set_event_callback(w858,w846)
  return client.set_event_callback(w858, w846)
end

function w837.system_time()
  return client.system_time()
end

function w837.timestamp()
  return client.timestamp()
end

function w837.trace_bullet(w867,w868,w869,w870,w871,w872,w873,w874)
  return client.trace_bullet(w867, w868, w869, w870, w871, w872, w873, w874)
end

function w837.trace_line(w875,w868,w869,w870,w871,w872,w873)
  return client.trace_line(w875, w868, w869, w870, w871, w872, w873)
end

function w837.unix_time()
  return client.unix_time()
end

function w837.unset_event_callback(w858,w846)
  return client.unset_event_callback(w858, w846)
end

function w837.update_player_list()
  return client.update_player_list()
end

function w837.userid_to_entindex(w876)
  return client.userid_to_entindex(w876)
end

function w837.visible(w847,w848,w849)
  return client.visible(w847, w848, w849)
end

return w837]]
w207["require/help/color"] = [[local function w840(w841)
    w841 = tostring(w841 or "")
    local w842= w841:match("([0-9A-Fa-f]+)$")
    if not w842 or #w842 ~= 8 then
        return 255,255,255,255
    end
    local w843= tonumber(w842:sub(1,2), 16)
    local w844= tonumber(w842:sub(3,4), 16)
    local w845= tonumber(w842:sub(5,6), 16)
    local w846= tonumber(w842:sub(7,8), 16)
    return w843,w844,w845,w846
end

local function w847(w843,w844,w845,w846)
    return string.format("\a%02x%02x%02x%02x", tonumber(w843) or 0, tonumber(w844) or 0, tonumber(w845) or 0, tonumber(w846) or 255)
end

local function w848(w849)
    local w850= tonumber(w849) or 0
    if w850 < 0 then return 0 end
    if w850 > 255 then return 255 end
    return math.floor(w850 + 0.5)
end

local function w851(w843,w844,w845,w846,w852)
    w852 = tonumber(w852) or 32
    return w848((w843 or 0) + w852), w848((w844 or 0) + w852), w848((w845 or 0) + w852), w848(w846 or 255)
end

local function w853(w843,w844,w845,w846,w852)
    w852 = tonumber(w852) or 32
    return w848((w843 or 0) - w852), w848((w844 or 0) - w852), w848((w845 or 0) - w852), w848(w846 or 255)
end

local w854= {
    default = "d6d6d6FF", 
    green  = "a5ca2aFF", 
    red    = "d96464FF", 
    reddark = "b22222FF", 
    orange = "dca53aFF", 
    yellow = "ccb854FF", 
    blue   = "5462ccFF", 
    cyan   = "54ccccFF", 
    purple = "7054ccFF", 
    white  = "ffffffFF", 
    grey   = "757575FF", 
    black  = "000000FF", 
    pink   = "c8a2deFF", 
    discord = "7289daFF", 
    youtube = "FF0000FF", 
    sellhub = "FFC107FF", 

}


local w855= {}
for w856, w841 in pairs(w854) do
    local w843,w844,w845,w846= w840(w841)
    w855[w856] = {
        base = w841,
        lighter = w847(w851(w843,w844,w845,w846,32)),
        darker  = w847(w853(w843,w844,w845,w846,32)),
        light2  = w847(w851(w843,w844,w845,w846,64)),
        dark2   = w847(w853(w843,w844,w845,w846,64)),
        rgb = {w843,w844,w845,w846},
        log = {w843,w844,w845},
        ui = w841,
    }
end

function w855.get(w856,w857)
    w857 = w857 or "base"
    local w858= w855[w856]
    if not w858 then return nil end
    if w857 == "log" and w858.log then
        return unpack(w858.log)
    elseif w857 == "ui" and w858.ui then
        return "\a"..w858.ui
    elseif w858[w857] then
        return w858[w857]
    end
    return nil
end

function w855.blend(w859,w860,w861)
    local w862,w863,w864,w865= unpack(w855[w859].rgb)
    local w866,w867,w868,w869= unpack(w855[w860].rgb)
    w861 = w861 or 0.5
    local w843= w848(w862 + (w866-w862)*w861)
    local w844= w848(w863 + (w867-w863)*w861)
    local w845= w848(w864 + (w868-w864)*w861)
    local w846= w848(w865 + (w869-w865)*w861)
    return w847(w843,w844,w845,w846)
end

function w855.hex_to_rgba(w841)
    return w840(w841)
end

function w855.rgba_to_hex(w843,w844,w845,w846)
    return w847(w843,w844,w845,w846)
end

function w855.clamp(w843,w844,w845,w846)
    return w848(w843), w848(w844), w848(w845), w848(w846)
end

function w855.normalize(w843,w844,w845,w846)
    return w848(w843), w848(w844), w848(w845), w848(w846 or 255)
end

function w855.modulate(w843,w844,w845,w846,w870,w871,w872,w873)
    w870 = tonumber(w870) or 1
    w871 = tonumber(w871) or w870
    w872 = tonumber(w872) or w870
    w873 = tonumber(w873) or 1
    local w874= w848((tonumber(w843) or 0) * w870)
    local w875= w848((tonumber(w844) or 0) * w871)
    local w876= w848((tonumber(w845) or 0) * w872)
    local w877= w848((tonumber(w846) or 255) * w873)
    return w874, w875, w876, w877
end

function w855.alpha_modulate(w846,w878)
    w878 = tonumber(w878) or 1
    return w848((tonumber(w846) or 255) * w878)
end

return w855]]
w207["require/help/drag"] = [[local w843= {}
local w844= {}
local w845= false

local w846= {
	['top-left'] = function(w847,w848,w849,w850) return 0, 0 end,
	['top-center'] = function(w847,w848,w849,w850) return math.floor(w847/2 - w849/2), 0 end,
	['top-right'] = function(w847,w848,w849,w850) return math.floor(w847 - w849), 0 end,
	['center-left'] = function(w847,w848,w849,w850) return 0, math.floor(w848/2 - w850/2) end,
	['center'] = function(w847,w848,w849,w850) return math.floor(w847/2 - w849/2), math.floor(w848/2 - w850/2) end,
	['center-right'] = function(w847,w848,w849,w850) return math.floor(w847 - w849), math.floor(w848/2 - w850/2) end,
	['bottom-left'] = function(w847,w848,w849,w850) return 0, math.floor(w848 - w850) end,
	['bottom-center'] = function(w847,w848,w849,w850) return math.floor(w847/2 - w849/2), math.floor(w848 - w850) end,
	['bottom-right'] = function(w847,w848,w849,w850) return math.floor(w847 - w849), math.floor(w848 - w850) end,
}

local function w851(w852,w853,w849,w850,w854,w855)
	if not w854 or not w855 then return false end
	return w854 >= w852 and w854 <= w852 + w849 and w855 >= w853 and w855 <= w853 + w850
end

local function w856(w857,w858,w859)
	if not w857 then return w858 end
	if w857 < w858 then return w858 end
	if w857 > w859 then return w859 end
	return w857
end

function w843.new(w860,w861)
	if not w860 then error('drag.new requires id') end
	w861 = w861 or {}
	local w862= {}
	w862.id = w860
	w862.x = w861.x or 0
	w862.y = w861.y or 0
	w862.w = w861.w or 100
	w862.h = w861.h or 20
	w862.snap = w861.snap == nil and true or w861.snap
	w862.snap_threshold = w861.snap_threshold or 24
	w862.snap_positions = w861.snap_positions or nil
	w862.require_menu_open = w861.require_menu_open == nil and true or w861.require_menu_open
	w862.locked = w861.lock or false
	w862.box_color = w861.box_color or {255,255,255,100}
	w862.show_alignment = w861.show_alignment == nil and true or w861.show_alignment
	w862.align_color = w861.align_color or {255,255,255,100}
	w862.align_cross_size = w861.align_cross_size or 6
	w862.show_screen_guides = w861.show_screen_guides == nil and true or w861.show_screen_guides
	w862.line_snap_threshold = w861.line_snap_threshold or 6
	w862.bounds = w861.bounds or nil
	w862.constraint_center = w861.constraint_center or nil
	w862.constraint_box = w861.constraint_box or nil
	w862.default_pos = w861.default_pos or nil
	w862.default_center = w861.default_center or nil

	local w863= {
		obj = w862,
		dragging = false,
		drag_offset_x = 0,
		drag_offset_y = 0,
		last_left = false,
		last_right = false,
		locked_to = nil,
		snap_progress = 0,
		snap_target = 0,
		line_snap_progress_x = 0,
		line_snap_progress_y = 0,
		line_snap_target_x = 0,
		line_snap_target_y = 0,
		drag_button = nil,
		disable_snap = false,
	}
	w844[w860] = w863

	local w864, w865= pcall(database.read, 'drag_positions')
	if w864 and type(w865) == 'table' and w865[w860] then
		local w866= w865[w860]
		if type(w866.x) == 'number' and type(w866.y) == 'number' then
			w862.x = w866.x
			w862.y = w866.y
		end
	end

	if not w845 then
		client.set_event_callback('setup_command', function(w867)
			for w868, w869 in pairs(w844) do
				if w869.dragging then
					pcall(function()
						w867.in_attack = false
						w867.in_attack2 = false
					end)
					break
				end
			end
		end)
		w845 = true
	end

	function w862:set_pos(w852,w853)
		self.x = w852
		self.y = w853
	end
	function w862:set_size(w849,w850)
		self.w = w849; self.h = w850
	end
	function w862:set_bounds(w852,w853,w849,w850)
		self.bounds = { x = w852, y = w853, w = w849, h = w850 }
	end
	function w862:clear_bounds()
		self.bounds = nil
	end
	function w862:get_pos()
		return self.x, self.y
	end
	function w862:is_dragging()
		return not not w863.dragging
	end
	function w862:get_bounds()
		return self.bounds
	end
	function w862:set_locked(w870)
		self.locked = not not w870
	end
	function w862:set_snap(w870)
		self.snap = not not w870
	end
	function w862:toggle_snap()
		self.snap = not self.snap
	end
	function w862:reset_to_anchor(w871)
		local w847, w848= client.screen_size()
		if not w847 or not w848 then return end
		local w872= w846[w871]
		if type(w872) == 'function' then
			local w873, w874= w872(w847,w848,self.w,self.h)
			self.x = w873; self.y = w874
			w863.locked_to = w871
		end
	end

	function w862:handle()
		if self.locked then return end
		local w847, w848= client.screen_size()
		if not w847 or not w848 then return end
		if self.require_menu_open and not ui.is_menu_open() then w863.last_left = false; return end

		local w854, w855= ui.mouse_position()
		local w875= client.key_state(1)
		local w876= client.key_state(2)

		if w875 and w876 and (w851(self.x, self.y, self.w, self.h, w854, w855) or w863.dragging) then
			if self.default_pos then
				self.x = self.default_pos.x
				self.y = self.default_pos.y
				return
			elseif self.default_center then
				self.x = (self.default_center.x or 0) - math.floor(self.w/2)
				self.y = (self.default_center.y or 0) - math.floor(self.h/2)
				return
			end
		end
		if w875 and not w863.last_left and w851(self.x, self.y, self.w, self.h, w854, w855) then
			w863.dragging = true
			w863.drag_button = 1
			w863.disable_snap = false
			w863.drag_offset_x = w854 - self.x
			w863.drag_offset_y = w855 - self.y
			w863.locked_to = nil
		elseif w876 and not w863.last_right and w851(self.x, self.y, self.w, self.h, w854, w855) then
			w863.dragging = true
			w863.drag_button = 2
			w863.disable_snap = true
			w863.drag_offset_x = w854 - self.x
			w863.drag_offset_y = w855 - self.y
			w863.locked_to = nil
			w863.snap_target = 0
			w863.line_snap_target_x = 0
			w863.line_snap_target_y = 0
		end

		if (w875 and w863.dragging and w863.drag_button == 1) or (w876 and w863.dragging and w863.drag_button == 2) then
			local w873= w854 - w863.drag_offset_x
			local w874= w855 - w863.drag_offset_y
			local w877, w878= 0, math.max(0, w847 - self.w)
			local w879, w880= 0, math.max(0, w848 - self.h)
			if self.constraint_center then
				local w881= w882.constraint_center
				local w883= w881.cx or math.floor(w847/2)
				local w884= w881.cy or math.floor(w848/2)
				local w885= w881.radius or 0
				w877 = (w883 - w885) - math.floor(w882.w/2)
				w878 = (w883 + w885) - math.floor(w882.w/2)
				w879 = (w884 - w885) - math.floor(w882.h/2)
				w880 = (w884 + w885) - math.floor(w882.h/2)
			elseif w882.bounds or w882.constraint_box then
				local w886= w882.bounds or w882.constraint_box
				local w887= w886.x or w886[1] or 0
				local w888= w886.y or w886[2] or 0
				local w889= w886.w or w886[3] or (w847 - w887)
				local w890= w886.h or w886[4] or (w848 - w888)
				w877 = w887
				w878 = math.max(w887, w887 + w889 - w882.w)
				w879 = w888
				w880 = math.max(w888, w888 + w890 - w882.h)
			end
			w873 = w856(w873, w877, w878)
			w874 = w856(w874, w879, w880)
			w882.x = w873; w882.y = w874
			if w882.snap and not w863.disable_snap then
				local w891= {}
				if w882.snap_positions and #w882.snap_positions > 0 then
					for w868,w892 in ipairs(w882.snap_positions) do
						if type(w892) == 'string' and w846[w892] then
							local w872= w846[w892]
							local w893, w894= w872(w847,w848,w882.w,w882.h)
							table.insert(w891, {x=w893,y=w894})
						elseif type(w892) == 'table' and #w892 >= 2 then
							table.insert(w891, {x=w892[1], y=w892[2]})
						end
					end
				else
					for w895,w872 in pairs(w846) do
						local w893, w894= w872(w847,w848,w882.w,w882.h)
						table.insert(w891, {x=w893,y=w894})
					end
				end
				local w896= math.huge
				for w868,w881 in ipairs(w891) do
					local w897= (w881.x - w882.x)
					local w898= (w881.y - w882.y)
					local w899= math.sqrt(w897*w897 + w898*w898)
					if w899 < w896 then w896 = w899 end
				end
				if w896 <= w882.snap_threshold then w863.snap_target = 1 else w863.snap_target = 0 end
				local w900= math.floor(w847/2)
				local w901= math.floor(w848/2)
				local w883= math.floor(w882.x + w882.w/2)
				local w884= math.floor(w882.y + w882.h/2)
				if math.abs(w883 - w900) <= (w882.line_snap_threshold or 6) then w863.line_snap_target_x = 1 else w863.line_snap_target_x = 0 end
				if math.abs(w884 - w901) <= (w882.line_snap_threshold or 6) then w863.line_snap_target_y = 1 else w863.line_snap_target_y = 0 end
			end
		end

		local w902= false
		if w863.dragging then
			if w863.drag_button == 1 and not w875 and w863.last_left then w902 = true end
			if w863.drag_button == 2 and not w876 and w863.last_right then w902 = true end
		end
		if w902 then
			if not w863.disable_snap then
				local w900, w901= math.floor(w847/2), math.floor(w848/2)
				local w883= math.floor(w882.x + w882.w/2)
				local w884= math.floor(w882.y + w882.h/2)
				if w882.show_screen_guides then
					if math.abs(w883 - w900) <= (w882.line_snap_threshold or 6) then
						w882.x = w900 - math.floor(w882.w/2)
					end
					if math.abs(w884 - w901) <= (w882.line_snap_threshold or 6) then
						w882.y = w901 - math.floor(w882.h/2)
					end
				end
			end
			w863.dragging = false
			local w903, w904= pcall(database.read, 'drag_positions')
			local w905= (w903 and type(w904) == 'table') and w904 or {}
			w905[w882.id] = { x = w882.x, y = w882.y }
			pcall(function() database.write('drag_positions', w905) end)
			if w882.snap and not w863.disable_snap then
				local w891= {}
				if w882.snap_positions and #w882.snap_positions > 0 then
					for w868,w892 in ipairs(w882.snap_positions) do
						if type(w892) == 'string' and w846[w892] then
							local w872= w846[w892]
							local w893, w894= w872(w847,w848,w882.w,w882.h)
							table.insert(w891, {x=w893,y=w894, key=w892})
						elseif type(w892) == 'table' and #w892 >= 2 then
							table.insert(w891, {x=w892[1], y=w892[2], key=nil})
						end
					end
				else
					for w895,w872 in pairs(w846) do
						local w893, w894= w872(w847,w848,w882.w,w882.h)
						table.insert(w891, {x=w893,y=w894, key=w895})
					end
				end
				local w906, w896= nil, math.huge
				for w868,w881 in ipairs(w891) do
					local w897= (w881.x - w882.x)
					local w898= (w881.y - w882.y)
					local w899= math.sqrt(w897*w897 + w898*w898)
					if w899 < w896 then w896 = w899; w906 = w881 end
				end
				if w906 and w896 <= w882.snap_threshold then
					w882.x = w906.x; w882.y = w906.y
					w863.locked_to = w906.key
				end
			end
		end

		w863.last_left = w875
		w863.last_right = w876
	end

	function w862:draw()
		local w863= w844[w882.id]
		if not w863 then return end
		if w863.dragging then
			local w885,w907,w886,w908= unpack(w882.box_color)
			local w909,w910,w911,w912= unpack(w882.align_color)
			local w913= globals.frametime() or 0.016
			local w914= math.min(1, 12 * w913)
			w863.snap_progress = w863.snap_progress + (w863.snap_target - w863.snap_progress) * w914
			w863.line_snap_progress_x = w863.line_snap_progress_x + (w863.line_snap_target_x - w863.line_snap_progress_x) * w914
			w863.line_snap_progress_y = w863.line_snap_progress_y + (w863.line_snap_target_y - w863.line_snap_progress_y) * w914
			local w915= math.floor(w885 + (0 - w885) * w863.snap_progress)
			local w916= math.floor(w907 + (0 - w907) * w863.snap_progress)
			local w917= math.floor(w886 + (0 - w886) * w863.snap_progress)
			local w918= math.floor(w908 + (200 - w908) * w863.snap_progress)
			renderer.rectangle(w882.x, w882.y, w882.w, w882.h, w915, w916, w917, w918)
			renderer.line(w882.x, w882.y, w882.x + w882.w, w882.y, 200,200,200,150)
			renderer.line(w882.x + w882.w, w882.y, w882.x + w882.w, w882.y + w882.h, 200,200,200,150)
			renderer.line(w882.x + w882.w, w882.y + w882.h, w882.x, w882.y + w882.h, 200,200,200,150)
			renderer.line(w882.x, w882.y + w882.h, w882.x, w882.y, 200,200,200,150)
			if w882.show_alignment then
				local w847, w848= client.screen_size()
				if w847 and w848 then
					if w882.show_screen_guides then
						local w900= math.floor(w847/2)
						local w901= math.floor(w848/2)
						local w883= math.floor(w882.x + w882.w/2)
						local w884= math.floor(w882.y + w882.h/2)
						local w919= math.abs(w883 - w900) <= (w882.line_snap_threshold or 6)
						local w920= math.abs(w884 - w901) <= (w882.line_snap_threshold or 6)
						local w921= math.floor(w912 * 0.35)
						renderer.line(w900, w901, 0, w901, w909,w910,w911, w921)
						renderer.line(w900, w901, w900, 0, w909,w910,w911, w921)
						renderer.line(w900, w901, w847, w901, w909,w910,w911, w921)
						renderer.line(w900, w901, w900, w848, w909,w910,w911, w921)
						local w922= math.floor(w912 * w863.line_snap_progress_x)
						local w923= math.floor(w912 * w863.line_snap_progress_y)
						if w922 > 0 then renderer.line(w900, 0, w900, w848, w909,w910,w911, w922) end
						if w923 > 0 then renderer.line(0, w901, w847, w901, w909,w910,w911, w923) end
					end
				end
			end
			if w882.constraint_center then
				local w881= w882.constraint_center
				local w883= w881.cx or math.floor((client.screen_size()) / 2)
				local w884= w881.cy or math.floor((client.screen_size()) / 2)
				local w885= w881.radius or 0
				local w887= w883 - w885
				local w888= w884 - w885
				local w889= w885 * 2
				local w890= w885 * 2
				renderer.rectangle(w887, w888, w889, w890, 255, 255, 255, 60)
				renderer.line(w887, w888, w887 + w889, w888, 255, 255, 255, 160)
				renderer.line(w887 + w889, w888, w887 + w889, w888 + w890, 255, 255, 255, 160)
				renderer.line(w887 + w889, w888 + w890, w887, w888 + w890, 255, 255, 255, 160)
				renderer.line(w887, w888 + w890, w887, w888, 255, 255, 255, 160)
			end
		end
	end

	return w862
end

function w843.get(w860)
	local w863= w844[w860]
	if not w863 then return nil end
	return w863.obj
end

function w843.ids()
	local w924= {}
	for w895,w868 in pairs(w844) do table.insert(w924, w895) end
	return w924
end

return w843]]
w207["require/help/emojis"] = [[local w846= {

    chat = { "" },
    rewind = { "" },
    thumbsup = { "" },
    mail = { "U+E135" },
    square = { "" },
    square2 = { "" },
    square_hollow = { "" },
    play = { "" },
    pause = { "" },
    sun = { "" },
    pc = { "" },
    pc2 = { "" },
    phone = { "U+E1C9" },
    trash = { "" },
    reject = { "" },
    accept = { "" },
    config = { "" },
    config_write = { "U+E28F" },
    gear = { "" },
    arrow_right = { "" },
    arrow_left = { "" },
    arrow_up = { "" },
    arrow_down = { "" },
    star = { "U+E0B4" },
    minus = { "" },
    plus = { "" },
    plus_in_brackets = { "U+E0C5" },
    pen = { "" },
    recycle = { "" },
    camera = { "" },
    download = { "" },
    upload = { "" },
    question = { "" },
    search = { "" },
    globe = { "" },
    globe2 = { "" },
    id = { "" },
    phone = { "" },
    user = { "" },
    user2 = { "U+E2AF" },
    user3 = { "U+E13D" },
    users = { "" },
    users2 = { "U+E125" },
    user_no = { "U+E1E0" },
    pin = { "" },
    unpin = { "U+E196" },
    windows = { "" },
    turning = { "" },
    turning2 = { "" },
    arrow_double = { "" },
    clip = { "" },
    clipboard = { "U+E16D" },
    exclamation = { "" },
    time = { "" },
    clock = { "U+E2AD" },
    paper = { "" },
    paper2 = { "" },
    link = { "" },
    link2 = { "U+E167" },
    wrench = { "" },
    url = { "" },
    speaker = { "" },
    house = { "" },
    pallete = { "" },
    lock = { "" },
    lock_open = { "" },
    tsarrow_left = { "" },
    tsarrow_right = { "" },
    tsarrow_up = { "" },
    tsarrow_up = { "" },
    warning = { "⚠︎" },
    video = { "" },
    connection = { "" },
    heart = { "" },
    triangle_upside = { "⛛" },
    music_note = { "U+E142" },
    test = { "U+E2B1" },
    keyboard = { "U+E0D2" },
    latency0 = { "U+E1E5" },
    latency1 = { "U+E1E6" },
    latency2 = { "U+E1E7" },
    latency3 = { "U+E1E8" },
    latency4 = { "U+E1E9" },
    expand = { "U+E1D9" },
    monitor = { "U+E2F0" },
    rain = { "U+E28A" },
    likedislike = { "U+E19D" },
    text = { "U+E1C8" },
    back = { "U+E10E" },
    folder = { "U+E1C1" },
    menu = { "U+E179" },
    menu2 = { "U+E1A0" },
    at = { "U+E168" },
    circle = { "U+E235" },
    updown = { "U+E174" },

}

local w847= {}

local function w848(w849)
    if w849 == nil then return "ERROR" end
    if type(w849) ~= "string" then w849 = tostring(w849) end
    if w849 == "ERROR" then return "ERROR" end
    local w850= w849:match('^U%+([0-9A-Fa-f]+)$') or w849:match('^u%+([0-9A-Fa-f]+)$') or w849:match('^0x([0-9A-Fa-f]+)$')
    if w850 then
        local w851= tonumber(w850, 16)
        if w851 then
            local w852= nil
            if type(utf8) == 'table' and type(utf8.char) == 'function' then
                pcall(function() w852 = utf8.char(w851) end)
            end
            if not w852 then
                local function w853(w854)
                    if w854 < 0x80 then return string.char(w854) end
                    if w854 < 0x800 then return string.char(0xC0 + math.floor(w854 / 0x40), 0x80 + (w854 % 0x40)) end
                    if w854 < 0x10000 then return string.char(0xE0 + math.floor(w854 / 0x1000), 0x80 + (math.floor(w854 / 0x40) % 0x40), 0x80 + (w854 % 0x40)) end
                    if w854 < 0x110000 then return string.char(0xF0 + math.floor(w854 / 0x40000), 0x80 + (math.floor(w854 / 0x1000) % 0x40), 0x80 + (math.floor(w854 / 0x40) % 0x40), 0x80 + (w854 % 0x40)) end
                    return '?'
                end
                w852 = w853(w851)
            end
            w849 = w852 or w849
        end
    end
    if w849:sub(-1) == " " then return w849 end
    return w849 .. " "
end

function w847.get(w855,w856,w857)
    if not w855 then return "ERROR" end
    local w858= w846[w855]
    if w858 == nil then return "ERROR" end
    if type(w858) == "string" then return w848(w858) end
    if type(w858) == "table" then
        if w857 == nil then
            return w848(w858[1])
        end
        local w859= tonumber(w857) or 1
        return w848(w858[w859])
    end
    return "ERROR"
end

function w847.set(w855,w860)
	if not w855 then return false end
	if type(w860) == "string" then
		w846[w855] = { w860 }
	else
		w846[w855] = w860
	end
	return true
end

function w847.list()
	local w861= {}
	for w862, w858 in pairs(w846) do
		if type(w858) == "table" then
			local w863= {}
			for w859 = 1, #w858 do w863[w859] = w858[w859] end
			w861[w862] = w863
		else
			w861[w862] = w858
		end
	end
	return w861
end

setmetatable(w847, {
    __index = function(w864,w862)
        local w858= w846[w862]
        if w858 == nil then return "ERROR" end
        if type(w858) == "table" then return w848(w858[1]) end
        return w848(w858)
    end,
})

return w847]]
w207["require/help/enemies"] = [[local w849= {}

local entity= entity
local client= client
local globals= globals

function w849.list()
    return entity and entity.get_players and entity.get_players(true) or {}
end

function w849.is_alive(w850)
    return w850 and entity.is_alive and entity.is_alive(w850) or false
end

function w849.is_dormant(w850)
    return w850 and entity.is_dormant and entity.is_dormant(w850) or false
end

function w849.player_name(w850)
    return w850 and entity.get_player_name and entity.get_player_name(w850) or nil
end

function w849.steam64(w850)
    return w850 and entity.get_steam64 and entity.get_steam64(w850) or nil
end

function w849.health(w850)
    return w850 and entity.get_prop and entity.get_prop(w850, 'm_iHealth') or 0
end

function w849.current_threat()
    return client and client.current_threat and client.current_threat() or nil
end

local w851= {}

function w849.is_afk(w850,w852,w853)
    w852 = w852 or 5
    w853 = w853 or 20
    local w854, w855, w856= entity.get_prop(w850, 'm_vecVelocity')
    local w857= 0
    if w854 and w855 and w856 then
        w857 = math.sqrt(w854 * w854 + w855 * w855 + w856 * w856)
    end
    local w858= globals and globals.realtime and globals.realtime() or os.clock()
    if not w851[w850] then
        w851[w850] = { last_active = w858, last_check = w858 }
    end
    if w857 >= w852 then
        w851[w850].last_active = w858
    end
    w851[w850].last_check = w858
    return (w858 - w851[w850].last_active) > w853
end

function w849.distance(w850,w859)
    if not w850 or not entity.get_origin then return nil end
    local w860, w861, w862= entity.get_origin(w850)
    if not w860 then return nil end
    if not w859 then
        w859 = entity.get_local_player and entity.get_local_player()
    end
    local w863, w864, w865= entity.get_origin(w859)
    if not w863 then return nil end
    local w866, w867, w868= w860 - w863, w861 - w864, w862 - w865
    return math.sqrt(w866 * w866 + w867 * w867 + w868 * w868)
end


local function w869(w870)
    if not w870 then return "" end
    return tostring(w870):lower()
end

local function w871(w872)
    local w873= ""
    if w872 and entity.get_classname then w873 = entity.get_classname(w872) or "" end
    if w873 == "" and w872 and client.get_model_name then
        w873 = client.get_model_name(w872) or ""
    end
    return w869(w873)
end

function w849.has_knife(w850)
    if not w850 or not entity.get_player_weapon then return false end
    local w872= entity.get_player_weapon(w850)
    if not w872 then return false end
    local w874= w871(w872)
    return w874:find('knife') ~= nil
end

function w849.has_nade(w850)
    if not w850 or not entity.get_player_weapon then return false end
    local w872= entity.get_player_weapon(w850)
    if not w872 then return false end
    local w874= w871(w872)
    local w875= {'grenade', 'hegrenade', 'flashbang', 'smoke', 'molotov', 'incendiary', 'decoy', 'frag', 'nade'}
    for w876 = 1, #w875 do
        if w874:find(w875[w876]) then return true end
    end
    return false
end

function w849.has_taser(w850)
    if not w850 or not entity.get_player_weapon then return false end
    local w872= entity.get_player_weapon(w850)
    if not w872 then return false end
    local w874= w871(w872)
    return w874:find('taser') ~= nil or w874:find('zeus') ~= nil
end

return w849]]
w207["require/help/ffi"] = [[local w852= rawget(_G, 'ffi')
local w853= {}

function w853.available()
  return w852 ~= nil
end

function w853.cdef(w854)
  if not w852 then error('ffi not available') end
  return w852.cdef(w854)
end

function w853.typeof(w855)
  if not w852 then error('ffi not available') end
  return w852.typeof(w855)
end

function w853.new(w855,...)
  if not w852 then error('ffi not available') end
  return w852.new(w855, ...)
end

function w853.cast(w855,w856)
  if not w852 then error('ffi not available') end
  return w852.cast(w855, w856)
end

function w853.string(w857,w858)
  if not w852 then error('ffi not available') end
  return w852.string(w857, w858)
end

function w853.copy(w859,w860,w858)
  if not w852 then error('ffi not available') end
  return w852.copy(w859, w860, w858)
end

function w853.fill(w859,w861,w858)
  if not w852 then error('ffi not available') end
  return w852.fill(w859, w861, w858)
end

function w853.sizeof(w855)
  if not w852 then error('ffi not available') end
  return w852.sizeof(w855)
end

function w853.alignof(w855)
  if not w852 then error('ffi not available') end
  return w852.alignof(w855)
end

function w853.errno()
  if not w852 then error('ffi not available') end
  return w852.errno()
end

function w853.gc(w857,w862)
  if not w852 then error('ffi not available') end
  return w852.gc(w857, w862)
end

function w853.load(w863,w864)
  if not w852 then error('ffi not available') end
  return w852.load(w863, w864)
end

function w853.metatype(w855,w865)
  if not w852 then error('ffi not available') end
  return w852.metatype(w855, w865)
end

function w853.offsetof(w855,w866)
  if not w852 then error('ffi not available') end
  return w852.offsetof(w855, w866)
end

function w853.istype(w855,w856)
  if not w852 then error('ffi not available') end
  return w852.istype(w855, w856)
end

w853.raw = w852

return w853]]
w207["require/help/globals"] = [[local w855= {}

w855.raw = globals

function w855.absoluteframetime()
  return globals.absoluteframetime()
end

function w855.chokedcommands()
  return globals.chokedcommands()
end

function w855.commandack()
  return globals.commandack()
end

function w855.curtime()
  return globals.curtime()
end

function w855.framecount()
  return globals.framecount()
end

function w855.frametime()
  return globals.frametime()
end

function w855.lastoutgoingcommand()
  return globals.lastoutgoingcommand()
end

function w855.mapname()
  return globals.mapname()
end

function w855.maxplayers()
  return globals.maxplayers()
end

function w855.oldcommandack()
  return globals.oldcommandack()
end

function w855.realtime()
  return globals.realtime()
end

function w855.servertickcount()
  return globals.servertickcount()
end

function w855.tickcount()
  return globals.tickcount()
end

function w855.tickinterval()
  return globals.tickinterval()
end

return w855]]
w207["require/help/json"] = [[local w858= rawget(_G, 'json')
local w859= {}

function w859.available()
  return w858 ~= nil
end

function w859.decode_invalid_numbers(w860)
  if not w858 then error('json not available') end
  if w860 == nil then
    return w858.decode_invalid_numbers()
  end
  return w858.decode_invalid_numbers(w860)
end

function w859.decode_max_depth(w861)
  if not w858 then error('json not available') end
  if w861 == nil then
    return w858.decode_max_depth()
  end
  return w858.decode_max_depth(w861)
end

function w859.encode_invalid_numbers(w860)
  if not w858 then error('json not available') end
  if w860 == nil then
    return w858.encode_invalid_numbers()
  end
  return w858.encode_invalid_numbers(w860)
end

function w859.encode_max_depth(w861)
  if not w858 then error('json not available') end
  if w861 == nil then
    return w858.encode_max_depth()
  end
  return w858.encode_max_depth(w861)
end

function w859.encode_number_precision(w862)
  if not w858 then error('json not available') end
  if w862 == nil then
    return w858.encode_number_precision()
  end
  return w858.encode_number_precision(w862)
end

function w859.encode_sparse_array(...)
  if not w858 then error('json not available') end
  return w858.encode_sparse_array(...)
end

function w859.parse(w863)
  if not w858 then error('json not available') end
  if w858.parse then
    return w858.parse(w863)
  end
  if w858.decode then
    return w858.decode(w863)
  end
  error('json.parse / json.decode not available')
end

function w859.stringify(w864)
  if not w858 then error('json not available') end
  if w858.stringify then
    return w858.stringify(w864)
  end
  if w858.encode then
    return w858.encode(w864)
  end
  error('json.stringify / json.encode not available')
end

w859.raw = w858

return w859]]
w207["require/help/libs"] = [[local function w861(w862)
	local w863, w864= pcall(require, w862)
	return w863 and w864 or nil
end

local w865= {
	antiaim_funcs   = 'gamesense/antiaim_funcs',
	base64          = 'gamesense/base64',
	clipboard       = 'gamesense/clipboard',
	http            = 'gamesense/http',
	csgo_weapons    = 'gamesense/csgo_weapons',
	icons           = 'gamesense/icons',
	entity          = 'gamesense/entity',
	vector          = 'vector',
	bit             = 'bit',
	ffi             = 'ffi',
	pui             = 'gamesense/pui',
	trace           = 'gamesense/trace',
	md5             = 'gamesense/md5',
	websocket       = 'gamesense/websocket',
	surface         = 'gamesense/surface',
	color           = 'gamesense/color',
}

local w866= {}
for w867, w868 in pairs(w865) do
	w866[w867] = w861(w868)
end

local w869= {
	antiaim_funcs = {
		get_tickbase_shifting = "Returns true if tickbase shifting is active.",
		get_fake_lag = "Returns current fake lag value.",
		get_desync = "Returns current desync value.",
		get_manual_direction = "Returns manual anti-aim direction.",
		get_antiaim_condition = "Returns current anti-aim condition.",
		get_body_yaw = "Returns current body yaw value.",
		get_yaw_base = "Returns current yaw base value.",
		get_pitch = "Returns current pitch value.",
		get_yaw_jitter = "Returns current yaw jitter value.",
		get_enabled = "Returns if anti-aim is enabled.",
		get_fakelag_mode = "Returns fakelag mode.",
		get_fakelag_limit = "Returns fakelag limit.",
		get_fakelag_variance = "Returns fakelag variance.",
		get_fakelag_enabled = "Returns if fakelag is enabled.",
		get_double_tap = "Returns true if double tap exploit is active.",
		get_overlap = "Returns overlap value (exploit related).",
	},
	base64 = {
		encode = "Encodes a string to base64.",
		decode = "Decodes a base64 string.",
	},
	clipboard = {
		get = "Gets clipboard contents as string.",
		set = "Sets clipboard contents to string.",
	},
	http = {
		get = "Performs HTTP GET request.",
		post = "Performs HTTP POST request.",
		download = "Downloads a file from URL.",
	},
	csgo_weapons = {
		get_weapon_name = "Returns weapon name by id.",
		get_weapon_id = "Returns weapon id by name.",
		get_weapon_type = "Returns weapon type by id.",
		get_weapon_group = "Returns weapon group by id.",
		get_weapon_slot = "Returns weapon slot by id.",
		get_weapon_price = "Returns weapon price by id.",
	},
	icons = {
		hero = "Table of hero icons.",
		get_texture = "Returns texture id for icon name.",
		get_icon = "Returns icon object by name.",
		get_all_icons = "Returns all available icons.",
	},
	entity = {
		get_local_player = "Returns entindex of local player.",
		get_all = "Returns array of entindices for all entities.",
		get_players = "Returns array of player entindices.",
		get_game_rules = "Returns entindex of game rules proxy.",
		get_player_resource = "Returns entindex of player resource.",
		get_classname = "Returns classname of entity.",
		set_prop = "Sets netvar property.",
		get_prop = "Gets netvar property.",
		is_enemy = "Returns true if entity is enemy.",
		is_alive = "Returns true if entity is alive.",
		is_dormant = "Returns true if entity is dormant.",
		get_player_name = "Returns player name.",
		get_player_weapon = "Returns active weapon entindex.",
		hitbox_position = "Returns world position of hitbox.",
		get_steam64 = "Returns SteamID3.",
		get_bounding_box = "Returns bounding box coordinates.",
		get_origin = "Returns world origin of entity.",
		get_esp_data = "Returns ESP data for player.",
	},
	vector = {
		new = "Creates a new vector object.",
		dot = "Returns dot product of two vectors.",
		cross = "Returns cross product of two vectors.",
		length = "Returns length of vector.",
		normalize = "Normalizes vector.",
		add = "Adds two vectors.",
		sub = "Subtracts two vectors.",
		mul = "Multiplies vector by scalar.",
		div = "Divides vector by scalar.",
		dist = "Returns distance between two vectors.",
	},
	bit = {
		arshift = "Arithmetic right shift.",
		band = "Bitwise AND.",
		bnot = "Bitwise NOT.",
		bor = "Bitwise OR.",
		bswap = "Byte swap (endian conversion).",
		bxor = "Bitwise XOR.",
		lshift = "Logical left shift.",
		rol = "Bitwise left rotation.",
		ror = "Bitwise right rotation.",
		rshift = "Logical right shift.",
		tobit = "Normalize to 32-bit signed.",
		tohex = "Convert to hexadecimal string.",
	},
	ffi = {
		cdef = "Define C types/functions.",
		cast = "Cast value to C type.",
		new = "Allocate new C object.",
		typeof = "Get C type object.",
		string = "Convert C data to Lua string.",
	},
	pui = {
		create_panel = "Creates a custom UI panel.",
		add_icon = "Adds an icon to a panel.",
		set_icon = "Sets the icon for a panel.",
		set_panel_visible = "Shows/hides a panel.",
		set_panel_position = "Sets panel position.",
		set_panel_size = "Sets panel size.",
	},
	trace = {
		trace_line = "Performs a line trace.",
		trace_bullet = "Performs a bullet trace.",
		trace_hull = "Performs a hull trace.",
	},
	md5 = {
		sumhexa = "Returns MD5 hash as hex string.",
		sum = "Returns MD5 hash as raw bytes.",
	},
	websocket = {
		connect = "Connects to a WebSocket server.",
		send = "Sends data over WebSocket.",
		close = "Closes the WebSocket connection.",
		on_message = "Callback for incoming messages.",
	},
	surface = {
		text = "Draws text on screen.",
		rectangle = "Draws a rectangle.",
		line = "Draws a line.",
		circle = "Draws a circle.",
		gradient = "Draws a gradient rectangle.",
		load_texture = "Loads a texture from file.",
	},
	color = {
		blend = "Blends two colors.",
		lighten = "Lightens a color.",
		darken = "Darkens a color.",
		hex_to_rgba = "Converts hex to RGBA.",
		rgba_to_hex = "Converts RGBA to hex.",
	},
}

local function w870(w862)
	return w866[w862]
end

function w871()
	local w872= {}
	for w867, w868 in pairs(_G) do
		if type(w868) == "table" or type(w868) == "userdata" then
			w872[#w872+1] = w867
		end
	end
	return w872
end

function w873(w874)
	local w875= w869[w874]
	if not w875 then return {} end
	local w872= {}
	for w867, w868 in pairs(w875) do
		w872[#w872+1] = w867 .. " - " .. w868
	end
	return w872
end

return {
	get = w870,
	list = w871,
	list_features = w873,
	features = w869,
	libs = w866,
	lib_defs = w865
}
]]
w207["require/help/math"] = [[local w864= {}

function w864.clamp(w865,w866,w867)
    if not w866 and not w867 then return w865 end
    w866 = tonumber(w866) or 0
    w867 = tonumber(w867) or w866
    if w866 > w867 then w866, w867 = w867, w866 end
    w865 = tonumber(w865) or w866
    if w865 < w866 then return w866 end
    if w865 > w867 then return w867 end
    return w865
end

function w864.clamp01(w865)
    return w864.clamp(w865, 0, 1)
end

function w864.abs(w865)
    w865 = tonumber(w865) or 0
    return math.abs(w865)
end

function w864.max(...)
    local w868= {...}
    if #w868 == 0 then return 0 end
    local w869= nil
    for w870 = 1, #w868 do
        local w871= tonumber(w868[w870]) or 0
        if w869 == nil or w871 > w869 then w869 = w871 end
    end
    return w869
end

function w864.min(...)
    local w868= {...}
    if #w868 == 0 then return 0 end
    local w869= nil
    for w870 = 1, #w868 do
        local w871= tonumber(w868[w870]) or 0
        if w869 == nil or w871 < w869 then w869 = w871 end
    end
    return w869
end

function w864.atan2(w872,w873)
    w872 = tonumber(w872) or 0
    w873 = tonumber(w873) or 0
    return math.atan(w872, w873)
end

function w864.floor(w865)
    w865 = tonumber(w865) or 0
    return math.floor(w865)
end

function w864.round(w865,w874)
    w865 = tonumber(w865) or 0
    w874 = tonumber(w874) or 0
    local w875= 10 ^ w874
    return math.floor(w865 * w875 + 0.5) / w875
end

function w864.lerp(w876,w877,w878)
    w876 = tonumber(w876) or 0
    w877 = tonumber(w877) or 0
    w878 = tonumber(w878) or 0
    return w876 + (w877 - w876) * w878
end

function w864.distance2d(w879,w880,w881,w882)
    w879 = tonumber(w879) or 0
    w880 = tonumber(w880) or 0
    w881 = tonumber(w881) or 0
    w882 = tonumber(w882) or 0
    return math.sqrt((w881 - w879)^2 + (w882 - w880)^2)
end

function w864.distance3d(w879,w880,w883,w881,w882,w884)
    w879 = tonumber(w879) or 0
    w880 = tonumber(w880) or 0
    w883 = tonumber(w883) or 0
    w881 = tonumber(w881) or 0
    w882 = tonumber(w882) or 0
    w884 = tonumber(w884) or 0
    return math.sqrt((w881 - w879)^2 + (w882 - w880)^2 + (w884 - w883)^2)
end

function w864.sign(w865)
    w865 = tonumber(w865) or 0
    return (w865 > 0 and 1) or (w865 < 0 and -1) or 0
end

function w864.frac(w865)
    w865 = tonumber(w865) or 0
    return w865 - math.floor(w865)
end

function w864.is_even(w865)
    w865 = tonumber(w865) or 0
    return w865 % 2 == 0
end

function w864.is_odd(w865)
    w865 = tonumber(w865) or 0
    return w865 % 2 ~= 0
end

function w864.sqr(w865)
    w865 = tonumber(w865) or 0
    return w865 * w865
end

function w864.cube(w865)
    w865 = tonumber(w865) or 0
    return w865 * w865 * w865
end

function w864.approximately(w876,w877,w885)
    w876 = tonumber(w876) or 0
    w877 = tonumber(w877) or 0
    w885 = tonumber(w885) or 1e-6
    return math.abs(w876 - w877) < w885
end

function w864.rad_to_deg(w886)
    w886 = tonumber(w886) or 0
    return w886 * (180 / math.pi)
end

function w864.deg_to_rad(w887)
    w887 = tonumber(w887) or 0
    return w887 * (math.pi / 180)
end

function w864.wrap_degrees(w888)
    local w876= tonumber(w888) or 0
    w876 = w876 % 360
    if w876 < 0 then w876 = w876 + 360 end
    return w876
end

function w864.normalize_angle(w888)
    local w876= tonumber(w888) or 0
    w876 = w876 % 360
    if w876 > 180 then w876 = w876 - 360 end
    return w876
end

function w864.angle_diff(w876,w877)
    w876 = tonumber(w876) or 0
    w877 = tonumber(w877) or 0
    local w889= (w876 - w877) % 360
    if w889 > 180 then w889 = w889 - 360 end
    return w889
end

function w864.lerp_angle(w876,w877,w878)
    w876 = tonumber(w876) or 0
    w877 = tonumber(w877) or 0
    w878 = tonumber(w878) or 0
    local w889= w864.angle_diff(w877, w876)
    return (w876 + w889 * w878) % 360
end

function w864.map(w865,w890,w891,w892,w893)
    w865 = tonumber(w865) or 0
    w890 = tonumber(w890) or 0
    w891 = tonumber(w891) or w890
    w892 = tonumber(w892) or 0
    w893 = tonumber(w893) or w892
    if w891 == w890 then return w892 end
    return (w865 - w890) * (w893 - w892) / (w891 - w890) + w892
end

function w864.smoothstep(w894,w895,w873)
    w894 = tonumber(w894) or 0
    w895 = tonumber(w895) or w894
    w873 = tonumber(w873) or 0
    if w895 == w894 then return 0 end
    local w878= w864.clamp((w873 - w894) / (w895 - w894), 0, 1)
    return w878 * w878 * (3 - 2 * w878)
end

function w864.random_float(w866,w867)
    w866 = tonumber(w866) or 0
    w867 = tonumber(w867) or w866
    if w866 > w867 then w866, w867 = w867, w866 end
    return w866 + math.random() * (w867 - w866)
end

function w864.random_int(w866,w867)
    w866 = tonumber(w866) or 0
    w867 = tonumber(w867) or w866
    if w866 > w867 then w866, w867 = w867, w866 end
    return math.random(w866, w867)
end

function w864.mean(w896)
    if type(w896) ~= 'table' or #w896 == 0 then return 0 end
    local w897= 0
    for w870 = 1, #w896 do w897 = w897 + (tonumber(w896[w870]) or 0) end
    return w897 / #w896
end

function w864.swap(w876,w877)
    return w877, w876
end

return w864]]
w207["require/help/panorama"] = [[local w867= {}

w867.raw = panorama

function w867.loadstring(w868,w869)
  return panorama.loadstring(w868, w869)
end

function w867.open(w869)
  return panorama.open(w869)
end

return w867]]
w207["require/help/plist"] = [[local w870= {}

w870.raw = plist

function w870.get(w871,w872)
  return plist.get(w871, w872)
end

function w870.set(w871,w872,w873)
  return plist.set(w871, w872, w873)
end

return w870]]
w207["require/help/reference"] = [[local w873= {}

w873.known_items = {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

function w873.add_known(w874)
    for w875, w876 in ipairs(w874 or {}) do
        table.insert(w873.known_items, w876)
    end
end

function w873.get(w877,w878,w879)
    return ui.reference(w877, w878, w879)
end

function w873.build(w880)
    local w881= {}
    local w882= {}
    for w883, w884 in ipairs(w880) do
        local w885= {ui.reference(w884[1], w884[2], w884[3])}
        w881[w883] = w885
        for w875, w886 in ipairs(w885) do
            if w886 ~= nil then
                w882[w886] = true
            end
        end
    end
    return w881, w882
end

function w873.build_known()
    return w873.build(w873.known_items)
end

function w873.get_all_known()
    return w873.known_items
end

return w873]]
w207["require/help/references_old"] = [[

local w876= {}

local function w877(w878)
    
    if type(w878) ~= 'table' then
        local w879= w878
        return {
            raw = w879,
            get = function()
                local w880, w881= pcall(ui.get, w879)
                if w880 then return w881 end
                return nil
            end
        }
    end

    
    
    
    local w882= w878
    return {
        raw = w882,
        get = function()
            if w882[2] ~= nil then
                local w880, w881= pcall(ui.get, w882[2])
                if w880 then return w881 end
            end
            if w882[1] ~= nil then
                local w880, w881= pcall(ui.get, w882[1])
                if w880 then return w881 end
            end
            return nil
        end
    }
end


w876.minimum_damage = w877(ui.reference("RAGE", "Aimbot", "Minimum damage"))
w876.minimum_damage_override = w877({ ui.reference("RAGE", "Aimbot", "Minimum damage override") })
w876.doubletap = w877({ ui.reference("RAGE", "Aimbot", "Double tap") })
w876.force_body_aim = w877({ ui.reference("RAGE", "Aimbot", "Force body aim") })
w876.force_safe_point = w877({ ui.reference("RAGE", "Aimbot", "Force safe point") })
w876.duck_peek_assist = w877({ ui.reference("RAGE", "Other", "Duck peek assist") })
w876.quick_peek_assist = w877({ ui.reference("RAGE", "Aimbot", "Quick peek assist") })


w876.pitch = w877(ui.reference("AA", "Anti-aimbot angles", "Pitch"))
w876.yaw_base = w877(ui.reference("AA", "Anti-aimbot angles", "Yaw base"))
w876.yaw = w877(ui.reference("AA", "Anti-aimbot angles", "Yaw"))
w876.yaw_jitter = w877(ui.reference("AA", "Anti-aimbot angles", "Yaw jitter"))
w876.body_yaw = w877(ui.reference("AA", "Anti-aimbot angles", "Body yaw"))
w876.roll = w877(ui.reference("AA", "Anti-aimbot angles", "Roll"))

return w876]]
w207["require/help/renderer"] = [[local w879= {}

w879.raw = renderer

function w879.blur(w880,w881,w882,w883,w884,w885)
  return renderer.blur(w880, w881, w882, w883, w884, w885)
end

function w879.circle(w880,w881,w886,w887,w888,w889,w890,w891,w892)
  return renderer.circle(w880, w881, w886, w887, w888, w889, w890, w891, w892)
end

function w879.circle_outline(w880,w881,w886,w887,w888,w889,w890,w891,w892,w893)
  return renderer.circle_outline(w880, w881, w886, w887, w888, w889, w890, w891, w892, w893)
end

function w879.gradient(w880,w881,w882,w883,w894,w895,w896,w897,w898,w899,w900,w901,w902)
  return renderer.gradient(w880, w881, w882, w883, w894, w895, w896, w897, w898, w899, w900, w901, w902)
end

function w879.indicator(w886,w887,w888,w889,...)
  return renderer.indicator(w886, w887, w888, w889, ...)
end

function w879.line(w903,w904,w905,w906,w886,w887,w888,w889)
  return renderer.line(w903, w904, w905, w906, w886, w887, w888, w889)
end

function w879.load_jpg(w907,w908,w909)
  return renderer.load_jpg(w907, w908, w909)
end

function w879.load_png(w907,w908,w909)
  return renderer.load_png(w907, w908, w909)
end

function w879.load_rgba(w907,w908,w909)
  return renderer.load_rgba(w907, w908, w909)
end

function w879.load_svg(w907,w908,w909)
  return renderer.load_svg(w907, w908, w909)
end

function w879.measure_text(w910,...)
  return renderer.measure_text(w910, ...)
end

function w879.rectangle(w880,w881,w882,w883,w886,w887,w888,w889)
  return renderer.rectangle(w880, w881, w882, w883, w886, w887, w888, w889)
end

function w879.text(w880,w881,w886,w887,w888,w889,w910,w911,...)
  return renderer.text(w880, w881, w886, w887, w888, w889, w910, w911, ...)
end

function w879.texture(w912,w880,w881,w882,w883,w886,w887,w888,w889,w913)
  return renderer.texture(w912, w880, w881, w882, w883, w886, w887, w888, w889, w913)
end

function w879.triangle(w903,w904,w905,w906,w914,w915,w886,w887,w888,w889)
  return renderer.triangle(w903, w904, w905, w906, w914, w915, w886, w887, w888, w889)
end

function w879.world_to_screen(w880,w881,w916)
  return renderer.world_to_screen(w880, w881, w916)
end

function w879.rectangle_outline(w880,w881,w882,w883,w886,w887,w888,w889,w893)
  w893 = w893 or 1
  for w917 = 0, w893 - 1 do
    renderer.line(w880 + w917, w881 + w917, w880 + w882 - w917, w881 + w917, w886, w887, w888, w889)
    renderer.line(w880 + w917, w881 + w883 - w917, w880 + w882 - w917, w881 + w883 - w917, w886, w887, w888, w889)
    renderer.line(w880 + w917, w881 + w917, w880 + w917, w881 + w883 - w917, w886, w887, w888, w889)
    renderer.line(w880 + w882 - w917, w881 + w917, w880 + w882 - w917, w881 + w883 - w917, w886, w887, w888, w889)
  end
end

function w879.text_centered(w880,w881,w886,w887,w888,w889,w910,w911,...)
  local w882, w883= renderer.measure_text(w910, ...)
  if not w882 or not w883 then return end
  return renderer.text(w880 - w882 / 2, w881 - w883 / 2, w886, w887, w888, w889, w910, w911, ...)
end

function w879.texture_from_file(w918)
  local w907= w919(w918)
  if not w907 then return nil end
  local w912= renderer.load_png(w907)
  if not w912 then
    w912 = renderer.load_jpg(w907)
  end
  return w912
end

return w879]]
w207["require/help/safe"] = [[local w882= {}

function w882.safe_call(w883,...)
	local w884, w885= pcall(w883, ...)
	return w884 and w885 or nil
end

function w882.safe_set(w886,w887)
	local w884= pcall(function() ui.set(w886, w887) end)
	return w884
end

function w882.safe_get(w886)
	local w884, w885= pcall(function() return ui.get(w886) end)
	return w884 and w885 or nil
end

return w882]]
w207["require/help/self"] = [[local w885= {}

local entity= entity
local globals= globals
local client= client

function w885.index()
	return entity and entity.get_local_player and entity.get_local_player() or nil
end

function w885.exists()
	return w885.index() ~= nil
end

function w885.is_alive()
	local w886= w885.index()
	return w886 and entity.is_alive and entity.is_alive(w886) or false
end

function w885.health()
	local w886= w885.index()
	return w886 and entity.get_prop and entity.get_prop(w886, 'm_iHealth') or 0
end

function w885.ping()
	return client and client.latency and client.latency() or 0
end

function w885.velocity()
	local w886= w885.index()
	if not w886 or not entity.get_prop then return 0 end
	local w887, w888, w889= entity.get_prop(w886, 'm_vecVelocity')
	if w887 and w888 and w889 then
		return math.sqrt(w887 * w887 + w888 * w888 + w889 * w889)
	end
	return 0
end

function w885.velocity2d()
	local w886= w885.index()
	if not w886 or not entity.get_prop then return 0 end
	local w887, w888= entity.get_prop(w886, 'm_vecVelocity')
	if w887 and w888 then
		return math.sqrt(w887 * w887 + w888 * w888)
	end
	return 0
end

function w885.weapon()
	local w886= w885.index()
	return w886 and entity.get_player_weapon and entity.get_player_weapon(w886) or nil
end

function w885.tickbase_shifted()
	
	return false
end

function w885.simtime()
	local w886= w885.index()
	return w886 and entity.get_prop and entity.get_prop(w886, 'm_flSimulationTime') or 0
end

function w885.eye_angles()
	return client and client.camera_angles and client.camera_angles() or nil
end

function w885.fps()
	local w890= globals and globals.absoluteframetime and globals.absoluteframetime() or globals.frametime and globals.frametime() or 0.01
	if w890 > 0 then
		return math.floor(1 / w890 + 0.5)
	end
	return 0
end

function w885.map()
	return globals and globals.mapname and globals.mapname() or nil
end

function w885.is_dormant()
	local w886= w885.index()
	return w886 and entity.is_dormant and entity.is_dormant(w886) or false
end

function w885.team_number()
	local w886= w885.index()
	return w886 and entity.get_prop and entity.get_prop(w886, 'm_iTeamNum') or 0
end

function w885.player_name()
	local w886= w885.index()
	return w886 and entity.get_player_name and entity.get_player_name(w886) or nil
end

function w885.steam64()
	local w886= w885.index()
	return w886 and entity.get_steam64 and entity.get_steam64(w886) or nil
end

function w885.ammo_count()
	local w891= w885.weapon()
	return w891 and entity.get_prop and entity.get_prop(w891, 'm_iClip1') or 0
end

function w885.has_armor()
	local w886= w885.index()
	return w886 and entity.get_prop and entity.get_prop(w886, 'm_ArmorValue') > 0 or false
end

function w885.has_helmet()
	local w886= w885.index()
	return w886 and entity.get_prop and entity.get_prop(w886, 'm_bHasHelmet') == 1 or false
end

function w885.current_tick()
	return globals and globals.tickcount and globals.tickcount() or 0
end

function w885.tick_interval()
	return globals and globals.tickinterval and globals.tickinterval() or 0
end

function w885.current_frame()
	return globals and globals.framecount and globals.framecount() or 0
end

function w885.current_time()
	return globals and globals.curtime and globals.curtime() or 0
end

function w885.real_latency()
	return client and client.real_latency and client.real_latency() or 0
end

function w885.system_time()
	return client and client.system_time and client.system_time() or {0,0,0,0}
end

function w885.unix_time()
	return client and client.unix_time and client.unix_time() or 0
end

function w885.kills()
	local w886= w885.index()
	if not w886 or not entity.get_prop then return 0 end
	local w892= entity.get_player_resource and entity.get_player_resource()
	if w892 then
		return entity.get_prop(w892, 'm_iKills', w886) or 0
	end
	return 0
end

function w885.deaths()
	local w886= w885.index()
	if not w886 or not entity.get_prop then return 0 end
	local w892= entity.get_player_resource and entity.get_player_resource()
	if w892 then
		return entity.get_prop(w892, 'm_iDeaths', w886) or 0
	end
	return 0
end

function w885.assists()
	local w886= w885.index()
	if not w886 or not entity.get_prop then return 0 end
	local w892= entity.get_player_resource and entity.get_player_resource()
	if w892 then
		return entity.get_prop(w892, 'm_iAssists', w886) or 0
	end
	return 0
end

return w885
]]
w207["require/help/string"] = [[local w888= {}

function w888.lower(w889)
	return string.lower(w889)
end

function w888.upper(w889)
	return string.upper(w889)
end

function w888.capitalize(w889)
	return (w889:gsub("^%l", string.upper):gsub("^(%u)(.*)", function(w890,w891) return w890 .. string.lower(w891) end))
end

function w888.title(w889)
	return (w889:gsub("%S+", function(w892)
		return w892:sub(1,1):upper() .. w892:sub(2):lower()
	end))
end

function w888.random_case(w889)
	local w893= {}
	for w894 = 1, #w889 do
		local w895= w889:sub(w894,w894)
		if math.random() < 0.5 then
			w893[w894] = string.lower(w895)
		else
			w893[w894] = string.upper(w895)
		end
	end
	return table.concat(w893)
end

function w888.startswith(w889,w896)
	return w889:sub(1, #w896) == w896
end

function w888.endswith(w889,w897)
	return w897 == '' or w889:sub(-#w897) == w897
end

function w888.byte(w889,w894,w898)
	return string.byte(tostring(w889 or ""), w894, w898)
end

function w888.char(...)
	return string.char(...)
end

function w888.find(w889,w899,w900,w901)
	return string.find(tostring(w889 or ""), w899, w900, w901)
end

function w888.format(w902,...)
	return string.format(w902, ...)
end

function w888.gmatch(w889,w899)
	return string.gmatch(tostring(w889 or ""), w899)
end

function w888.gsub(w889,w899,w903,w904)
	return string.gsub(tostring(w889 or ""), w899, w903, w904)
end

function w888.split(w889,w905)
	local w906= {}
	if w905 == '' then
		for w894 = 1, #w889 do w906[w894] = w889:sub(w894,w894) end
		return w906
	end
	local w899= string.format("([^%s]+)", w905)
	for w907 in w889:gmatch(w899) do
		w906[#w906+1] = w907
	end
	return w906
end

function w888.join(w908,w905)
	return table.concat(w908, w905)
end

function w888.replace(w889,w899,w903)
	return w889:gsub(w899, w903)
end

function w888.reverse(w889)
	return string.reverse(w889)
end

function w888.repeat_str(w889,w904)
	return string.rep(w889, w904)
end

function w888.rep(w889,w904)
	return string.rep(tostring(w889 or ""), w904)
end

function w888.contains(w889,w909)
	return w889:find(w909, 1, true) ~= nil
end

function w888.count(w889,w909)
	if w909 == '' then return 0 end
	local w910= 0
	local w911= 1
	while true do
		local w912= w889:find(w909, w911, true)
		if not w912 then break end
		w910 = w910 + 1
		w911 = w912 + #w909
	end
	return w910
end

function w888.is_empty(w889)
	return w889 == nil or w889 == ''
end

function w888.is_digit(w889)
	return w889:match("^%d+$") ~= nil
end

function w888.is_alpha(w889)
	return w889:match("^%a+$") ~= nil
end

function w888.random_string(w913)
	local w914= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local w893= {}
	for w894 = 1, w913 do
		local w915= math.random(1, #w914)
		w893[w894] = w914:sub(w915, w915)
	end
	return table.concat(w893)
end

function w888.safe_substr(w889,w894,w898)
	local w916= tostring(w889 or "")
	local w904= #w916
	local w912= tonumber(w894) or 1
	if w912 < 0 then w912 = w904 + 1 + w912 end
	if w912 < 1 then w912 = 1 end
	if w898 == nil then
		return w916:sub(w912)
	end
	local w917= tonumber(w898)
	if not w917 then
		return w916:sub(w912)
	end
	if w917 >= 0 then
		return w916:sub(w912, math.min(w904, w912 + w917 - 1))
	else
		local w918= w904 + w917
		if w918 < w912 then return "" end
		return w916:sub(w912, w918)
	end
end

function w888.sub(w889,w916,w919)
	return string.sub(tostring(w889 or ""), w916, w919)
end

function w888.len(w889)
	return string.len(tostring(w889 or ""))
end

function w888.match(w889,w899,w900)
	return string.match(tostring(w889 or ""), w899, w900)
end

function w888.trim(w889)
	return (tostring(w889 or ""):gsub("^%s*(.-)%s*$", "%1"))
end

function w888.ltrim(w889)
	return (tostring(w889 or ""):gsub("^%s*(.-)$", "%1"))
end

function w888.rtrim(w889)
	return (tostring(w889 or ""):gsub("^(.-)%s*$", "%1"))
end

function w888.escape_pattern(w889)
	return tostring(w889 or ""):gsub("([%%%$%(%)%.%[%]%*%+%-%?%^])", "%%%1")
end

function w888.ensure_prefix(w889,w896)
	local w916= tostring(w889 or "")
	local w920= tostring(w896 or "")
	if w920 == "" then return w916 end
	if w916:sub(1, #w920) == w920 then return w916 end
	return w920 .. w916
end

function w888.ensure_suffix(w889,w897)
	local w916= tostring(w889 or "")
	local w921= tostring(w897 or "")
	if w921 == "" then return w916 end
	if w916:sub(-#w921) == w921 then return w916 end
	return w916 .. w921
end

function w888.truncate(w889,w922,w923)
	local w916= tostring(w889 or "")
	local w924= tonumber(w922) or 0
	if w924 <= 0 or #w916 <= w924 then return w916 end
	local w919= tostring(w923 or "...")
	local w925= w924 - #w919
	if w925 <= 0 then return w919:sub(1, w924) end
	return w916:sub(1, w925) .. w919
end

local w926= {
	a = '4', A = '4', e = '3', E = '3', i = '1', I = '1', o = '0', O = '0',
	s = '5', S = '5', t = '7', T = '7', b = '8', B = '8', g = '6', G = '6',
	z = '2', Z = '2', l = '1', L = '1'
}

function w888.leet(w889,w927)
	local w916= tostring(w889 or "")
	local w920= tonumber(w927) or 1
	if w920 <= 0 then return w916 end
	local w893= {}
	for w894 = 1, #w916 do
		local w895= w916:sub(w894,w894)
		local w891= w926[w895]
		if w891 and math.random() <= w920 then w893[#w893+1] = w891 else w893[#w893+1] = w895 end
	end
	return table.concat(w893)
end

function w888.pipeline(w889,...)
	local w916= tostring(w889 or "")
	for w894 = 1, select('#', ...) do
		local w928= select(w894, ...)
		if type(w928) == 'function' then
			w916 = w928(w916)
		elseif type(w928) == 'string' and w888[w928] then
			w916 = w888[w928](w916)
		end
	end
	return w916
end

return w888]]
w207["require/help/time"] = [[local w891= {}

local client= client
local globals= globals

local function w892()
	if globals and globals.realtime then
		return globals.realtime()
	end
	if client and client.timestamp then
		local w893= client.timestamp()
		if w893 then return w893 / 1000 end
	end
	return 0
end

function w891.simtime()
	if globals and globals.curtime then return globals.curtime() end
	return w892()
end

function w891.realtime()
	return w892()
end

function w891.tickcount()
	if globals and globals.tickcount then return globals.tickcount() end
	local w894= w891.tickinterval()
	if w894 and w894 > 0 then return math.floor(w892() / w894) end
	return 0
end

function w891.tickinterval()
	if globals and globals.tickinterval then return globals.tickinterval() end
	return 0.015625
end

function w891.seconds_to_ticks(w895)
	local w896= w891.tickinterval()
	if w896 and w896 > 0 then return math.floor(w895 / w896 + 0.5) end
	return math.floor(w895 * 64 + 0.5)
end

function w891.ticks_to_seconds(w897)
	local w896= w891.tickinterval()
	if w896 then return w897 * w896 end
	return w897 * 0.015625
end

function w891.frametime()
	if globals and globals.frametime then return globals.frametime() end
	return 0
end

function w891.absoluteframetime()
	if globals and globals.absoluteframetime then return globals.absoluteframetime() end
	return 0
end

function w891.framecount()
	if globals and globals.framecount then return globals.framecount() end
	return 0
end

function w891.framecount_to_seconds(w898)
	local w899= w891.frametime()
	return w898 * (w899 or 0)
end

function w891.seconds_to_framecount(w895)
	local w899= w891.frametime()
	if w899 and w899 > 0 then return math.floor(w895 / w899 + 0.5) end
	return math.floor(w895 * 60 + 0.5)
end

function w891.new(w900)
	return { start = w892(), duration = w900 or 0 }
end

function w891.expired(w901)
	return w892() - (w901.start or 0) >= (w901.duration or 0)
end

function w891.reset(w901,w900)
	w901.start = w892()
	if w900 then w901.duration = w900 end
end

function w891.elapsed(w901)
	return w892() - (w901.start or 0)
end

function w891.interval(w896,w902)
	local w903= w892()
	return function(...)
		local w904= w892()
		if w904 - w903 >= w896 then
			w903 = w904
			w902(...)
		end
	end
end

function w891.timeout(w905,w902)
	local w906= false
	local w907= w892()
	return function(...)
		if not w906 and w892() - w907 >= w905 then
			w906 = true
			w902(...)
		end
	end
end

function w891.debounce(w896,w902)
	local w903= 0
	return function(...)
		local w904= w892()
		if w904 - w903 >= w896 then
			w903 = w904
			w902(...)
		end
	end
end

function w891.throttle(w896,w902)
	local w903= 0
	return function(...)
		local w904= w892()
		if w904 - w903 >= w896 then
			w903 = w904
			w902(...)
		end
	end
end

function w891.wait(w905)
	local w907= w892()
	return function()
		return w892() - w907 >= w905
	end
end

function w891.stopwatch()
	local w908= { running = false, start = 0, elapsed = 0 }
	function w908:start()
		if not self.running then
			self.running = true
			self.start = w892()
		end
	end
	function w908:stop()
		if self.running then
			self.running = false
			self.elapsed = self.elapsed + (w892() - (self.start or 0))
		end
	end
	function w908:reset()
		self.running = false
		self.start = 0
		self.elapsed = 0
	end
	function w908:get()
		if self.running then
			return self.elapsed + (w892() - (self.start or 0))
		else
			return self.elapsed
		end
	end
	return w908
end

w891.Scheduler = {}
w891.Scheduler.__index = w891.Scheduler

function w891.Scheduler.new()
    return setmetatable({ tasks = {} }, w891.Scheduler)
end

function w891.Scheduler:add(w896,w902)
	self.tasks[#self.tasks+1] = { interval = w896, callback = w902, last = w892() }
end

function w891.Scheduler:remove(w902)
    for w909 = #self.tasks, 1, -1 do
        if self.tasks[w909].callback == w902 then
            table.remove(self.tasks, w909)
        end
    end
end

function w891.Scheduler:run(...)
	local w904= w892()
	for w910, w911 in ipairs(self.tasks) do
		if w904 - w911.last >= w911.interval then
			w911.last = w904
			w911.callback(...)
		end
	end
end

function w891.safe_timeout(w905,w902)
	local w907= w892()
	local w906= false
	return function(...)
		if not w906 and w892() - w907 >= w905 then
			w906 = true
			w902(...)
		end
	end
end

function w891.lerp(w912,w913,w904)
	return w912 + (w913 - w912) * w904
end

function w891.ease_in_out(w904)
	if w904 < 0 then w904 = 0 end
	if w904 > 1 then w904 = 1 end
	return w904 < 0.5 and 2 * w904 * w904 or -1 + (4 - 2 * w904) * w904
end

function w891.ping_pong(w904,w914)
	if w914 <= 0 then return 0 end
	local w915= w904 % (w914 * 2)
	if w915 < w914 then return w915 / w914 end
	return 1 - ((w915 - w914) / w914)
end

function w891.apply_animation(w900,w916,w917)
	local w907= w892()
	return function()
		local w904= (w892() - w907) / (w900 or 1)
		if w904 >= 1 then
			w916(1)
			if w917 then w917() end
			return true
		else
			w916(w904)
			return false
		end
	end
end

function w891.within_ticks_window(w918,w919)
	local w920= w891.tickcount()
	if not w920 or not w918 then return false end
	return w920 - w918 <= (w919 or 0)
end

return w891]]
w207["require/help/trace"] = [[]]
w207["require/help/ui"] = [[local w897= {}

w897.raw = ui

local function w898()
    if type(ui) ~= 'table' then
        error('ui library is not available in this environment')
    end
end

function w897.available()
    return type(ui) == 'table'
end

function w897.get(w899)
    w898()
    return ui.get(w899)
end

function w897.is_menu_open()
    w898()
    return ui.is_menu_open()
end

function w897.menu_position()
    w898()
    return ui.menu_position()
end

function w897.menu_size()
    w898()
    return ui.menu_size()
end

function w897.mouse_position()
    w898()
    return ui.mouse_position()
end

function w897.name(w899)
    w898()
    return ui.name(w899)
end


function w897.new_button(w900,w901,w902,w903)
    w898()
    return ui.new_button(w900, w901, w902, w903)
end

function w897.new_checkbox(w900,w901,w902)
    w898()
    return ui.new_checkbox(w900, w901, w902)
end

function w897.new_color_picker(w900,w901,w902,w904,w905,w906,w907)
    w898()
    return ui.new_color_picker(w900, w901, w902, w904 or 0, w905 or 0, w906 or 0, w907 or 255)
end

function w897.new_combobox(w900,w901,w902,...)
    w898()
    return ui.new_combobox(w900, w901, w902, ...)
end

function w897.new_hotkey(w900,w901,w902,w908,w909)
    w898()
    return ui.new_hotkey(w900, w901, w902, w908 and true or false, w909)
end

function w897.new_label(w900,w901,w902)
    w898()
    return ui.new_label(w900, w901, w902)
end

function w897.new_listbox(w900,w901,w902,w910)
    w898()
    return ui.new_listbox(w900, w901, w902, w910)
end

function w897.new_multiselect(w900,w901,w902,...)
    w898()
    return ui.new_multiselect(w900, w901, w902, ...)
end

function w897.new_slider(w900,w901,w902,w911,w912,w913,w914,w915,w916,w917)
    w898()
    return ui.new_slider(w900, w901, w902, w911, w912, w913, w914, w915, w916, w917)
end

function w897.new_string(w902,w918)
    w898()
    return ui.new_string(w902, w918)
end

function w897.new_textbox(w900,w901,w902)
    w898()
    return ui.new_textbox(w900, w901, w902)
end

function w897.reference(w900,w901,w902)
    w898()
    return ui.reference(w900, w901, w902)
end


function w897.set(w899,...)
    w898()
    return ui.set(w899, ...)
end

function w897.set_callback(w899,w903)
    w898()
    return ui.set_callback(w899, w903)
end

function w897.set_enabled(w899,w919)
    w898()
    return ui.set_enabled(w899, w919)
end

function w897.set_visible(w899,w920)
    w898()
    return ui.set_visible(w899, w920)
end

function w897.type(w899)
    w898()
    return ui.type(w899)
end

function w897.update(w899,...)
    w898()
    if ui.update then
        return ui.update(w899, ...)
    end
    error('ui.update is not supported in this environment')
end

function w897.get_color(w899)
    w898()
    local w904,w905,w906,w907= ui.get(w899)
    if w904 == nil then return nil end
    return { r = w904, g = w905, b = w906, a = w907 }
end

function w897.set_color(w899,w921)
    w898()
    if type(w921) == 'table' then
        return ui.set(w899, w921.r or 0, w921.g or 0, w921.b or 0, w921.a or 255)
    else
        error('color must be a table {r,g,b,a}')
    end
end

function w897.get_multiselect(w899)
    w898()
    local w922= ui.get(w899)
    return w922
end

function w897.list_refs(w900,w901)
    w898()
    local w923= {}
    for w924, w902 in ipairs(ui.get_children and ui.get_children(w900, w901) or {}) do
        w923[#w923+1] = ui.reference(w900, w901, w902)
    end
    return w923
end

return w897]]
w207["require/help/vector"] = [[local w900
do
    local function w901(w902,w903,w904)
        local w905= { x = 0, y = 0, z = 0 }
        if type(w902) == "table" then
            w905.x = w902.x or w902[1] or 0
            w905.y = w902.y or w902[2] or 0
            w905.z = w902.z or w902[3] or 0
        elseif type(w902) == "number" then
            w905.x = w902
            w905.y = w903 or 0
            w905.z = w904 or 0
        elseif w902 ~= nil then
            w905.x = (w902.x or w902[1]) or 0
            w905.y = (w902.y or w902[2]) or 0
            w905.z = (w902.z or w902[3]) or 0
        end
        return setmetatable(w905, vector_mt)
    end

    local w906= {}

    vector_mt = {
        __index = function(w907,w908)
            if w908 == 1 then return rawget(w907,"x") end
            if w908 == 2 then return rawget(w907,"y") end
            if w908 == 3 then return rawget(w907,"z") end
            local w905= rawget(w907,w908)
            if w905 ~= nil then return w905 end
            return w906[w908]
        end,
        __sub = function(w902,w903)
            return w901((w902.x or 0) - (w903.x or 0), (w902.y or 0) - (w903.y or 0), (w902.z or 0) - (w903.z or 0))
        end,
        __add = function(w902,w903)
            return w901((w902.x or 0) + (w903.x or 0), (w902.y or 0) + (w903.y or 0), (w902.z or 0) + (w903.z or 0))
        end,
        __mul = function(w902,w903)
            if type(w902) == 'number' then return w901(w902 * (w903.x or 0), w902 * (w903.y or 0), w902 * (w903.z or 0)) end
            if type(w903) == 'number' then return w901((w902.x or 0) * w903, (w902.y or 0) * w903, (w902.z or 0) * w903) end
            return nil
        end,
        __div = function(w902,w903)
            if type(w903) == 'number' and w903 ~= 0 then return w901((w902.x or 0) / w903, (w902.y or 0) / w903, (w902.z or 0) / w903) end
            return nil
        end,
        __unm = function(w902) return w901(-(w902.x or 0), -(w902.y or 0), -(w902.z or 0)) end,
        __tostring = function(w902) return string.format("vec(%.3f, %.3f, %.3f)", w902.x or 0, w902.y or 0, w902.z or 0) end
    }

    w906.length = function(w909) return math.sqrt((w909.x or 0)^2 + (w909.y or 0)^2 + (w909.z or 0)^2) end
    w906.dot = function(w902,w903) return (w902.x or 0)*(w903.x or 0) + (w902.y or 0)*(w903.y or 0) + (w902.z or 0)*(w903.z or 0) end
    w906.cross = function(w902,w903)
        return w901((w902.y or 0)*(w903.z or 0) - (w902.z or 0)*(w903.y or 0),
                        (w902.z or 0)*(w903.x or 0) - (w902.x or 0)*(w903.z or 0),
                        (w902.x or 0)*(w903.y or 0) - (w902.y or 0)*(w903.x or 0))
    end
    w906.normalized = function(w909)
        local w910= w906.length(w909)
        if w910 == 0 or w910 == nil then return w901(0,0,0) end
        return w901((w909.x or 0)/w910, (w909.y or 0)/w910, (w909.z or 0)/w910)
    end
    w906.normalize = function(w909)
        local w910= w906.length(w909)
        if w910 == 0 or w910 == nil then return w909 end
        w909.x = (w909.x or 0)/w910
        w909.y = (w909.y or 0)/w910
        w909.z = (w909.z or 0)/w910
        return w909
    end
    w906.copy = function(w909) return w901(w909.x or 0, w909.y or 0, w909.z or 0) end
    w906.distance_to = function(w909,w911)
        local w912= w911
        if type(w911) == 'number' then w912 = w900(w911) end
        local w913= (w909.x or 0) - (w912.x or 0)
        local w914= (w909.y or 0) - (w912.y or 0)
        local w915= (w909.z or 0) - (w912.z or 0)
        return math.sqrt(w913*w913 + w914*w914 + w915*w915)
    end
    w906.to_screen = function(w909)
        if not renderer or not renderer.world_to_screen then return nil end
        return renderer.world_to_screen(w909.x or 0, w909.y or 0, w909.z or 0)
    end
    w906.to_angles = function(w909,w911)
        local w912= w911
        if not w912 then return nil end
        local w913= (w912.x or 0) - (w909.x or 0)
        local w914= (w912.y or 0) - (w909.y or 0)
        local w915= (w912.z or 0) - (w909.z or 0)
        local w916= math.deg(math.atan2(w914, w913))
        local w917= math.sqrt(w913*w913 + w914*w914)
        local w918= -math.deg(math.atan2(w915, w917))
        return w918, w916
    end

    w900 = setmetatable({}, {
        __call = function(w919,w902,w903,w904)
            return w901(w902, w903, w904)
        end
    })
end
return w900]]
w207["main"] = [[


local function w903(w904)
    local w905, w906= pcall(require, w904)
    if w905 then
        return w906
    else
        return nil
    end
end




w903("require/brain/dll")





local function w907()

    w903("require/brain/test")

    local w908= {
        menu = w903("require/abc/menu_header"),
        login = w903("require/abc/login_system"),
        config = w903("require/abc/config_system"),
        player_condition = w903("require/aa/player_condition"),
        menu_setup = w903("require/abc/menu_setup"),
        gc = w903("require/abc/garbage_collector"),
        pushlog = w903("require/abc/push_logger"),
        screenlog = w903("require/abc/screen_logger"),
        self = w903("require/help/self"),
        enemies = w903("require/help/enemies"),
        COLORS = w903("require/help/color"),
        str = w903("require/help/string"),
        safe = w903("require/help/safe"),
        build_menu = w903("require/abc/build_menu"),
        menu_visibility = w903("require/abc/menu_visibility"),
        config_system = w903("require/abc/config_system"),
    }

    
    w903("require/abc/register")

    
    w903("require/features/aa/antiaim")

    
    
    w903("require/features/misc/resolver")
    w903("require/features/misc/analyze")
    w903("require/features/misc/dormant_aimbot")
    w903("require/features/misc/fakelag")
    w903("require/features/misc/hotkeys")
    w903("require/features/misc/freestand_helper")
    w903("require/features/misc/enhance_osaa")
    
    w903("require/features/misc/exploit_fakelag")
    w903("require/features/misc/walkbot")
    w903("require/features/misc/backstab_assist")
    w903("require/features/misc/spin_on_dead_enemies")
    w903("require/features/misc/localdebug")

    
    w903("require/features/paint/world_hitmarker_plus")
    w903("require/features/paint/onshot_skeleton")
    w903("require/features/paint/damage")
    w903("require/features/paint/damage_penetration")
    w903("require/features/paint/aimbot_logs")
    w903("require/features/paint/aspect_ratio")
    w903("require/features/paint/third_person_distance")
    w903("require/features/paint/watermark_solus")
    w903("require/features/paint/watermark_gamesense")
    w903("require/features/paint/entidx")
    w903("require/features/paint/target_info")
    w903("require/features/paint/clantag")
    w903("require/features/paint/indicators_bold")
    w903("require/features/paint/indicators_small")
    w903("require/features/paint/hit_miss_indicator")
    w903("require/features/paint/bomb_esp")
    w903("require/features/paint/presmoke_warning")
    w903("require/features/paint/self_skeleton")
    w903("require/features/paint/performance_mode")
    
    w903("require/features/paint/minimum_damage")
    w903("require/features/paint/filter_console")
    w903("require/features/paint/warnings")
    w903("require/features/paint/text_watermark")
    w903("require/features/paint/bullet_tracer")
    w903("require/features/paint/animations")
    w903("require/features/paint/lagcomp_box")
    w903("require/features/paint/insults")
    w903("require/features/paint/molotov_particles")
    
    

    
    w908.pushlog("The lua has initialized", 4, 255, 255, 0, 255)
    w908.screenlog("The lua has initialized", 4, 255, 255, 255, 255)

    
    local function w909()
        local w910= database.read('cached_credentials')
        if w910 and w910.username and w910.password then
            w908.safe.safe_set(w908.menu_setup.ui.login_username, w910.username)
            w908.safe.safe_set(w908.menu_setup.ui.login_password, w910.password)
            w908.safe.safe_set(w908.menu_setup.ui.cache_credentials, true)
            
            local w911= w908.login.login(w910.username, w910.password)
            if w911 then
                local w912,w913,w914= w908.COLORS.get("green", "log")
                w908.screenlog("Auto-login successful!", 3, w912, w913, w914, 255)
                w908.pushlog("Auto-login successful!", 3, 255, 255, 0, 255)
            else
                local w912,w913,w914= w908.COLORS.get("red", "log")
                w908.screenlog("Auto-login failed!", 3, w912, w913, w914, 255)
                w908.pushlog("Auto-login failed!", 3, 255, 255, 0, 255)
            end
        end
    end

    
    w908.build_menu(w908)
    w908.menu_visibility.setup_callbacks(w908)

    
    local function w915()
        local w916= w908.login.logged_in
        if not w916 then return end
        w908.menu.draw_menu()
        if w908.menu.is_menu_open() then
            local w917= w908.menu.tab_sections()
            local w918, w919= w908.menu.mouse_position()
            local w920= w908.menu.current_tab_index()
            local w921= w908.menu.current_tab()
            local w922, w923= w908.menu.menu_position()
            local w924, w925= w908.menu.menu_size()
        end
    end

    
    local function w926(w927)
        if not w908.menu.is_menu_open() then return end
        if not w908.menu.is_mouse_outside_menu() then
            w927.in_attack = false
        end
    end

    
    local function w928()
        if w908.gc then
            if w908.gc.dynamic then
                w908.gc.dynamic()
            elseif w908.gc.step then
                w908.gc.step(100)
            end
        end
    end

    
    local function w929()
        w909()
        w908.menu_visibility.update(w908)
    end

    w929()

    local w930

    
    client.set_event_callback('setup_command', function(w927)
        w926(w927)
    end)

    client.set_event_callback('paint', function()
        w915()
        
    end)

    client.set_event_callback('paint_ui', function()

        if not w908.menu.is_menu_open() then return end
        local w921= w908.menu.current_tab()

        w908.menu_setup.toggle_gamesense_menu(false)

        if w921 ~= w930 then
            w930 = w921
            w908.menu_visibility.update(w908)
        end

    end)

    client.set_event_callback('shutdown', function(w927)
        w908.menu_setup.toggle_gamesense_menu(true)
    end)
end

_G.loader_init_after_hwid = w907
w903("require/abc/hwid_check")]]

return w210("main")
