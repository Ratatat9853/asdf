
local d958= {}
local d959= {}
local d960= require

local function d961(d962)
    if d959[d962] then
        return d959[d962]
    end

    local d963= d958[d962]
    if not d963 then
        return d960(d962)
    end
    local d964= {}
    setmetatable(d964, { __index = _G })
    d964.require = d961

    local d965, d966
    if type(setfenv) == "function" then
        d965, err = load(d963, d962)
        if not d965 then
            error("Failed to load module: " .. d962 .. " (" .. tostring(d966) .. ")")
        end
        setfenv(d965, d964)
    else
        d965, err = load(d963, d962, nil, d964)
        if not d965 then
            error("Failed to load module: " .. d962 .. " (" .. tostring(d966) .. ")")
        end
    end

    local d967= d965()
    d959[d962] = d967 or true
    return d959[d962]
end

d958["require/aa/player_condition"] = [[
local d342= require("require/help/libs")
local d343= d342.get("antiaim_funcs")
local d344= d342.get("entity") or d344
local d345= d342.get("bit") or d345
local d346= require('require/abc/menu_setup')
local d347= { last_air = false, last_tick = 0, last_cond = nil }

local function d348(d349)
    if d349 == 'global' then return true end
    if not d346 or not d346.ui then return true end
    local d350= 'enable_' .. d349
    local d351= d346.ui[d350]
    if not d351 then
        return true
    end
    local d352, d353= pcall(ui.get, d351)
    return d352 and d353 == true
end


local function d354()
    local d355= d344.get_local_player()
    if not d355 or not d344.is_alive(d355) then
        return nil
    end
    
    if client.key_state(0x45) then
        if d348('legit') then return "legit" end
    end

    local d356= false
    if d343 and d343.get_double_tap then
        d356 = d343.get_double_tap()
    else
        d356 = true
    end

    if d356 == false then
        if d348('fakelag') then return "fakelag" end
    end

    if misc_gs_hotkey_slowmotion and ui.get(misc_gs_hotkey_slowmotion) == true then
        if d348('walk') then return "walk" end
    end
    
    if client.key_state(0x10) then
        local d357, d358= d344.get_prop(d355, 'm_vecVelocity')
        local d359= math.sqrt((d357 or 0)^2 + (d358 or 0)^2)
        if d359 >= 20 and d359 <= 140 then
            if d348('walk') then return "walk" end
        end
    end

    local d357, d358= d344.get_prop(d355, 'm_vecVelocity')
    local d359= math.sqrt((d357 or 0)^2 + (d358 or 0)^2)
    local d360= d344.get_prop(d355, 'm_flDuckAmount') > 0.5
    local d361= d345.band(d344.get_prop(d355, 'm_fFlags') or 0, 1) == 1
    local d362= globals.tickcount()

    if not d361 then
        if d360 then
            d347.last_air = true
            d347.last_tick = d362
            d347.last_cond = "jump+"
            if d348('jump+') then return "jump+" end
        else
            d347.last_air = true
            d347.last_tick = d362
            d347.last_cond = "jump"
            if d348('jump') then return "jump" end
        end
    else
        if d347.last_air and (d362 - d347.last_tick <= 2) then
            if d347.last_cond and d348(d347.last_cond) then
                return d347.last_cond
            end
        end
        d347.last_air = false
        d347.last_cond = nil
    end

    if d360 then
        if d359 >= 2 then
            if d348('duck+') then return "duck+" end
        else
            if d348('duck') then return "duck" end
        end
    else
        if d359 >= 2 then
            if d348('move') then return "move" end
        else
            if d348('stand') then return "stand" end
        end
    end

    return "global"
end

return {
    get = d354
}]]
d958["require/abc/build_menu"] = [[tab = {
    "RAGE",
    "AA",
    "LEGIT",
    "VISUALS",
    "MISC",
    "PLIST",
    "CONFIG",
    "LUA"
}

cont = {
    {
        "Aimbot",
        "Other"
    },
    {
        "Anti-aimbot angles",
        "Fake lag",
        "Other"
    },
    {},
    {
        "Player ESP",
        "Other ESP",
        "Colored models",
        "Effects"
    },
    {},
    {},
    {},
    {
        "A",
        "B",
    }
}

local d345= {
    "global",
    "stand",
    "move",
    "duck",
    "duck+",
    "jump",
    "jump+",
    "walk",
    "fakelag",
    "legit",
}

local d346= require("require/abc/menu_setup")
local d347= require("require/help/color")
local d348= require("require/abc/screen_logger")
local d349= require("require/help/emojis")

local function d350(d351)
    local d352= 'inDGnidgdisgndsin'

    local function d353()
        local d354= database.read(d352)
        return type(d354) == 'table' and d354 or {}
    end

    local function d355(d354)
        database.write(d352, d354)
    end

    local function d356(d354,d357)
        for i = 1, #d354 do if d354[i] == d357 then return i end end
        return nil
    end

    local function d358()
        if not (d351 and d351.menu_setup and d351.menu_setup.ui and d351.menu_setup.ui.paint_logger) then
            return false
        end
        local d359, d360= pcall(ui.get, d351.menu_setup.ui.paint_logger)
        if not d359 or not d360 then return false end
        if type(d360) == 'table' then
            for _, v in ipairs(d360) do
                if tostring(v) == 'config' then return true end
            end
            return false
        else
            return tostring(d360) == 'config'
        end
    end

    local function d361(d362)
        local d363= d353()
        if #d363 == 0 then d363 = {'(empty)'} end
            if d346.ui.cfg_listbox then
                pcall(ui.set_visible, d346.ui.cfg_listbox, false)
            end
            d346.ui.cfg_listbox = d346.register_ui(
                ui.new_listbox(tab[2], cont[2][1], 'Configs', d363),
                { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
            )
        if d362 then
            local d364= d356(d363, d362)
            if d364 then ui.set(d346.ui.cfg_listbox, d364-1) end
        end
    end
 
    
    
    
    d346.ui.cache_credentials = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("pin") .. d347.get("default", "ui") .. 'Cache credentials'),
        { requires_login = false, key = 'cache_credentials', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    d346.ui.login_username = d346.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Username', 'username'),
        { requires_login = false, key = 'login_username', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    d346.ui.login_password = d346.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Password', 'password'),
        { requires_login = false, key = 'login_password', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    d346.ui.login_howto_header = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], d347.get("grey", "ui") .. '───────[ ' .. d347.get("white", "ui") .. 'How to ' .. d347.get("green", "ui") .. 'log in' .. d347.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'login_howto_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.login_console_register = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], d347.get("grey", "ui") .. '1. In console -> "register ' .. d347.get("green", "ui") .. 'user' .. d347.get("grey", "ui") .. ' ' .. d347.get("red", "ui") .. 'pass' .. d347.get("grey", "ui") .. ' ' .. d347.get("blue", "ui") .. 'code' .. d347.get("grey", "ui") .. '"'),
        { requires_login = false, key = 'login_console_register', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.login_menu_credentials = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], d347.get("grey", "ui") .. '2. Write password & username in the menu.'),
        { requires_login = false, key = 'login_menu_credentials', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.login_press_login = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], d347.get("grey", "ui") .. '3. Press log in and enjoy ' .. d347.get("green", "ui") .. 'premium features' .. d347.get("grey", "ui") .. '.'),
        { requires_login = false, key = 'login_press_login', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.login_spacer1 = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer1', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.reset_header = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], d347.get("grey", "ui") .. '───────[ ' .. d347.get("white", "ui") .. 'How to ' .. d347.get("yellow", "ui") .. 'reset pass' .. d347.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'reset_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.reset_step1 = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], d347.get("grey", "ui") .. '1. Write username -> press reset.'),
        { requires_login = false, key = 'reset_step1', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.reset_step2 = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], d347.get("grey", "ui") .. '2. Login with your oldest password.'),
        { requires_login = false, key = 'reset_step2', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.login_spacer2 = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer2', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.support_header = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], d347.get("grey", "ui") .. '───────[ ' .. d347.get("red", "ui") .. 'Support & Other' .. d347.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'support_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.support_discord = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], d347.get("grey", "ui") .. '1. Join the ' .. d347.get("discord", "ui") .. 'discord ' .. d347.get("grey", "ui") .. 'for support.'),
        { requires_login = false, key = 'support_discord', tab = 'AA', visible = true, config_type = 'label' }
    )

    d346.ui.login_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("lock_open") .. d347.get("default", "ui") .. 'Login', function()
            local d365= d351.safe.safe_get(d346.ui.login_username)
            local d366= d351.safe.safe_get(d346.ui.login_password)
            local d367= d351.safe.safe_get(d346.ui.cache_credentials)
            if d365 ~= '' and d366 ~= '' then
                local d368= d351.login.login(d365, d366)
                if d368 then
                    d351.pushlog("Welcome back, " .. d351.str.capitalize(d365) .. ". You logged in successfully.", 3, 75, 145, 55, 255)
                    if d367 then
                        database.write('cached_credentials', { username = d365, password = d366 })
                    else
                        database.write('cached_credentials', nil)
                    end
                    local d369,d370,d371= d347.get("green", "log")
                    d351.screenlog("Login successful!", 4, d369, d370, d371, 255)
                else
                    local d369,d370,d371= d347.get("red", "log")
                    d351.screenlog("Login failed!", 4, d369, d370, d371, 255)
                end
            end
                if d351.menu_visibility and d351.menu_visibility.update then
                    d351.menu_visibility.update(d351)
                end
        end),
        { requires_login = false, key = 'login_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    d346.ui.logout_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][3], d347.get("red", "ui") .. d349.get("lock") .. d347.get("default", "ui") .. 'Logout', function()
            d351.login.logout()
            local d369,d370,d371= d347.get("red", "log")
            d351.screenlog("Logged out!", 4, d369, d370, d371, 255)
                if d351.menu_visibility and d351.menu_visibility.update then
                    d351.menu_visibility.update(d351)
                end
        end),
        { requires_login = true, key = 'logout_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    d346.ui.reset_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][1], d347.get("yellow", "ui") .. d349.get("warning") .. d347.get("default", "ui") .. 'Reset', function()
            local d365= d351.safe.safe_get(d346.ui.login_username)
            d351.login.reset_password(d365)
            local d369,d370,d371= d347.get("yellow", "log")
            d351.screenlog("Password reset.", 4, d369, d370, d371, 255)
            d351.pushlog("Password reset for user: " .. d365, 5, 255, 255, 0, 255)
                if d351.menu_visibility and d351.menu_visibility.update then
                    d351.menu_visibility.update(d351)
                end
        end),
        { requires_login = true, key = 'reset_button', tab = 'AA', visible = true, config_type = 'button' }
    )

    d346.ui.discord_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][3], d347.get("discord", "ui") .. d349.get("chat") .. d347.get("default", "ui") .. 'Discord', function()
            local d372= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            d351.safe.safe_set(d372, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://discord.gg/a2bFbVWWg9')
        end),
        { requires_login = true, key = 'discord_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    d346.ui.youtube_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][3], d347.get("youtube", "ui") .. d349.get("play") .. d347.get("default", "ui") .. 'YouTube', function()
            local d372= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            d351.safe.safe_set(d372, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://www.youtube.com/@vile-gs/videos')
        end),
        { requires_login = true, key = 'youtube_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    d346.ui.sellhub_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][3], d347.get("sellhub", "ui") .. d349.get("folder") .. d347.get("default", "ui") .. 'Sellhub', function()
            local d372= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            d351.safe.safe_set(d372, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://sodium.sellhub.cx/#products-list')
        end),
        { requires_login = true, key = 'sellhub_button', tab = 'AA', visible = true, config_type = 'button' }
    )


    
    
    
    d346.ui.condition_label = d346.register_ui(
        ui.new_label(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("menu") .. d347.get("default", "ui") .. 'Condition', unpack(d345)),
        { requires_login = true, key = 'condition_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.condition = d346.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nCondition', unpack(d345)),
        { requires_login = true, key = 'condition', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    d346.ui.condition_label2 = d346.register_ui(
        ui.new_label(tab[2], cont[2][1], '\ncondition label'),
        { requires_login = true, key = 'condition_label2', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.misc_resolver = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("wrench") .. d347.get("default", "ui") .. 'Resolver'),
        { requires_login = true, key = 'misc_resolver', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    d346.ui.misc_ragebot = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("arrow_double") .. d347.get("default", "ui") .. 'Ragebot'),
        { requires_login = true, key = 'misc_ragebot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    d346.ui.misc_dormantaimbot = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("time") .. d347.get("default", "ui") .. 'Dormant aimbot'),
        { requires_login = true, key = 'misc_dormantaimbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    d346.ui.misc_dormantaimbot_key = d346.register_ui(
        ui.new_hotkey(tab[2], cont[2][1], '\ndormant aimbot key', true),
        { requires_login = true, key = 'misc_dormantaimbot_key', tab = 'MISC', visible = true, config_type = 'hotkey' }
    )
    d346.ui.misc_dormantaimbot_value = d346.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\ndormant aimbot value', 60, 100, 0, true, '%'),
        { requires_login = true, key = 'misc_dormantaimbot_value', tab = 'MISC', visible = true, config_type = 'slider' }
    )
    d346.ui.misc_exploit_fakelag = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("latency3") .. d347.get("default", "ui") .. 'Limit exploit fakelag'),
        { requires_login = true, key = 'misc_exploit_fakelag', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    d346.ui.misc_walkbot = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("arrow_up") .. d347.get("default", "ui") .. 'Walkbot'),
        { requires_login = true, key = 'misc_walkbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    d346.ui.misc_backstab = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("triangle_upside") .. d347.get("default", "ui") .. 'Backstab Assist'),
        { requires_login = true, key = 'misc_backstab', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    d346.ui.misc_spindead = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("turning2") .. d347.get("default", "ui") .. 'Spin on dead enemies'),
        { requires_login = true, key = 'misc_spindead', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    d346.ui.aa_gskey_freestandh = d346.register_ui(
        ui.new_label(tab[2], cont[2][3], d347.get("green", "ui") .. d349.get("turning2") .. d347.get("default", "ui") .. 'Freestand'),
        { requires_login = false, key = 'aa_gskey_freestandh', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.aa_gskey_freestand = d346.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'freestand', true),
        { requires_login = true, key = 'aa_gskey_freestand', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    d346.ui.aa_gskey_slowmotionh = d346.register_ui(
        ui.new_label(tab[2], cont[2][3], d347.get("green", "ui") .. d349.get("gear") .. d347.get("default", "ui") .. 'Slowmotion'),
        { requires_login = false, key = 'aa_gskey_slowmotionh', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.aa_gskey_slowmotion = d346.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'slowmotion', true),
        { requires_login = true, key = 'aa_gskey_slowmotion', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    d346.ui.aa_gskey_edgeyawh = d346.register_ui(
        ui.new_label(tab[2], cont[2][3], d347.get("green", "ui") .. d349.get("recycle") .. d347.get("default", "ui") .. 'Edge Yaw'),
        { requires_login = false, key = 'aa_gskey_edgeyawh', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.aa_gskey_edgeyaw = d346.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'edge yaw', true),
        { requires_login = true, key = 'aa_gskey_edgeyaw', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    d346.ui.aa_gskey_onshoth = d346.register_ui(
        ui.new_label(tab[2], cont[2][3], d347.get("green", "ui") .. d349.get("arrow_double") .. d347.get("default", "ui") .. 'On-shot aa'),
        { requires_login = false, key = 'aa_gskey_onshoth', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.aa_gskey_onshot = d346.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'on-shot aa', true),
        { requires_login = true, key = 'aa_gskey_onshot', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    
    for _, cond in ipairs(d345) do
        local d373= 'enable_' .. cond
        d346.ui[d373] = d346.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("accept") .. d347.get("default", "ui") .. 'Enable ' .. cond),
            { requires_login = true, key = d373, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        d346.ui['pitch_' .. cond] = d346.register_ui(
            ui.new_combobox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("triangle_upside") .. d347.get("default", "ui") .. 'Pitch', 'off', 'up', 'down', 'minimal', 'ideal'),
            { requires_login = true, key = 'pitch_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        d346.ui['yaw_base_' .. cond] = d346.register_ui(
            ui.new_combobox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("recycle") .. d347.get("default", "ui") .. 'Yaw Base', 'target', 'view', 'threat', 'distance', 'smart'),
            { requires_login = true, key = 'yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        d346.ui['yaw_' .. cond] = d346.register_ui(
            ui.new_combobox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("turning2") .. d347.get("default", "ui") .. 'Yaw', 'off', 'spin', '180', '3way', 'ideal'),
            { requires_login = true, key = 'yaw_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        d346.ui['label1_' .. cond] = d346.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label1_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        d346.ui['body_yaw_base_' .. cond] = d346.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Base', -90, 90, 0, true, '°'),
            { requires_login = true, key = 'body_yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        d346.ui['body_yaw_left_' .. cond] = d346.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Left', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_left_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        d346.ui['body_yaw_right_' .. cond] = d346.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Right', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_right_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        d346.ui['randomize_yaw_' .. cond] = d346.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Randomize Yaw', 0, 30, 0, true, '%', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'randomize_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        d346.ui['label2_' .. cond] = d346.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label2_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        d346.ui['yaw_jitter_' .. cond] = d346.register_ui(
            ui.new_combobox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("turning") .. d347.get("default", "ui") .. 'Yaw Jitter', 'off', 'center', 'skitter'),
            { requires_login = true, key = 'yaw_jitter_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        d346.ui['yaw_jitter_base_' .. cond] = d346.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Yaw Jitter - Base', 0, 120, 0, true, '°', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'yaw_jitter_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        d346.ui['body_yaw_mode_' .. cond] = d346.register_ui(
            ui.new_combobox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("gear") .. d347.get("default", "ui") .. 'Body Yaw Mode', 'off', 'static', 'opposite', 'jitter'),
            { requires_login = true, key = 'body_yaw_mode_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        d346.ui['static_body_yaw_' .. cond] = d346.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Static Body Yaw', -58, 58, 0, true, '°'),
            { requires_login = true, key = 'static_body_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        d346.ui['body_yaw_value_' .. cond] = d346.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw Value', 1, 3, 2, true, '', 2, {
                [1] = 'left', [2] = 'back', [3] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_value_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        d346.ui['delay_' .. cond] = d346.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Delay', 0, 17, 1, true, 't', 1, {
                [0] = 'jitter'
            }),
            { requires_login = true, key = 'delay_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        d346.ui['label3_' .. cond] = d346.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label3_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        d346.ui['fifty_fifty_' .. cond] = d346.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("question") .. d347.get("default", "ui") .. '50/50'),
            { requires_login = true, key = 'fifty_fifty_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        d346.ui['only_flip_on_0_choke_' .. cond] = d346.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("time") .. d347.get("default", "ui") .. 'Only Flip on 0 Choke'),
            { requires_login = true, key = 'only_flip_on_0_choke_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        d346.ui['aa_label_space' .. cond] = d346.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n abc'),
            { requires_login = true, key = 'aa_label_space', tab = 'AA', visible = true, config_type = 'label' }
        )
        d346.ui['aa_label_combo' .. cond] = d346.register_ui(
            ui.new_label(tab[2], cont[2][1], 'Send state -> state'),
            { requires_login = true, key = 'aa_label_combo', tab = 'AA', visible = true, config_type = 'label' }
        )
        d346.ui['send_combo' .. cond] = d346.register_ui(
            ui.new_combobox(tab[2], cont[2][1], '\n', unpack(d345)),
            { requires_login = true, key = 'send_combo' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        d346.ui['send_button' .. cond] = d346.register_ui(
            ui.new_button(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("upload") .. d347.get("default", "ui") .. 'Send', function() end),
            { requires_login = true, key = 'send_button', tab = 'AA', visible = true, config_type = 'button' }
        )

    end


    
    
    
    d346.ui.fakelag_mode = d346.register_ui(
        ui.new_combobox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("gear") .. d347.get("default", "ui") .. 'Mode', 'defensive', 'stealer', 'fakelag', 'settings'),
        { requires_login = true, key = 'fakelag_mode', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    d346.ui.fakelag_defensive = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("turning2") .. d347.get("default", "ui") .. 'Defensive'),
        { requires_login = true, key = 'fakelag_defensive', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    d346.ui.fakelag_force = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("exclamation") .. d347.get("default", "ui") .. 'Force'),
        { requires_login = true, key = 'fakelag_force', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    d346.ui.fakelag_fakedef = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("globe") .. d347.get("default", "ui") .. 'Unmatched.gg'),
        { requires_login = true, key = 'fakelag_fakedef', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    d346.ui.fakelag_force_on = d346.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("clip") .. d347.get("default", "ui") .. 'Force whilst', 'peek', 'reload', 'shot', 'damaged'),
        { requires_login = true, key = 'fakelag_force_on', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    
    
    
    d346.ui.cfg_load_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("arrow_double") .. d347.get("default", "ui") .. 'Load', function()
            local d363= d353()
            local d364= ui.get(d346.ui.cfg_listbox)
            local d374= d363[(d364 or 0) + 1]
            local d375= ui.get(d346.ui.cfg_input_box)
            local d357= (d374 and d374 ~= '(empty)' and d374 ~= '') and d374 or d375

            if d357 and d357 ~= '' and d357 ~= '(empty)' then
                local d376= require("require/abc/config_system")
                local function d377()
                    if not d346.ui.cfg_selection then return nil end
                    local d359, d378= pcall(ui.get, d346.ui.cfg_selection)
                    if not d359 or not d378 or type(d378) ~= 'table' or #d378 == 0 then return nil end
                    local d379= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local d380= {}
                    for _, v in ipairs(d378) do
                        local d354= d379[tostring(v)]
                        if d354 then d380[#d380+1] = d354 end
                    end
                    if #d380 == 0 then return nil end
                    return d380
                end
                local d381= d377()
                d376.load(d357, d381)
                d351.screenlog('[Config] Loaded config: ' .. d357, 4, 120, 180, 255, 255)
                if d351 and d351.pushlog and d358() then
                    d351.pushlog('Loaded config: ' .. d357, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for load.')
                if d351 and d351.pushlog and d358() then
                    d351.pushlog('No config name selected for load.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_load_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    d346.ui.cfg_save_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("config") .. d347.get("default", "ui") .. 'Save', function()
            local d363= d353()
            local d364= ui.get(d346.ui.cfg_listbox)
            local d374= d363[(d364 or 0) + 1]
            local d375= ui.get(d346.ui.cfg_input_box)
            local d357= (d374 and d374 ~= '(empty)' and d374 ~= '') and d374 or d375

            if d357 and d357 ~= '' then
                local d376= require("require/abc/config_system")
                local function d377()
                    if not d346.ui.cfg_selection then return nil end
                    local d359, d378= pcall(ui.get, d346.ui.cfg_selection)
                    if not d359 or not d378 or type(d378) ~= 'table' or #d378 == 0 then return nil end
                    local d379= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local d380= {}
                    for _, v in ipairs(d378) do
                        local d354= d379[tostring(v)]
                        if d354 then d380[#d380+1] = d354 end
                    end
                    if #d380 == 0 then return nil end
                    return d380
                end
                local d381= d377()
                d376.save(d357, d381)
                local d363= d353()
                if not d356(d363, d357) then
                    d363[#d363+1] = d357
                    d355(d363)
                end
                d361(d357)
                d351.screenlog('[Config] Saved config: ' .. d357, 4, 120, 180, 255, 255)
                if d351 and d351.pushlog and d358() then
                    d351.pushlog('Saved config: ' .. d357, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name provided for save.')
                if d351 and d351.pushlog and d358() then
                    d351.pushlog('No config name provided for save.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_save_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    d346.ui.cfg_create_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("plus") .. d347.get("default", "ui") .. 'Create', function()
            local d375= ui.get(d346.ui.cfg_input_box)
            if not d375 or d375 == '' then
                client.error_log('[Config] No config name provided for create.')
                if d351 and d351.pushlog and d358() then
                    d351.pushlog('No config name provided for create.', 4, 255, 255, 255, 255)
                end
                return
            end

            local d363= d353()
            if d356(d363, d375) then
                client.error_log('[Config] Config with that name already exists: ' .. d375)
                if d351 and d351.pushlog and d358() then
                    d351.pushlog('Config already exists: ' .. d375, 4, 255, 255, 255, 255)
                end
                return
            end

            local d376= require("require/abc/config_system")
            local function d377()
                if not d346.ui.cfg_selection then return nil end
                local d359, d378= pcall(ui.get, d346.ui.cfg_selection)
                if not d359 or not d378 or type(d378) ~= 'table' or #d378 == 0 then return nil end
                local d379= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local d380= {}
                for _, v in ipairs(d378) do
                    local d354= d379[tostring(v)]
                    if d354 then d380[#d380+1] = d354 end
                end
                if #d380 == 0 then return nil end
                return d380
            end
            local d381= d377()
            d376.save(d375, d381)
            d363[#d363+1] = d375
            d355(d363)
            d361(d375)
            d351.screenlog('[Config] Created config: ' .. d375, 4, 120, 180, 255, 255)
            if d351 and d351.pushlog and d358() then
                d351.pushlog('Created config: ' .. d375, 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_create_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    d346.ui.cfg_delete_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][1], d347.get("red", "ui") .. d349.get("trash") .. d347.get("default", "ui") .. 'Delete', function()
            local d363= d353()
            local d364= ui.get(d346.ui.cfg_listbox)
            local d374= d363[(d364 or 0) + 1]
            local d375= ui.get(d346.ui.cfg_input_box)
            local d357= (d374 and d374 ~= '(empty)' and d374 ~= '') and d374 or d375

            if d357 and d357 ~= '' and d357 ~= '(empty)' then
                local d376= require("require/abc/config_system")
                d376.delete(d357)
                local d363= d353()
                local d364= d356(d363, d357)
                if d364 then
                    table.remove(d363, d364)
                    d355(d363)
                end
                d361()
                d351.screenlog('[Config] Deleted config: ' .. d357, 4, 255, 80, 80, 255)
                if d351 and d351.pushlog and d358() then
                    d351.pushlog('Deleted config: ' .. d357, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for delete.')
                if d351 and d351.pushlog and d358() then
                    d351.pushlog('No config name selected for delete.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_delete_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    d346.ui.cfg_refresh_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("turning") .. d347.get("default", "ui") ..'Refresh', function()
            d361()
            d351.screenlog('[Config] Refreshed config list.', 4, 120, 180, 255, 255)
            if d351 and d351.pushlog and d358() then
                d351.pushlog('Refreshed config list.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_refresh_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    
    local d376= require("require/abc/config_system")
    local d382, d383= pcall(require, 'gamesense/clipboard')
    local d384= d383
    if not d382 or not d384 then
        d384 = {
            set = function(d385) end,
            get = function() return '' end,
        }
    end


    d346.ui.cfg_export_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("upload") .. d347.get("default", "ui") .. 'Export', function()
            local function d377()
                if not d346.ui.cfg_selection then return nil end
                local d359, d378= pcall(ui.get, d346.ui.cfg_selection)
                if not d359 or not d378 or type(d378) ~= 'table' or #d378 == 0 then return nil end
                local d379= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local d380= {}
                for d385, v in ipairs(d378) do
                    local d354= d379[tostring(v)]
                    if d354 then d380[#d380+1] = d354 end
                end
                if #d380 == 0 then return nil end
                return d380
            end
            local d381= d377()
            local d386= d376.build(d381)
            d384.set(d386)
            client.log('[Config] Exported config string:')
            client.log(d386)
            d351.screenlog('[Config] Exported config string to clipboard and console.', 4, 120, 180, 255, 255)
            if d351 and d351.pushlog and d358() then
                d351.pushlog('Exported config string to clipboard.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_export_button', tab = 'CFG', visible = true, config_type = 'button' }
    )

    d346.ui.cfg_import_button = d346.register_ui(
        ui.new_button(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("download") .. d347.get("default", "ui") .. 'Import', function()
            local d387= d384.get()
            if d387 and d387 ~= '' then
                local function d377()
                    if not d346.ui.cfg_selection then return nil end
                    local d359, d378= pcall(ui.get, d346.ui.cfg_selection)
                    if not d359 or not d378 or type(d378) ~= 'table' or #d378 == 0 then return nil end
                    local d379= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local d380= {}
                    for d385, v in ipairs(d378) do
                        local d354= d379[tostring(v)]
                        if d354 then d380[#d380+1] = d354 end
                    end
                    if #d380 == 0 then return nil end
                    return d380
                end
                local d381= d377()
                d376.apply(d387, d381)
                d351.screenlog('[Config] Imported config string from clipboard.', 4, 120, 180, 255, 255)
                if d351 and d351.pushlog and d358() then
                    d351.pushlog('Imported config string from clipboard.', 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config string found in clipboard.')
                if d351 and d351.pushlog and d358() then
                    d351.pushlog('No config string found in clipboard for import.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_import_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    d346.ui.cfg_selection = d346.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\n selection', 'antiaim', 'paint', 'misc'),
        { requires_login = true, key = 'cfg_selection', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    d346.ui.cfg_input_box = d346.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Config name'),
        { requires_login = true, key = 'cfg_input_box', tab = 'CFG', visible = true, config_type = 'textbox' }
    )
    d346.ui.cfg_listbox = d346.register_ui(
        ui.new_listbox(tab[2], cont[2][1], 'Configs', {}),
        { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    d361()

    d346.ui.cfg_cloud_apply = d346.register_ui(
        ui.new_button(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("globe") .. d347.get("default", "ui") .. ' Apply cloud', function()
            local d359, d378= pcall(ui.get, d346.ui.cfg_cloud)
            if not d359 then
                client.log('cfg_cloud_apply: failed to read selection')
                return
            end

            local d388= { 'Reset', 'Defensive', 'Unmatched', 'Community' }
            local d357= nil

            if type(d378) == 'number' then
                local d364= d378 + 1
                d357 = d388[d364]
            elseif type(d378) == 'table' then
                if #d378 > 0 and type(d378[1]) == 'number' then
                    d357 = d388[d378[1] + 1]
                else
                    d357 = tostring(d378[1])
                end
            else
                d357 = tostring(d378)
            end

            if not d357 or d357 == '' then
                client.log('cfg_cloud_apply: no selection')
                return
            end

            local d389, d390= pcall(require, 'require/abc/config_cloud')
            if not d389 or not d390 then
                client.log('cfg_cloud_apply: failed to load config_cloud module')
                return
            end

            local d391= d390[d357]
            if not d391 then
                client.log('cfg_cloud_apply: no cloud config string for', tostring(d357))
                return
            end

            local d392, d376= pcall(require, 'require/abc/config_system')
            if not d392 or not d376 or not d376.apply then
                client.log('cfg_cloud_apply: config_system.apply not available')
                return
            end

            d376.apply(d391)
            client.log('cfg_cloud_apply: applied cloud config', tostring(d357))
        end),
        { requires_login = true, key = 'cfg_cloud_apply', tab = 'AA', visible = true, config_type = 'button' }
    )

    d346.ui.cfg_cloud = d346.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'Cloud', { d347.get("red", "ui") .. 'Reset', d347.get("reddark", "ui") .. 'Defensive', d347.get("yellow", "ui") .. 'Unmatched', d347.get("grey", "ui") .. 'Community'}),
        { requires_login = true, key = 'cfg_cloud', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    d346.ui.fakelag_stealer = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("download") .. d347.get("default", "ui") .. 'Stealer' .. d347.get("blue", "ui") .. ' [BETA]' ),
        { requires_login = true, key = 'fakelag_stealer', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    d346.ui.fakelag_stealer_type = d346.register_ui(
        ui.new_combobox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("gear") .. d347.get("default", "ui") .. 'Type', 'mimic', 'import'),
        { requires_login = true, key = 'fakelag_stealer_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    d346.ui.fakelag_stealer_target = d346.register_ui(
        ui.new_combobox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("id") .. d347.get("default", "ui") .. 'Target', 'threat', 'closest', 'random', 'best kdas'),
        { requires_login = true, key = 'fakelag_stealer_target', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    d346.ui.fakelag_stealer_list = d346.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'target list', {'-'}),
        { requires_login = true, key = 'fakelag_stealer_list', tab = 'AA', visible = true, config_type = 'listbox' }
    )
    d346.ui.fakelag_stealer_refresh = d346.register_ui(
        ui.new_button(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("refresh") .. d347.get("default", "ui") .. 'Refresh', function() end),
        { requires_login = true, key = 'fakelag_stealer_refresh', tab = 'AA', visible = true, config_type = 'button' }
    )
    d346.ui.fakelag_stealer_steal = d346.register_ui(
        ui.new_button(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("clip") .. d347.get("default", "ui") .. 'Steal', function() end),
        { requires_login = true, key = 'fakelag_stealer_steal', tab = 'AA', visible = true, config_type = 'button' }
    )
    d346.ui.fakelag_fakelag = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("latency3") .. d347.get("default", "ui") .. 'Fakelag'),
        { requires_login = true, key = 'fakelag_fakelag', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    d346.ui.fakelag_fakelag_type = d346.register_ui(
        ui.new_combobox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("gear") .. d347.get("default", "ui") .. 'Type', 'gamesense', 'sodium'),
        { requires_login = true, key = 'fakelag_fakelag_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    d346.ui.fakelag_fakelag_amount = d346.register_ui(
        ui.new_combobox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("plus") .. d347.get("default", "ui") .. 'Amount', 'dynamic', 'maximum', 'fluctuate'),
        { requires_login = true, key = 'fakelag_fakelag_amount', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    d346.ui.fakelag_fakelag_variance = d346.register_ui(
        ui.new_slider(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("recycle") .. d347.get("default", "ui") .. 'Variance', 0, 100, 0, true, '%'),
        { requires_login = true, key = 'fakelag_fakelag_variance', tab = 'AA', visible = true, config_type = 'slider' }
    )
    d346.ui.fakelag_fakelag_limit = d346.register_ui(
        ui.new_slider(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("lock") .. d347.get("default", "ui") .. 'Limit', 1, 15, 1, true, 't'),
        { requires_login = true, key = 'fakelag_fakelag_limit', tab = 'AA', visible = true, config_type = 'slider' }
    )
    d346.ui.fakelag_fakelag_type2 = d346.register_ui(
        ui.new_combobox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("config") .. d347.get("default", "ui") .. 'Preset', 'jitter', 'max'),
        { requires_login = true, key = 'fakelag_fakelag_type2', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    d346.ui.fakelag_settings_freestanding = d346.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("turning2") .. d347.get("default", "ui") .. 'Freestanding options', 'static', 'zero pitch', 'defensive', 'side flip', 'pitch flip'),
        { requires_login = true, key = 'fakelag_settings_freestanding', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    d346.ui.fakelag_settings_enhance_onshot = d346.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("arrow_double") .. d347.get("default", "ui") .. 'Enhance on-shot aa', 'defensive', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_enhance_onshot', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    d346.ui.fakelag_settings_antibrute = d346.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("exclamation") .. d347.get("default", "ui") .. 'Antibrute', 'defensive', 'flip', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_antibrute', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    d346.ui.fakelag_settings_roll_checkbox = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], '\nuse roll'),
        { requires_login = true, key = 'fakelag_settings_roll_checkbox', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    d346.ui.fakelag_settings_roll_label = d346.register_ui(
        ui.new_label(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("recycle") .. d347.get("default", "ui") .. 'Roll'),
        { requires_login = false, key = 'label_roll', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.fakelag_settings_roll = d346.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nroll', 0, 45, 0, true, '°'),
        { requires_login = true, key = 'fakelag_settings_roll', tab = 'AA', visible = true, config_type = 'slider' }
    )
    d346.ui.fakelag_settings_side = d346.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nside', 1, 3, 1, true, '', 1, {
            [1] = 'left', [2] = 'swap', [3] = 'right'
        }),
        { requires_login = true, key = 'fakelag_settings_side', tab = 'AA', visible = true, config_type = 'slider' }
    )

    
    
    
    d346.ui.paint_advertisement = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nadvertisement', true),
        { requires_login = true, key = 'paint_advertisement', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_advertisement_animation = d346.register_ui(
        ui.new_slider(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("speaker") .. d347.get("default", "ui") .. 'Advertisement', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_advertisement_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    d346.ui.paint_advertisement_color = d346.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'rizz546456', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_advertisement_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    d346.ui.paint_watermark = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nwatermark'),
        { requires_login = true, key = 'paint_watermark', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_watermark_type = d346.register_ui(
        ui.new_slider(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("text") .. d347.get("default", "ui") .. 'Watermark', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_watermark_type', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    d346.ui.paint_watermark_color = d346.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'sigma9745', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_watermark_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    d346.ui.label_space2 = d346.register_ui(
        ui.new_label(tab[2], cont[2][1], '\n abc'),
        { requires_login = false, key = 'label_space2', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.label_space3 = d346.register_ui(
        ui.new_label(tab[2], cont[2][1], d347.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space3', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.paint_entidx = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'entidx'),
        { requires_login = true, key = 'paint_entidx', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_target_info = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'target info'),
        { requires_login = true, key = 'paint_target_info', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_filter_console = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'filter console'),
        { requires_login = true, key = 'paint_filter_console', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_minimum_damage = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'minimum damage'),
        { requires_login = true, key = 'paint_minimum_damage', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_show_damage_penetration = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'show damage penetration'),
        { requires_login = true, key = 'paint_show_damage_penetration', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_hitmiss_indicator = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'hit/miss indicator'),
        { requires_login = true, key = 'paint_hitmiss_indicator', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_self_skeleton = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'self skeleton'),
        { requires_login = true, key = 'paint_self_skeleton', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_bullet_tracer = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'bullet tracer'),
        { requires_login = true, key = 'paint_bullet_tracer', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_lagcomp_box = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lagcomp box'),
        { requires_login = true, key = 'paint_lagcomp_box', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_lagcomp_box_color = d346.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'lagcomp box color', 47, 117, 221, 255),
        { requires_login = true, key = 'paint_lagcomp_box_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    d346.ui.paint_presmoke = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'presmoke warning'),
        { requires_login = true, key = 'paint_presmoke', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_bombwarning = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'c4 warning'),
        { requires_login = true, key = 'paint_bombwarning', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_insults = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'insults'),
        { requires_login = true, key = 'paint_insults', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_rainbow_esp = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'rainbow esp'),
        { requires_login = true, key = 'paint_rainbow_esp', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_molotov = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'molotov particles'),
        { requires_login = true, key = 'paint_molotov', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_lag_record = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lag record'),
        { requires_login = true, key = 'paint_lag_record', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.label_space4 = d346.register_ui(
        ui.new_label(tab[2], cont[2][1], d347.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space4', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.paint_clantag = d346.register_ui(
        ui.new_combobox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("id") .. d347.get("default", "ui") .. 'Clantag', 'off', 'gamesense', 'sodium'),
        { requires_login = true, key = 'paint_clantag', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    d346.ui.paint_aimbot_logs = d346.register_ui(
        ui.new_combobox(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("clipboard") .. d347.get("default", "ui") .. 'Aimbot logs', 'off', 'gamesense', 'gamesense beta', 'sodium'),
        { requires_login = true, key = 'paint_aimbot_logs', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    d346.ui.label_space1 = d346.register_ui(
        ui.new_label(tab[2], cont[2][1], '\nextra space'),
        { requires_login = false, key = 'label_space1', tab = 'AA', visible = true, config_type = 'label' }
    )
    
    d346.ui.paint_indicators_enable = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n enable'),
        { requires_login = true, key = 'paint_indicators_enable', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_indicators_label = d346.register_ui(
        ui.new_label(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("pallete") .. d347.get("default", "ui") .. 'Indicators'),
        { requires_login = false, key = 'paint_indicators_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.paint_indicators = d346.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nIndicators', 'off', 'small', 'bold'),
        { requires_login = true, key = 'paint_indicators', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    d346.ui.paint_indicator_color = d346.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_indicator_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    d346.ui.paint_indicators_bar = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n bar'),
        { requires_login = true, key = 'paint_indicators_bar', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_indicators_animation = d346.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_indicators_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    d346.ui.paint_logger_checkbox = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n abc'),
        { requires_login = true, key = 'paint_logger_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_logger_label = d346.register_ui(
        ui.new_label(tab[2], cont[2][1], d347.get("green", "ui") .. d349.get("pen") .. d347.get("default", "ui") .. 'Logger'),
        { requires_login = false, key = 'paint_logger_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    d346.ui.paint_logger = d346.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\nLogger', 'aimbot', 'config', 'anti-aim', 'other'),
        { requires_login = true, key = 'paint_logger', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    d346.ui.paint_logger_color = d346.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_logger_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    d346.ui.paint_logger_animation = d346.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_logger_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    d346.ui.paint_hitmarker = d346.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("reject") .. d347.get("default", "ui") .. 'Hitmarkers', 'world +', 'skeleton', 'damage'),
        { requires_login = true, key = 'paint_hitmarker', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    d346.ui.paint_hitmarker_color = d346.register_ui(
        ui.new_color_picker(tab[2], cont[2][2], '\n + color', 0, 225, 225, 255),
        { requires_login = true, key = 'paint_hitmarker_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    d346.ui.paint_warnings = d346.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("warning") .. d347.get("default", "ui") .. 'Warnings', 'lethal', 'cant fire', 'low bullets'),
        { requires_login = true, key = 'paint_warnings', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    d346.ui.paint_performance_mode = d346.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("latency4") .. d347.get("default", "ui") .. 'Performance mode', 'blood', 'ragdolls', 'particles', 'lens flare', 'animations', 'feature updates'),
        { requires_login = true, key = 'paint_performance_mode', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    d346.ui.paint_animations = d346.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], d347.get("green", "ui") .. d349.get("turning2") .. d347.get("default", "ui") .. 'Animations', 'kingaru', 'body lean', 'gamesense legs', 'moonwalk', 'allah', 'static legs', 'no pitch on land', 'reversed legs', 'earthquake', 't-pose', 'blind', 'pitch up'),
        { requires_login = true, key = 'paint_animations', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    d346.ui.paint_aspect_ratio_checkbox = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], d347.get("green", "ui") .. d349.get("expand") .. d347.get("default", "ui") .. 'Aspect ratio'),
        { requires_login = true, key = 'paint_aspect_ratio_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_aspect_ratio = d346.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\naspect ratio', 0, 300, 0, true, '', 0.01, {
            [0] = 'default', [125] = '5:4', [133] = '4:3', [150] = '3:2', [160] = '16:10', [177] = '16:9'
        }),
        { requires_login = true, key = 'paint_aspect_ratio', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    d346.ui.paint_third_person_distance_checkbox = d346.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], d347.get("green", "ui") .. d349.get("camera") .. d347.get("default", "ui") .. 'Third person distance'),
        { requires_login = true, key = 'paint_third_person_distance_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    d346.ui.paint_third_person_distance = d346.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\nthird person distance', 30, 166, 150, true, '', 1, {
            [150] = 'default'
        }),
        { requires_login = true, key = 'paint_third_person_distance', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    
    
    
    
    local d393= {
        checkbox = 'c',
        slider = 's',
        combobox = 'o',
        multiselect = 'm',
    }
    for key, item in pairs(d346.ui) do
        for d385, entry in ipairs(d346.registered_items or {}) do
            if entry.key == key and entry.config_type and d393[entry.config_type] then
                d376.register(key, item, d393[entry.config_type], entry.tab)
            end
        end
    end
end

return d350]]
d958["require/abc/callbacks"] = [[




local d348= {}

local d349= 1
local d350= {}          
local d351= {}      
local d352= {}   

local function d353()
	local d354, d355= pcall(require, "require/abc/login_system")
	if not d354 or not d355 then return false end
	return d355.logged_in == true
end

local function d356(d357)
	if not d357 then return true end
	if d357.menu_only and not (ui and ui.is_menu_open and ui.is_menu_open()) then return false end
	if d357.alive_only then
		local d358= (entity and entity.get_local_player) and entity.get_local_player()
		if not d358 or not entity.is_alive(d358) then return false end
	end
	if d357.require_login then
		if not d353() then return false end
	end
	return true
end

local function d359(d360)
	return function(d361)
		local d362= d351[d360]
		if not d362 then return end
		local d363= {}
		for i=1,#d362 do d363[i] = d362[i] end
		for i=1,#d363 do
			local d364= d363[i]
			local d365= d350[d364]
			if d365 and d365.wrapper then
				local d354, d366= pcall(d365.wrapper, d361)
				if not d354 then
					local d367= nil
					pcall(function()
						d367 = debug.getinfo(d365.user_fn, "Sln")
					end)
					local d368= d367 and d367.short_src or "<unknown>"
					local d369= d367 and (d367.linedefined or -1) or -1
					pcall(client.error_log, string.format("callback[%d] error: %s (source=%s:%d)", d364, tostring(d366), d368, d369))
				end
			end
		end
	end
end



function d348.register(d360,d370,d371,d372,d373)
	if type(d360) ~= 'string' then error('event must be a string') end
	if type(d370) ~= 'function' then error('callback must be a function') end

	local d357= nil
	if type(d371) == 'table' then d357 = d371
	else
		d357 = { menu_only = (d371 == true), alive_only = (d372 == true), require_login = (d373 == true) }
	end

	local d364= d349; d349 = d349 + 1
	local d374= function(d361)
		if d356(d357) then
			return d370(d361)
		end
	end

	d350[d364] = { event = d360, wrapper = d374, user_fn = d370, opts = d357 }
	d351[d360] = d351[d360] or {}
	d351[d360][#d351[d360] + 1] = d364

	
	if not d352[d360] then
		local d375= d359(d360)
		d352[d360] = d375
		pcall(client.set_event_callback, d360, d375)
	end

	return d364
end

function d348.callback(d360,d371,d372,d373,d376)
	if type(d371) == 'function' then
		return d348.register(d360, d371, d372)
	end
	if type(d376) == 'function' then
		local d370= d376
		local d357= { menu_only = (d371 == true), alive_only = (d372 == true), require_login = (d373 == true) }
		return d348.register(d360, d370, d357)
	end
	error('invalid callback signature')
end

function d348.unregister(d364)
	local d365= d350[d364]
	if not d365 then return false end
	local d360= d365.event
	d350[d364] = nil
	local d377= d351[d360]
	if d377 then
		for i=#d377,1,-1 do if d377[i] == d364 then table.remove(d377, i) end end
		if #d377 == 0 then
			d351[d360] = nil
			local d375= d352[d360]
			if d375 then pcall(client.unset_event_callback, d360, d375) end
			d352[d360] = nil
		end
	end
	return true
end

function d348.clear_all()
	for d360, d375 in pairs(d352) do
		pcall(client.unset_event_callback, d360, d375)
	end
	d350 = {}
	d351 = {}
	d352 = {}
end

function d348._list()
	return { regs = d350, by_event = d351 }
end

pcall(function()
	if lua and lua.defer then
		lua.defer(d348.clear_all)
	else
		pcall(client.set_event_callback, 'shutdown', d348.clear_all)
	end
end)

return d348
]]
d958["require/abc/config_cloud"] = [[local d351= {
    Reset = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfbW92ZXx0PW98dj1vZmYKeWF3X2Zha2VsYWd8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wK3x0PXN8dj0wCmZha2VsYWdfc2V0dGluZ3Nfc2lkZXx0PXN8dj0xCnBpdGNoX21vdmV8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbW92ZXx0PXN8dj0wCmZha2VsYWdfZm9yY2Vfb258dD1tfHY9CmZha2VsYWdfZGVmZW5zaXZlfHQ9Y3x2PWZhbHNlCnlhd193YWxrfHQ9b3x2PW9mZgpzdGF0aWNfYm9keV95YXdfZmFrZWxhZ3x0PXN8dj0wCnBpdGNoX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfanVtcHx0PXN8dj0yCmJvZHlfeWF3X21vZGVfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXArfHQ9c3x2PTIKeWF3X2ppdHRlcl9iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfYmFzZV9kdWNrK3x0PW98dj10YXJnZXQKb25seV9mbGlwX29uXzBfY2hva2VfZHVjayt8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PWZhbHNlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9MApib2R5X3lhd19sZWZ0X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19zdGFuZHx0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19nbG9iYWx8dD1zfHY9MApwaXRjaF9kdWNrfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PW9mZgp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRhcmdldApmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wfHQ9c3x2PTAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PQpzZW5kX2NvbWJvanVtcHx0PW98dj1nbG9iYWwKc2VuZF9jb21ib2p1bXArfHQ9b3x2PWdsb2JhbApvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj1mYWxzZQpzdGF0aWNfYm9keV95YXdfbW92ZXx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVjayt8dD1zfHY9MAp5YXdfYmFzZV9nbG9iYWx8dD1vfHY9dGFyZ2V0CmVuYWJsZV9sZWdpdHx0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PQpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9kdWNrK3x0PXN8dj0yCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfdmFsdWVfbGVnaXR8dD1zfHY9Mgpib2R5X3lhd19iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfanVtcCt8dD1vfHY9b2ZmCmRlbGF5X3dhbGt8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdHlwZTJ8dD1vfHY9aml0dGVyCnlhd19sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9zdGFuZHx0PXN8dj0wCmVuYWJsZV9qdW1wK3x0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZmFrZWxhZ3x0PW98dj1nbG9iYWwKeWF3X2ppdHRlcl9iYXNlX2R1Y2t8dD1zfHY9MApmaWZ0eV9maWZ0eV9qdW1wfHQ9Y3x2PWZhbHNlCnBpdGNoX2xlZ2l0fHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfc3RhbmR8dD1zfHY9MAp5YXdfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfanVtcHx0PW98dj1vZmYKYm9keV95YXdfcmlnaHRfZHVja3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVjayt8dD1zfHY9MApib2R5X3lhd19tb2RlX3dhbGt8dD1vfHY9b2ZmCmJvZHlfeWF3X3JpZ2h0X2p1bXArfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10YXJnZXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj1mYWxzZQp5YXdfanVtcHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV93YWxrfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19nbG9iYWx8dD1zfHY9MApmaWZ0eV9maWZ0eV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfbW92ZXx0PW98dj1vZmYKeWF3X2Jhc2VfanVtcCt8dD1vfHY9dGFyZ2V0CnBpdGNoX2R1Y2srfHQ9b3x2PW1pbmltYWwKYm9keV95YXdfbW9kZV9qdW1wK3x0PW98dj1vZmYKc2VuZF9jb21ib2R1Y2t8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfZmFrZWxhZ3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVja3x0PW98dj1vZmYKZmFrZWxhZ19zdGVhbGVyX3RhcmdldHx0PW98dj10aHJlYXQKZmlmdHlfZmlmdHlfZHVjayt8dD1jfHY9ZmFsc2UKb25seV9mbGlwX29uXzBfY2hva2VfanVtcHx0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTAKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0wCmRlbGF5X2R1Y2srfHQ9c3x2PTEKYm9keV95YXdfbW9kZV9sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfZHVja3x0PXN8dj0yCmVuYWJsZV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PW9mZgp5YXdfYmFzZV9zdGFuZHx0PW98dj10YXJnZXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PW9mZgp5YXdfaml0dGVyX3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2xlZ2l0fHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19iYXNlX2xlZ2l0fHQ9b3x2PXRhcmdldApzdGF0aWNfYm9keV95YXdfd2Fsa3x0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X2Zha2VsYWd8dD1zfHY9MApkZWxheV9kdWNrfHQ9c3x2PTEKZmFrZWxhZ19zZXR0aW5nc19yb2xsfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2xpbWl0fHQ9c3x2PTEKZmFrZWxhZ19mYWtlbGFnX3ZhcmlhbmNlfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2Ftb3VudHx0PW98dj1keW5hbWljCmZha2VsYWdfZmFrZWxhZ190eXBlfHQ9b3x2PWdhbWVzZW5zZQpyYW5kb21pemVfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9nbG9iYWx8dD1zfHY9MApyYW5kb21pemVfeWF3X3dhbGt8dD1zfHY9MApjZmdfc2VsZWN0aW9ufHQ9bXx2PWFudGlhaW0KYm9keV95YXdfdmFsdWVfbW92ZXx0PXN8dj0yCmZpZnR5X2ZpZnR5X21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfbW92ZXx0PWN8dj1mYWxzZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ3x0PWN8dj1mYWxzZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfd2Fsa3x0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9zdGFuZHx0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZHVjayt8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnlhd19qaXR0ZXJfanVtcCt8dD1vfHY9b2ZmCnlhd19iYXNlX2p1bXB8dD1vfHY9dGFyZ2V0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKcGl0Y2hfanVtcCt8dD1vfHY9b2ZmCnlhd19kdWNrfHQ9b3x2PW9mZgpkZWxheV9qdW1wK3x0PXN8dj0xCmRlbGF5X3N0YW5kfHQ9c3x2PTEKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj0wCmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVja3x0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10YXJnZXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9MApib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgpib2R5X3lhd19sZWZ0X2dsb2JhbHx0PXN8dj0wCmRlbGF5X21vdmV8dD1zfHY9MQpkZWxheV9qdW1wfHQ9c3x2PTEKZW5hYmxlX2p1bXB8dD1jfHY9ZmFsc2UKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PTAKYm9keV95YXdfbGVmdF9qdW1wK3x0PXN8dj0wCnlhd19tb3ZlfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PWZhbHNlCmZha2VsYWdfZmFrZWRlZnx0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX2dsb2JhbHx0PW98dj1vZmYKZmlmdHlfZmlmdHlfanVtcCt8dD1jfHY9ZmFsc2UKY29uZGl0aW9ufHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X21vdmV8dD1zfHY9MApkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PWZhbHNl0000',
    Defensive = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9dHJ1ZQp5YXdfd2Fsa3x0PW98dj0xODAKc3RhdGljX2JvZHlfeWF3X2Zha2VsYWd8dD1zfHY9MApwaXRjaF9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXB8dD1zfHY9Mgpib2R5X3lhd19tb2RlX3N0YW5kfHQ9b3x2PWppdHRlcgpib2R5X3lhd192YWx1ZV9qdW1wK3x0PXN8dj0yCnlhd19qaXR0ZXJfYmFzZV9mYWtlbGFnfHQ9c3x2PTAKeWF3X2Jhc2VfZHVjayt8dD1vfHY9dGhyZWF0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2srfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PXRydWUKZGVsYXlfbGVnaXR8dD1zfHY9MQp5YXdfc3RhbmR8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVja3x0PXN8dj0wCmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKcGl0Y2hfZHVja3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfZHVjayt8dD1vfHY9aml0dGVyCnlhd19iYXNlX21vdmV8dD1vfHY9dGhyZWF0CmZha2VsYWdfbW9kZXx0PW98dj1zZXR0aW5ncwpwaXRjaF93YWxrfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9iYXNlX2p1bXB8dD1zfHY9MTIwCnNlbmRfY29tYm93YWxrfHQ9b3x2PWdsb2JhbApmYWtlbGFnX3NldHRpbmdzX2ZyZWVzdGFuZGluZ3x0PW18dj1zdGF0aWMJemVybyBwaXRjaAlkZWZlbnNpdmUJc2lkZSBmbGlwCnNlbmRfY29tYm9qdW1wfHQ9b3x2PWdsb2JhbApzZW5kX2NvbWJvanVtcCt8dD1vfHY9Z2xvYmFsCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXArfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9dHJ1ZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PWRlZmVuc2l2ZQlyb2xsCWppdHRlcgpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9MgpzZW5kX2NvbWJvbGVnaXR8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfbGVnaXR8dD1zfHY9LTU4Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTQKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9MApyYW5kb21pemVfeWF3X2R1Y2srfHQ9c3x2PTAKYm9keV95YXdfbW9kZV93YWxrfHQ9b3x2PXN0YXRpYwpib2R5X3lhd19yaWdodF9qdW1wK3x0PXN8dj0zNwpvbmx5X2ZsaXBfb25fMF9jaG9rZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmZha2VsYWdfc2V0dGluZ3NfYW50aWJydXRlfHQ9bXx2PQp5YXdfYmFzZV93YWxrfHQ9b3x2PXRocmVhdApmYWtlbGFnX3N0ZWFsZXJ8dD1jfHY9ZmFsc2UKZW5hYmxlX3N0YW5kfHQ9Y3x2PXRydWUKeWF3X2p1bXB8dD1vfHY9MTgwCmJvZHlfeWF3X2Jhc2Vfd2Fsa3x0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19zdGFuZHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZ2xvYmFsfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZHVja3x0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX21vdmV8dD1vfHY9aml0dGVyCnlhd19iYXNlX2p1bXArfHQ9b3x2PXRocmVhdApwaXRjaF9kdWNrK3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2p1bXB8dD1zfHY9MTgKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0tMwpkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjcKc2VuZF9jb21ib21vdmV8dD1vfHY9Z2xvYmFsCnJhbmRvbWl6ZV95YXdfbW92ZXx0PXN8dj0wCnBpdGNoX2p1bXB8dD1vfHY9ZG93bgp5YXdfYmFzZV9zdGFuZHx0PW98dj10aHJlYXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9zdGFuZHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2dsb2JhbHx0PWN8dj1mYWxzZQp5YXdfYmFzZV9sZWdpdHx0PW98dj10aHJlYXQKc3RhdGljX2JvZHlfeWF3X3dhbGt8dD1zfHY9MApib2R5X3lhd19yaWdodF9mYWtlbGFnfHQ9c3x2PTAKZGVsYXlfZHVja3x0PXN8dj01CmZha2VsYWdfc2V0dGluZ3Nfcm9sbHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19saW1pdHx0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ192YXJpYW5jZXx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19hbW91bnR8dD1vfHY9ZHluYW1pYwpmYWtlbGFnX2Zha2VsYWdfdHlwZXx0PW98dj1zb2RpdW0KcmFuZG9taXplX3lhd19qdW1wfHQ9c3x2PTAKeWF3X2ppdHRlcl9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKcmFuZG9taXplX3lhd193YWxrfHQ9c3x2PTAKY2ZnX3NlbGVjdGlvbnx0PW18dj1hbnRpYWltCmJvZHlfeWF3X3ZhbHVlX21vdmV8dD1zfHY9MgpmaWZ0eV9maWZ0eV9tb3ZlfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfYmFzZV9kdWNrK3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX21vdmV8dD1jfHY9dHJ1ZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0yNApmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV93YWxrfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCnNlbmRfY29tYm9kdWNrK3x0PW98dj1nbG9iYWwKYm9keV95YXdfcmlnaHRfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9qdW1wK3x0PW98dj1vZmYKeWF3X2Jhc2VfanVtcHx0PW98dj10aHJlYXQKb25seV9mbGlwX29uXzBfY2hva2VfbGVnaXR8dD1jfHY9dHJ1ZQpib2R5X3lhd19tb2RlX2R1Y2t8dD1vfHY9c3RhdGljCnN0YXRpY19ib2R5X3lhd19sZWdpdHx0PXN8dj0wCnBpdGNoX2p1bXArfHQ9b3x2PWRvd24KeWF3X2R1Y2t8dD1vfHY9MTgwCmRlbGF5X2p1bXArfHQ9c3x2PTMKZGVsYXlfc3RhbmR8dD1zfHY9NApmYWtlbGFnX2ZvcmNlfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X3JpZ2h0X2R1Y2srfHQ9c3x2PTQ0CmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0tMTUKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTE0Cnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9NTgKYm9keV95YXdfdmFsdWVfZ2xvYmFsfHQ9c3x2PTIKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApkZWxheV9tb3ZlfHQ9c3x2PTEKZGVsYXlfanVtcHx0PXN8dj0xCmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTQKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PS0xNgpib2R5X3lhd19sZWZ0X2p1bXArfHQ9c3x2PS05Cnlhd19tb3ZlfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PS0xNQpzdGF0aWNfYm9keV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3dhbGt8dD1jfHY9dHJ1ZQpmYWtlbGFnX2Zha2VkZWZ8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9nbG9iYWx8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmNvbmRpdGlvbnx0PW98dj1zdGFuZApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfbW92ZXx0PXN8dj00MgpkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PXRydWU00=',
    Unmatched = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9MgplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9ZmFsc2UKeWF3X3dhbGt8dD1vfHY9MTgwCnN0YXRpY19ib2R5X3lhd19mYWtlbGFnfHQ9c3x2PTAKcGl0Y2hfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9qdW1wfHQ9c3x2PTIKYm9keV95YXdfbW9kZV9zdGFuZHx0PW98dj1qaXR0ZXIKYm9keV95YXdfdmFsdWVfanVtcCt8dD1zfHY9Mgp5YXdfaml0dGVyX2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19iYXNlX2R1Y2srfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV9kdWNrK3x0PWN8dj10cnVlCnlhd19iYXNlX2Zha2VsYWd8dD1vfHY9dGFyZ2V0CnNlbmRfY29tYm9nbG9iYWx8dD1vfHY9Z2xvYmFsCnN0YXRpY19ib2R5X3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3dhbGt8dD1zfHY9MgplbmFibGVfd2Fsa3x0PWN8dj10cnVlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9LTM0CmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIxCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX3dhbGt8dD1zfHY9MApib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PWppdHRlcgpmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9ZG93bgp5YXdfaml0dGVyX2Jhc2VfanVtcHx0PXN8dj0xMjAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PXN0YXRpYwlkZWZlbnNpdmUKc2VuZF9jb21ib2p1bXB8dD1vfHY9Z2xvYmFsCnNlbmRfY29tYm9qdW1wK3x0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9ZmFsc2UKZmFrZWxhZ19zZXR0aW5nc19lbmhhbmNlX29uc2hvdHx0PW18dj1kZWZlbnNpdmUJcm9sbAlqaXR0ZXIKc3RhdGljX2JvZHlfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2Jhc2VfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF93YWxrfHQ9c3x2PTIzCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTIKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9NDQKcmFuZG9taXplX3lhd19kdWNrK3x0PXN8dj0wCmJvZHlfeWF3X21vZGVfd2Fsa3x0PW98dj1zdGF0aWMKYm9keV95YXdfcmlnaHRfanVtcCt8dD1zfHY9NTQKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10aHJlYXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj10cnVlCnlhd19qdW1wfHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3dhbGt8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfc3RhbmR8dD1zfHY9MApyYW5kb21pemVfeWF3X2dsb2JhbHx0PXN8dj0wCmZpZnR5X2ZpZnR5X2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9tb3ZlfHQ9b3x2PWppdHRlcgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9zdGFuZHx0PWN8dj10cnVlCmJvZHlfeWF3X2Jhc2VfanVtcHx0PXN8dj03CmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTI0CnJhbmRvbWl6ZV95YXdfZmFrZWxhZ3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfanVtcCt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9zdGFuZHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfanVtcCt8dD1zfHY9MApkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PWRvd24KeWF3X2Jhc2Vfc3RhbmR8dD1vfHY9dGhyZWF0Cnlhd19qaXR0ZXJfZmFrZWxhZ3x0PW98dj1vZmYKc2VuZF9jb21ib3N0YW5kfHQ9b3x2PWdsb2JhbApwaXRjaF9zdGFuZHx0PW98dj1kb3duCnlhd19qaXR0ZXJfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbGVnaXR8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV9nbG9iYWx8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfbGVnaXR8dD1vfHY9dGFyZ2V0CnN0YXRpY19ib2R5X3lhd193YWxrfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfZmFrZWxhZ3x0PXN8dj0wCmRlbGF5X2R1Y2t8dD1zfHY9NQpmYWtlbGFnX3NldHRpbmdzX3JvbGx8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfbGltaXR8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdmFyaWFuY2V8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfYW1vdW50fHQ9b3x2PWR5bmFtaWMKZmFrZWxhZ19mYWtlbGFnX3R5cGV8dD1vfHY9c29kaXVtCnlhd19qaXR0ZXJfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2dsb2JhbHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfd2Fsa3x0PXN8dj0wCmNmZ19zZWxlY3Rpb258dD1tfHY9YW50aWFpbQpib2R5X3lhd192YWx1ZV9tb3ZlfHQ9c3x2PTIKZmlmdHlfZmlmdHlfbW92ZXx0PWN8dj1mYWxzZQpkZWxheV9tb3ZlfHQ9c3x2PTMKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmZha2VsYWdfc3RlYWxlcl90eXBlfHQ9b3x2PW1pbWljCmJvZHlfeWF3X3JpZ2h0X3N0YW5kfHQ9c3x2PTQwCnBpdGNoX2R1Y2t8dD1vfHY9ZG93bgpmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQplbmFibGVfbW92ZXx0PWN8dj10cnVlCmVuYWJsZV9nbG9iYWx8dD1jfHY9ZmFsc2UKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApib2R5X3lhd19yaWdodF9tb3ZlfHQ9c3x2PTQyCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXArfHQ9b3x2PW9mZgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj10cnVlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1qaXR0ZXIKZGVsYXlfc3RhbmR8dD1zfHY9MQp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApwaXRjaF9qdW1wK3x0PW98dj1kb3duCmRlbGF5X2p1bXArfHQ9c3x2PTUKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQplbmFibGVfZmFrZWxhZ3x0PWN8dj1mYWxzZQpvbmx5X2ZsaXBfb25fMF9jaG9rZV9tb3ZlfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX21vdmV8dD1zfHY9MAp5YXdfZ2xvYmFsfHQ9b3x2PW9mZgpjYWNoZV9jcmVkZW50aWFsc3x0PWN8dj10cnVlCnJhbmRvbWl6ZV95YXdfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF9sZWdpdHx0PXN8dj0wCmRlbGF5X2dsb2JhbHx0PXN8dj0xCmRlbGF5X2p1bXB8dD1zfHY9MQpib2R5X3lhd19sZWZ0X2p1bXB8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2xlZnRfd2Fsa3x0PXN8dj0tMTYKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcCt8dD1zfHY9LTE4Cnlhd19kdWNrfHQ9b3x2PTE4MAp5YXdfYmFzZV9qdW1wK3x0PW98dj10aHJlYXQKeWF3X21vdmV8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVjayt8dD1zfHY9LTE1CmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKZmFrZWxhZ19mYWtlZGVmfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZ2xvYmFsfHQ9b3x2PW9mZgp5YXdfYmFzZV9qdW1wfHQ9b3x2PXRocmVhdApjb25kaXRpb258dD1vfHY9ZHVjaysKc2VuZF9jb21ib2R1Y2srfHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj00NAp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX2R1Y2srfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2Zha2VsYWd8dD1vfHY9b2ZmCmRlbGF5X2Zha2VsYWd8dD1zfHY9MQpzdGF0aWNfYm9keV95YXdfZHVjayt8dD1zfHY9MAp5YXdfaml0dGVyX2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXB8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X3dhbGt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfZmFrZWxhZ3x0PWN8dj1mYWxzZQpwaXRjaF9kdWNrK3x0PW98dj1kb3du0000',
    Community = '',
}
return d351]]
d958["require/abc/config_system"] = [[


local d354='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

local function d355(d356)
    return ((d356:gsub('.', function(d357)
        local d358,d354='',d357:byte()
        for i=8,1,-1 do d358=d358..(d354%2^i-d354%2^(i-1)>0 and '1' or '0') end
        return d358
    end)..'0000'):gsub('%d%d%d%d%d%d', function(d357)
        if (#d357 < 6) then return '' end
        return d354:sub(tonumber(d357,2)+1,tonumber(d357,2)+1)
    end)..({ '', '==', '=' })[#d356%3+1])
end

local function d359(d356)
    d356 = string.gsub(d356, '[^'..b..'=]', '')
    return (d356:gsub('.', function(d357)
        if d357 == '=' then return '' end
        local d358,d360='',(d354:find(d357)-1)
        for i=6,1,-1 do d358=d358..(d360%2^i-d360%2^(i-1)>0 and '1' or '0') end
        return d358
    end):gsub('%d%d%d%d%d%d%d%d', function(d357)
        if (#d357 ~= 8) then return '' end
        local d361=0
        for i=1,8 do d361=d361+(d357:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(d361)
    end))
end





local d362= database

local d363= {}
local d364= {}

local function d365(d366,d367,d368,d369)
    if not d366 or d366 == '' or not d367 or d364[d366] then return end
    d363[#d363+1] = { key = d366, ref = d367, type = d368, tab = d369 }
    d364[d366] = d363[#d363]
end

local function d370(d371)
    local function d372(d373,d371)
        if not d371 or #d371 == 0 then return true end
        if d373 == 'CFG' then return true end
        if not d373 then return true end
        for _, t in ipairs(d371) do if t == d373 then return true end end
        return false
    end

    local d374= { 'v=1' }
    for i = 1, #d363 do
        local d375= d363[i]
        if d372(d375.tab, d371) then
            local d376= d375.type
            local d377= ui.get(d375.ref)
            if d376 == 'c' then
                d374[#d374+1] = d375.key .. '|t=c|v=' .. (d377 and 'true' or 'false')
            elseif d376 == 's' then
                d374[#d374+1] = d375.key .. '|t=s|v=' .. tostring(d377 or 0)
            elseif d376 == 'o' then
                d374[#d374+1] = d375.key .. '|t=o|v=' .. tostring(d377 or '')
            elseif d376 == 'm' then
                if type(d377) == 'table' then
                    d374[#d374+1] = d375.key .. '|t=m|v=' .. table.concat(d377, '\t')
                end
            end
        end
    end
    return d355(table.concat(d374, '\n'))
end

local function d378(d379,d371)
    if not d379 or d379 == '' then return end
    local d380, d381= pcall(d359, d379)
    if not d380 or not d381 or d381 == '' then return end
    local function d372(d373,d371)
        if not d371 or #d371 == 0 then return true end
        if d373 == 'CFG' then return true end
        if not d373 then return true end
        for _, d376 in ipairs(d371) do if d376 == d373 then return true end end
        return false
    end
    for line in d381:gmatch('([^\n]+)') do
        if line ~= 'v=1' then
            local d366, d382, d383= line:match('^(.-)|t=(.)|v=(.*)$')
            if d366 and d382 and d383 then
                local d375= d364[d366]
                if d375 and d375.type == d382 and d372(d375.tab, d371) then
                    if d382 == 'c' then
                        ui.set(d375.ref, vseg == 'true')
                    elseif d382 == 's' then
                        local d384= tonumber(d383)
                        if d384 ~= nil then
                            ui.set(d375.ref, d384)
                        end
                    elseif d382 == 'o' then
                        pcall(ui.set, d375.ref, d383)
                    elseif d382 == 'm' then
                        local d385= {}
                        for token in d383:gmatch('[^\t]+') do d385[#d385+1] = token end
                        ui.set(d375.ref, d385)
                    end
                end
            end
        end
    end
end


local function d386(d387,d371)
    if not d387 or d387 == '' then return end
    local d379= d370(d371)
    d362.write('cfg:' .. d387, d379)
end


local function d388(d387,d371)
    if not d387 or d387 == '' then return end
    local d379= d362.read('cfg:' .. d387)
    if d379 then d378(d379, d371) end
end


local function d389(d387)
    if not d387 or d387 == '' then return end
    d362.write('cfg:' .. d387, nil)
end


local d390= {
    register = d365,
    build = d370,
    apply = d378,
    save = d386,
    load = d388,
    delete = d389,
}

return d390]]
d958["require/abc/garbage_collector"] = [[local d357= {}

local d358= {
    pause = 200,
    stepmul = 600,
    mode = "collect"
}

function d357.tune(d359)
	if type(d359) == "table" then
		if d359.pause then
			collectgarbage("setpause", d359.pause)
			d358.pause = d359.pause
		end
		if d359.stepmul then
			collectgarbage("setstepmul", d359.stepmul)
			d358.stepmul = d359.stepmul
		end
		if d359.mode then
			d358.mode = d359.mode
		end
	end
end

function d357.collect(d360)
	collectgarbage(d360 or d358.mode)
end

function d357.step(d361)
	return collectgarbage("step", d361 or 0)
end

function d357.stop()
	collectgarbage("stop")
end

function d357.restart()
	collectgarbage("restart")
end

function d357.memory()
	return collectgarbage("count")
end

function d357.status()
	return {
		memory = d357.memory(),
		pause = d358.pause,
		stepmul = d358.stepmul,
		mode = d358.mode
	}
end

local d362= 0
function d357.dynamic(d359)
	d359 = type(d359) == "table" and d359 or {}
	local d363= d359.min_interval or 0.6
	local d364= (globals and globals.realtime) and globals.realtime() or (d362 + d363)
	if d364 - d362 < d363 then
		return
	end
	d362 = d364

	local d361= d359.step_size or 20
	local d365= d359.full_threshold_kb or 65536
	local d366= d359.aggressive_threshold_kb or 12288

	local d367, d368= pcall(collectgarbage, "count")
	if not d367 or type(d368) ~= "number" then
		pcall(collectgarbage, "step", d361)
		return
	end

	if d368 >= d365 then
		pcall(collectgarbage, "collect")
		return
	end

	if d368 >= d366 then
		pcall(collectgarbage, "step", d361)
		pcall(collectgarbage, "step", d361)
		return
	end

	pcall(collectgarbage, "step", d361)
end

if lua and lua.defer then
	lua.defer(function()
		d357.collect()
	end)
end

return d357]]
d958["require/abc/hwid_check"] = [[local d360= require("ffi")
local d361= require("require/brain/dll")
local d362= 2
local d363= 1

local function d364()
    return globals.curtime and globals.curtime() or 0
end

local function d365()
    local shared= rawget(_G, "loader_shared")
    if not shared or type(shared) ~= "table" then
    return nil, "missing"
    end
    local d366= tonumber(shared.expires) or 0
    if d364() > d366 then
    return nil, "expired"
    end
    if type(shared.hwids) ~= "table" then
    return nil, "bad_hwids"
    end
    return shared, nil
end

local d367= false

local function d368()
    if not d361 or type(d361) ~= "table" or type(d361.get_hwid) ~= "function" then
        print("invalid hwid 1")
    return
    end

    local d369
    
    local d370, d371= pcall(d361.get_hwid)
    if d370 and d371 and d371 ~= d360.NULL then
    if type(d371) == "cdata" then
        local d372, d373= pcall(d360.string, d371)
        if d372 then d369 = d373 end
    else
        d369 = tostring(d371)
    end
    end

    if not d369 or d369 == "" then
        print("invalid hwid 2")
    end

    local shared, d374= d365()
    if not shared then
        print("invalid hwid 3")
    end

    local d375= shared.hwids
    local d376= false
    for i = 1, #d375 do
    local d377= tostring(d375[i] or "")
    if d377:find(tostring(d369), 1, true) then
        d376 = true
        break
    end
    end


    if d376 then
        local d378= rawget(_G, "loader_init_after_hwid")
        if not d367 and type(d378) == "function" then
        d367 = true
        local d379, d380= pcall(d378)
        if not d379 then
            print("invalid hwid 4")
        end
        end
    else
        print("invalid hwid 5")
    end
end

local d381= 0
local function d382()
    d381 = d381 + 1
    local shared= rawget(_G, "loader_shared")
    if shared then
    d368()
    return
    end
    print(d381 .. "/" .. d362)
    if d381 > d362 then
        print("invalid hwid 6")
        return
    end

    if type(client.delay_call) == "function" then
        client.delay_call(d363, d382)
    else
        d368()
    end

end


d382()]]
d958["require/abc/login_system"] = [[local d363= {}


local function d364(d365)
	if client.hash_sha256 then
		return client.hash_sha256(d365)
	end
	
	return tostring(d365):reverse()
end


local d366= "acc_" .. "897ntv45ynvttyjt980745nyv0t485vn87t6"

local function d367()
	local d368= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local d369= ""
	for i = 1, 16 do
		local d370= math.random(1, #d368)
		d369 = d369 .. d368:sub(d370, d370)
	end
	return d369
end

function d363.hash_password(d371,d369)
	return d364(d369 .. d371)
end

function d363.verify_password(d371,d372,d369)
	return d363.hash_password(d371, d369) == d372
end

function d363.get_hwid()
	
	return tostring(client.userid_to_entindex(client.userid_to_entindex(1)))
end

function d363.store_credentials(d373,d371)
	local d369= d367()
	local d372= d363.hash_password(d371, d369)
	database.write("login_credentials", { username = d373, hash = d372, salt = d369 })
end

function d363.load_credentials()
	return database.read("login_credentials")
end


function d363.login(d373,d371)
	
	local d374= database.read(d366) or {}
	local d375= d374[d373]
	if d375 and d375.enabled ~= false then
		if d363.verify_password(d371, d375.hash, d375.salt) then
			d363.logged_in = true
			return true
		end
	end
	
	local d376= d363.load_credentials()
	if d376 and d376.username == d373 then
		if d363.verify_password(d371, d376.hash, d376.salt) then
			d363.logged_in = true
			return true
		end
	end
	d363.logged_in = false
	return false
end

function d363.logout()
	d363.logged_in = false
end

function d363.reset_password(d377)
	
	database.write("login_credentials", nil)
end



function d363.is_valid_invite(d378)
	if not d378 or d378 == "" then
		return false, nil
	end
	local d379= database.read(d366 .. ":invites") or {}
	local d380= d379[d378]
	if not d380 then
		return false, nil
	end
	if d380.used then
		return false, d380
	end
	return true, d380
end

function d363.add_account(d373,d371)
	local d369= d367()
	local d372= d363.hash_password(d371, d369)
	local d374= database.read(d366) or {}
	d374[d373] = { hash = d372, salt = d369, role = "user", enabled = true, orig_password = d371 }
	database.write(d366, d374)
end

function d363.register_with_invite(d378,d373,d371)
	if not d378 or d378 == '' then return false, 'no invite provided' end
	local d379= database.read(d366 .. ":invites") or {}
	local d380= d379[d378]
	if not d380 then return false, 'invalid invite' end
	if d380.used then return false, 'invite already used' end

	d363.add_account(d373, d371)

	d380.used = true
	d380.used_by = d373
	d380.redeemed_at = client.unix_time()
	d379[d378] = d380
	database.write(d366 .. ":invites", d379)

	return true
end

function d363.invalidate_invite(d378)
	local d379= database.read(d366 .. ":invites") or {}
	if d379[d378] then
		d379[d378] = nil
		database.write(d366 .. ":invites", d379)
		return true
	end
	return false
end

return d363
]]
d958["require/abc/menu_header"] = [[local d366, d367, d368= 1, 398, 49
local d369= 0.85 
local d370= { "AA", "PAINT", "MISC", "CFG" }
local d371= d370[d366]
local d372= {}
local d373= {
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS1.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS2.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS3.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS4.png"
}
local d374

local d375= {
    size = {
        x = 6,
        y = 6,
        w = 120,
        h = 72, 
    },
    skeet_cur_tab = 8,
}

local function d376()
    local d377= { ui.menu_position() }
    local d378= { ui.mouse_position() }
    if not d377[1] or not d377[2] or not d378[1] or not d378[2] then
        return d375.skeet_cur_tab
    end

    for i = 1, 9 do
        local d379= { d375.size.x, d375.size.y + d375.size.h * (i - 1) }
        if d378[1] >= d377[1] + d379[1]
           and d378[1] <= d377[1] + d375.size.w + d379[1]
           and d378[2] >= d377[2] + d379[2]
           and d378[2] <= d377[2] + d375.size.h + d379[2] then
            return i
        end
    end

    return d375.skeet_cur_tab
end

local function d380()
    if not renderer.load_png or not readfile then return end
    for i, path in ipairs(d373) do
        if not d372[i] then
            local d381= readfile(path)
            if d381 then
                d372[i] = renderer.load_png(d381, d367, d368)
            end
        end
    end
end


local function d382()
    local d383= ui.is_menu_open()
    local d384, d385= ui.menu_position()
    local d386, d387= ui.menu_size()
    d386 = d386-2
    d384 = d384+1
    if d383 and d384 and d385 and d386 and d387 then
        local d388= (d375.skeet_cur_tab == 2)
        local d389= math.floor(90 * d369)
        local d390= math.max(1, math.floor(4 * d369))
        local d391= math.max(1, math.floor(3 * d369))
        local d392= math.max(1, math.floor(2 * d369))
        local d393= math.max(0, math.floor(1 * d369))
        local d394= 0
        local d395= d384 + d390
        local d396= d385 - math.floor(7 * d369) - d389
        local d397= d386 - 2 * d390

        if d388 then
            renderer.rectangle(d395-d390*1.3, d396-8, d397+2*d390*1.5-1, d389+16, 12, 12, 12, 255)
            renderer.rectangle(d395-d391*1.5, d396-7, d397+2*d391*1.5, d389+14, 60, 60, 60, 255)
            renderer.rectangle(d395-d392*1.51, d396-6, d397+2*d392*2, d389+12, 40, 40, 40, 255)
            renderer.rectangle(d395-d393, d396-3, d397+2*d393, d389+6, 60, 60, 60, 255)
            renderer.rectangle(d395-d394, d396-2, d397+2*d394, d389+4, 12, 12, 12, 255)

            local d398= nil
            if renderer.load_rgba then
                local d399, d400= pcall(renderer.load_rgba,
                    string.char(
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
                    ), 4, 4)
                if d399 and d400 then d398 = d400 end
            end
            if d398 and renderer.texture then
                renderer.texture(d398, d395-d394, d396-2, d397+2*d394, d389+4, 255,255,255,255, 'r')
            end

            if renderer.gradient then
                renderer.gradient(d395-d394, d396-2, (d397+2*d394)/2+1, 1, 59,175,222,255, 202,70,205,255, true)
                renderer.gradient(d395-d394+(d397+2*d394)/2+1, d396-2, (d397+2*d394)/2-1, 1, 202,70,205,255, 204,227,53,255, true)
            end

            local d401= math.max(1, math.floor(2 * d369))
            local d402= d396 - math.floor(8 * d369)

            local d403= math.max(1, math.floor(5 * d369))
            local d404= 60
            renderer.circle(d395-d390+d403, d402+d401/2, d403, 59,175,222, d404, 16)
            renderer.circle(d395+d397-d390-d394-d403, d402+d401/2, d403, 204,227,53, d404, 16)
        end

        local d405= 4
        local d406= d396 + d389 / 2
        local d407, d408= ui.mouse_position()
        local d409= {}
        local d410= d389
            local d411= math.max(1, math.floor(59 * d369))
            local d412= math.max(1, math.floor(d367 * d369))
            local d413= math.max(1, math.floor(d368 * d369))
            local d414= d405 * d412 + (d405 - 1) * d411
            local d415= math.max(0, d397 * 0.5)
            local d416= d395 + d415 + (d397 - 2 * d415 - d414) / 2
            if d414 > d397 then
                d411 = math.max(0, math.floor((d397 - d405 * d412) / (d405 - 1)))
                d414 = d405 * d412 + (d405 - 1) * d411
                d416 = d395 + (d397 - d414) / 2
            end
        d380()
        local d417= d397 / d405
        for i=1,d405 do
            local d418= d395 + (i-1) * d417
            local d419= d396
            d409[i] = {x=d418, y=d419, w=d417, h=d410}
            if d388 then
                if d366 == i then
                    renderer.rectangle(d418, d419, d417, d410+1, 32,32,32, 85)
                end
                local d420= d418 + d417/2 - d412/2
                local d421= d419 + d410/2 - d413/2
                if d372[i] then
                    renderer.texture(d372[i], d420, d421, d412, d413, 255,255,255,255, "f")
                else
                    renderer.text(d420 + d412/2, d421 + d413/2, 255,255,255,255, '+c', 0, tostring(i))
                end
            end
        end

        local d422= client.key_state(1)
        if d383 and d407 and d408 and ui.is_menu_open() then
            if d422 and not prev_mouse_down then
                for i=1,d405 do
                    local d423= d409[i]
                    if d407 >= d423.x and d407 <= d423.x+d423.w and d408 >= d423.y and d408 <= d423.y+d423.h then
                        d366 = i
                        d371 = d370[d366]
                    end
                end
                local d424= { ui.menu_position() }
                if d424[1] and d424[2] then
                    for si = 1, 9 do
                        local d379= { d375.size.x, d375.size.y + d375.size.h * (si - 1) }
                        if d407 >= d424[1] + d379[1]
                           and d407 <= d424[1] + d375.size.w + d379[1]
                           and d408 >= d424[2] + d379[2]
                           and d408 <= d424[2] + d375.size.h + d379[2] then
                            d375.skeet_cur_tab = si
                            break
                        end
                    end
                end
            end
            prev_mouse_down = d422
        else
            prev_mouse_down = false
        end
        local d425= d376()
        local d426= d375.skeet_cur_tab or 0
        local d427= "Skeet sel: " .. tostring(d426)
        if d425 and d425 ~= d426 then
            d427 = d427 .. "  (hover: " .. tostring(d425) .. ")"
        end
        if d388 then
            if renderer.measure_text then
                pcall(function() renderer.measure_text(nil, d427) end)
            end
            renderer.text(d395 + 6, d396 + d389 + 6, 200,200,200,255, nil, 0, d427)
        end
    end
end

local function d428()
    if not ui.is_menu_open() then return false end
    local d407, d408= ui.mouse_position()
    local d429, d430= ui.menu_position()
    local d431, d432= ui.menu_size()
    local d389= math.floor(90 * d369)
    local d390= math.max(1, math.floor(4 * d369))
    local d395, d396, d397= d429 + d390, d430 - math.floor(7 * d369) - d389, d431 - 2 * d390
    return not (
        d407 >= d429 and d407 <= d429 + d431 and d408 >= d430 and d408 <= d430 + d432
        or d407 >= d395 and d407 <= d395 + d397 and d408 >= d396 and d408 <= d396 + d389
    )
end

return {
    current_tab = function() return d371 end,
    current_tab_index = function() return d366 end,
    tab_names = d370,
    tab_sections = function() return d374 end,
    menu_position = function() return ui.menu_position() end,
    menu_size = function() return ui.menu_size() end,
    is_menu_open = function() return ui.is_menu_open() end,
    mouse_position = function() return ui.mouse_position() end,
    is_mouse_outside_menu = d428,
    draw_menu = d382
}]]
d958["require/abc/menu_setup"] = [[local d369= {
    ui = {},
    registered_items = {},
}

function d369.register_ui(d370,d371)
    
    
    
    if d371 and d371.key then
        for i = #d369.registered_items, 1, -1 do
            local d372= d369.registered_items[i]
            if d372 and d372.key == d371.key then
                
                pcall(function()
                    if d372.item then ui.set_visible(d372.item, false) end
                end)
                table.remove(d369.registered_items, i)
            end
        end
    end

    table.insert(d369.registered_items, {
        item = d370,
        key = d371.key,
        requires_login = d371.requires_login,
        tab = d371.tab,
        visible = d371.visible ~= false,
        config_type = d371.config_type,
        show_condition = d371.show_condition,
    })
    return d370
end

function d369.update_visibility(d373)
    for _, d372 in ipairs(d369.registered_items) do
        local d374= d372.visible
        if d372.requires_login and not d373 then
            d374 = false
        end
        if d372.show_condition then
            d374 = d372.show_condition()
        end
        if d372.item then
            ui.set_visible(d372.item, d374)
        end
    end
end

function d369.save_config()
    local d375= {}
    for _, d372 in ipairs(d369.registered_items) do
        if d372.key and d372.item then
            d375[d372.key] = ui.get(d372.item)
        end
    end
    return d375
end

function d369.load_config(d376)
    for _, d372 in ipairs(d369.registered_items) do
        if d372.key and d372.item and d376[d372.key] ~= nil then
            ui.set(d372.item, d376[d372.key])
        end
    end
end

local d377= {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

local d378= {

    { 'Rage', 'other', 'accuracy boost' },
    { 'Rage', 'other', 'anti-aim correction' },
    { 'rage', 'other', 'automatic fire' },
    { 'Rage', 'other', 'automatic penetration' },
    { 'Rage', 'other', 'silent aim' },
    { 'Rage', 'other', 'remove recoil' },
    { 'Rage', 'other', 'reduce aimstep' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'log misses due to spread' },
    { 'Rage', 'other', 'low fps mitigations ' },
    { 'rage', 'other', 'delay shot' },
    { 'Rage', 'other', 'quick peek assist' },
    { 'Rage', 'other', 'quick peek assist mode' },
    { 'Rage', 'other', 'quick peek assist distance' },
    { 'Rage', 'other', 'reduce aim step' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'low fps mitigations' },
    { 'Rage', 'other', 'duck peek assist' },


}

function d369.toggle_gamesense_menu(d374)
    d369.state = d369.state or {}
    d369.hidden_refs = d369.hidden_refs or {}
    for _, d372 in ipairs(d377) do
        local d379, d380, d381, d382, d383= pcall(ui.reference, d372[1], d372[2], d372[3], d372[4])
        if d379 then
            if d372[1] == 'AA' and d372[2] == 'Anti-aimbot angles' and d372[3] == 'Enabled' then
                d369.state.gs_enabled_ref = d380
                if d380 ~= nil and d374 then
                    if d369.state.gs_enabled_previous ~= nil then
                        ui.set(d380, d369.state.gs_enabled_previous)
                    end
                elseif d380 ~= nil and not d374 then
                    d369.state.gs_enabled_previous = ui.get(d380)
                    ui.set(d380, true)
                end
            end
            local d384= { d380, d381, d382, d383 }
            local d385= {}
            for _, ref in ipairs(d384) do
                if ref ~= nil then
                    ui.set_visible(ref, d374)
                    d385[#d385 + 1] = ref
                end
            end
            if not d374 and #d385 > 0 then
                table.insert(d369.hidden_refs, d385)
            end
        end
    end
    d369.state.gs_hidden = not d374
end

function d369.toggle_rage_menu(d374)
    d369.state = d369.state or {}
    d369.hidden_rage_refs = d369.hidden_rage_refs or {}
    d369.hidden_rage_refs = {} 

    for _, d372 in ipairs(d378) do
        local d379, d380, d381, d382, d383= pcall(ui.reference, d372[1], d372[2], d372[3])
        if d379 then
            local d384= { d380, d381, d382, d383 }
            local d385= {}
            for _, ref in ipairs(d384) do
                if ref ~= nil then
                    pcall(function() ui.set_visible(ref, d374) end)
                    d385[#d385 + 1] = ref
                end
            end
            if not d374 and #d385 > 0 then
                table.insert(d369.hidden_rage_refs, d385)
            end
        end
    end
    d369.state.rage_hidden = not d374
end

return d369]]
d958["require/abc/menu_visibility"] = [[local d372= {
	"global",
	"stand",
	"move",
	"duck",
	"duck+",
	"jump",
	"jump+",
	"walk",
	"fakelag",
	"legit",
}

local d373= require("require/abc/login_system")

local function d374(d375)
	if d375.menu_setup and d375.menu_setup.refresh_cfg_listbox then
		d375.menu_setup.refresh_cfg_listbox()
	end

	if d375 and not d375.login then
		d375.login = d373
	end
	d375.menu_setup.toggle_gamesense_menu(false)
	d375.menu_setup.toggle_rage_menu(true)
	d375.menu_setup.update_visibility(d375.login and d375.login.logged_in)
	local d376= (d375.login and d375.login.logged_in) or false

	local d377= not d376
	local d378= (d375.menu_header and d375.menu_header.current_tab and d375.menu_header.current_tab()) or d375.menu.current_tab()
	 	
	ui.set_visible(d375.menu_setup.ui.login_howto_header, d377)
	ui.set_visible(d375.menu_setup.ui.login_console_register, d377)
	ui.set_visible(d375.menu_setup.ui.login_menu_credentials, d377)
	ui.set_visible(d375.menu_setup.ui.login_press_login, d377)
	ui.set_visible(d375.menu_setup.ui.login_spacer1, d377)
	ui.set_visible(d375.menu_setup.ui.reset_header, d377)
	ui.set_visible(d375.menu_setup.ui.reset_step1, d377)
	ui.set_visible(d375.menu_setup.ui.reset_step2, d377)
	ui.set_visible(d375.menu_setup.ui.login_spacer2, d377)
	ui.set_visible(d375.menu_setup.ui.support_header, d377)
	ui.set_visible(d375.menu_setup.ui.support_discord, d377)
	ui.set_visible(d375.menu_setup.ui.login_username, d377)
	ui.set_visible(d375.menu_setup.ui.login_password, d377)
	ui.set_visible(d375.menu_setup.ui.cache_credentials, d377)
	ui.set_visible(d375.menu_setup.ui.login_button, d377)
	ui.set_visible(d375.menu_setup.ui.reset_button, d377)
	ui.set_visible(d375.menu_setup.ui.discord_button, d377)
	ui.set_visible(d375.menu_setup.ui.youtube_button, d377)
	ui.set_visible(d375.menu_setup.ui.sellhub_button, d377)
	ui.set_visible(d375.menu_setup.ui.logout_button, d376 and d378 == "CFG")

	if d375.menu_setup.ui.condition then
		local d379= ui.get(d375.menu_setup.ui.condition)
		for _, cond in ipairs(d372) do
			local d380= d376 and d378 == "AA" and d379 == cond
			local d381= 'enable_' .. cond
			if d375.menu_setup.ui[d381] then
				ui.set_visible(d375.menu_setup.ui[d381], d380)
				local d382= d375.safe.safe_get(d375.menu_setup.ui[d381])

				local d383= d375.menu_setup.ui['yaw_' .. cond] and ui.get(d375.menu_setup.ui['yaw_' .. cond]) or nil
				local d384= d375.menu_setup.ui['yaw_jitter_' .. cond] and ui.get(d375.menu_setup.ui['yaw_jitter_' .. cond]) or nil
				local d385= d375.menu_setup.ui['body_yaw_mode_' .. cond] and ui.get(d375.menu_setup.ui['body_yaw_mode_' .. cond]) or nil
				local d386= d375.menu_setup.ui['delay_' .. cond] and ui.get(d375.menu_setup.ui['delay_' .. cond]) or nil
				ui.set_visible(d375.menu_setup.ui['pitch_' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['yaw_base_' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['yaw_' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['label1_' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['label2_' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['label3_' .. cond], d380 and d382)
				local d387= d380 and d382 and (d383 ~= 'off' and d383 ~= 'ideal' and d383 ~= '3way')
				ui.set_visible(d375.menu_setup.ui['body_yaw_base_' .. cond], d387)
				local d388= d380 and d382 and (d383 == '180' or d383 == '3way')
				ui.set_visible(d375.menu_setup.ui['body_yaw_left_' .. cond], d388)
				ui.set_visible(d375.menu_setup.ui['body_yaw_right_' .. cond], d388)
				local d389= d380 and d382 and (d383 ~= 'off' and d383 ~= 'ideal')
				ui.set_visible(d375.menu_setup.ui['randomize_yaw_' .. cond], d389)
				local d390= d380 and d382 and (d384 ~= 'off')
				ui.set_visible(d375.menu_setup.ui['yaw_jitter_base_' .. cond], d390)
				local d391= d380 and d382 and (d385 == 'static')
				ui.set_visible(d375.menu_setup.ui['static_body_yaw_' .. cond], d391)
				local d392= d380 and d382 and (d385 == 'jitter' and d386 and d386 <= 0)
				ui.set_visible(d375.menu_setup.ui['body_yaw_value_' .. cond], d392)
				local d393= d380 and d382 and (d385 == 'jitter')
				ui.set_visible(d375.menu_setup.ui['delay_' .. cond], d393)
				ui.set_visible(d375.menu_setup.ui['yaw_jitter_' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['body_yaw_mode_' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['fifty_fifty_' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['only_flip_on_0_choke_' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['aa_label_space' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['aa_label_combo' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['send_button' .. cond], d380 and d382)
				ui.set_visible(d375.menu_setup.ui['send_combo' .. cond], d380 and d382)
			end
		end
		ui.set_visible(d375.menu_setup.ui.condition, d376 and d378 == "AA")
		ui.set_visible(d375.menu_setup.ui.condition_label, d376 and d378 == "AA")
		ui.set_visible(d375.menu_setup.ui.condition_label2, d376 and d378 == "AA")


		ui.set_visible(d375.menu_setup.ui.fakelag_mode, d376 and d378 == "AA")
		if d375.menu_setup.ui.fakelag_mode then
			local d394= ui.get(d375.menu_setup.ui.fakelag_mode)
			local d395= d376 and d378 == "AA"
			local d396= d395 and d394 == "defensive"
			local d397= d375.safe.safe_get(d375.menu_setup.ui.fakelag_defensive) == true
			ui.set_visible(d375.menu_setup.ui.fakelag_defensive, d396)
			ui.set_visible(d375.menu_setup.ui.fakelag_force, d396 and d397)
			ui.set_visible(d375.menu_setup.ui.fakelag_force_on, d396 and d397)
			ui.set_visible(d375.menu_setup.ui.fakelag_fakedef, d396 and d397)

			local d398= d395 and d394 == "stealer"
			local d399= d375.safe.safe_get(d375.menu_setup.ui.fakelag_stealer) == true
			ui.set_visible(d375.menu_setup.ui.fakelag_stealer, d398)
			ui.set_visible(d375.menu_setup.ui.fakelag_stealer_type, d398 and d399)
			ui.set_visible(d375.menu_setup.ui.fakelag_stealer_target, d398 and d399)
			ui.set_visible(d375.menu_setup.ui.fakelag_stealer_list, d398 and d399)
			ui.set_visible(d375.menu_setup.ui.fakelag_stealer_refresh, d398 and d399)
			ui.set_visible(d375.menu_setup.ui.fakelag_stealer_steal, d398 and d399)

			local d400= d395 and d394 == "fakelag"
			local d401= d375.safe.safe_get(d375.menu_setup.ui.fakelag_fakelag) == true
			local d402= d375.safe.safe_get(d375.menu_setup.ui.fakelag_fakelag_type) == "sodium"
			ui.set_visible(d375.menu_setup.ui.fakelag_fakelag, d400)
			ui.set_visible(d375.menu_setup.ui.fakelag_fakelag_type, d400 and d401)
			ui.set_visible(d375.menu_setup.ui.fakelag_fakelag_amount, d400 and d401 and not d402)
			ui.set_visible(d375.menu_setup.ui.fakelag_fakelag_variance, d400 and d401 and not d402)
			ui.set_visible(d375.menu_setup.ui.fakelag_fakelag_limit, d400 and d401 and not d402)
			ui.set_visible(d375.menu_setup.ui.fakelag_fakelag_type2, d400 and d401 and d402)

			local d403= d395 and d394 == "settings"
			ui.set_visible(d375.menu_setup.ui.fakelag_settings_freestanding, d403)
			ui.set_visible(d375.menu_setup.ui.fakelag_settings_enhance_onshot, d403)
			ui.set_visible(d375.menu_setup.ui.fakelag_settings_antibrute, d403)
			ui.set_visible(d375.menu_setup.ui.fakelag_settings_roll_label, d403)
			ui.set_visible(d375.menu_setup.ui.fakelag_settings_roll_checkbox, d403)
			local d404= d403 and d375.safe.safe_get(d375.menu_setup.ui.fakelag_settings_roll_checkbox) == true
			ui.set_visible(d375.menu_setup.ui.fakelag_settings_roll, d404)
			ui.set_visible(d375.menu_setup.ui.fakelag_settings_side, d404)
		end

		local d405= d376 and d378 == "PAINT" and ui.get(d375.menu_setup.ui.paint_indicators_enable) == true
		local d406= d376 and d378 == "PAINT" and d405 and ui.get(d375.menu_setup.ui.paint_indicators) ~= "off"
		local d407= d376 and d378 == "PAINT" and d405 and ui.get(d375.menu_setup.ui.paint_indicators) == "small"
		ui.set_visible(d375.menu_setup.ui.paint_indicators, d405)
		ui.set_visible(d375.menu_setup.ui.paint_indicators_enable, d406)
		ui.set_visible(d375.menu_setup.ui.paint_indicators_animation, d406)
		ui.set_visible(d375.menu_setup.ui.paint_indicators_bar, d407)
		ui.set_visible(d375.menu_setup.ui.paint_indicator_color, d406)

		local d408= d376 and d378 == "PAINT" and ui.get(d375.menu_setup.ui.paint_advertisement) == true
		ui.set_visible(d375.menu_setup.ui.paint_advertisement_color, d408)

		local d409= d376 and d378 == "PAINT" and ui.get(d375.menu_setup.ui.paint_watermark) == true
		ui.set_visible(d375.menu_setup.ui.paint_watermark_color, d409)

		local d410= d376 and d378 == "MISC" and d375.safe.safe_get(d375.menu_setup.ui.misc_dormantaimbot) == true
		ui.set_visible(d375.menu_setup.ui.misc_dormantaimbot_key, d410)
		ui.set_visible(d375.menu_setup.ui.misc_dormantaimbot_value, d410)

		local d411= d376 and d378 == "PAINT" and d375.safe.safe_get(d375.menu_setup.ui.paint_logger_checkbox) == true
		ui.set_visible(d375.menu_setup.ui.paint_logger, d411)
		ui.set_visible(d375.menu_setup.ui.paint_logger_animation, d411)
		ui.set_visible(d375.menu_setup.ui.paint_logger_color, d411)

		local d412= d376 and d378 == "PAINT" and d375.safe.safe_get(d375.menu_setup.ui.paint_aspect_ratio_checkbox) == true
		ui.set_visible(d375.menu_setup.ui.paint_aspect_ratio, d412)

		local d413= d376 and d378 == "PAINT" and d375.safe.safe_get(d375.menu_setup.ui.paint_third_person_distance_checkbox) == true
		ui.set_visible(d375.menu_setup.ui.paint_third_person_distance, d413)

	end

	local d414= {
		'aa_gskey_freestand',
		'aa_gskey_freestandh',
		'aa_gskey_slowmotion',
		'aa_gskey_slowmotionh',
		'aa_gskey_edgeyaw',
		'aa_gskey_edgeyawh',
		'aa_gskey_onshot',
		'aa_gskey_onshoth',
	}
	for _, key in ipairs(d414) do
		if d375.menu_setup.ui[key] then
			ui.set_visible(d375.menu_setup.ui[key], tab_name == "AA")
		end
	end

	local d415= {
		'misc_resolver',
		'misc_ragebot',
		'misc_dormantaimbot',
		'misc_exploit_fakelag',
		'misc_walkbot',
		'misc_backstab',
		'misc_spindead',
	}
	for _, key in ipairs(d415) do
		if d375.menu_setup.ui[key] then
			ui.set_visible(d375.menu_setup.ui[key], tab_name == "MISC")
		end
	end

	local d416= {
		'paint_target_info',
		'label_space2',
		'label_space3',
		'label_space4',
		'paint_entidx',
		'paint_filter_console',
		'paint_minimum_damage',
		'paint_show_damage_penetration',
		'paint_hitmiss_indicator',
		'paint_self_skeleton',
		'paint_bullet_tracer',
		'paint_lagcomp_box',
		'paint_lagcomp_box_color',
		'paint_presmoke',
		'paint_bombwarning',
		'paint_insults',
		'paint_rainbow_esp',
		'paint_molotov',
		'paint_lag_record',
		'paint_advertisement',
		'paint_advertisement_animation',
		'paint_clantag',
		'paint_aimbot_logs',
		'paint_indicators_label',
		'paint_indicators_enable',
		'label_space1',
		'paint_watermark',
		'paint_watermark_type',
		'paint_logger_label',
		'paint_logger_checkbox',
		'paint_hitmarker',
		'paint_hitmarker_color',
		'paint_warnings',
		'paint_animations',
		'paint_performance_mode',
		'paint_aspect_ratio_checkbox',
		'paint_third_person_distance_checkbox',
	}
	for _, key in ipairs(d416) do
		if d375.menu_setup.ui[key] then
			ui.set_visible(d375.menu_setup.ui[key], tab_name == "PAINT")
		end
	end

		local d417= {
			'cfg_load_button',
			'cfg_save_button',
			'cfg_delete_button',
			'cfg_refresh_button',
			'cfg_create_button',
			'cfg_export_button',
			'cfg_import_button',
			'cfg_input_box',
			'cfg_listbox',
			'cfg_selection',
			'cfg_cloud',
			'cfg_cloud_apply',
		}
		for _, key in ipairs(d417) do
			if d375.menu_setup.ui[key] then
				ui.set_visible(d375.menu_setup.ui[key], d376 and d378 == "CFG")
			end
		end

end

local function d418(d375)
	local d419= {
		d375.menu_setup.ui.condition,
		d375.menu_setup.ui.fakelag_mode,
	}
	for _, item in ipairs(d419) do
		if item then
			ui.set_callback(item, function()
				d374(d375)
			end)
		end
	end

	for _, cond in ipairs(d372) do
		local d420= {
			'enable_' .. cond,
			'yaw_' .. cond,
			'yaw_jitter_' .. cond,
			'body_yaw_mode_' .. cond,
			'fifty_fifty_' .. cond,
			'only_flip_on_0_choke_' .. cond,
			'aa_label_space' .. cond,
			'aa_label_combo' .. cond,
			'send_button' .. cond,
			'send_combo' .. cond,
		}
		for _, key in ipairs(d420) do
			local d421= d375.menu_setup.ui[key]
			if d421 then
				ui.set_callback(d421, function()
					d374(d375)
				end)
			end
		end
	end

	local d422= {
		'fakelag_defensive',
		'fakelag_stealer',
		'fakelag_fakelag',
		'fakelag_fakelag_type',
		'fakelag_settings_roll_label',
		'fakelag_settings_roll_checkbox',
	}
	for _, key in ipairs(d422) do
		local d421= d375.menu_setup.ui[key]
		if d421 then
			ui.set_callback(d421, function()
				d374(d375)
			end)
		end
	end

	if d375.menu_setup.ui.paint_indicators then
		ui.set_callback(d375.menu_setup.ui.paint_indicators, function()
			d374(d375)
		end)
	end

	if d375.menu_setup.ui.paint_advertisement then
		ui.set_callback(d375.menu_setup.ui.paint_advertisement, function()
			d374(d375)
		end)
	end
	
	if d375.menu_setup.ui.paint_watermark then
		ui.set_callback(d375.menu_setup.ui.paint_watermark, function()
			d374(d375)
		end)
	end

	if d375.menu_setup.ui.misc_dormantaimbot then
		ui.set_callback(d375.menu_setup.ui.misc_dormantaimbot, function()
			d374(d375)
		end)
	end

	if d375.menu_setup.ui.paint_logger_checkbox then
		ui.set_callback(d375.menu_setup.ui.paint_logger_checkbox, function()
			d374(d375)
		end)
	end

	if d375.menu_setup.ui.paint_aspect_ratio_checkbox then
		ui.set_callback(d375.menu_setup.ui.paint_aspect_ratio_checkbox, function()
			d374(d375)
		end)
	end

	if d375.menu_setup.ui.paint_third_person_distance_checkbox then
		ui.set_callback(d375.menu_setup.ui.paint_third_person_distance_checkbox, function()
			d374(d375)
		end)
	end

	if d375.menu_setup.ui.paint_indicators_enable then
		ui.set_callback(d375.menu_setup.ui.paint_indicators_enable, function()
			d374(d375)
		end)
	end

	if d375.login and type(d375.login.add_state_callback) == 'function' then
		d375.login.add_state_callback(function()
			d374(d375)
		end)
	end
end

return {
	update = d374,
	setup_callbacks = d418
}]]
d958["require/abc/push_gamesense"] = [[local d375= renderer
local d376= globals
local d377= string.char

local d378= nil
local function d379()
    if d378 then return d378 end
    if d375.load_rgba then
        local d380, d381= pcall(d375.load_rgba,
            string.char(
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
            ), 4, 4)
        if d380 and d381 then d378 = d381 end
    end
    return d378
end


local function d382(d383,d384,d385,d386,d387,d388)
    local d389= d383 - 3
    local d390= d384 - 40
    local d391= d385 + 5
    local d392= d386 + 1
    d375.rectangle(d383 - 10, d384 - 48, d385 + 20, d386 + 16, 0, 0, 0, 200)
    d375.rectangle(d383 - 9, d384 - 47, d385 + 18, d386 + 14, 60, 60, 60, 255)
    d375.rectangle(d383 - 8, d384 - 46, d385 + 16, d386 + 12, 40, 40, 40, 255)
    d375.rectangle(d383 - 5, d384 - 43, d385 + 10, d386 + 6, 60, 60, 60, 255)
    d375.rectangle(d383 - 4, d384 - 42, d385 + 8, d386 + 4, 12, 12, 12, 255)
    d375.rectangle(d383 - 4, d384 - 42, d385 + 8, d386 + 4, 32, 32, 32, 255)
    local d393= d379()
    if d393 and d375.texture then
        d375.texture(d393, d389, d390, d391, d392, 255,255,255,d387, 'r')
    else
        d375.rectangle(d389, d390, d391, d392, 0, 0, 0, 0)
    end

    
    if d375.gradient then
        d375.gradient(d383 - 4, d384 - 42, d385 / 2 + 1, 1, 59, 175, 222, 255, 202, 70, 205, 255, true)
        d375.gradient(d383 - 4 + d385 / 2, d384 - 42, d385 / 2 + 8.5, 1, 202, 70, 205, 255, 204, 227, 53, 255, true)
    end
    d375.text(d383, d384 - 40, 255, 255, 255, 255, '', nil, d388)
end

return d382
]]
d958["require/abc/push_logger"] = [[local d378= renderer
local d379= globals
local d380= client
local d381= entity
local d382= table.insert
local d383= table.remove
local d384= math.floor
local d385= math.sqrt
local d386= string.char


local d387, d388= pcall(require, "require/abc/menu_setup")


local d389, d390= pcall(ui.reference, 'misc', 'settings', 'menu color')

local d391= {}
local d392= 5

local function d393(d394,d395,d396,d397,d398,d399)
    if #d391 >= d392 then
        d383(d391, 1)
    end
    d382(d391, {
        text = tostring(d394),
        duration = d395 or 5,
        color = { d396 or 255, d397 or 255, d398 or 255, d399 or 255 },
        timestamp = d379 and d379.curtime and d379.curtime() or os.clock(),
    })
end

local function d400(d401)
    local d402, d403, d404= pcall(d378.measure_text, '', d401)
    if d402 and type(d403) == 'number' then return d403, d404 or 0 end
    d402, d403, h = pcall(d378.measure_text, d401)
    if d402 and type(d403) == 'number' then return d403, d404 or 0 end
    return 0, 0
end

local function d405(d406,d407,d408)
    if d406 < d407 then return d407 end
    if d406 > d408 then return d408 end
    return d406
end


local function d409()
    if d387 and d388 and d388.ui and d388.ui.paint_logger then
        local d402, d410= pcall(ui.get, d388.ui.paint_logger)
        if d402 and d410 then return true end
        return false
    end
    
    return true
end


local function d411()
    if d387 and d388 and d388.ui and d388.ui.paint_logger_animation then
        local d402, d406= pcall(ui.get, d388.ui.paint_logger_animation)
        if d402 and type(d406) == 'number' then return d406 end
    end
    return 0
end


local d412, d413= pcall(require, "require/abc/push_modern")
local d414, d415= pcall(require, "require/abc/push_gamesense")


local function d416(d417)
    local d418= 80
    local d419= d417 - 80
    local d420= 40
    local d421= d417 / 2 - 300
    local d422= d417 - d421 - 10
    d422 = d405(d422, d418 + d420, d419 - d420)
    local d423= d422 - d420
    local d424= d422 + d420
    return d423, d424, d422
end

local function d425()
    if not d378 or not d378.text then return end
    if not d409() then return end

    local d426= d411() or 0
    local d427= d379 and d379.curtime and d379.curtime()
    local d428, d417= d380 and d380.screen_size and d380.screen_size() or 800, 600
    local d429= d417 * 0.5 + (d417 * 0.5 * 1.8)
    local d430= 0
    for i = #d391, 1, -1 do
        local d431= d391[i]
        local d432= (d431.timestamp + d431.duration) - d427
        if d432 <= 0 then
            d383(d391, i)
        else
            local d433, d434= d400(d431.text)
            local d435= (d426 == 1) and 4 or 2
            local d436= 2
            local d437= d428 / 2 - d433 / 2
            local d438= d429 + d430
            local d439= 5
            local d440= d384((d431.color[4] or 255) * math.min(1, (d432 / d431.duration) * d439))
            local d441= (d431.duration - d432)
            local d442= (d431.duration > 0 and d431.duration or 1)
            local d443= d441 / d442
            local d444= 6
            local d445= d405(d443 * d444, 0, 1)
            local d446= d445
            
            
            local d447= math.min(0.5, d442 * 0.25)
            if d432 <= d447 then
                local d448= d432 / d447 
                d446 = d405(d448, 0, 1)
            end
            if d426 == 1 then
                d413(d437, d438, d433, 13, d440, d431.text, d446)
                d430 = d430 + (d434 + d435 * 2 + d385(d436 / 10) * 4)
            else
                d415(d437, d438, d433, 13, d440, d431.text)
                d430 = d430 + (d434 + d435 * 2 + d385(d436 / 10) * 35)
            end
        end
    end
end

if d380 and d380.set_event_callback then
    d380.set_event_callback('paint', d425)
else
    
    d380.set_event_callback('paint', d425)
end

return d393
]]
d958["require/abc/push_modern"] = [[local d381= renderer
local d382= ui
local d383= math.floor

local d384, d385= pcall(require, "require/abc/menu_setup")
local d386, d387= pcall(d382.reference, 'misc', 'settings', 'menu color')

local function d388(d389,d390,d391,d392,d393,d394,d395,d396,d397)
    if not d393 or d393 <= 0 then
        d381.rectangle(d389, d390, d391, d392, d394,d395,d396,d397)
        return
    end
    d381.rectangle(d389 + d393, d390, d391 - (d393 * 2), d392, d394,d395,d396,d397)
    d381.rectangle(d389, d390 + d393, d391, d392 - (d393 * 2), d394,d395,d396,d397)
    d381.circle(d389 + d393, d390 + d393, d394,d395,d396,d397, d393, 0, 1)
    d381.circle(d389 + d391 - d393, d390 + d393, d394,d395,d396,d397, d393, 0, 1)
    d381.circle(d389 + d393, d390 + d392 - d393, d394,d395,d396,d397, d393, 0, 1)
    d381.circle(d389 + d391 - d393, d390 + d392 - d393, d394,d395,d396,d397, d393, 0, 1)
end

local function d398(d399,d400,d401,d402)
    local d403, d404, d405, d406= d399 or 255, d400 or 140, d401 or 0, d402 or 255
    
    if d384 and d385 and d385.ui and d385.ui.paint_logger_color then
        local d407, d408, d409, d410, d411= pcall(d382.get, d385.ui.paint_logger_color)
        if d407 then
            if type(d408) == 'number' then
                d403 = d383(d408 or d403)
                d404 = d383(d409 or d404)
                d405 = d383(d410 or d405)
                d406 = d383(d411 or d406)
            elseif type(d408) == 'string' and #d408 == 12 then
                local d412
                d412, mr = pcall(function() return tonumber(d408:sub(1,3)) end)
                d412, mg = pcall(function() return tonumber(d408:sub(4,6)) end)
                d412, mb = pcall(function() return tonumber(d408:sub(7,9)) end)
                d412, ma = pcall(function() return tonumber(d408:sub(10,12)) end)
                d403 = d403 or d399; d404 = d404 or d400; d405 = d405 or d401; d406 = d406 or d402
            end
            return d403, d404, d405, d406
        end
    end

    
    if d386 and d387 then
        local d407, d408, d409, d410, d411= pcall(d382.get, d387)
        if d407 then
            if type(d408) == 'number' then
                d403 = d383(d408 or d403)
                d404 = d383(d409 or d404)
                d405 = d383(d410 or d405)
                d406 = d383(d411 or d406)
            elseif type(d408) == 'string' and #d408 == 12 then
                local d412
                d412, mr = pcall(function() return tonumber(d408:sub(1,3)) end)
                d412, mg = pcall(function() return tonumber(d408:sub(4,6)) end)
                d412, mb = pcall(function() return tonumber(d408:sub(7,9)) end)
                d412, ma = pcall(function() return tonumber(d408:sub(10,12)) end)
                d403 = d403 or d399; d404 = d404 or d400; d405 = d405 or d401; d406 = d406 or d402
            end
        end
    end
    return d403, d404, d405, d406
end

local function d413(d389,d390,d391,d392,d414,d415,d416)
    local d417= d389 - 4
    local d418= d390 - 40
    local d419= d391 + 8
    local d420= d392 + 1

    local d421= 6
    if d420 < 12 then d421 = math.max(1, math.floor(d420 / 2)) end
    local d422= math.max(1, d421 - 1)

    local d403, d404, d405, d406= d398(255, 140, 0, 255)
    local d423= d383((d406 or 255) * 0.95)

    d416 = math.max(0, math.min(1, d416 or 1))
    local d424= d417 - 1
    local d425= d418 - 1
    local d426= d419 + 2
    local d427= d420 + 2
    local d428= d426 / 2 + (d426 * 0.1)
    local d429= d383(d428 * d416)

    if d429 > 0 then
        local d430= math.min(d421 + 1, d383(d427 / 2), d383(d429 / 2))
        d388(d424, d425, d429, d427, d430, d403, d404, d405, d423)
        d388(d424 + d426 - d429, d425, d429, d427, d430, d403, d404, d405, d423)
    end
    d388(d417, d418, d419, d420, d421, 10, 10, 10, 230)
    d388(d417 + 1, d418 + 1, d419 - 2, d420 - 2, d422, 6, 6, 6, 220)
    if d381.gradient then
        d381.gradient(d417 + 2, d418 + 1, math.max(0, d419 - 4), 2, d403, d404, d405, d383(d423 * 0.14), d403, d404, d405, 0, true)
    end
    d381.text(d389, d390 - 40, 255, 255, 255, 255, '', nil, d415)
end

return d413]]
d958["require/abc/register"] = [[local d384= require("require.abc.login_system")
local d385= "acc_" .. "OIDFGNSOIGNSFGIOSNGOISNGIOS"

local function d386(d387)
    local d388= {}
    for part in d387:gmatch("%S+") do
        table.insert(d388, part)
    end
    return d388
end

client.set_event_callback("console_input", function(d389)
    local d388= d386(d389 or "")
    if #d388 == 0 then return end

    local d390= d388[1]:lower()
    if d390 ~= "register" then
        
        return
    end

    if #d388 < 4 then
        client.log("Usage: register <username> <password> <invite>")
        return
    end

    local d391= d388[2]
    local d392= d388[3]
    local d393= d388[4]

    local d394, d395= d384.is_valid_invite(d393)
    if not d394 then
        client.log("Register failed: invalid or used invite")
        return
    end

    local d396= database.read(d385) or {}
    if d396[d391] then
        client.log("Register failed: username already exists - ", d391)
        return
    end

    local d397, d398= d384.register_with_invite(d393, d391, d392)
    if d397 then
        client.log("Registered user:", d391)
    else
        client.log("Register failed:", d398 or "unknown error")
    end
end)]]
d958["require/abc/screen_logger"] = [[local d387= renderer
local d388= globals
local d389= client
local d390= table.insert
local d391= table.remove
local d392= math.floor




local d393= {}
local d394= 12

local function d395(d396)
    local d397, d398, d399= pcall(d387.measure_text, '', d396)
    if d397 and type(d398) == 'number' then return d398, d399 or 0 end
    d397, d398, h = pcall(d387.measure_text, d396)
    if d397 and type(d398) == 'number' then return d398, d399 or 0 end
    return 0, 0
end

local function d400(d401,d402,d403,d404,d405,d406)
    if not d401 then return end
    d402 = d402 or 4
    if #d393 >= d394 then
        d391(d393, 1)
    end
    d390(d393, {
        text = tostring(d401),
        duration = d402,
        color = { d403 or 255, d404 or 255, d405 or 255, d406 or 255 },
        ts = d388 and d388.curtime and d388.curtime() or os.clock(),
    })
    return true
end

local function d407()
    if not d387 or not d387.text then return end
    local d408= d388 and d388.curtime and d388.curtime() or os.clock()
    local d409, d410= d389 and d389.screen_size and d389.screen_size() or 800, 600

    local d411= 8
    local d412= 6
    local d413= 14
    local d414= 2

    local d415= d412

    for i = #d393, 1, -1 do
        local d416= d393[i]
        if not d416 then goto continue end
        local d417= d408 - (d416.ts or 0)
        local d418= (d416.duration or 4) - d417
        if d418 <= 0 then
            d391(d393, i)
        else
            local d419, d420= d395(d416.text)
            
            local d421= d392(d416.color[4] or 255)
            
            pcall(d387.text, d411, d415, d416.color[1] or 255, d416.color[2] or 255, d416.color[3] or 255, d421, 'b', 0, d416.text)
            d415 = d415 + (d420 > 0 and d420 or d413) + d414
        end
        ::continue::
    end
end

if d389 and d389.set_event_callback then
    d389.set_event_callback('paint', d407)
end

return d400]]
d958["require/brain/dll"] = [=[local ffi = require("ffi")

ffi.cdef([[
struct Vec3 { double x; double y; double z; };
struct AspectState { double original; double last; double last_update; int initialized; };
const char* clipboard_get();
int clipboard_set(const char* text);
int clipboard_empty();
int clantag_anim(double start_time, double now, char* out_buf, int out_buf_len);
void tracer_reset();
void tracer_push_shot(double sx, double sy, double sz, double t);
void tracer_set_impact(double ix, double iy, double iz, double t);
int tracer_collect(double now, double tracer_life, double fade_fraction, double pitch, double yaw, double fallback_dist, double base_alpha, double* out_buf, int max_lines);
 ]])


local function hex(val)
    local ok, num = pcall(ffi.cast, "uintptr_t", val)
    if not ok then return "<na>" end
    return string.format("0x%X", tonumber(num))
end

local function resolve_call_trampoline()
    local tramp = client.find_signature("engine.dll", "\xFF\xE1")
    if tramp == nil then
        return nil
    end
    return ffi.cast("void*", tramp)
end

local function make_import_thunk(sig_pattern, cast_type)
    local addr = client.find_signature("engine.dll", sig_pattern)
    if addr == nil then
        return nil
    end
    local ptr = ffi.cast("void***", ffi.cast("uintptr_t", addr) + 2)[0][0]
    return ptr
end

local call_trampoline = resolve_call_trampoline()
local gm_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B", "void *")
local gpa_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05", "void *")

if gm_thunk and gpa_thunk then
else
    return
end

local function via_trampoline(target, signature, label)
    local fn = ffi.cast(signature, call_trampoline)
    return function(...)
        return fn(target, ...)
    end
end

local function to_wide(str)
    local buf = ffi.new("wchar_t[?]", #str + 1)
    for i = 1, #str do buf[i - 1] = string.byte(str, i) end
    buf[#str] = 0
    return buf
end

local GetModuleHandleA_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const char *)", "GMH A")
local GetModuleHandleW_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const wchar_t *)", "GMH W")
local GetProcAddress_tr   = via_trampoline(gpa_thunk, "void *(__thiscall *)(void *, void *, const char *)", "GPA")

local function call_GetModuleHandle(name)
    local ok1, res1 = pcall(GetModuleHandleA_tr, name)
    if not ok1 then dbg("GetModuleHandleA tramp err", res1) end
    if ok1 and res1 ~= nil and res1 ~= ffi.NULL then
        return res1, "tramp ansi"
    end

    local ok2, res2 = pcall(GetModuleHandleW_tr, to_wide(name))
    if not ok2 then dbg("GetModuleHandleW tramp err", res2) end
    if ok2 and res2 ~= nil and res2 ~= ffi.NULL then
        return res2, "tramp wide"
    end

    return nil, "failed"
end

local function call_GetProcAddress(mod, name)
    local ok, res = pcall(GetProcAddress_tr, mod, name)
    if not ok then dbg("GetProcAddress tramp err", res) end
    if ok and res ~= nil and res ~= ffi.NULL then return res end
    return nil
end

local mod, gm_variant = call_GetModuleHandle("sodiumdll.dll")
if mod == nil then
    return
end

local function bind_export(name, cdecl_sig)
    local addr = call_GetProcAddress(mod, name)
    if addr == nil then
        return nil
    end
    return addr, ffi.cast(cdecl_sig, addr)
end

local add_addr, add_fn = bind_export("add", "int(__cdecl*)(int, int)")
local get_value_addr, get_value_fn = bind_export("get_value", "int(__cdecl*)(void)")
local pin_module_addr, pin_module_fn = bind_export("pin_module", "void(__cdecl*)(void)")
local release_module_addr, release_module_fn = bind_export("release_module", "void(__cdecl*)(void)")
local get_hwid_addr, get_hwid_fn = bind_export("get_hwid", "const char*(__cdecl*)(void)")
local clipboard_get_addr, clipboard_get_fn = bind_export("clipboard_get", "const char*(__cdecl*)(void)")
local clipboard_set_addr, clipboard_set_fn = bind_export("clipboard_set", "int(__cdecl*)(const char*)")
local clipboard_empty_addr, clipboard_empty_fn = bind_export("clipboard_empty", "int(__cdecl*)(void)")
local clantag_anim_addr, clantag_anim_fn = bind_export("clantag_anim", "int(__cdecl*)(double, double, char*, int)")
local tracer_reset_addr, tracer_reset_fn = bind_export("tracer_reset", "void(__cdecl*)(void)")
local tracer_push_shot_addr, tracer_push_shot_fn = bind_export("tracer_push_shot", "void(__cdecl*)(double, double, double, double)")
local tracer_set_impact_addr, tracer_set_impact_fn = bind_export("tracer_set_impact", "void(__cdecl*)(double, double, double, double)")
local tracer_collect_addr, tracer_collect_fn = bind_export("tracer_collect", "int(__cdecl*)(double, double, double, double, double, double, double, double*, int)")

local vec_make_addr, vec_make_fn = bind_export("vec_make", "struct Vec3(__cdecl*)(double, double, double)")
local vec_add_addr, vec_add_fn = bind_export("vec_add", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_sub_addr, vec_sub_fn = bind_export("vec_sub", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_mul_scalar_addr, vec_mul_scalar_fn = bind_export("vec_mul_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_div_scalar_addr, vec_div_scalar_fn = bind_export("vec_div_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_unm_addr, vec_unm_fn = bind_export("vec_unm", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_length_addr, vec_length_fn = bind_export("vec_length", "double(__cdecl*)(struct Vec3)")
local vec_dot_addr, vec_dot_fn = bind_export("vec_dot", "double(__cdecl*)(struct Vec3, struct Vec3)")
local vec_cross_addr, vec_cross_fn = bind_export("vec_cross", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_normalized_addr, vec_normalized_fn = bind_export("vec_normalized", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_distance_addr, vec_distance_fn = bind_export("vec_distance", "double(__cdecl*)(struct Vec3, struct Vec3)")

local m_clamp_addr, m_clamp_fn = bind_export("m_clamp", "double(__cdecl*)(double, double, double)")
local m_clamp01_addr, m_clamp01_fn = bind_export("m_clamp01", "double(__cdecl*)(double)")
local m_abs_addr, m_abs_fn = bind_export("m_abs", "double(__cdecl*)(double)")
local m_lerp_addr, m_lerp_fn = bind_export("m_lerp", "double(__cdecl*)(double, double, double)")
local m_distance2d_addr, m_distance2d_fn = bind_export("m_distance2d", "double(__cdecl*)(double, double, double, double)")
local m_distance3d_addr, m_distance3d_fn = bind_export("m_distance3d", "double(__cdecl*)(double, double, double, double, double, double)")
local m_rad_to_deg_addr, m_rad_to_deg_fn = bind_export("m_rad_to_deg", "double(__cdecl*)(double)")
local m_deg_to_rad_addr, m_deg_to_rad_fn = bind_export("m_deg_to_rad", "double(__cdecl*)(double)")
local m_wrap_degrees_addr, m_wrap_degrees_fn = bind_export("m_wrap_degrees", "double(__cdecl*)(double)")
local m_normalize_angle_addr, m_normalize_angle_fn = bind_export("m_normalize_angle", "double(__cdecl*)(double)")
local m_angle_diff_addr, m_angle_diff_fn = bind_export("m_angle_diff", "double(__cdecl*)(double, double)")
local m_lerp_angle_addr, m_lerp_angle_fn = bind_export("m_lerp_angle", "double(__cdecl*)(double, double, double)")
local m_map_addr, m_map_fn = bind_export("m_map", "double(__cdecl*)(double, double, double, double, double)")
local m_smoothstep_addr, m_smoothstep_fn = bind_export("m_smoothstep", "double(__cdecl*)(double, double, double)")
local aspect_update_addr, aspect_update_fn = bind_export("aspect_update", "void(__cdecl*)(void*, double, double, double, double*, int*)")

if not (add_fn and get_value_fn and pin_module_fn and release_module_fn and get_hwid_fn and
    vec_make_fn and vec_add_fn and vec_sub_fn and vec_mul_scalar_fn and vec_div_scalar_fn and
    vec_unm_fn and vec_length_fn and vec_dot_fn and vec_cross_fn and vec_normalized_fn and vec_distance_fn and
    m_clamp_fn and m_clamp01_fn and m_abs_fn and m_lerp_fn and m_distance2d_fn and m_distance3d_fn and
    m_rad_to_deg_fn and m_deg_to_rad_fn and m_wrap_degrees_fn and m_normalize_angle_fn and m_angle_diff_fn and
    m_lerp_angle_fn and m_map_fn and m_smoothstep_fn and aspect_update_fn and
    clipboard_get_fn and clipboard_set_fn and clipboard_empty_fn and clantag_anim_fn and
    tracer_reset_fn and tracer_push_shot_fn and tracer_set_impact_fn and tracer_collect_fn) then
    return
end

local Call_add = via_trampoline(add_addr, "int(__thiscall *)(void*, int, int)", "add")
local Call_get_value = via_trampoline(get_value_addr, "int(__thiscall *)(void*)", "get_value")
local Call_pin_module = via_trampoline(pin_module_addr, "void(__thiscall *)(void*)", "pin_module")
local Call_release_module = via_trampoline(release_module_addr, "void(__thiscall *)(void*)", "release_module")
local Call_get_hwid = via_trampoline(get_hwid_addr, "const char*(__thiscall *)(void*)", "get_hwid")
local Call_clipboard_get = via_trampoline(clipboard_get_addr, "const char*(__thiscall *)(void*)", "clipboard_get")
local Call_clipboard_set = via_trampoline(clipboard_set_addr, "int(__thiscall *)(void*, const char*)", "clipboard_set")
local Call_clipboard_empty = via_trampoline(clipboard_empty_addr, "int(__thiscall *)(void*)", "clipboard_empty")
local Call_clantag_anim = via_trampoline(clantag_anim_addr, "int(__thiscall *)(void*, double, double, char*, int)", "clantag_anim")
local Call_tracer_reset = via_trampoline(tracer_reset_addr, "void(__thiscall *)(void*)", "tracer_reset")
local Call_tracer_push_shot = via_trampoline(tracer_push_shot_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_push_shot")
local Call_tracer_set_impact = via_trampoline(tracer_set_impact_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_set_impact")
local Call_tracer_collect = via_trampoline(tracer_collect_addr, "int(__thiscall *)(void*, double, double, double, double, double, double, double, double*, int)", "tracer_collect")
local Call_vec_make = via_trampoline(vec_make_addr, "struct Vec3(__thiscall *)(void*, double, double, double)", "vec_make")
local Call_vec_add = via_trampoline(vec_add_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_add")
local Call_vec_sub = via_trampoline(vec_sub_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_sub")
local Call_vec_mul_scalar = via_trampoline(vec_mul_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_mul_scalar")
local Call_vec_div_scalar = via_trampoline(vec_div_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_div_scalar")
local Call_vec_unm = via_trampoline(vec_unm_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_unm")
local Call_vec_length = via_trampoline(vec_length_addr, "double(__thiscall *)(void*, struct Vec3)", "vec_length")
local Call_vec_dot = via_trampoline(vec_dot_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_dot")
local Call_vec_cross = via_trampoline(vec_cross_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_cross")
local Call_vec_normalized = via_trampoline(vec_normalized_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_normalized")
local Call_vec_distance = via_trampoline(vec_distance_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_distance")

local Call_m_clamp = via_trampoline(m_clamp_addr, "double(__thiscall *)(void*, double, double, double)", "m_clamp")
local Call_m_clamp01 = via_trampoline(m_clamp01_addr, "double(__thiscall *)(void*, double)", "m_clamp01")
local Call_m_abs = via_trampoline(m_abs_addr, "double(__thiscall *)(void*, double)", "m_abs")
local Call_m_lerp = via_trampoline(m_lerp_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp")
local Call_m_distance2d = via_trampoline(m_distance2d_addr, "double(__thiscall *)(void*, double, double, double, double)", "m_distance2d")
local Call_m_distance3d = via_trampoline(m_distance3d_addr, "double(__thiscall *)(void*, double, double, double, double, double, double)", "m_distance3d")
local Call_m_rad_to_deg = via_trampoline(m_rad_to_deg_addr, "double(__thiscall *)(void*, double)", "m_rad_to_deg")
local Call_m_deg_to_rad = via_trampoline(m_deg_to_rad_addr, "double(__thiscall *)(void*, double)", "m_deg_to_rad")
local Call_m_wrap_degrees = via_trampoline(m_wrap_degrees_addr, "double(__thiscall *)(void*, double)", "m_wrap_degrees")
local Call_m_normalize_angle = via_trampoline(m_normalize_angle_addr, "double(__thiscall *)(void*, double)", "m_normalize_angle")
local Call_m_angle_diff = via_trampoline(m_angle_diff_addr, "double(__thiscall *)(void*, double, double)", "m_angle_diff")
local Call_m_lerp_angle = via_trampoline(m_lerp_angle_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp_angle")
local Call_m_map = via_trampoline(m_map_addr, "double(__thiscall *)(void*, double, double, double, double, double)", "m_map")
local Call_m_smoothstep = via_trampoline(m_smoothstep_addr, "double(__thiscall *)(void*, double, double, double)", "m_smoothstep")
local Call_aspect_update = via_trampoline(aspect_update_addr, "void(__thiscall *)(void*, void*, double, double, double, double*, int*)", "aspect_update")


return {
    add = function(a, b)
        return Call_add(a, b)
    end,
    get_value = function()
        return Call_get_value()
    end,
    pin_module = function()
        return Call_pin_module()
    end,
    release_module = function()
        return Call_release_module()
    end,
    get_hwid = function()
        return Call_get_hwid()
    end,
    clipboard_get = function()
        return Call_clipboard_get()
    end,
    clipboard_set = function(text)
        return Call_clipboard_set(text)
    end,
    clipboard_empty = function()
        return Call_clipboard_empty()
    end,
    clantag_anim = function(start_time, now, out_buf, out_buf_len)
        return Call_clantag_anim(start_time, now, out_buf, out_buf_len)
    end,
    tracer_reset = function()
        return Call_tracer_reset()
    end,
    tracer_push_shot = function(sx, sy, sz, t)
        return Call_tracer_push_shot(sx, sy, sz, t)
    end,
    tracer_set_impact = function(ix, iy, iz, t)
        return Call_tracer_set_impact(ix, iy, iz, t)
    end,
    tracer_collect = function(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
        return Call_tracer_collect(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
    end,
    vec_make = function(x, y, z)
        return Call_vec_make(x, y, z)
    end,
    vec_add = function(a, b)
        return Call_vec_add(a, b)
    end,
    vec_sub = function(a, b)
        return Call_vec_sub(a, b)
    end,
    vec_mul_scalar = function(v, s)
        return Call_vec_mul_scalar(v, s)
    end,
    vec_div_scalar = function(v, s)
        return Call_vec_div_scalar(v, s)
    end,
    vec_unm = function(v)
        return Call_vec_unm(v)
    end,
    vec_length = function(v)
        return Call_vec_length(v)
    end,
    vec_dot = function(a, b)
        return Call_vec_dot(a, b)
    end,
    vec_cross = function(a, b)
        return Call_vec_cross(a, b)
    end,
    vec_normalized = function(v)
        return Call_vec_normalized(v)
    end,
    vec_distance = function(a, b)
        return Call_vec_distance(a, b)
    end,
    m_clamp = function(val, minVal, maxVal)
        return Call_m_clamp(val, minVal, maxVal)
    end,
    m_clamp01 = function(val)
        return Call_m_clamp01(val)
    end,
    m_abs = function(val)
        return Call_m_abs(val)
    end,
    m_lerp = function(a, b, t)
        return Call_m_lerp(a, b, t)
    end,
    m_distance2d = function(x1, y1, x2, y2)
        return Call_m_distance2d(x1, y1, x2, y2)
    end,
    m_distance3d = function(x1, y1, z1, x2, y2, z2)
        return Call_m_distance3d(x1, y1, z1, x2, y2, z2)
    end,
    m_rad_to_deg = function(rad)
        return Call_m_rad_to_deg(rad)
    end,
    m_deg_to_rad = function(deg)
        return Call_m_deg_to_rad(deg)
    end,
    m_wrap_degrees = function(angle)
        return Call_m_wrap_degrees(angle)
    end,
    m_normalize_angle = function(angle)
        return Call_m_normalize_angle(angle)
    end,
    m_angle_diff = function(a, b)
        return Call_m_angle_diff(a, b)
    end,
    m_lerp_angle = function(a, b, t)
        return Call_m_lerp_angle(a, b, t)
    end,
    m_map = function(val, in_min, in_max, out_min, out_max)
        return Call_m_map(val, in_min, in_max, out_min, out_max)
    end,
    m_smoothstep = function(edge0, edge1, x)
        return Call_m_smoothstep(edge0, edge1, x)
    end,
    aspect_update = function(state, raw_slider, current_aspect, now, out_target, out_dirty)
        return Call_aspect_update(state, raw_slider, current_aspect, now, out_target, out_dirty)
    end,
    module_base = mod,
}]=]
d958["require/brain/test"] = [[local d393= require("require/brain/api/math/math")
local d394= require("require/brain/api/health/health")
local d395= require("require/brain/api/hwid/hwid")
local d396= require("require/brain/dll")


client.set_event_callback("paint_ui", function()
    local d397, d398= pcall(d393.add, 2, math.random(1, 100))
    if d397 then
        
    end

end)

local d399, d400= pcall(d395.get_hwid)
if d399 and d400 and d400 ~= "" then
    
else
    
end]]
d958["require/brain/api/clipboard/clipboard"] = [[]]
d958["require/brain/api/health/health"] = [[local d399= require("require/brain/dll")

if not d399 then
	error("sodiumdll exports unavailable")
end

return {
	pin_module = function()
		return d399.pin_module()
	end,
	release_module = function()
		return d399.release_module()
	end,
	module_base = d399.module_base,
}]]
d958["require/brain/api/hwid/hwid"] = [[local d402= require("ffi")
local d403= require("require/brain/dll")

if not d403 or not d403.get_hwid then
    error("sodiumdll hwid export missing")
end

return {
	get_hwid = function()
		local d404= d403.get_hwid()
		if not d404 or d404 == d402.NULL then
			return ""
		end
		return d402.string(d404)
	end,
}]]
d958["require/brain/api/ip/ip"] = [[
local d405= require("require/brain/dll")

if not d405 or not d405.get_public_ip then
	return error("sodiumdll ip export missing")
end

return {
	get_public_ip = function(d406,d407)
		return d405.get_public_ip(d406, d407)
	end,
}]]
d958["require/brain/api/math/math"] = [[local d408= require("require/brain/dll")

if not d408 or not d408.m_clamp then
	error("sodiumdll math exports missing")
end

return {
	add = function(d409,d410)
		return d408.add(d409, d410)
	end,
	get_value = function()
		return d408.get_value()
	end,
	m_clamp = function(d411,d412,d413)
		return d408.m_clamp(d411, d412, d413)
	end,
	m_clamp01 = function(d411)
		return d408.m_clamp01(d411)
	end,
	m_abs = function(d411)
		return d408.m_abs(d411)
	end,
	m_lerp = function(d409,d410,d414)
		return d408.m_lerp(d409, d410, d414)
	end,
	m_distance2d = function(d415,d416,d417,d418)
		return d408.m_distance2d(d415, d416, d417, d418)
	end,
	m_distance3d = function(d415,d416,d419,d417,d418,d420)
		return d408.m_distance3d(d415, d416, d419, d417, d418, d420)
	end,
	m_rad_to_deg = function(d421)
		return d408.m_rad_to_deg(d421)
	end,
	m_deg_to_rad = function(d422)
		return d408.m_deg_to_rad(d422)
	end,
	m_wrap_degrees = function(d423)
		return d408.m_wrap_degrees(d423)
	end,
	m_normalize_angle = function(d423)
		return d408.m_normalize_angle(d423)
	end,
	m_angle_diff = function(d409,d410)
		return d408.m_angle_diff(d409, d410)
	end,
	m_lerp_angle = function(d409,d410,d414)
		return d408.m_lerp_angle(d409, d410, d414)
	end,
	m_map = function(d411,d424,d425,d426,d427)
		return d408.m_map(d411, d424, d425, d426, d427)
	end,
	m_smoothstep = function(d428,d429,d430)
		return d408.m_smoothstep(d428, d429, d430)
	end,
}]]
d958["require/brain/api/vector/vector"] = [[local d411= require("ffi")
local d412= require("require/brain/dll")

if not d412 or not d412.vec_make or not d412.vec_add or not d412.vec_sub or not d412.vec_mul_scalar or
   not d412.vec_div_scalar or not d412.vec_unm or not d412.vec_length or not d412.vec_dot or
   not d412.vec_cross or not d412.vec_normalized or not d412.vec_distance or not d412.aspect_update then
    error("sodiumdll vector exports missing")
end

local d413= d411.typeof("struct Vec3")

local function d414(d415)
    if d411.istype(d413, d415) then
        return d415
    end
    local d416= (d415 and d415.x) or 0
    local d417= (d415 and d415.y) or 0
    local d418= (d415 and d415.z) or 0
    return d412.vec_make(d416, d417, d418)
end

return {
    Vec3 = d413,
    make = function(d416,d417,d418)
        return d412.vec_make(d416 or 0, d417 or 0, d418 or 0)
    end,
    add = function(d419,d420)
        return d412.vec_add(d414(d419), d414(d420))
    end,
    sub = function(d419,d420)
        return d412.vec_sub(d414(d419), d414(d420))
    end,
    mul_scalar = function(d415,d421)
        return d412.vec_mul_scalar(d414(d415), d421)
    end,
    div_scalar = function(d415,d421)
        return d412.vec_div_scalar(d414(d415), d421)
    end,
    unm = function(d415)
        return d412.vec_unm(d414(d415))
    end,
    length = function(d415)
        return d412.vec_length(d414(d415))
    end,
    dot = function(d419,d420)
        return d412.vec_dot(d414(d419), d414(d420))
    end,
    cross = function(d419,d420)
        return d412.vec_cross(d414(d419), d414(d420))
    end,
    normalized = function(d415)
        return d412.vec_normalized(d414(d415))
    end,
    distance = function(d419,d420)
        return d412.vec_distance(d414(d419), d414(d420))
    end,
    aspect_update = d412.aspect_update,
}]]
d958["require/brain/examples/boxes"] = [[local d414= require("ffi")
local d415= {


}


d415.GetModuleHandlePtr = 
    d414.cast(
        "void***", 
        d414.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B")) + 2
    )[0][0]

d415.GetProcAddressPtr = 
    d414.cast(
        "void***", 
        d414.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05")) + 2
    )[0][0]


d415.reinterpret_cast = function(d416,d417) 
    return function(...) 
        return d414.cast(d417, client.find_signature("engine.dll", "\xFF\xE1"))(d416, ...) 
    end
end


d415.fnGetModuleHandle = d415.reinterpret_cast(
    d415.GetModuleHandlePtr, 
    "void*(__thiscall*)(void*, const char*)"
)

d415.GetModuleHandle = function(d418)
    return d415.fnGetModuleHandle(d418)
end 


d415.fnGetProcAddress = d415.reinterpret_cast(
    d415.GetProcAddressPtr, 
    "void*(__thiscall*)(void*, void*, const char*)"
)

d415.GetProcAddress = function(d418,d419)
    local d416= d415.fnGetProcAddress(d418, d419)
    return d416
end 


d415.lib = {}
d415.lib.user32 = d415.GetModuleHandle("user32.dll")


d415.export = {}
d415.export.user32 = {}

d415.export.user32.MessageBoxPtr = d415.GetProcAddress(d415.lib.user32, "MessageBoxA")
d415.export.user32.MessageBox = d415.reinterpret_cast(
    d415.export.user32.MessageBoxPtr,
    "int(__thiscall*)(void*, void*, const char*, const char*, unsigned int)"
)


local d420= 0x00000000
local d421= 0x00000001
local d422= 0x00000004
local d423= 0x00000010
local d424= 0x00000020
local d425= 0x00000030
local d426= 0x00000040


local d427= 1
local d428= 2
local d429= 6
local d430= 7


local function d431(d432,d433,d434)
    d433 = d433 or "Gamesense"
    d434 = d434 or d420
    
    local d435= d415.export.user32.MessageBox(nil, d432, d433, d434)
    return d435
end


local function d436(d432,d433)
    return d431(d432, d433, d420 + d426)
end

local function d437(d432,d433)
    return d431(d432, d433, d420 + d425)
end

local function d438(d432,d433)
    return d431(d432, d433, d420 + d423)
end

local function d439(d432,d433)
    local d435= d431(d432, d433, d422 + d424)
    return d435 == d429
end
d436("test", "test")]]
d958["require/brain/features/aspectratio"] = [[local d417= require("ffi")
local d418= require("require/brain/dll")

if not d418 or not d418.aspect_update then
    error("sodiumdll aspect_update export missing")
end

return {
    aspect_update = function(d419,d420,d421,d422)
        local d423= d417.new("double[1]")
        local d424= d417.new("int[1]")

        d418.aspect_update(d419 or d417.NULL, d420, d421, d422, d423, d424)

        return d423[0], d424[0]
    end,
}]]
d958["require/features/aa/aa_collect"] = [[
local d420= entity
local d421= require('require/abc/menu_setup')
local d422= require('require/aa/player_condition')

local d423= {}
d423.last_side = 'left'

local function d424()
    local d425, d426= pcall(d422.get)
    if not d425 or not d426 then return nil end
    local d427= 'delay_' .. d426
    if not (d421 and d421.ui) then return nil end
    local d428= d421.ui[d427]
    if not d428 then return nil end
    local d429, d430= pcall(ui.get, d428)
    if not d429 then return nil end
    local d431= tonumber(d430)
    if d431 then return d431 end
    return d430
end

local function d432()
    local d425, d426= pcall(d422.get)
    if not d425 or not d426 then return nil end
    local d427= 'fifty_fifty_' .. d426
    if not (d421 and d421.ui) then return nil end
    local d428= d421.ui[d427]
    if not d428 then return nil end
    local d429, d430= pcall(ui.get, d428)
    if not d429 then return nil end
    local d431= tonumber(d430)
    if d431 then return d431 end
    return d430
end

local function d433()
    local d425, d426= pcall(d422.get)
    if not d425 or not d426 then return nil end
    local d427= 'body_yaw_mode_' .. d426
    if not (d421 and d421.ui) then return nil end
    local d428= d421.ui[d427]
    if not d428 then return nil end
    local d429, d430= pcall(ui.get, d428)
    if not d429 then return nil end
    local d431= tonumber(d430)
    if d431 then return d431 end
    return d430
end

local function d434(d435)
    if not (d420 and d420.get_prop and d435) then return d423.last_side end
    local d436= d420.get_prop(d435, 'm_flPoseParameter', 11)
    if d436 == nil then
        return d423.last_side
    end
    local d437= (d436 > 0.5) and 'right' or 'left'
    d423.last_side = d437
    return d437
end

local function d438()
    local d439= d424() + 1
    local d431= tonumber(d439) or 1
    if d431 < 1 then d431 = 1 end
    if d431 > 17 then d431 = 17 end

    local d440= globals.tickcount()
    if not d440 then return d423.last_side end

    local d441= math.floor(d440 / d431) % 2
    local d437= (d441 == 0) and 'left' or 'right'
    d423.last_side = d437
    return d437
end




local function d442()

    local d443= d432()

    if d443 then
        local d444= math.random(0, 1)
        local d437= (d444 == 0) and 'left' or 'right'
        d423.last_side = d437
        return d437
    end

    local d439= d424()
    local d431= tonumber(d439)

    if d433() ~= 'jitter' then
        return d434(d420.get_local_player())
    end

    if not d431 or d431 == 0 then
        local d435= d420.get_local_player()
        if not d435 or d435 == 0 then return d423.last_side end
        return d434(d435)
    else
        return d438()
    end
end





d423.resolve_side = d434
d423.resolve_local_side = d442
d423.get_delay_for_current_condition = d424

return d423]]
d958["require/features/aa/antiaim"] = [[local d423= require('require/features/aa/builder')
local d424= require('require/features/aa/defensive')

local d425= require('require/abc/callbacks')

local function d426()
    local d427= (globals.maxplayers and globals.maxplayers() or 64)
    local d428, d429, d430= entity.get_classname, entity.is_enemy, entity.is_alive
    if not (d428 and d429 and d430) then return 0 end
    local d431= 0
    for i=1,d427 do
        if d428(i) == 'CCSPlayer' and d429(i) and d430(i) then d431 = d431 + 1 end
    end
    return d431
end

d425.register('setup_command', function(d432)
    if d423 and d423.activate then
        d423.activate(d432)
    end

end, { alive_only = true, require_login = true })]]
d958["require/features/aa/antibrute"] = [[]]
d958["require/features/aa/builder"] = [[local d429= require('require/abc/menu_setup')
local d430= require('require/aa/player_condition')
local d431= require('require/features/aa/aa_collect')
local d432= require('require/help/math')
local d433= require('require/help/vector')
local d434= require('require/help/time')
local d435= require('require/help/string')

local d436= {}
client.set_event_callback('weapon_fire', function(d437)
  if not d437 or not d437.userid then return end
  local d438, d439= pcall(client.userid_to_entindex, d437.userid)
  if not d438 or not d439 or d439 == 0 then return end
  d436[d439] = d434.tickcount()
end)

local function d440(d441)
	if not d441 then return nil end

	local d442= {
		pitch = 'pitch_',
		yaw_base = 'yaw_base_',
		yaw = 'yaw_',
		body_yaw_base = 'body_yaw_base_',
		body_yaw_left = 'body_yaw_left_',
		body_yaw_right = 'body_yaw_right_',
		randomize_yaw = 'randomize_yaw_',
		yaw_jitter = 'yaw_jitter_',
		yaw_jitter_base = 'yaw_jitter_base_',
		body_yaw_mode = 'body_yaw_mode_',
		static_body_yaw = 'static_body_yaw_',
		body_yaw_value = 'body_yaw_value_',
		delay = 'delay_',
		fifty_fifty = 'fifty_fifty_',
		only_flip_on_0_choke = 'only_flip_on_0_choke_',
	}

	local d443= { condition = d441 }
	for name, prefix in pairs(d442) do
		local d444= prefix .. d441
		local d445= d429.ui and d429.ui[d444]
		if d445 then
			local d446, d447= pcall(ui.get, d445)
			if d446 then d443[name] = d447 else d443[name] = nil end
		else
			d443[name] = nil
		end
	end

	return d443
end




local function d448()
  local d446, d441= pcall(d430.get)
  if not d446 or not d441 then
    return nil
  end
  local d449= d440(d441)
  return d449 and d449.pitch or nil
end




local function d450()
  local d446, d441= pcall(d430.get)
  if not d446 or not d441 then
    return nil
  end
  local d449= d440(d441)
  local d451= d449 and d449.yaw_base or nil
  if d451 == nil then return nil end
  local d452= d435.lower(tostring(d451))
  if d452 == 'threat' then
    return 'local view'
  elseif d452 == 'distance' then
    return 'local view'
  elseif d452 == 'target' then
    return 'at targets'
  elseif d452 == 'view' then
    return 'local view'
  elseif d452 == 'smart' then
    return 'local view'
  else
    return tostring(d451)
  end
end




local function d453()
	local d446, d441= pcall(d430.get)
	if not d446 or not d441 then
		return nil
	end
	local d449= d440(d441)
	return d449 and d449.yaw or nil
end




local function d454()
    local d446, d441= pcall(d430.get)
    if not d446 or not d441 then
        return nil
    end
    local d449= d440(d441)
    return d449 and d449.yaw_jitter or nil
end




local function d455()
  local d446, d441= pcall(d430.get)
  if not d446 or not d441 then
    return nil
  end
  local d449= d440(d441)
  return d449 and d449.yaw_jitter_base or nil
end




local function d456()
  local d446, d441= pcall(d430.get)
  if not d446 or not d441 then return nil end
  local d449= d440(d441)
  if not d449 then return nil end
  local d457= d449.randomize_yaw
  if d457 == nil then return nil end
  local d458= tonumber(d457)
  if not d458 then return nil end
  if d458 < 0 then d458 = 0 end
  if d458 > 30 then d458 = 30 end
  return math.floor(d458)
end




local function d459()
    local d446, d441= pcall(d430.get)
    if not d446 or not d441 then
        return nil
    end
  local d449= d440(d441)
  local d460= d449 and d449.body_yaw_mode or nil
  if not d460 then return nil end
  local d461= d435.lower(tostring(d460))
  if d461 == 'jitter' then
    local d462= d431.get_delay_for_current_condition and d431.get_delay_for_current_condition() or nil
    local d458= tonumber(d462) or 0
    if d458 > 0 then
      return 'static'
    else
      return 'jitter'
    end
  end
  return d460
end




local function d463()
  local d446, d441= pcall(d430.get)
  if not d446 or not d441 then
    return nil
  end
  local d449= d440(d441)
  if not d449 then return nil end


  local d460= d449.body_yaw_mode
  if d460 ~= nil then d460 = d435.lower(tostring(d460)) end

  if d460 == 'jitter' then
    local d462= d431.get_delay_for_current_condition and d431.get_delay_for_current_condition() or nil
    local d464= tonumber(d462) or 0
    if d464 > 0 then
      local d465= d431.resolve_local_side and d431.resolve_local_side() or nil
      if d465 == 'right' then
        return -58
      else
        return 58
      end
    end

    local d451= d449.body_yaw_value
    local d458= tonumber(d451) or nil
    if d458 == 1 then
      return -180
    elseif d458 == 2 then
      return 0
    elseif d458 == 3 then
      return 180
    end
    return nil
  elseif d460 == 'static' then
    if d449.static_body_yaw ~= nil then
      local d466= tonumber(d449.static_body_yaw)
      if d466 then return d466 end
    end
    local d451= d449.body_yaw_value
    local d458= tonumber(d451) or nil
    if d458 == 1 then
      return -180
    elseif d458 == 2 then
      return 0
    elseif d458 == 3 then
      return 180
    end
    return nil
  else
    return 0
  end
end




local function d467()
  local d446, d441= pcall(d430.get)
  if not d446 or not d441 then
    return nil
  end
  local d449= d440(d441)
  return d449 and d449.body_yaw_base or nil
end




local function d468()
    local d446, d441= pcall(d430.get)
    if not d446 or not d441 then
        return nil
    end
    local d449= d440(d441)
    return d449 and d449.body_yaw_left or nil
end




local function d469()
    local d446, d441= pcall(d430.get)
    if not d446 or not d441 then
        return nil
    end
    local d449= d440(d441)
    return d449 and d449.body_yaw_right or nil
end




local function d470()
    local d446, d441= pcall(d430.get)
    if not d446 or not d441 then
        return nil
    end
    local d449= d440(d441)
    if not d449 then return nil end
    local d457= d449.only_flip_on_0_choke
    if d457 == nil then return nil end
    return not not d457
end




local function d471()
  local d446, d441= pcall(d430.get)
  if not d446 or not d441 then
    return nil
  end
  local d444= 'delay_' .. d441
  if not (d429 and d429.ui) then return nil end
  local d445= d429.ui[d444]
  if not d445 then return nil end
  local d472, d447= pcall(ui.get, d445)
  if d472 then return d447 end
  return nil
end




local function d473()
  local d446, d441= pcall(d430.get)
  if not d446 or not d441 then return nil end
  local d449= d440(d441)
  if not d449 then return nil end
  local d457= d449.fifty_fifty
  if d457 == nil then return nil end
  return not not d457
end





local function d474(d460)
  local d461= d435.lower(tostring(d460 or 'threat'))

  local d475= nil
  if d461 == 'distance' then
    local d476, d477= pcall(entity.get_players, true)
    if not d476 or not d477 or #d477 == 0 then return nil end
    local d478= entity.get_local_player()
    if not d478 then return nil end
    local d479, d480, d481, d482= pcall(entity.get_origin, d478)
    if not d479 or not d480 then return nil end
    local d483= nil
    local d484= nil
    for _, d439 in ipairs(d477) do
      if d439 and entity.is_alive and entity.is_alive(d439) and entity.is_enemy and entity.is_enemy(d439) then
        local d485, d486, d487, d488= pcall(entity.get_origin, d439)
        if d485 and d486 then
          local d489= d432.distance2d(d480, d481, d486, d487)
          if not d484 or d489 < d484 then
            d484 = d489
            d483 = d439
          end
        end
      end
    end
    d475 = d483
    elseif d461 == 'smart' then
      local d476, d477= pcall(entity.get_players, true)
      if d476 and d477 and #d477 > 0 then
        local d478= entity.get_local_player()
        if d478 then
          local d479, d480, d481, d482= pcall(entity.get_origin, d478)
          if d479 and d480 then
            local d483= nil
            local d484= nil
            for _, d439 in ipairs(d477) do
              if d439 and entity.is_alive and entity.is_alive(d439) and entity.is_enemy and entity.is_enemy(d439) then
                local d485, d486, d487, d488= pcall(entity.get_origin, d439)
                if d485 and d486 then
                  local d490= d436[d439]
                  if d490 and d434.within_ticks_window(d490, 10) then goto continue_smart end
                  local d491, d492= pcall(entity.get_player_weapon, d439)
                  if d491 and d492 and d492 ~= 0 then
                    local d493, d494= pcall(entity.get_classname, d492)
                    local d495= d435.lower(d493 and d494 and tostring(d494) or '')
                    if d495:find('knife') or d495:find('grenade') or d495:find('taser') or d495:find('zeus') then goto continue_smart end
                  end
                  do
                    local d489= d432.distance2d(d480, d481, d486, d487)
                    if not d484 or d489 < d484 then
                      d484 = d489
                      d483 = d439
                    end
                  end
                  ::continue_smart::
                end
              end
            end
            d475 = d483
          end
        end
      end
      if not d475 then
        local d496, d497= pcall(client.current_threat)
        if d496 and d497 then d475 = d497 end
      end
    else
      local d496, d497= pcall(client.current_threat)
      if d496 and d497 then d475 = d497 end
    end

  if not d475 then return nil end
  if not (entity.is_alive and entity.is_enemy and entity.is_alive(d475) and entity.is_enemy(d475)) then
    return nil
  end

  local d478= entity.get_local_player()
  if not d478 then return nil end

  local d498, d480, d481, d482= pcall(entity.get_origin, d478)
  local d499, d486, d487, d488= pcall(entity.get_origin, d475)
  if not d498 or not d499 or not d480 or not d486 then return nil end

  local d500= d486 - d480
  local d501= d487 - d481
  local d502= math.atan2(d501, d500)
  local d503= d432.rad_to_deg(d502)

  local d504, d505, d506= pcall(client.camera_angles)
  local d507= d504 and d506 or 0

  local d508= d432.normalize_angle(d503 - d507)
  return d432 and d432.round and d432.round(d508) or math.floor(d508 + 0.5)

end




local d509= {}
local d510= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local d511= {ui.reference(item[1], item[2], item[3])}
    d509[i] = d511
    for _, ref in ipairs(d511) do
        d510[ref] = true
    end
end





local function d512(d513)
  if weaponn ~= nil and entity.get_classname(weaponn) == "CC4" then
    if d513.in_attack == 1 then
        d513.in_attack = 0 
        d513.in_use = 1
    end
  else
    if d513.chokedcommands == 0 then
        d513.in_use = 0
    end
  end

end





local function d514(d513)

    local d515= d513.chokedcommands
    
    if d470() then
        if d515 > 0 then
            return
        end
    end

    local d465= d431.resolve_local_side()

    
    
    
    ui.set(d509[2][1], tostring(d448()))

    
    
    
    ui.set(d509[3][1], tostring(d450()))

    
    
    
    local d516= d453()
    if d516 == "3way" then
      d516 = '180'
    elseif d516 == "ideal" then
      d516 = '180'
    end
    ui.set(d509[4][1], d516)

    
    
    
    ui.set(d509[5][1], tostring(d454()))

    
    
    
    ui.set(d509[5][2], tostring(d455()))

    
    
    
    ui.set(d509[6][1], tostring(d459()))

    
    
    
    ui.set(d509[6][2], tostring(d463()))

    
    
    
    local d517= tonumber(d467()) or 0
    local d518= 0
    if ui.get(d509[4][1]) == '180' then
      if d465 == 'right' then
        d518 = tonumber(d468()) or 0
      elseif d465 == 'left' then
        d518 = tonumber(d469()) or 0
      end
    end
    local d519= d517 + d518
    local d520= tonumber(d456()) or 0
    if d520 > 0 then
      local d521= math.abs(d519) * (d520 / 100)
      local d522= (d432.random_int(-1000, 1000) / 1000)
      local d523= d522 * d521
      d519 = d519 + d523
    end

    do
      local d524, d441= pcall(d430.get)
      if d524 and d441 then
        local d449= d440(d441)
        if d449 then
          local d525= d435.lower(tostring(d449.yaw_base or ''))
          if d525 == 'threat' or d525 == 'distance' then
            local d526= d474(d525)
            if d526 then
              d519 = d519 + tonumber(d526) or d519
            end
          end
        end
      end
    end

    local d527= d432.normalize_angle(d519)
    ui.set(d509[4][2], d432.round(d527))

    
    
    
    d512(d513)

end


return {
  gather = d440,
  activate = d514,
  print_current = d514,
}]]
d958["require/features/aa/defensive"] = [[local d432= {}
d432.active = nil
d432.activate = nil
local d433= require('require/help/time')
local d434= require('require/abc/menu_setup')
local d435= require('require/features/aa/defensive_presets')
local d436= require('require/aa/player_condition')
local d437= require('require/abc/screen_logger')
local d438, d439= pcall(require, 'require/abc/callbacks')




local d440= {}
local d441= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'RAGE', 'Aimbot', 'Double tap' },
    { 'RAGE', 'Other', 'Duck peek assist' },

}) do
    local d442= {ui.reference(item[1], item[2], item[3])}
    d440[i] = d442
    for _, ref in ipairs(d442) do
        d441[ref] = true
    end
end


local d443= {
    cond = nil,
    idx = nil,
    preset = nil,
    selected_tick = 0,
}
local d444= false
local d445= 0





local d446= {
    last = false,
    pending_until = nil,
}
local function d447()
    local d448, d449= pcall(ui.get, d440[10][2])
    local d450= d448 and not not d449 or false
    local d451= d433.tickcount() or (globals and globals.tickcount and globals.tickcount()) or 0
    if d450 and not d446.last then
        d446.pending_until = d451 + 32
    end
    if not d450 then
        d446.pending_until = nil
    end
    d446.last = d450
    if d446.pending_until then
        return d451 >= d446.pending_until
    end
    return d450
end

local function d452()
    local d442= d440[11]
    if not d442 or not d442[1] then
        return false
    end
    local d448, d449= pcall(ui.get, d442[1])
    return d448 and not not d449 or false
end

local function d453()
  local d454= entity.get_local_player()
  if not d454 or not entity.is_alive(d454) then
    return false
  end
  local d455= entity.get_player_weapon(d454)
  if not d455 then
    return false
  end
  local d456= entity.get_classname(d455)
  return d456 == "CKnife"
end




local function d457()
    if not d434 or type(d434) ~= 'table' or not d434.ui then
        return false
    end
    local d458= d434.ui.fakelag_defensive
    if not d458 then
        return false
    end
    local d448, d449= pcall(ui.get, d458)
    return d448 and not not d449 or false
end

local function d459()
    if not d434 or type(d434) ~= 'table' or not d434.ui then
        return false
    end
    local d458= d434.ui.fakelag_force
    if not d458 then
        return false
    end
    local d448, d449= pcall(ui.get, d458)
    return d448 and not not d449 or false
end

local function d460(d461)

    


    local d451= (globals and globals.tickcount and globals.tickcount()) or d433.tickcount() or 0
    d445 = d451
end




local function d462(d463)

    d463 = d463 or 20
    local d464= entity.get_local_player()
    if not d464 then return false end
    local d465= entity.get_prop(d464, "m_flSimulationTime")
    local d466= 1 / globals.tickinterval()
    if not d465 or d466 == 0 then return false end
    local d467= math.floor(d465 * d466 + 0.5)
    local d468= globals.tickcount()
    nigga = d468 >= d467 and d468 <= d467 + d463

    return d468 >= d467 and d468 <= d467 + d463

end







local function d469(d461)
    
    
    
    local d470= false
    local d471= d457()
    local d472= d447()
    local d473= d452()
    local d474= d453()
    local d475= d462()
    

    d470 = d471 and d472 and not d473 and not d474 
    d432.active = d470


    local d451= (globals and globals.tickcount and globals.tickcount()) or d433.tickcount() or 0
    local d476= false
    if d451 and (d445 == nil or d451 - d445 >= 64) then
        d476 = true
        d460(d461)
    end



    
    
    

    
    
    
    if d470 then
        local d477= d436.get() or 'global'
        if (not d444) or (d443.cond ~= d477) or (not d443.preset) then
            local d478, d479= d435.get_random_for_condition(d477)
            if d478 and d479 then
                d443.cond = d477
                d443.idx = d478
                d443.preset = d479
                d443.selected_tick = globals.tickcount()
            else
                d443.cond = d477
                d443.idx = nil
                d443.preset = nil
                d443.selected_tick = 0
            end
        end

        if not d476 then
            if d443.preset and type(d443.preset.apply) == 'function' then
                d443.preset.apply(d443, d461)
            end
        end
    else
        if d444 then
            d443.cond = nil
            d443.idx = nil
            d443.preset = nil
            d443.selected_tick = 0
        end
    end

    d444 = d470

end


d432.activate = d469
d432.reset = d460


d439.register('setup_command', function(d461)
    d469(d461)
end, { alive_only = true, require_login = true })


return d432]]
d958["require/features/aa/defensive_presets"] = [[local d435= require('require/aa/player_condition')
local d436= require('require/help/time')
local d437= require('require/abc/screen_logger')



local d438= {}
local d439= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },

}) do
    local d440= {ui.reference(item[1], item[2], item[3])}
    d438[i] = d440
    for _, ref in ipairs(d440) do
        d439[ref] = true
    end
end


local d441= {}

local function d442(d443,d444,d445) if d443 < d444 then return d444 end if d443 > d445 then return d445 end return d443 end

local function d446(d447,d448,d449)
    local d440= d438[d447]
    if not d440 or not d440[d448] then return false end
    pcall(ui.set, d440[d448], d449)
    return true
end



local d450, d451= pcall(require, "require/abc/menu_setup")



local function d452(d453)

    local d454, d451= pcall(require, "require/abc/menu_setup")
    if not d454 or not d451 or not d451.ui then return end
    local d455, d456= pcall(ui.get, d451.ui.fakelag_fakedef)

    
    if d456 then 
        d453.force_defensive = false
    else
        d453.force_defensive = true
    end

end

do
    local d457, d458= pcall(require, "require/abc/callbacks")

    ticks = ticks or {}
    ticks.tickbase_max = ticks.tickbase_max or nil
    ticks.tickbase_diff = ticks.tickbase_diff or nil
    ticks.current_cmd = ticks.current_cmd or nil

    ticks.runc = function(d453)
        if not d453 then return end
        ticks.current_cmd = d453.command_number
    end

    ticks.tickcalc = function(d453)
        if not d453 then return end
        if d453.command_number == ticks.current_cmd then
            ticks.current_cmd = nil
            local d459= entity.get_local_player()
            if not d459 then return end
            local d460= entity.get_prop(d459, "m_nTickBase")
            if d460 then
                if ticks.tickbase_max ~= nil then
                    ticks.tickbase_diff = d460 - ticks.tickbase_max
                end
                ticks.tickbase_max = math.max(d460, ticks.tickbase_max or 0)
            end
        end
    end

    if d457 and d458 and d458.callback then
        d458.callback('run_command', ticks.runc, { alive_only = true, require_login = true })
        d458.callback('predict_command', ticks.tickcalc, { alive_only = true, require_login = true })
    end
end

client.set_event_callback("level_init", function()
    ticks.tickbase_max = nil
    ticks.tickbase_diff = nil
end)


local function d461(d462)
    local d459= entity.get_local_player()
    if not d459 then return false end

    local d463= entity.get_prop(d459, 'm_nTickBase')
    if not d463 then return false end

    local d464= ticks and ticks.tickbase_max or 0

    if math.abs(d463 - d464) > 64 then
        d464 = 0
    end

    local d465= 0

    if d463 > d464 then
        d464 = d463
    elseif d464 > d463 then
        d465 = math.min(14, math.max(0, d464 - d463 - 1))
    end

    d462 = d462 or 7

    return d465 > d462
end




local d466= {



    stand = {

        [1] = {
            name = "jitter -90/90",
            apply = function(d467,d453)

                local d468= globals.tickcount()
                local d469= math.floor(d468 / 2) % 2

                local function d470()
                    local d468= globals.tickcount()

                    if not d467._next_change_at then
                        d467._next_change_at = d468 + math.random(24, 64)
                        d467._mode = math.random(1, 3)
                        d467._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        d467._spin_speed = math.random(45, 55)
                        d467._spin_angle = (d469 == 0) and -90 or 90
                    end

                    if d468 >= (d467._next_change_at or 0) then
                        d467._next_change_at = d468 + math.random(24, 64)
                        d467._mode = math.random(1, 3)
                        d467._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        d467._spin_speed = math.random(45, 55)
                        d467._spin_angle = (d469 == 0) and -90 or 90

                        if d467._mode == 2 then
                            d467._spin_until = d468 + math.random(12, 24)
                        elseif d467._mode == 3 then
                            local d471= math.ceil(360 / d467._spin_speed)
                            d467._spin_until = d468 + d471
                            d467._rest_until = d468 + d471 + math.random(24, 64)
                            d467._spin_done = false
                        else
                            d467._spin_until = nil
                            d467._rest_until = nil
                        end
                    end

                    if d467._mode == 1 then
                        local d472= (d469 == 0) and -120 or 120
                        local d473= 0
                        return d472, d473

                    elseif d467._mode == 2 then
                        if d467._spin_until and d468 <= d467._spin_until then
                            d467._spin_angle = (d467._spin_angle or ((d469 == 0) and -90 or 90)) + (d467._spin_dir * (d467._spin_speed or 50))
                            if d467._spin_angle > 180 then d467._spin_angle = d467._spin_angle - 360 end
                            if d467._spin_angle < -180 then d467._spin_angle = d467._spin_angle + 360 end
                            return d467._spin_angle, 0
                        end
                        local d472= (d469 == 0) and -90 or 90
                        return d472, 0
                    else
                        if d467._spin_until and d468 <= d467._spin_until then
                            d467._spin_angle = (d467._spin_angle or ((d469 == 0) and -90 or 90)) + (d467._spin_dir * (d467._spin_speed or 50))
                            if d467._spin_angle > 180 then d467._spin_angle = d467._spin_angle - 360 end
                            if d467._spin_angle < -180 then d467._spin_angle = d467._spin_angle + 360 end
                            return d467._spin_angle, -89
                        end

                        if d467._rest_until and d468 <= d467._rest_until then
                            return nil, nil
                        end

                        local d472= (d469 == 0) and -90 or 90
                        return d472, 0
                    end
                end

                local d472, d473= d470()

                if d472 ~= nil and d453.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (d461(6))) then
                    d452(d453)
                    d446(4, 2, d472)
                    d446(2, 1, 'Custom')
                    d446(2, 2, d473)
                    d446(5, 1, 'off')
                    d446(6, 1, 'off')
                end

            end
        }
    },

    move = {

        [1] = {
            name = "jitter -90/90",
            apply = function(d467,d453)


                local d468= globals.tickcount()
                local d469= math.floor(d468 / 2) % 2
                local d472= (d469 == 0) and -135 or 135
                d467._side = d472
                d467._pitch = -55


                if d453.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (d461(3))) then
                    d452(d453)
                    d446(4, 2, d467._side)
                    d446(2, 1, 'Custom')
                    d446(2, 2, d467._pitch)
                    d446(5, 1, 'off')
                    d446(6, 1, 'off')
                    d446(3, 1, 'at targets')
                end
            end
        }
    },

    walk = {

        [1] = {
            name = "jitter -90/90",
            apply = function(d467,d453)

                local d468= globals.tickcount()
                local d469= math.floor(d468 / 2) % 2
                local d474= (d469 == 0) and -130 or 130

                
                local d472, d473
                if (d468 % 8) == 0 then
                    d472 = 0
                    d473 = 89
                else
                    d472 = d474
                    d473 = -65
                end

                d467._side = d472
                d467._pitch = d473





                if d453.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (d461(3))) then
                    d452(d453)
                    d446(4, 2, d467._side)
                    d446(2, 1, 'Custom')
                    d446(2, 2, d467._pitch)
                    d446(5, 1, 'off')
                    d446(6, 1, 'off')
                    d446(3, 1, 'at targets')
                end
            end
        },
    },

    duck = {
        
        [1] = {
            name = "jitter -90/90",
            apply = function(d467,d453)

                local d468= globals.tickcount()
                local d469= math.floor(d468 / 2) % 2

                local function d470()
                    local d468= globals.tickcount()

                    
                    if not d467._next_change_at then
                        d467._next_change_at = d468 + math.random(24, 64)
                        d467._mode = 1 
                    end

                    if d468 >= (d467._next_change_at or 0) then
                        d467._next_change_at = d468 + math.random(24, 64)
                        d467._mode = math.random(1, 5)
                        
                        d467._spin_dir = nil
                        d467._spin_speed = nil
                        d467._spin_angle = nil
                        d467._jitter_yaw = nil
                        d467._jitter_pitch = nil
                        d467._rand_yaw = nil
                        d467._rand_pitch = nil
                        d467._rand_until = nil
                        d467._phase_tick = d468
                    end

                    
                    
                    
                    
                    
                    

                    if d467._mode == 1 then
                        if not d467._spin_dir then
                            d467._spin_dir = (math.random(0,1) == 0) and -1 or 1
                            d467._spin_speed = 35
                            d467._spin_angle = (d469 == 0) and -90 or 90
                        end

                        if d468 % 10 == 0 then
                            return nil, nil
                        end

                        d467._spin_angle = (d467._spin_angle or ((d469 == 0) and -90 or 90)) + (d467._spin_dir * (d467._spin_speed or 45))
                        if d467._spin_angle > 180 then d467._spin_angle = d467._spin_angle - 360 end
                        if d467._spin_angle < -180 then d467._spin_angle = d467._spin_angle + 360 end
                        return d467._spin_angle, 0

                    elseif d467._mode == 2 then
                        local d475= math.random(-100, 100)
                        return d475, -50

                    elseif d467._mode == 3 then
                        local d475= math.random(-180, 180)
                        local d473= math.random(-89, 89)
                        return d475, d473

                    elseif d467._mode == 4 then
                        if not d467._rand_until then
                            d467._rand_yaw = math.random(-180, 180)
                            d467._rand_pitch = math.random(-89, 89)
                            d467._rand_until = d468 + 2
                            d467._rand_rest = d468 + 3
                        end
                        if d468 <= d467._rand_until then
                            return d467._rand_yaw, d467._rand_pitch
                        elseif d468 <= d467._rand_rest then
                            return nil, nil
                        else
                            d467._rand_until = nil
                            d467._rand_rest = nil
                            return nil, nil
                        end

                    else
                        
                        if not d467._ramp then
                            d467._ramp = {}
                            d467._ramp.yaw = math.random(-180, 180)
                            d467._ramp.pitch = 89
                            d467._ramp.dir = -1 
                        end

                        
                        if not d467._ramp.step then d467._ramp.step = 30 end
                        if d467._ramp.pitch == 89 then
                            
                            d467._ramp.pitch = d467._ramp.pitch + (d467._ramp.dir * d467._ramp.step)
                            if d467._ramp.pitch < -89 then d467._ramp.pitch = -89 end
                            return d467._ramp.yaw, 89
                        else
                            
                            local d476= d467._ramp.pitch
                            d467._ramp.pitch = d467._ramp.pitch + (d467._ramp.dir * d467._ramp.step)
                            if d467._ramp.pitch <= -89 then
                                
                                d467._ramp = nil
                            end
                            return d467._ramp and d467._ramp.yaw or math.random(-180,180), d476
                        end
                    end
                end

                local d472, d473= d470()

                if d472 ~= nil and d453.chokedcommands == 1 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (d461(8))) then
                    d452(d453)
                    d446(4, 2, d472)
                    d446(2, 1, 'Custom')
                    d446(2, 2, d473)
                    d446(5, 1, 'off')
                    d446(6, 1, 'off')
                    d446(3, 1, 'at targets')
                end
            end
        }
    },

    ["duck+"] = {
        
        [1] = {

            name = "jitter -90/90",
            apply = function(d467,d453)


                local d468= globals.tickcount()
                local d469= math.floor(d468 / 2) % 2
                local d472= (d469 == 0) and -90 or 90
                d467._side = 180
                d467._pitch = -76


                if d453.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (d461(1))) then
                    d452(d453)
                    d446(4, 2, d467._side)
                    d446(2, 1, 'Custom')
                    d446(2, 2, d467._pitch)
                    d446(5, 1, 'off')
                    d446(6, 1, 'off')
                    d446(3, 1, 'at targets')
                end

            end
        }
    },

    ['jump'] = {
        [1] = {
            name = "jitter -90/90",
            apply = function(d467,d453)

                local d468= globals.tickcount()
                
                if not d467._spin_choice_at then
                    d467._spin_choice_at = d468 + 64
                    d467._spin_dir = (math.random(0,1) == 0) and -1 or 1
                    d467._spin_angle = 0
                end

                if d468 >= (d467._spin_choice_at or 0) then
                    d467._spin_choice_at = d468 + 64
                    d467._spin_dir = (math.random(0,1) == 0) and -1 or 1
                end

                
                if (d468 % 10) == 0 then
                    return
                end

                
                d467._spin_angle = (d467._spin_angle or 0) + (d467._spin_dir * 35)
                if d467._spin_angle > 180 then d467._spin_angle = d467._spin_angle - 360 end
                if d467._spin_angle < -180 then d467._spin_angle = d467._spin_angle + 360 end

                local d472= d467._spin_angle
                d467._side = d472
                d467._pitch = 0

                if d453.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (d461(8))) then
                    d452(d453)
                    d446(4, 2, d467._side)
                    d446(2, 1, 'Custom')
                    d446(2, 2, d467._pitch)
                    d446(5, 1, 'off')
                    d446(6, 1, 'off')
                    d446(3, 1, 'at targets')
                end
            end
        },

    },

    ['jump+'] = {
        [0] = {
            name = "jitter -90/90",
            apply = function(d467,d453)

                local d468= globals.tickcount()
                local d469= math.floor(d468 / 2) % 2
                local d472= (d469 == 0) and -90 or 90
                d467._side = d472
                d467._pitch = 0

                if d453.chokedcommands > 0 and (not (d461(6))) then
                    d452(d453)
                    d446(4, 2, d467._side)
                    d446(2, 1, 'Custom')
                    d446(2, 2, d467._pitch)
                    d446(5, 1, 'off')
                    d446(6, 1, 'off')
                    d446(3, 1, 'at targets')
                end
            end
        },
    },

    
    global = {
        [0] = {
            name = "back",
            apply = function(d467,d453)

            end
        }
    }


}





local function d477(d478)
    local d479= {}
    for k, _ in pairs(d478) do
        if type(k) == 'number' then table.insert(d479, k) end
    end
    table.sort(d479)
    return d479
end

function d441.get_presets_for_condition(d480)
    d480 = d480 or d435.get() or 'global'
    return d466[d480] or d466['global'] or {}
end

function d441.get_preset_by_index(d480,d481)
    local d482= d441.get_presets_for_condition(d480)
    return d482[d481]
end

function d441.get_random_for_condition(d480)
    local d482= d441.get_presets_for_condition(d480)
    local d479= d477(d482)
    if #d479 == 0 then return nil, nil end
    local d483= d479[math.random(1, #d479)]
    return d483, d482[d483]
end

function d441.get_random_for_current_condition()
    return d441.get_random_for_condition(d435.get())
end


function d441.get_next_for_condition(d480,d484)
    local d482= d441.get_presets_for_condition(d480)
    local d479= d477(d482)
    if #d479 == 0 then return nil, nil end
    
    local d485= 1
    for i, k in ipairs(d479) do
        if k == d484 then d485 = i; break end
    end
    local d486= (d485 % #d479) + 1
    local d487= d479[d486]
    return d487, d482[d487]
end


function d441.available_conditions()
    local d488= {}
    for k, _ in pairs(d466) do table.insert(d488, k) end
    table.sort(d488)
    return d488
end

d441._presets = d466

return d441]]
d958["require/features/misc/analyze"] = [[local function d438(d439)
	while d439 > 180 do d439 = d439 - 360 end
	while d439 < -180 do d439 = d439 + 360 end
	return d439
end

local d440= _G.player_labels or {}
_G.player_labels = d440

local d441= function(ent)
	return (_G.player_history and _G.player_history[ent]) or nil
end

local d442, d443= pcall(require, "require/features/misc/resolver_dispatcher")
local d444= require('require/abc/callbacks')

local function d445(d446)
	
	local d447= d441(d446)
	if not d447 or #d447 < 2 then
		d440[d446] = nil
		return
	end

	
	
	local d448, d449= pcall(function() return (globals and globals.curtime and globals.curtime()) or nil end)
	if d447[1] and d447[1].last_shot_time and d448 and d449 then
		local d450= d449 - d447[1].last_shot_time
		if d450 >= 0 and d450 <= 0.25 then
			d440[d446] = "ON SHOT"
			return
		end
	end

	
	local d451= {}
	for i = 1, #d447 - 1 do
		local d452= d447[i] and d447[i].yaw
		local d453= d447[i+1] and d447[i+1].yaw
		if d452 ~= nil and d453 ~= nil then
			d451[#d451 + 1] = d438(d452 - d453)
		end
	end

	if #d451 == 0 then
		d440[d446] = nil
		return
	end

	
	local d454, d455= 0, 0
	local d456, d457= -1e9, 1e9
	for _, v in ipairs(d451) do
		d454 = d454 + v
		d455 = d455 + math.abs(v)
		if v > d456 then d456 = v end
		if v < d457 then d457 = v end
	end
	local d458= d454 / #d451
	local d459= d455 / #d451

	local d460= 0
	for _, v in ipairs(d451) do
		d460 = d460 + (v - d458) ^ 2
	end
	local d461= math.sqrt(d460 / #d451)

	local d462= 0
	for i = 2, #d451 do
		if (d451[i] > 0 and d451[i-1] < 0) or (d451[i] < 0 and d451[i-1] > 0) then
			d462 = d462 + 1
		end
	end

	
	local d463= d451[1]
	local d464= d456 - d457

	
	local d465= {}
	for i, v in ipairs(d451) do d465[i] = v end
	table.sort(d465)
	local d466= d465[math.ceil(#d465 / 2)]

	
	local d467= {
		deltas = d451,
		mean = d458,
		meanabs = d459,
		std = d461,
		sign_changes = d462,
		max_delta = d456,
		min_delta = d457,
		total_range = d464,
		median = d466,
		last_delta = d463,
		samples = #d451,
		last_yaw = d447[1] and d447[1].yaw,
		oldest_yaw = d447[#d447] and d447[#d447].yaw,
		hist = d447
	}

	
	do
		local d468, d469= 0, 0
		local d470, d471, d472
		for i=1,math.min(#d447, 20) do
			local d473= d447[i]
			if d473 then
				if d473.moveSpeedAnim then d468 = d468 + (d473.moveSpeedAnim or 0); d469 = d469 + 1 end
				if d473.speed2d then d468 = d468 + (d473.speed2d or 0); d469 = d469 + 1 end
				if not d470 and d473.feetYaw then d470 = d473.feetYaw end
				if not d471 and d473.goalFeetYaw then d471 = d473.goalFeetYaw end
				if not d472 and d473.moveSpeedAnim then d472 = d473.moveSpeedAnim end
			end
		end
		local d474= (d469 > 0) and (d468 / d469) or 0
		d467.movement = d474 >= 1.2
		d467.avg_speed = d474
		d467.feet_yaw = d470
		d467.goal_feet_yaw = d471
		d467.move_anim = d472
	end

	local d475= nil
	if detect_static and detect_static(d467, d446) then d475 = "STATIC" end
	if detect_spin and detect_spin(d467, d446) then d475 = "SPIN" end
	if detect_jitter_minus and detect_jitter_minus(d467, d446) then d475 = "JITTER-" end
	if detect_jitter and detect_jitter(d467, d446) then d475 = "JITTER" end
	if detect_jitter_plus and detect_jitter_plus(d467, d446) then d475 = "JITTER+" end
	if detect_sway and detect_sway(d467, d446) then d475 = "SWAY" end
	if detect_skitter and detect_skitter(d467, d446) then d475 = "SKITTER" end
	if detect_defensive and detect_defensive(d467, d446) then d475 = "DEFENSIVE" end
	if detect_random and detect_random(d467, d446) then d475 = "RANDOM" end
	if detect_delayed and detect_delayed(d467, d446) then d475 = "DELAYED" end

	if not d475 then d475 = "?" end
	pcall(function()
		local d476= nil
		pcall(function() d476 = entity.get_player_name(d446) end)
		local d477= "nil"
		if d447 and d447[1] and d447[1].last_shot_time then
			d477 = string.format("%.3f", d447[1].last_shot_time)
		end
		local d478= d467.feet_yaw and string.format("%.2f", d467.feet_yaw) or "nil"
		local d479= d467.goal_feet_yaw and string.format("%.2f", d467.goal_feet_yaw) or "nil"

	end)

	d440[d446] = d475

	
	if d442 and d443 and type(d443.process_entity) == "function" then
		pcall(function() d443.process_entity(d446, d475, d467) end)
	end
end



function d480(d467,d446)
	local d459= d467.meanabs or 0
	local d461= d467.std or 0
	local d481= d467.samples or 0
	local d451= d467.deltas or {}
	local d482= 1.0
	local d483= 1.5
	local d484= 2.5

	if d459 <= d482 and d461 <= d483 then
		return true
	end

	local d485= 0
	local d486= nil
	for i, d in ipairs(d451) do
		if math.abs(d) >= d484 then
			d485 = d485 + 1
			if not d486 then
				d486 = i
			end
		end
	end

	if d485 == 0 then
		return true
	end

	if d485 == 1 and d486 and d486 > 20 then
		return true
	end

	return false
end

function d487(d467,d446)
	local d459= d467.meanabs or 0
	local d461= d467.std or 0
	local d481= d467.samples or 0
	local d462= d467.sign_changes or 0
	local d488= math.max(math.abs(d467.max_delta or 0), math.abs(d467.min_delta or 0))

	local d489= false

	if d481 >= 4 then
		local d490= 5.0
		local d491= 12.0
		local d492= 22.0
		local d493= 40.0

		if d459 >= d490 and d459 < d491 and d461 <= d492 and d488 <= d493 then
			d489 = true
		end
	end

	return d489
end

function d494(d467,d446)
	local d459= d467.meanabs or 0
	local d461= d467.std or 0
	local d481= d467.samples or 0
	local d462= d467.sign_changes or 0
	local d488= math.max(math.abs(d467.max_delta or 0), math.abs(d467.min_delta or 0))

	local d489= false

	if d481 >= 4 then
		local d490= (d467.movement and 8.0) or 6.0
		local d491= 24.0
		local d495= 34.0
		local d496= 28.0
		local d497= 100.0

		if d459 >= d490 and d459 < d491 and d461 <= d495 then
			if d462 >= 2 or d488 <= d497 or (d459 < 12.0 and d461 <= d496) then
				d489 = true
			end
		end
	end

	return d489
end

function d498(d467,d446)
	local d459= d467.meanabs or 0
	local d461= d467.std or 0
	local d481= d467.samples or 0
	local d462= d467.sign_changes or 0
	local d488= math.max(math.abs(d467.max_delta or 0), math.abs(d467.min_delta or 0))

	local d489= false

	if d481 >= 4 then
		local d490= 18.0
		local d499= 22.0
		local d500= 26.0
		local d501= 70.0

		if d459 >= d490 and (d461 >= d500 or d488 >= d501) then
			if d459 >= d499 or d488 >= d501 or d461 >= (d500 + 8) then
				d489 = true
			end
		end
	end
	
	return d489
end

function d502(d467,d446)
	local d459= d467.meanabs or 0
	local d461= d467.std or 0
	local d481= d467.samples or 0
	local d462= d467.sign_changes or 0
	local d464= d467.total_range or 0
	local d488= math.max(math.abs(d467.max_delta or 0), math.abs(d467.min_delta or 0))

	local d489= false

	if d481 >= 6 then
		local d490= 2.5
		local d491= 15.0
		local d503= 0.08
		local d504= 30.0
		local d505= 180.0

		if d459 >= d490 and d459 < d491 and d461 <= 40.0 and d464 >= d504 and d464 <= d505 then
			if (d462 / math.max(1, d481)) >= d503 then
				d489 = true
			end
		end
	end

	return d489
end

function d506(d467,d446)
	local d459= d467.meanabs or 0
	local d461= d467.std or 0
	local d481= d467.samples or 0
	local d462= d467.sign_changes or 0
	local d464= d467.total_range or 0
	local d463= d467.last_delta or 0
	local d488= math.max(math.abs(d467.max_delta or 0), math.abs(d467.min_delta or 0))

	local d451= d467.deltas or {}

	local d507, d508, d509= 0, 0, 0
	for _, v in ipairs(d451) do
		if v > 0.5 then d507 = d507 + 1
		elseif v < -0.5 then d508 = d508 + 1
		else d509 = d509 + 1 end
	end

	local d510= math.max(d507, d508) / math.max(1, d481)
	local d511= math.abs(d507 - d508) / math.max(1, (d507 + d508))

	local d512, d513, d514= 0, 0, 0
	for _, v in ipairs(d451) do
		local d473= 0
		if v > 0.5 then d473 = 1 elseif v < -0.5 then d473 = -1 end
		if d473 ~= 0 and d473 == d514 then
			d513 = d513 + 1
		else
			d513 = (d473 ~= 0) and 1 or 0
			d514 = d473
		end
		if d513 > d512 then d512 = d513 end
	end

	local d515= d512 / math.max(1, d481)

	local d489= false

	if d481 >= 6 then
		if d464 >= 300 and (d510 >= 0.60 or d511 >= 0.60) then
			d489 = true
		end

		if not d489 and d464 >= 140 and d459 >= 9 and (d510 >= 0.75 or d511 >= 0.70 or d462 <= 1) then
			d489 = true
		end

		if not d489 and d515 >= 0.50 and d459 >= 8 and d464 >= 120 then
			d489 = true
		end

		if not d489 and d488 >= 120 and (d510 >= 0.60 or d511 >= 0.60) then
			d489 = true
		end
	end
	local d516= nil
	if not d489 and d481 > 0 then
		local d517= math.min(d464, 360) / 360.0
		local d518= math.min(d459, 60) / 60.0
		local d519= (d462 or 0) / math.max(1, d481)
		d516 = d517 * 0.45 + d518 * 0.35 + d511 * 0.15 + d510 * 0.05 - d519 * 0.20
		if d516 >= 0.42 and d464 >= 200 and d459 >= 6 then
			d489 = true
		end
		d467.spin_score = d516
	end

	return d489
end

function d520(d467,d446)
	
	return false
end

function d521(d467,d446)
	
	return false
end

function d522(d467,d446)
	local d459= d467.meanabs or 0
	local d461= d467.std or 0
	local d481= d467.samples or 0
	local d462= d467.sign_changes or 0
	local d464= d467.total_range or 0
	local d488= math.max(math.abs(d467.max_delta or 0), math.abs(d467.min_delta or 0))
	local d451= d467.deltas or {}

	if d481 < 6 then return false end

	local d523= d462 / math.max(1, d481)
	local d524= d467.movement
	if d523 >= 0.45 and d461 >= (d524 and 12.0 or 18.0) and d459 >= (d524 and 4.0 or 6.0) then
		return true
	end

	if d488 >= 120 and d523 >= 0.30 and d461 >= 12.0 then
		return true
	end

	if d464 >= 60 and d464 <= 300 and d523 >= 0.40 and d461 >= 14.0 and d459 >= 4.0 then
		return true
	end

	if d461 >= 30.0 and d523 >= 0.25 and d459 >= 5.0 then
		return true
	end

	return false
end

function d525(d467,d446)
	local d459= d467.meanabs or 0
	local d461= d467.std or 0
	local d481= d467.samples or 0
	local d462= d467.sign_changes or 0
	local d464= d467.total_range or 0
	local d488= math.max(math.abs(d467.max_delta or 0), math.abs(d467.min_delta or 0))

	if d481 >= 6 then
		local d490= 2.5
		local d491= 24.0
		local d526= 9.0
		local d527= 40.0
		local d504= 10.0

		if d459 >= d490 and d459 < d491 and d461 >= d526 and d461 <= d527 and d464 >= d504 then
			local d528= (d462 or 0) / math.max(1, d481)
			if d462 <= 3 or d528 <= 0.12 or d488 >= 40 then
				return true
			end
		end
	end

	return false
end

local function d529()
	local d530, d531= pcall(entity.get_players, true)
	if not d530 or type(d531) ~= "table" then return end
	for _, d446 in ipairs(d531) do
		if entity.is_alive(d446) and not entity.is_dormant(d446) then
			pcall(d445, d446)
		else
			d440[d446] = nil
		end
	end
end

local function d532(d446)
	if not entity.is_alive(entity.get_local_player()) then return end
	if not d446 or d446 == 0 then return end

	local d533= d440[d446]


	if d533 then
		return true, d533
	end

	local d447= d441(d446)
	if d447 and d447[1] and d447[1].yaw ~= nil then
		return true, tostring(d447[1].yaw)
	end
end

client.register_esp_flag("Resolver", 255, 255, 255, d532)

d444.register('net_update_end', function()
	local d534, d535= pcall(require, "require/abc/menu_setup")
	if d534 and d535 and d535.ui and d535.ui.misc_resolver then
		local d536, d537= pcall(ui.get, d535.ui.misc_resolver)
		if d536 and d537 then
			pcall(d529)
		end
	end
end, { alive_only = true, require_login = true })
]]
d958["require/features/misc/backstab_assist"] = [[local d441= require("require/abc/menu_setup")
local d442= require('require/abc/callbacks')
local d443= require('require/help/enemies')

local d444= ui.reference("AA", "Anti-aimbot angles", "Pitch")
local d445= ui.reference("AA", "Anti-aimbot angles", "Yaw base")
local d446, d447= ui.reference("AA", "Anti-aimbot angles", "Yaw")
local d448= nil

local function d449()
	if d448 then return end
	d448 = {}
	if d444 then d448.pitch = ui.get(d444) end
	if d445 then d448.yaw_base = ui.get(d445) end
	if d446 then d448.yaw = ui.get(d446) end
	if d447 then d448.yaw_slider = ui.get(d447) end
end

local function d450()
	if not d448 then return end
	if d444 and d448.pitch ~= nil then pcall(ui.set, d444, d448.pitch) end
	if d445 and d448.yaw_base ~= nil then pcall(ui.set, d445, d448.yaw_base) end
	if d446 and d448.yaw ~= nil then pcall(ui.set, d446, d448.yaw) end
	if d447 and d448.yaw_slider ~= nil then pcall(ui.set, d447, d448.yaw_slider) end
	d448 = nil
end

local function d451()
	d449()
	if d444 then pcall(ui.set, d444, "Off") end
	if d445 then pcall(ui.set, d445, "At targets") end
	if d446 then pcall(ui.set, d446, "180") end
	if d447 then pcall(ui.set, d447, 180) end
end

local function d452(d453)
	local d454= entity.get_local_player()
	if not d454 or not entity.is_alive(d454) then return false end
	local d455= d443.list() or {}
	for _, enemy in ipairs(d455) do
		if d443.is_alive(enemy) and not d443.is_dormant(enemy) and d443.has_knife(enemy) then
			local d456= d443.distance(enemy)
			if d456 and d456 <= d453 then
				return true
			end
		end
	end
	return false
end

local function d457(d458)
	if not (d441 and d441.ui and d441.ui.misc_backstab) then d450() return end
	local d459, d460= pcall(ui.get, d441.ui.misc_backstab)
	if not d459 or not d460 then d450() return end
	local d453= 200
	if d452(d453) then
		d451()
	else
		d450()
	end
end

if d441 and d441.ui and d441.ui.misc_backstab then
	ui.set_callback(d441.ui.misc_backstab, function()
		local d459, d461= pcall(ui.get, d441.ui.misc_backstab)
		if not d459 or not d461 then d450() end
	end)
end

d442.register("setup_command", d457, { alive_only = true, require_login = true })
d442.register("shutdown", d450, { alive_only = true, require_login = true })]]
d958["require/features/misc/collect"] = [=[
local M = {}


do
    local ok, ffi = pcall(require, "ffi")
    if ok and ffi and client and client.create_interface then
        local status, entity_list_ptr = pcall(function()
            return client.create_interface("client.dll", "VClientEntityList003")
        end)

        if status and entity_list_ptr then
            local pointer_type = ffi.typeof("void***")
            local entity_list = ffi.cast(pointer_type, entity_list_ptr)
            local ok_cast, get_client_entity = pcall(function()
                return ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
            end)

            if ok_cast and get_client_entity then
                
                local animstate_offset = 0x9960

                
                
                
                ffi.cdef[[
                struct animation_layer_t {
                    char  pad_0000[20];
                    uint32_t m_nOrder;
                    uint32_t m_nSequence;
                    float m_flPrevCycle;
                    float m_flWeight;
                    float m_flWeightDeltaRate;
                    float m_flPlaybackRate;
                    float m_flCycle;
                    void *m_pOwner;
                    char  pad_0038[4];
                };
                ]]

                
                
                

                ffi.cdef[[
                struct c_animstate_min {
                    char pad0[3];
                    char m_bForceWeaponUpdate;
                    char pad1[91];
                    void* m_pBaseEntity;
                    void* m_pActiveWeapon;
                    void* m_pLastActiveWeapon;
                    float m_flLastClientSideAnimationUpdateTime;
                    int m_iLastClientSideAnimationUpdateFramecount;
                    float m_flAnimUpdateDelta;
                    float m_flEyeYaw;
                    float m_flPitch;
                    float m_flGoalFeetYaw;
                    float m_flCurrentFeetYaw;
                    float m_flCurrentTorsoYaw;
                    float m_flUnknownVelocityLean;
                    float m_flLeanAmount;
                    char pad2[4];
                    float m_flFeetCycle;
                    float m_flFeetYawRate;
                    char pad3[4];
                    float m_fDuckAmount;
                    float m_fLandingDuckAdditiveSomething;
                    char pad4[4];
                    float m_vOriginX;
                    float m_vOriginY;
                    float m_vOriginZ;
                    float m_vLastOriginX;
                    float m_vLastOriginY;
                    float m_vLastOriginZ;
                    float m_vVelocityX;
                    float m_vVelocityY;
                    char pad5[4];
                    float m_flUnknownFloat1;
                    char pad6[8];
                    float m_flUnknownFloat2;
                    float m_flUnknownFloat3;
                    float m_flUnknown;
                    float m_flSpeed2D;
                    float m_flUpVelocity;
                    float m_flSpeedNormalized;
                    float m_flFeetSpeedForwardsOrSideWays;
                    float m_flFeetSpeedUnknownForwardOrSideways;
                    float m_flTimeSinceStartedMoving;
                    float m_flTimeSinceStoppedMoving;
                    bool m_bOnGround;
                    bool m_bInHitGroundAnimation;
                    char pad7[2];
                    float m_flTimeSinceInAir;
                    float m_flLastOriginZ;
                    float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
                    float m_flStopToFullRunningFraction;
                    float m_flMagicFraction;
                    char pad8[60];
                    float m_flWorldForce;
                    char pad9[462];
                    float m_flMaxYaw;
                };
                ]]

                
                M._get_animstate = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    
                    
                    local base = ffi.cast("char*", ent_ptr)
                    local anim_ptr_ptr = ffi.cast("struct c_animstate_min**", base + animstate_offset)
                    if anim_ptr_ptr == nil or anim_ptr_ptr == ffi.NULL then return nil end
                    local anim_ptr = anim_ptr_ptr[0]
                    if anim_ptr == nil or anim_ptr == ffi.NULL then return nil end
                    return anim_ptr
                end
                
                M._get_entity_ptr = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    return ent_ptr
                end
            end
        end
    end
end



function M.get_sim_time(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flSimulationTime") end)
    if ok then return val end
    return nil
end


function M.get_enemies_simtimes()
    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        out[ent] = M.get_sim_time(ent)
    end
    return out
end


function M.get_velocity_3d(ent)
    local ok, vals = pcall(function() return { entity.get_prop(ent, "m_vecVelocity") } end)
    if not ok or type(vals) ~= "table" then return nil end
    if #vals >= 3 then
        return { vals[1], vals[2], vals[3] }
    end
    return nil
end


function M.get_speed_2d(ent)
    local v = M.get_velocity_3d(ent)
    if not v then return nil end
    local x, y = v[1] or 0, v[2] or 0
    return math.sqrt(x * x + y * y)
end




function M.get_origin(ent)
    local ok, x, y, z = pcall(function() return entity.get_prop(ent, "m_vecOrigin") end)
    if ok and x then
        
        if type(x) == "table" then
            return x[1], x[2], x[3]
        elseif y and z then
            return x, y, z
        end
    end
    return nil
end


function M.get_view_offset(ent)
    local tries = { "m_vecViewOffset[0]", "m_vecViewOffset" }
    for _, prop in ipairs(tries) do
        local ok, v1, v2, v3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and v1 then
            if type(v1) == "table" then
                return v1[1], v1[2], v1[3]
            elseif v2 and v3 then
                return v1, v2, v3
            end
        end
    end
    return nil
end


function M.get_eye_pos(ent)
    local ox, oy, oz = M.get_origin(ent)
    local vx, vy, vz = M.get_view_offset(ent)
    if ox and vx then
        return ox + vx, oy + vy, oz + vz
    end
    return nil
end


function M.get_eye_angles(ent)
    local tries = { "m_angEyeAngles[0]", "m_angEyeAngles", "m_angRotation", "m_angNetworkAngles" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return nil
end


function M.get_abs_angles(ent)
    local tries = { "m_angAbsRotation", "m_angAbsAngles", "m_angAbsOrigin" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return M.get_eye_angles(ent)
end


function M.get_lower_body_yaw(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flLowerBodyYawTarget") end)
    if ok and val then return val end
    return nil
end


function M.get_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flCurrentFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    
    return M.get_lower_body_yaw(ent)
end

function M.get_goal_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flGoalFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    return M.get_feet_yaw(ent)
end


function M.get_speed(ent)
    
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flVelocityModifier") end)
    if ok and val then return val end
    
    local v = M.get_velocity_3d(ent)
    if v then
        return math.sqrt((v[1] or 0) * (v[1] or 0) + (v[2] or 0) * (v[2] or 0) + (v[3] or 0) * (v[3] or 0))
    end
    return nil
end

function M.get_move_speed_anim(ent)
    
    
    
    
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local try_fields = { "m_flFeetSpeedForwardsOrSideWays", "m_flSpeed2D", "m_flSpeedNormalized", "m_flFeetSpeedUnknownForwardOrSideways" }
            for _, f in ipairs(try_fields) do
                local okf, val = pcall(function() return tonumber(anim[f]) end)
                if okf and val and val ~= 0 then
                    return val
                end
            end
        end
    end

    
    local ok_nv, nv = pcall(function() return entity.get_prop(ent, "m_flMaxspeed") end)
    if ok_nv and nv then return nv end

    
    return M.get_speed_2d(ent)
end


function M.get_flags(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_fFlags") end)
    if ok and val then return val end
    ok, val = pcall(function() return entity.get_prop(ent, "m_iFlags") end)
    if ok and val then return val end
    return nil
end



function M.read_animstate(ent)
    if not M._get_animstate then return nil end
    local ok, anim = pcall(function() return M._get_animstate(ent) end)
    if not ok or not anim then return nil end
    local out = {}
    pcall(function()
        out.m_flEyeYaw = tonumber(anim.m_flEyeYaw)
        out.m_flPitch = tonumber(anim.m_flPitch)
        out.m_flGoalFeetYaw = tonumber(anim.m_flGoalFeetYaw)
        out.m_flCurrentFeetYaw = tonumber(anim.m_flCurrentFeetYaw)
        out.m_flCurrentTorsoYaw = tonumber(anim.m_flCurrentTorsoYaw)
        out.m_flUnknownVelocityLean = tonumber(anim.m_flUnknownVelocityLean)
        out.m_flLeanAmount = tonumber(anim.m_flLeanAmount)
        out.m_flFeetCycle = tonumber(anim.m_flFeetCycle)
        out.m_flFeetYawRate = tonumber(anim.m_flFeetYawRate)
        out.m_fDuckAmount = tonumber(anim.m_fDuckAmount)
        out.m_fLandingDuckAdditiveSomething = tonumber(anim.m_fLandingDuckAdditiveSomething)
        out.m_vOrigin = { tonumber(anim.m_vOriginX), tonumber(anim.m_vOriginY), tonumber(anim.m_vOriginZ) }
        out.m_vLastOrigin = { tonumber(anim.m_vLastOriginX), tonumber(anim.m_vLastOriginY), tonumber(anim.m_vLastOriginZ) }
        out.m_vVelocity = { tonumber(anim.m_vVelocityX), tonumber(anim.m_vVelocityY) }
        out.m_flUnknownFloat1 = tonumber(anim.m_flUnknownFloat1)
        out.m_flUnknownFloat2 = tonumber(anim.m_flUnknownFloat2)
        out.m_flUnknownFloat3 = tonumber(anim.m_flUnknownFloat3)
        out.m_flUnknown = tonumber(anim.m_flUnknown)
        out.m_flSpeed2D = tonumber(anim.m_flSpeed2D)
        out.m_flUpVelocity = tonumber(anim.m_flUpVelocity)
        out.m_flSpeedNormalized = tonumber(anim.m_flSpeedNormalized)
        out.m_flFeetSpeedForwardsOrSideWays = tonumber(anim.m_flFeetSpeedForwardsOrSideWays)
        out.m_flFeetSpeedUnknownForwardOrSideways = tonumber(anim.m_flFeetSpeedUnknownForwardOrSideways)
        out.m_flTimeSinceStartedMoving = tonumber(anim.m_flTimeSinceStartedMoving)
        out.m_flTimeSinceStoppedMoving = tonumber(anim.m_flTimeSinceStoppedMoving)
        out.m_bOnGround = (anim.m_bOnGround ~= 0)
        out.m_bInHitGroundAnimation = (anim.m_bInHitGroundAnimation ~= 0)
        out.m_flTimeSinceInAir = tonumber(anim.m_flTimeSinceInAir)
        out.m_flLastOriginZ = tonumber(anim.m_flLastOriginZ)
        out.m_flHeadHeightOrOffsetFromHittingGroundAnimation = tonumber(anim.m_flHeadHeightOrOffsetFromHittingGroundAnimation)
        out.m_flStopToFullRunningFraction = tonumber(anim.m_flStopToFullRunningFraction)
        out.m_flMagicFraction = tonumber(anim.m_flMagicFraction)
        out.m_flWorldForce = tonumber(anim.m_flWorldForce)
        out.m_flMaxYaw = tonumber(anim.m_flMaxYaw)
    end)
    return out
end



function M.read_anim_layers(ent)
    if not M._get_entity_ptr then return nil end
    local ok_ent, ent_ptr = pcall(function() return M._get_entity_ptr(ent) end)
    if not ok_ent or not ent_ptr then return nil end
    local ok, res = pcall(function()
        local ffi = require("ffi")
        local base = ffi.cast("char*", ent_ptr)
        local layers_ptr = ffi.cast("struct animation_layer_t**", base + 0x2990)
        if layers_ptr == nil or layers_ptr == ffi.NULL then return nil end
        local owner = layers_ptr[0]
        if owner == nil or owner == ffi.NULL then return nil end
        local out = {}
        for i = 0, 15 do
            local layer = owner[i]
            if layer == nil or layer == ffi.NULL then break end
            local t = {}
            t.m_nOrder = tonumber(layer.m_nOrder)
            t.m_nSequence = tonumber(layer.m_nSequence)
            t.m_flPrevCycle = tonumber(layer.m_flPrevCycle)
            t.m_flWeight = tonumber(layer.m_flWeight)
            t.m_flWeightDeltaRate = tonumber(layer.m_flWeightDeltaRate)
            t.m_flPlaybackRate = tonumber(layer.m_flPlaybackRate)
            t.m_flCycle = tonumber(layer.m_flCycle)
            t.m_pOwner = tostring(layer.m_pOwner)
            table.insert(out, t)
        end
        return out
    end)
    if not ok then return nil end
    return res
end


function M.get_tick_from_simtime(simtime)
    if not simtime or not globals or not globals.tickinterval then return nil end
    local ti = globals.tickinterval()
    if not ti or ti == 0 then return nil end
    return math.floor(simtime / ti + 0.5)
end

function M.get_tick(ent)
    local sim = M.get_sim_time(ent)
    if sim then return M.get_tick_from_simtime(sim) end
    return nil
end








function M.get_enemies_snapshot(opts)
    opts = opts or {}
    local heavy = true 

    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        local snap = {}

        
        snap.is_alive = (pcall(function() return entity.is_alive(ent) end) and entity.is_alive(ent)) or false
        snap.is_dormant = (pcall(function() return entity.is_dormant(ent) end) and entity.is_dormant(ent)) or false

        
        local ok_name, name = pcall(function() return entity.get_player_name(ent) end)
        snap.name = ok_name and name or nil

        
        snap.simtime = M.get_sim_time(ent)
        do
            local base_tick = snap.simtime and M.get_tick_from_simtime(snap.simtime) or nil
            
            local ok_flags, esp_flags = pcall(function()
                local d = entity.get_esp_data and entity.get_esp_data(ent)
                return (d and d.flags) or 0
            end)

            local adjusted_tick = base_tick
            if ok_flags and esp_flags and base_tick then
                
                local ok_bit, is_backtrack = pcall(function()
                    return bit and bit.band(esp_flags, bit.lshift(1, 17)) ~= 0
                end)
                if ok_bit and is_backtrack then
                    adjusted_tick = base_tick - 14
                end
            end
            snap.simTicks = adjusted_tick
        end

        
        do
            local ok, ox, oy, oz = pcall(function() return M.get_origin(ent) end)
            if ok and ox then snap.origin = { ox, oy, oz } end
        end
        do
            local ok, vx, vy, vz = pcall(function() return M.get_view_offset(ent) end)
            if ok and vx then snap.viewOffset = { vx, vy, vz } end
        end
        do
            local ok, ex, ey, ez = pcall(function() return M.get_eye_pos(ent) end)
            if ok and ex then snap.eyePos = { ex, ey, ez } end
        end

        
        do
            local ok, a1, a2, a3 = pcall(function() return M.get_eye_angles(ent) end)
            if ok and a1 then snap.eyeAngles = { a1, a2, a3 } end
        end
        do
            local ok, aa1, aa2, aa3 = pcall(function() return M.get_abs_angles(ent) end)
            if ok and aa1 then snap.absAngles = { aa1, aa2, aa3 } end
        end

        
        snap.lowerBodyYaw = (pcall(function() return M.get_lower_body_yaw(ent) end) and M.get_lower_body_yaw(ent)) or nil
        snap.feetYaw = (pcall(function() return M.get_feet_yaw(ent) end) and M.get_feet_yaw(ent)) or snap.lowerBodyYaw
        snap.goalFeetYaw = (pcall(function() return M.get_goal_feet_yaw(ent) end) and M.get_goal_feet_yaw(ent)) or snap.feetYaw

        
        snap.velocity3d = (pcall(function() return M.get_velocity_3d(ent) end) and M.get_velocity_3d(ent)) or nil
        if snap.velocity3d then
            snap.speed2d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0))
            snap.speed3d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0) + (snap.velocity3d[3] or 0) * (snap.velocity3d[3] or 0))
        else
            snap.speed2d = M.get_speed_2d(ent)
            snap.speed3d = M.get_speed(ent)
        end

        
        do
            local ok_ms, ms = pcall(function() return M.get_move_speed_anim(ent) end)
            if ok_ms and ms then
                snap.moveSpeedAnim = ms
            else
                snap.moveSpeedAnim = nil
            end
        end

        
        snap.flags = (pcall(function() return M.get_flags(ent) end) and M.get_flags(ent)) or nil

        
        local ok_head, hx, hy, hz = pcall(function() return entity.hitbox_position(ent, "head") end)
        if ok_head and hx then snap.headPos = { hx, hy, hz } end

        
        local ok_w, w = pcall(function() return entity.get_player_weapon(ent) end)
        snap.weapon = ok_w and w or nil

        

        
        local ok_b, bones = pcall(function() return entity.get_bone_matrices and entity.get_bone_matrices(ent) end)
        if ok_b and bones then snap.bones = bones end

        local ok_as, as = pcall(function() return M.read_animstate(ent) end)
        if ok_as and as then snap.animstate_full = as end
        local ok_layers, layers = pcall(function() return M.read_anim_layers(ent) end)
        if ok_layers and layers then snap.animLayers = layers end

        out[ent] = snap
    end
    return out
end

return M
]=]
d958["require/features/misc/dormant_aimbot"] = [[local d447, d448, d449, d450= client.visible, client.eye_position, client.log, client.trace_bullet
local d451, d452, d453, d454, d455, d456, d457, d458, d459, d460= entity.get_bounding_box, entity.get_local_player, entity.get_origin, entity.get_player_name, entity.get_player_resource, entity.get_player_weapon, entity.get_prop, entity.is_dormant, entity.is_enemy, entity.is_alive
local d461, d462, d463= globals.curtime, globals.maxplayers, globals.tickcount
local d464, d465, d466= math.max, math.min, math.sqrt
local d467, d468, d469= renderer.indicator, string.format, table.unpack or unpack
local d470, d471, d472, d473, d474, d475, d476, d477, d478, d479= ui.get, ui.new_checkbox, ui.new_color_picker, ui.new_hotkey, ui.new_multiselect, ui.new_slider, ui.reference, ui.set, ui.set_callback, ui.set_visible
local d480, d481= plist.get, entity.hitbox_position
local d482= require("ffi")
local d483= require("vector")
local d484= require("gamesense/csgo_weapons")
local d485= vtable_bind("client_panorama.dll", "VClientEntityList003", 3, "void*(__thiscall*)(void*, int)")
local d486= vtable_thunk(166, "bool(__thiscall*)(void*)")
local d487= vtable_thunk(483, "float(__thiscall*)(void*)")
local d488= {
	mindamage = d476("RAGE", "Aimbot", "Minimum damage"),
	dormant_esp = d476("VISUALS", "Player ESP", "Dormant"),
	override_mindamage = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}
local d489= require("require/abc/menu_setup")
local d490= require('require/abc/callbacks')

local d491= {}
local function d492(d493)
	if type(d489) ~= 'table' then return false end
	if d491[d493] == nil then d491[d493] = d489.ui and d489.ui[d493] end
	local d494= d491[d493]
	if not d494 then return false end
	local d495, d496= pcall(d470, d494)
	if not d495 then
		d491[d493] = d489.ui and d489.ui[d493]
		d494 = d491[d493]
		if not d494 then return false end
		d495, val = pcall(d470, d494)
		if not d495 then return false end
	end
	return d496
end

local d497= { "Head", "Chest", "Stomach" }
local d498= {
	"generic",
	"head",
	"chest",
	"stomach",
	"left arm",
	"right arm",
	"left leg",
	"right leg",
	"neck",
	"?",
	"gear"
}

local d499= {
	"",
	"Head",
	"Chest",
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs",
	"Head",
	"",
	""
}

local d500= {
	{ scale = 5, hitbox = "Stomach", vec = d483(0, 0, 40) },
	{ scale = 6, hitbox = "Chest", vec = d483(0, 0, 50) },
	{ scale = 3, hitbox = "Head", vec = d483(0, 0, 58) },
	{ scale = 4, hitbox = "Legs", vec = d483(0, 0, 20) }
}

local d501= {
	[0] = "Head",
	nil,
	"Stomach",
	nil,
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs"
}

local d502= 0
local d503= {}
local d504= {}
local d505= 1
local d506= false
local d507
local d508
local d509
local d510
local d511= false
local d512= {}

local d513= {
	0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18
}

local function d514(d515,d516,d517)
	local d518, d519= d515:to(d516):angles()
	local d520= math.rad(d519 + 90)
	local d521= d483(math.cos(d520), math.sin(d520), 0) * d517

	return {
		{ text = "Middle", vec = d516 },
		{ text = "Left", vec = d516 + d521 },
		{ text = "Right", vec = d516 - d521 }
	}
end

local function d522(d523,d524)
	for i = 1, #d523 do if d523[i] == d524 then return true end end
	return false
end
local function d525(d523,d524)
	for i = 1, #d523 do local d526= d523[i] if type(d526) == 'table' and d526[1] == d524 then return i end end
end
local function d527(d523,d528) return d525(d523, d528) ~= nil end
local function d529(d523,d528) local d530= d525(d523, d528) if d530 then table.remove(d523, d530) end end

local function d531(d532,d533)
	local d534= d466(d532.forwardmove*d532.forwardmove + d532.sidemove*d532.sidemove)
	if d533<=0 or d534<=0 then return end
	if d532.in_duck==1 then d533 = d533*2.94117647 end
	if d534<=d533 then return end
	local d535= d533/d534; d532.forwardmove = d532.forwardmove*d535; d532.sidemove = d532.sidemove*d535
end

local function d536()
	local d537, d538= {}, d455()
	for i=1,d462() do if d457(d538, "m_bConnected", i)==1 and i~=d452() and d459(i) then d537[#d537+1]=i end end
	return d537
end
local function d539()
	local d537, d538= {}, d455()
	for i=1,d462() do if d457(d538, "m_bConnected", i)==1 and not d480(i, "Add to whitelist") and d458(i) and d459(i) then d537[#d537+1]=i end end
	return d537
end

local function d540()
	for d518,enemy in ipairs(d536()) do
		local d518,d518,d518,d518,d541= d451(enemy)
		if d541<1 then if not d527(d504,enemy) then d504[#d504+1]={enemy,d463()} end else d529(d504,enemy) end
	end
end

local function d542(d543)
	local d544= d470(d488.override_mindamage[1]) and d470(d488.override_mindamage[2])
	local d545= d544 and d470(d488.override_mindamage[3]) or d470(d488.mindamage)
	local d546= entity.get_esp_data(d543).health
	if d545>100 then d545 = d545 - 100 + d546 end
	return d545
end

local function d547(d548,d535) return (d548.type=="sniperrifle" and d535) and d548.max_player_speed_alt or d548.max_player_speed end

local function d549(d543,d550,d551)
	local d552= {}
	local d553= d457(d543, "m_flDuckAmount") or 0
	for d518,p in ipairs(d500) do
		if #d551==0 or d522(d551,p.hitbox) then
			local d554= p.vec
			if p.hitbox=="Head" then d554 = d554 - d483(0,0,d553*10) elseif p.hitbox=="Chest" then d554 = d554 - d483(0,0,d553*4) end
			d552[#d552+1]={vec=d550+d554,scale=p.scale,hitbox=p.hitbox}
		end
	end
	for i=1,7 do
		local d555= d501[i-1]
		if d555 and (#d551==0 or d522(d551,d555)) then
			local d556= d481(d543,i-1)
			if d556 then d552[#d552+1]={vec=d483(d556),scale=3,hitbox=d555} end
		end
	end
	return d552
end

local function d557(d558,d559,d560,d561,d562)
	for d518,p in ipairs(d561) do
		for d518,d554 in ipairs(d514(d560,p.vec,3)) do
			local d518,d563= d450(d558, d560.x,d560.y,d560.z, d554.vec.x,d554.vec.y,d554.vec.z, true)
			if p.hitbox=="Head" then d563=d563*4 end
			if d563>d562 then return d554.vec,d563,p.hitbox,d554.text end
		end
	end
end

local function d564(d532)
	d540()

	if not d492('misc_dormantaimbot') and d492('misc_dormantaimbot_key') then
		return
	end

	local d565= d452()
	if not d565 or not d460(d565) then
		return
	end

	local d566= d456(d565)
	if not d566 then
		return
	end

	local d567= d485(d566)
	if not d567 or not d486(d567) then
		return
	end

	local d568= d487(d567)
	if not d568 then
		return
	end

	local d569= d483(d448())
	local d570= d457(d565, "m_flSimulationTime")
	local d571= d463()
	local d572= d484(d566)
	local d573= d457(d565, "m_bIsScoped") == 1
	local d574= bit.band(d457(d565, "m_fFlags"), bit.lshift(1, 0))

	local d575= d539()
	if #d575 == 0 then
		d503 = {}
		return
	end

	if d571 % #d575 ~= 0 then
		d505 = d505 + 1
	else
		d505 = 1
	end

	local d543= d575[d505]
	if not d543 then
		d503 = {}
		return
	end

	if d571 < d502 then
		d503 = {}
		return
	end

	if d572.type == "grenade" or d572.type == "knife" then
		d503 = {}
		return
	end

	if d532.in_jump == 1 and d574 == 0 then
		d503 = {}
		return
	end

	local d576= d497
	local d577= d483(d453(d543))
	local d518, d518, d518, d518, d578= d451(d543)

	d503[d543] = nil

	if d578 < 1 then
		if not d527(d512, d543) then
			d512[#d512 + 1] = { d543, d571 }
		end
	else
		d529(d512, d543)
	end

	local d579= d549(d543, d577, d576)
	local d580= d542(d543)

	local d581
	if d572.is_revolver then
		d581 = d570 > d457(d566, "m_flNextPrimaryAttack")
	else
		d581 = d570 > d464(
			d457(d565, "m_flNextAttack"),
			d457(d566, "m_flNextPrimaryAttack"),
			d457(d566, "m_flNextSecondaryAttack")
		)
	end

	if not d581 then
		return
	end

	local d582, d583, d584, d585= d557(
		d565,
		d572,
		d569,
		d579,
		d580
	)

	if not d582 then
		return
	end

	if d447(d582.x, d582.y, d582.z) then
		return
	end

	d531(d532, d547(d572, d573) * 0.33)

	local d586, d519= d569:to(d582):angles()

	if not d573 and d572.type == "sniperrifle" and d532.in_jump == 0 and d574 == 1 then
		d532.in_attack2 = 1
	end

	d503[d543] = true

	if d568 < 0.01 then
		d532.pitch = d586
		d532.yaw = d519
		d532.in_attack = 1
		d506 = true
		d507 = d584
		d508 = d585
		d509 = d543
		d510 = (d470(d489.ui.misc_dormantaimbot_value) or 0)
	end
end

local function d587(d588)
	client.delay_call(0.03, function()
		local d565= d452()
		if client.userid_to_entindex(d588.userid) ~= d565 then
			return
		end

		if d506 and not d511 then
			client.fire_event("dormant_miss", {
				userid = d509,
				aim_hitbox = d507,
				aim_point = d508,
				accuracy = d510
			})
		end

		d511 = false
		d506 = false
		d507 = nil
		d508 = nil
		d509 = nil
		d510 = nil
	end)
end

local function d589(d588)
	local d590= client.userid_to_entindex(d588.userid)
	local d591= client.userid_to_entindex(d588.attacker)

	if d591 == d452() and d590 ~= nil and d506 then
		d511 = true

		client.fire_event("dormant_hit", {
			userid = d590,
			attacker = d591,
			health = d588.health,
			armor = d588.armor,
			weapon = d588.weapon,
			dmg_health = d588.dmg_health,
			dmg_armor = d588.dmg_armor,
			hitgroup = d588.hitgroup,
			accuracy = d510 or 0,
			aim_hitbox = d507
		})
	end
end

local function d592()
	local d593= (cvar.mp_freezetime:get_float() + 1) / globals.tickinterval()
	d502 = d463() + d593
end

d490.register("setup_command", d564, { alive_only = true, require_login = true })
d490.register("round_prestart", d592, { alive_only = true, require_login = true })
d490.register("player_hurt", d589, { alive_only = true, require_login = true })
d490.register("weapon_fire", d587, { alive_only = true, require_login = true })

client.register_esp_flag("DA", 255, 255, 255, function(d528)
	if d492('misc_dormantaimbot') and d492('misc_dormantaimbot_key') and d460(d452()) then
		return d503[d528]
	end
end)


d490.register("paint", function()
	if not d460(d452()) then return end
	if d492('misc_dormantaimbot') and d492('misc_dormantaimbot_key') then
		local d594= {255,255,255,200}
		for d518,d526 in pairs(d503) do if d526 then d594={143,194,21,255}; break end end
		if #d539()==0 then d594={255,0,50,255} end
		d467(d594[1],d594[2],d594[3],d594[4],"DA")
	end
end, { alive_only = true, require_login = true })]]
d958["require/features/misc/enhance_osaa"] = [[local d450, d451= pcall(require, "require/abc/menu_setup")

local d452= require('require/abc/callbacks')

local d453= {}
local d454= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local d455= {ui.reference(item[1], item[2], item[3])}
    d453[i] = d455
    for _, ref in ipairs(d455) do
        d454[ref] = true
    end
end

local d456= {}
local d457= {}

d452.register("weapon_fire", function(d458)
    local d459= entity.get_local_player()
    if d459 and client.userid_to_entindex(d458.userid) == d459 then
        d456[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

d452.register("player_hurt", function(d458)
    local d459= entity.get_local_player()
    if d459 and client.userid_to_entindex(d458.userid) == d459 then
        d457[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

local function d460()
    local d461= globals.tickcount()
    local d462= nil
    for t = d461-20, d461 do
        if d456[t] then
            d462 = t
            break
        end
    end
    if d462 then
        if d461 - d462 <= 4 then
            return true
        end
        return true
    end
    return false
end



local function d463(d464)

    local d460= has_fired()

    local function d465(d466,d467)
        if type(d466) ~= 'table' then return false end
        for _, v in ipairs(d466) do if tostring(v) == tostring(d467) then return true end end
        return false
    end

    local d468= ui.get(d451.ui.fakelag_settings_enhance_onshot) or {}

    if d451 and d451.ui and d460 then
            if d465(d468, 'defensive') then
                d464.force_defensive = true
            end

            if d465(d468, 'roll') then
                ui.set(d453[3][1], math.random(-45, 45))
            end

            local d469= globals.tickcount() % 4 < 2
            if d465(d468, 'jitter') then
                ui.set(d453[2][1], '180')
                ui.set(d453[2][2], d469 and 55 or -48)
            end
    end
end

d452.register('setup_command', function(d464)

    d463(d464)

end, { alive_only = true, require_login = true })]]
d958["require/features/misc/events"] = [[local d453= {}
local d454= globals

d453.last_hit = {}
d453.last_miss = {}

d453.shots_queue = {}
d453.shots_by_id = {}

function d453.record_weapon_fire(d455)
  if not d455 or not d455.t then return end
  d453.shots_queue[#d453.shots_queue+1] = d455
end

function d453.record_aim_fire(d456,d455)
  if not d456 or not d455 then return end
  d453.shots_by_id[d456] = d455
end

function d453.record_aim_miss(d456,d457,d458)
  if not d457 then return end
  local d459= d454.curtime()
  local d460= d458 or {}
  d460.time = d459
  d453.last_miss[d457] = d460
  if d456 then d453.shots_by_id[d456] = nil end
end

function d453.record_player_hurt(d456,d457,d458)
  if not d457 then return end
  local d459= d454.curtime()
  local d460= d458 or {}
  d460.time = d459
  d453.last_hit[d457] = d460
  if d456 then d453.shots_by_id[d456] = nil end
end

function d453.link_recent_shot_to_victim(d457,d461)
  d461 = d461 or 0.35
  local d459= d454.curtime()
  for i=#d453.shots_queue,1,-1 do
    local d462= d453.shots_queue[i]
    if d462 and d462.target == d457 and (d459 - (d462.t or d459)) <= d461 and not d462.linked then
      d453.shots_queue[i].linked = true
      return d453.shots_queue[i]
    end
  end
  return nil
end

return d453
]]
d958["require/features/misc/exploit_fakelag"] = [[local d456, d457= pcall(require, "require/abc/menu_setup")

local d458= require('require/abc/callbacks')

local d459= {}
local d460= {}
for i, item in ipairs({
    { 'rage', 'aimbot', 'double tap' },
    { 'aa', 'other', 'on shot anti-aim' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },

}) do
    local d461= {ui.reference(item[1], item[2], item[3])}
    d459[i] = d461
    for _, ref in ipairs(d461) do
        d460[ref] = true
    end
end


local function d462(d463)

    local d464= ui.get(d457.ui.misc_exploit_fakelag)

    local d465= (ui.get(d459[1][1]) and ui.get(d459[1][2]))
    local d466= (ui.get(d459[2][1]) and ui.get(d459[2][2]))

    local d467= d464 and (d465 or d466)

    if d467 then
        ui.set(d459[3][1], false)
    end

end

d458.register('setup_command', function(d463)

    d462(d463)

end, { alive_only = true, require_login = true })]]
d958["require/features/misc/fakelag"] = [[local d459= {}
local d460= {}
for i, item in ipairs({
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
}) do
    local d461= {ui.reference(item[1], item[2], item[3])}
    d459[i] = d461
    for _, ref in ipairs(d461) do
        d460[ref] = true
    end
end

local d462, d463= pcall(require, "require/abc/menu_setup")

local d464= require('require/abc/callbacks')

d464.register("setup_command", function()
    if not (d462 and d463 and d463.ui) then return end

    local d465, d466= pcall(ui.get, d463.ui.fakelag_fakelag)
    if not d465 or not d466 then return end

    local d467, d468= pcall(ui.get, d463.ui.fakelag_fakelag_type)
    if not d467 then return end

    if tostring(d468) == "gamesense" then
        ui.set(d459[1][1], true)
        local d469, d470= pcall(ui.get, d463.ui.fakelag_fakelag_amount)
        local d471, d472= pcall(ui.get, d463.ui.fakelag_fakelag_variance)
        local d473, d474= pcall(ui.get, d463.ui.fakelag_fakelag_limit)

        if d469 and d470 and d459[2] and d459[2][1] then
            pcall(ui.set, d459[2][1], d470)
        end
        if d471 and d472 and d459[3] and d459[3][1] then
            pcall(ui.set, d459[3][1], d472)
        end
        if d473 and d474 and d459[4] and d459[4][1] then
            pcall(ui.set, d459[4][1], d474)
        end

        return
    end

    if tostring(d468) == "sodium" then
        ui.set(d459[1][1], true)
        local d475, d476= pcall(ui.get, d463.ui.fakelag_fakelag_type2)
        if not d475 then return end

        if tostring(d476) == "jitter" then
            if d459[2] and d459[2][1] then
                pcall(ui.set, d459[2][1], "dynamic")
            end
            local d477= globals.tickcount() or 0
            local d478= math.max(d477 % 101, 100)
            local d479= math.min(math.random(7) + (d477 % 15), 11)
            if d459[3] and d459[3][1] then pcall(ui.set, d459[3][1], d478) end
            if d459[4] and d459[4][1] then pcall(ui.set, d459[4][1], 15) end

            return
        end

        if tostring(d476) == "max" then
            if d459[2] and d459[2][1] then
                pcall(ui.set, d459[2][1], "dynamic")
            end
            if d459[3] and d459[3][1] then
                pcall(ui.set, d459[3][1], 0)
            end
            local d474= 14 + ((globals.tickcount() or 0) % 2)
            if d459[4] and d459[4][1] then pcall(ui.set, d459[4][1], d474) end

            return
        end
    end
end, { alive_only = true, require_login = true })]]
d958["require/features/misc/freestand_helper"] = [[local d462= {}
local d463= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
}) do
    local d464= {ui.reference(item[1], item[2], item[3])}
    d462[i] = d464
    for _, ref in ipairs(d464) do
        d463[ref] = true
    end
end

local d465, d466= pcall(require, "require/abc/menu_setup")

local d467= require('require/abc/callbacks')

local function d468(d469)
    if not (d466 and d466.ui and d466.ui.aa_gskey_freestand) then return end
    if not ui.get(d466.ui.aa_gskey_freestand) then return end

    local function d470(d471,d472)
        if type(d471) ~= 'table' then return false end
        for _, v in ipairs(d471) do if tostring(v) == tostring(d472) then return true end end
        return false
    end

    local d473= ui.get(d466.ui.fakelag_settings_freestanding) or {}


    localplayer = entity.get_local_player()
    local d474, d475, d476= entity.get_prop(localplayer, 'm_vecVelocity')
    if d474 and d475 and d476 then
        velvel =  math.sqrt(d474 * d474 + d475 * d475 + d476 * d476)
    end
    


    if d470(d473, 'static') then
        ui.set(d462[1][1], true)
        ui.set(d462[5][1], '180')
        ui.set(d462[5][2], 6)
        ui.set(d462[6][1], 'off')
        ui.set(d462[7][1], 'off')
    end

    if d470(d473, 'zero pitch') and velvel > 5 then
        ui.set(d462[3][1], 'Off')
    end

    if d470(d473, 'defensive') then
        d469.force_defensive = true
    end

    local d477= globals.tickcount() % 4 < 2
    if d470(d473, 'side flip') and velvel > 5 then
        ui.set(d462[5][1], '180')
        ui.set(d462[5][2], d477 and -90 or 90)
    end

    local d477= globals.tickcount() % 6 < 2
    if d470(d473, 'pitch flip') and velvel > 5 then
        ui.set(d462[3][1], 'custom')
        ui.set(d462[3][2], d477 and -89 or 89)
    end

end

d467.register('setup_command', function(d469)
    d468(d469)
end, { alive_only = true, require_login = true })]]
d958["require/features/misc/history"] = [[
local d465= {}

local d466= 20
local d467= {}

local function d468(d469)
  if not d467[d469] then d467[d469] = { buf = {} } end
  return d467[d469]
end

function d465.push(d469,d470)
  if not d469 or not d470 then return end
  local d471= d468(d469)
  d471.buf[#d471.buf+1] = d470
  if #d471.buf > d466 then table.remove(d471.buf, 1) end
end

function d465.get_last_n(d469,d472)
  d472 = d472 or d466
  local d471= d467[d469]
  if not d471 or #d471.buf == 0 then return {} end
  local d473= {}
  local d474= #d471.buf
  local d475= math.max(1, d474 - d472 + 1)
  for i = d475, d474 do d473[#d473+1] = d471.buf[i] end
  return d473
end

function d465.clear(d469)
  if not d469 then d467 = {} return end
  d467[d469] = nil
end

return d465
]]
d958["require/features/misc/hotkeys"] = [[local d468= {}
local d469= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local d470= {ui.reference(item[1], item[2], item[3])}
    d468[i] = d470
    for _, ref in ipairs(d470) do
        d469[ref] = true
    end
end

local d471, d472= pcall(require, "require/abc/menu_setup")

local d473= require('require/abc/callbacks')

local function d474()

    if ui.get(d472.ui.aa_gskey_freestand) then
        ui.set(d468[3][1], true)
        ui.set(d468[3][2], 'Always on')
    else
        ui.set(d468[3][1], false)
        ui.set(d468[3][2], 'On hotkey')
    end

    if ui.get(d472.ui.aa_gskey_slowmotion) then
        ui.set(d468[4][1], true)
    else
        ui.set(d468[4][1], false)
    end

    if d472 and d472.ui and ui.get(d472.ui.aa_gskey_edgeyaw) then
        ui.set(d468[2][1], true)
    else
        ui.set(d468[2][1], false)
    end

    if d472 and d472.ui and ui.get(d472.ui.aa_gskey_onshot) then
        ui.set(d468[6][2], 'Always on')
    else
        ui.set(d468[6][2], 'On hotkey')
    end

end

d473.register('setup_command', function()

    d474()

end, { alive_only = true, require_login = true })]]
d958["require/features/misc/localdebug"] = [=[local callbacks_ok, callbacks = pcall(require, "require/abc/callbacks")
local M = {}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")

local state = {
    last_yaw = nil,
    last_pitch = nil,
    last_defensive = false,
    skel_list = {},
    last_choked = 0,
    shot_ticks = {},
    shot_ticks_aim = {},
    skel_history = {},
}

local function normalize_angle(a)
    if not a then return a end
    local ang = tonumber(a) or 0
    while ang > 180 do ang = ang - 360 end
    while ang <= -180 do ang = ang + 360 end
    return ang
end

local function on_weapon_fire(ev)
    if not ev then return end
    local attacker_ent = client.userid_to_entindex(ev.userid)
    local lp = entity.get_local_player()
    if attacker_ent ~= lp then return end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks, t)
    while #state.shot_ticks > 200 do table.remove(state.shot_ticks, 1) end
end

local function on_aim_fire(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    if ev.attacker then
        local attacker_ent = client.userid_to_entindex(ev.attacker)
        if attacker_ent ~= lp then return end
    end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks_aim, t)
    while #state.shot_ticks_aim > 200 do table.remove(state.shot_ticks_aim, 1) end
end

local function had_recent_shot(ticks_back)
    ticks_back = ticks_back or 30
    local now = globals.tickcount and globals.tickcount() or 0
    for i = #state.shot_ticks_aim, 1, -1 do
        local s = state.shot_ticks_aim[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    for i = #state.shot_ticks, 1, -1 do
        local s = state.shot_ticks[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    return false
end

local function safe_tonumber(v)
    local n = tonumber(v)
    if n then return n end
    return 0
end


local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {
    head={names={'head','Head','HEAD'},idx={0}},
    neck={names={'neck','Neck'},idx={1}},
    chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},
    stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},
    pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},
    l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},
    l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},
    l_hand={names={'left hand','Left Hand'},idx={14}},
    r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},
    r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},
    r_hand={names={'right hand','Right Hand'},idx={13}},
    l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},
    l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},
    l_foot={names={'left foot','Left Foot'},idx={12}},
    r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},
    r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},
    r_foot={names={'right foot','Right Foot'},idx={11}},
}

local function find_bone(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x,y,z = entity.hitbox_position(ent, def.names[i])
        if x then return x,y,z end
    end
    for i = 1, #(def.idx or {}) do
        local x,y,z = entity.hitbox_position(ent, def.idx[i])
        if x then return x,y,z end
    end
end

local function snap_ent(ent)
    if not ent then return end
    local pts = {}
    for key, def in pairs(boxes) do
        local x,y,z = find_bone(ent, def)
        if x then pts[key] = {x=x,y=y,z=z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local function paint_handler()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lag_record then
        local ok_enabled, enabled = pcall(ui.get, menu_setup.ui.paint_lag_record)
        if not ok_enabled or not enabled then return end
    end
    if not renderer or not renderer.world_to_screen or not renderer.line then return end
    local now = globals.realtime and globals.realtime() or os.time()
    local i = 1
    while i <= #state.skel_list do
        local it = state.skel_list[i]
        if not it or not it.t or (now - it.t) > 10 then
            table.remove(state.skel_list, i)
        else
            local SKEL_SCALE = 1.15
            
            local trail = it.trail or {}
            if trail and #trail > 0 then
                for ti = 1, #trail do
                    local entry = trail[ti]
                    local trail_pts = entry.pts or {}
                    
                    local ratio = ti / #trail
                    local r, g, b, alpha
                    if ti == #trail then
                        
                        r = 0
                        g = 140
                        b = 255
                        alpha = 200
                    else
                        
                        r = 255
                        g = math.floor(255 * (1 - ratio))
                        b = math.floor(255 * (1 - ratio))
                        alpha = math.floor(40 + ratio * (160 - 40))
                    end
                    
                    local center = trail_pts.pelvis or trail_pts.chest
                    if not center then
                        local sx, sy, sz, ccount = 0,0,0,0
                        for k, v in pairs(trail_pts) do
                            if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                        end
                        if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
                    end
                    for c = 1, #chains do
                        local chain = chains[c]
                        local from, to = trail_pts[chain[1]], trail_pts[chain[2]]
                        if from and to then
                            local fxw, fyw, fzw = from.x, from.y, from.z
                            local txw, tyw, tzw = to.x, to.y, to.z
                            if center and center.x then
                                fxw = center.x + (from.x - center.x) * SKEL_SCALE
                                fyw = center.y + (from.y - center.y) * SKEL_SCALE
                                fzw = center.z + (from.z - center.z) * SKEL_SCALE
                                txw = center.x + (to.x - center.x) * SKEL_SCALE
                                tyw = center.y + (to.y - center.y) * SKEL_SCALE
                                tzw = center.z + (to.z - center.z) * SKEL_SCALE
                            end
                            local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                            local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                            if fx and tx then renderer.line(fx,fy,tx,ty,r,g,b,alpha) end
                        end
                    end
                end
            end
            
            local pts = it.pts or {}
            local center = pts.pelvis or pts.chest
            if not center then
                local sx, sy, sz, ccount = 0,0,0,0
                for k, v in pairs(pts) do
                    if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                end
                if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
            end
            for c = 1, #chains do
                local chain = chains[c]
                local from, to = pts[chain[1]], pts[chain[2]]
                if from and to then
                    local fxw, fyw, fzw = from.x, from.y, from.z
                    local txw, tyw, tzw = to.x, to.y, to.z
                    if center and center.x then
                        fxw = center.x + (from.x - center.x) * SKEL_SCALE
                        fyw = center.y + (from.y - center.y) * SKEL_SCALE
                        fzw = center.z + (from.z - center.z) * SKEL_SCALE
                        txw = center.x + (to.x - center.x) * SKEL_SCALE
                        tyw = center.y + (to.y - center.y) * SKEL_SCALE
                        tzw = center.z + (to.z - center.z) * SKEL_SCALE
                    end
                    local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                    local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                    if fx and tx then renderer.line(fx,fy,tx,ty,255,0,0,220) end
                end
            end
            i = i + 1
        end
    end
end


local function on_setup_command(cmd)
    if not cmd then return end
    local aa_funcs = nil
    local ok_req, req_lib = pcall(require, 'gamesense/antiaim_funcs')
    if ok_req and req_lib then aa_funcs = req_lib end
    if not aa_funcs then
        local ok_libs, libs = pcall(require, 'require/help/libs')
        if ok_libs and libs and libs.get then
            aa_funcs = libs.get('antiaim_funcs')
        end
    end

    local pitch, yaw = nil, nil
    if aa_funcs then
        local okp, pval = pcall(function() return aa_funcs.get_pitch and aa_funcs.get_pitch() end)
        if okp and pval ~= nil then pitch = pval end
        local oky, yval = pcall(function() return aa_funcs.get_yaw_base and aa_funcs.get_yaw_base() end)
        if oky and yval ~= nil then yaw = yval end
        if yaw == nil then
            local okb, bval = pcall(function() return aa_funcs.get_body_yaw and aa_funcs.get_body_yaw() end)
            if okb and bval ~= nil then yaw = bval end
        end
    end

    if (pitch == nil or yaw == nil) then
        local lp = entity.get_local_player()
        if lp then
            local ax, ay = entity.get_prop(lp, "m_angEyeAngles")
            if ax and ay then
                if pitch == nil then pitch = ax end
                if yaw == nil then yaw = ay end
            end
        end
    end

    if pitch ~= nil then state.last_pitch = pitch end
    if yaw ~= nil then state.last_yaw = normalize_angle(yaw) end

    do
        local ok_def, def_mod = pcall(require, 'require/features/aa/defensive')
        if ok_def and def_mod and def_mod.active ~= nil then
            state.last_defensive = not not def_mod.active
        else
            if cmd and cmd.force_defensive ~= nil then
                state.last_defensive = not not cmd.force_defensive
            end
        end
    end
    if cmd and cmd.chokedcommands ~= nil then
        state.last_choked = tonumber(cmd.chokedcommands) or 0
    end
    local lp = entity.get_local_player()
    if lp then
        local tick = globals.tickcount and globals.tickcount() or 0
        local hist_pts = snap_ent(lp)
        if hist_pts then
            state.skel_history[#state.skel_history + 1] = { tick = tick, pts = hist_pts }
            if #state.skel_history > 128 then table.remove(state.skel_history, 1) end
        end
    end
end

local function on_player_death(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    local victim_ent = client.userid_to_entindex(ev.userid)
    local attacker_ent = nil
    if ev.attacker then attacker_ent = client.userid_to_entindex(ev.attacker) end

    if victim_ent == lp then
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then
                attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker)
            else
                attacker_name = tostring(ev.attacker)
            end
        end
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] DIED — last_yaw=%.2f last_pitch=%.2f attacker=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
        return
    end
    if attacker_ent == lp and victim_ent and victim_ent ~= 0 and victim_ent ~= lp then
        local victim_name = entity.get_player_name(victim_ent) or tostring(ev.userid)
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] KILLED — last_yaw=%.2f last_pitch=%.2f victim=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, victim_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end
end

if callbacks_ok and callbacks and callbacks.callback then
    callbacks.callback('setup_command', on_setup_command, { alive_only = false, require_login = false })
    callbacks.callback('player_death', on_player_death, { alive_only = false, require_login = false })
    callbacks.callback('paint', paint_handler, { alive_only = false, require_login = false })
    callbacks.callback('weapon_fire', on_weapon_fire, { alive_only = false, require_login = false })
    callbacks.callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end, { alive_only = false, require_login = false })
else
    client.set_event_callback('setup_command', on_setup_command)
    client.set_event_callback('player_death', on_player_death)
    client.set_event_callback('paint', paint_handler)
    client.set_event_callback('weapon_fire', on_weapon_fire)
    client.set_event_callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end)
end
]=]
d958["require/features/misc/resolver"] = [[














local d474, d475= pcall(require, "require/features/misc/collect")
local d476, d477= pcall(require, "require/features/misc/history")
local d478, d479= pcall(require, "require/features/misc/state")
local d480, d481= pcall(require, "require/features/misc/events")
local d482, d483= pcall(require, "require/help/vector")
local d484= d482 and d483 or nil
local d485= require('require/abc/callbacks')







if not M then M = {} end
M.players = M.players or {}


local function d486()
	pcall(function()
		if not d474 or type(d475) ~= "table" or not d475.get_enemies_snapshot then return end

		local d487, d488= pcall(function() return d475.get_enemies_snapshot() end)
		if not d487 or type(d488) ~= "table" then return end

		M.players = M.players or {}

		for ent, snap in pairs(d488) do
			M.players[ent] = M.players[ent] or {}
			M.players[ent].snapshot = snap

            
            
            
			M.players[ent].simtime = snap.simtime
			M.players[ent].simTicks = snap.simTicks
			M.players[ent].lowerBodyYaw = snap.lowerBodyYaw
			M.players[ent].speed2d = snap.speed2d
			M.players[ent].velocity3d = snap.velocity3d
			M.players[ent].is_alive = snap.is_alive
			M.players[ent].is_dormant = snap.is_dormant
			M.players[ent].feetYaw = snap.feetYaw
			M.players[ent].goalFeetYaw = snap.goalFeetYaw
			M.players[ent].moveSpeedAnim = snap.moveSpeedAnim
		end

		for ent, snap in pairs(d488) do
			local d489= snap.name or "?"
			local d490= snap.simtime or 0
			local d491= snap.speed2d or 0
			local d492= snap.lowerBodyYaw or "nil"
			local d493= snap.moveSpeedAnim or 0
			local d494= snap.feetYaw or "nil"
			local d495= snap.goalFeetYaw or "nil"
			local d496= snap.animstate_full.m_fDuckAmount

		end
	end)
end



local function d497(d498)
    while d498 > 180 do
        d498 = d498 - 360
    end
    while d498 < -180 do
        d498 = d498 + 360
    end
    return d498
end


local function d499(d500,d501)
    local d502= d501 - d500
    local d498= math.atan(d502.y / d502.x)
    d498 = d497(d498 * 180 / math.pi)

    if d502.x >= 0 then
        d498 = d497(d498 + 180)
    end

    return d498
end



local d503= 100
local d504= {}
_G.player_history = d504

local function d505(d506)
    return math.floor(0.5 + d506 / globals.tickinterval())
end

local function d507(d508)
    local d509= entity.get_players(true)

	if #d509 == 0 then
		
		d504 = {}
		_G.player_history = d504
		return nil
	end


	for i, player in ipairs(d509) do
		if entity.is_alive(player) and not entity.is_dormant(player) then

			local d510= 0
			local d511= entity.get_esp_data(player).flags or 0

			if bit.band(d511, bit.lshift(1, 17)) ~= 0 then
				d510 = d505(entity.get_prop(player, "m_flSimulationTime")) - 14
			else
				d510 = d505(entity.get_prop(player, "m_flSimulationTime"))
			end

			
			local d512= d504[player] or {}
			local d513= d512[1]

			if d513 == nil or (d510 - (d513.simtime or -999)) >= 1 then

				local d514= d484(entity.get_prop(d508, "m_vecOrigin"))
				local d515= d484(entity.get_prop(player, "m_angEyeAngles"))
				local d516= d484(entity.get_prop(player, "m_vecOrigin"))
				local d517= math.floor(d497(d515.y - d499(d514, d516)))
				

				local d518= {
					id = player or nil,
					origin = d484(entity.get_origin(player)) or d484(nil,nil,nil),
					pitch = d515.x or nil,
					yaw = d517 or nil,
					yaw_backwards = backwards_angle or nil,
					simtime = d510 or nil,
					stance = stance or nil,
					esp_flags = entity.get_esp_data(player).flags or 0,
					last_shot_time = last_shot_time or nil
				}

				table.insert(d512, 1, d518)
				while #d512 > d503 do
					table.remove(d512)
				end

				d504[player] = d512
			end
		end
	end
end















client.set_event_callback('net_update_end', function()
    pcall(function()

        
        

        local d508= entity.get_local_player()
        if not entity.is_alive(d508) then
            return
        end
        d507(d508)


        local d519= (globals and globals.tickcount and globals.tickcount()) or (globals and globals.realtime and globals.realtime()) or os.time()
        

    end)
end, { alive_only = true, require_login = true })

d485.register('weapon_fire', function(d520)
    pcall(function()







        local d521= (d520 and d520.userid) and (client.userid_to_entindex and client.userid_to_entindex(d520.userid)) or (d520 and (d520.attacker or d520.userid)) or "?"
        local d522= (d520 and (d520.weapon or d520.weapon_name or d520.weaponid)) or "?"
        
    end)
    if EVENTS and EVENTS.record_weapon_fire then pcall(EVENTS.record_weapon_fire, d520) end
end, { alive_only = true, require_login = true })

d485.register('aim_fire', function(d520)
    pcall(function()








        local d523= d520 and d520.id or "?"
        local d524= d520 and d520.target or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_fire then pcall(EVENTS.record_aim_fire, d520) end
end, { alive_only = true, require_login = true })

d485.register('aim_hit', function(d520)
    pcall(function()








        local d523= d520 and d520.id or "?"
        local d524= d520 and d520.target or "?"
        local d525= d520 and d520.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_hit then pcall(EVENTS.record_aim_hit, d520) end
end, { alive_only = true, require_login = true })

d485.register('aim_miss', function(d520)
    pcall(function()






        local d523= d520 and d520.id or "?"
        local d526= d520 and d520.reason or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_miss then pcall(EVENTS.record_aim_miss, d520) end
end, { alive_only = true, require_login = true })

d485.register('player_hurt', function(d520)
    pcall(function()






        local d527= (d520 and d520.attacker) or (d520 and d520.userid) or "?"
        local d528= (d520 and d520.userid) or (d520 and d520.userid) or "?"
        local d525= d520 and d520.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_player_hurt then pcall(EVENTS.record_player_hurt, d520) end
end, { alive_only = true, require_login = true })

d485.register('bullet_impact', function(d520)
    pcall(function()




        local d521= (d520 and d520.userid) and (client.userid_to_entindex and client.userid_to_entindex(d520.userid)) or "?"
        local d529,d530,d531= d520 and d520.x or "?", d520 and d520.y or "?", d520 and d520.z or "?"
        
    end)
    if EVENTS and EVENTS.on_bullet_impact then pcall(EVENTS.on_bullet_impact, d520) end
    if EVENTS and EVENTS.record_bullet_impact then pcall(EVENTS.record_bullet_impact, d520) end
end, { alive_only = true, require_login = true })

d485.register('paint', function()
    pcall(function()

        

    end)
    if EVENTS and EVENTS.on_paint then pcall(EVENTS.on_paint) end
end, { alive_only = true, require_login = true })

d485.register("round_start", function(d520)
    pcall(function() print("[resolver] round_start") end)



    M.players = {}
    if EVENTS and EVENTS.on_round_start then pcall(EVENTS.on_round_start, d520) end
end, { alive_only = true, require_login = true })

d485.register("shutdown", function()
    if client and client.unset_event_callback then



    end
end, { alive_only = true, require_login = true })
]]
d958["require/features/misc/resolver_dispatcher"] = [[local d477= {}


local d478= {}


_G.player_resolver_state = _G.player_resolver_state or {}

local function d479(d480)
    if not d480 or type(d480) ~= "string" then return nil end
    
    local d481= d480:lower()
    d481 = d481:gsub("%+", "plus")
    d481 = d481:gsub("%-% ", "minus_") 
    d481 = d481:gsub("%-%", "minus")
    d481 = d481:gsub("%s+", "_")
    d481 = d481:gsub("[^%w_]", "")
    return d481
end

local function d482(d480)
    local d483
    
    if d480 == "?" then
        d483 = "default"
    else
        d483 = d479(d480)
    end
    if not d483 or d483 == "" then return nil end
    if d478[d483] ~= nil then return d478[d483] end
    local d484= "require/features/misc/res_" .. d483
    local d485, d486= pcall(require, d484)
    if d485 and type(d486) == "table" then
        d478[d483] = d486
        return d486
    end
    d478[d483] = false
    return nil
end



function d477.process_entity(d487,d480,d488)
    local d485, d489= pcall(function()
        if not d487 or d487 == 0 then return end
        if not d480 or d480 == "?" then return end

        local d486= d482(d480)
        if not d486 then return end

        
        local d490= _G.player_resolver_state[d487]
        if not d490 then
            d490 = {}
            _G.player_resolver_state[d487] = d490
        end

        if type(d486.run) == "function" then
            
            pcall(function() d486.run(d487, d488 or {}, d490, d480) end)
        elseif type(d486.process) == "function" then
            pcall(function() d486.process(d487, d488 or {}, d490, d480) end)
        end
    end)
    return d485
end


d477._modules = d478
d477._sanitize_label = d479

return d477
]]
d958["require/features/misc/res_default"] = [[local d480= {}

local function d481(d482)
    pcall(function()
        if plist and type(plist.set) == "function" then
            
            plist.set(d482, "Force body yaw", false)
            plist.set(d482, "Force body yaw value", 0)
            plist.set(d482, "Force pitch", false)
            plist.set(d482, "Force pitch value", 0)
        end
    end)
end

function d480.run(d482,d483,d484,d485)
    
    if d485 ~= "?" and d485 ~= "DEFAULT" and d485 ~= "default" then return end

    d484.clears = (d484.clears or 0) + 1
    d484.last_seen = (globals and globals.curtime and globals.curtime()) or os.time()

    
    d481(d482)

    pcall(function()
        print(string.format("[res_default] ent=%d cleared_forces label=%s count=%d", d482, tostring(d485), d484.clears))
    end)
end

return d480
]]
d958["require/features/misc/res_static"] = [=[local M = {}
local ok_ffi, ffi = pcall(require, "ffi")
local ok_bit, bit = pcall(require, "bit")


local get_entity_ptr
local function init_ffi_helpers()
    if not ok_ffi or not client or not client.create_interface then return end
    local status, res = pcall(function()
        local pointer_type = ffi.typeof("void***")
        local entity_list_ptr = client.create_interface("client.dll", "VClientEntityList003")
        if not entity_list_ptr then return nil end
        local entity_list = ffi.cast(pointer_type, entity_list_ptr)
        local get_client_entity = ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
        return function(entindex)
            if not entindex or entindex == 0 then return nil end
            local ptr = get_client_entity(entity_list, entindex)
            if ptr == nil then return nil end
            return ptr
        end
    end)
    if status and type(res) == "function" then
        get_entity_ptr = res
    else
        get_entity_ptr = nil
    end
end
init_ffi_helpers()

local function get_speed2d(ent)
    
    local ok, vx, vy = pcall(function()
        local x,y,z = entity.get_prop(ent, "m_vecVelocity")
        return x or 0, y or 0
    end)
    if ok and vx and vy then
        return math.sqrt((vx or 0)*(vx or 0) + (vy or 0)*(vy or 0))
    end
    return 0
end

local function estimate_max_desync_ent(ent)
    
    if not ok_ffi or not get_entity_ptr then return nil end
    local ok_read, result = pcall(function()
        ffi.cdef[[
        struct c_animstate {
            char pad0[3];
            char m_bForceWeaponUpdate;
            char pad1[91];
            void* m_pBaseEntity;
            void* m_pActiveWeapon;
            void* m_pLastActiveWeapon;
            float m_flLastClientSideAnimationUpdateTime;
            int m_iLastClientSideAnimationUpdateFramecount;
            float m_flAnimUpdateDelta;
            float m_flEyeYaw;
            float m_flPitch;
            float m_flGoalFeetYaw;
            float m_flCurrentFeetYaw;
            float m_flCurrentTorsoYaw;
            float m_flUnknownVelocityLean;
            float m_flLeanAmount;
            char pad2[4];
            float m_flFeetCycle;
            float m_flFeetYawRate;
            char pad3[4];
            float m_fDuckAmount;
            float m_fLandingDuckAdditiveSomething;
            char pad4[4];
            float m_vOriginX;
            float m_vOriginY;
            float m_vOriginZ;
            float m_vLastOriginX;
            float m_vLastOriginY;
            float m_vLastOriginZ;
            float m_vVelocityX;
            float m_vVelocityY;
            char pad5[4];
            float m_flUnknownFloat1;
            char pad6[8];
            float m_flUnknownFloat2;
            float m_flUnknownFloat3;
            float m_flUnknown;
            float m_flSpeed2D;
            float m_flUpVelocity;
            float m_flSpeedNormalized;
            float m_flFeetSpeedForwardsOrSideWays;
            float m_flFeetSpeedUnknownForwardOrSideways;
            float m_flTimeSinceStartedMoving;
            float m_flTimeSinceStoppedMoving;
            bool m_bOnGround;
            bool m_bInHitGroundAnimation;
            char pad7[2];
            float m_flTimeSinceInAir;
            float m_flLastOriginZ;
            float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
            float m_flStopToFullRunningFraction;
            float m_flMagicFraction;
            char pad8[60];
            float m_flWorldForce;
            char pad9[462];
            float m_flMaxYaw;
        };
        ]]
        local ent_ptr = get_entity_ptr(ent)
        if not ent_ptr then return nil end
        local animstate_ptr = ffi.cast("struct c_animstate**", ffi.cast("uintptr_t", ent_ptr) + 0x9960)
        if animstate_ptr == nil or animstate_ptr == ffi.NULL then return nil end
        local anim = animstate_ptr[0]
        if anim == nil or anim == ffi.NULL then return nil end

        local duck_amount = tonumber(anim.m_fDuckAmount) or 0
        local speed2d_norm = tonumber(anim.m_flFeetSpeedForwardsOrSideWays) or 0
        local stop_to_full = tonumber(anim.m_flStopToFullRunningFraction) or 0
        local max_yaw = tonumber(anim.m_flMaxYaw) or 0

        local yaw_modifier = ((-0.3 * stop_to_full) - 0.2) * math.max(0, math.min(speed2d_norm, 1)) + 1.0
        if duck_amount > 0 then
            yaw_modifier = yaw_modifier + (duck_amount * 0.5) * (0.5 - yaw_modifier)
        end

        local raw_delta = max_yaw * yaw_modifier
        local velocity = get_speed2d(ent) or 0
        local velocity_clamped = math.min(math.max(velocity, 0), 260)
        local move_scale = 1.0 - (velocity_clamped / 260)
        move_scale = 0.35 + (move_scale * 0.65)
        local delta = raw_delta * move_scale
        if velocity >= 250 then
            delta = math.min(delta, 28)
        end
        local flags = nil
        if ok_bit and entity and entity.get_prop then
            flags = entity.get_prop(ent, "m_fFlags") or 0
        end
        local on_ground = true
        if flags then on_ground = bit.band(flags, 1) == 1 end
        if not on_ground then delta = delta * 0.55 end
        if duck_amount > 0.9 then delta = delta * 0.9 end
        delta = math.max(0, math.min(delta, 60))
        return delta
    end)
    if ok_read then return result end
    return nil
end

local function safe_unset(ent)
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", false)
            plist.set(ent, "Force body yaw value", 0)
        end
    end)
end

local function now_time()
    local ok, t = pcall(function() return (globals and globals.curtime and globals.curtime()) or os.time() end)
    return ok and t or os.time()
end

local function normalize_angle(angle)
    if not angle or type(angle) ~= "number" then return 0 end
    while angle > 180 do angle = angle - 360 end
    while angle < -180 do angle = angle + 360 end
    return angle
end

local function round(n)
    return math.floor((n or 0) + 0.5)
end

function M.run(ent, features, state, label)
    
    state.count = (state.count or 0) + 1
    state.last_seen = now_time()
    if state.last_label and state.last_label ~= label then state.count = 1 end
    state.last_label = label

    
    if not label or label ~= "STATIC" then return end

    
    local required_count = 3
    if state.count < required_count then return end

    
    if features and features.shot_age and tonumber(features.shot_age) and features.shot_age <= 0.25 then
        return
    end

    
    local avg_speed = tonumber((features and features.avg_speed) or 0) or 0
    if features and features.movement and features.movement == true then return end
    if avg_speed >= 1.2 then return end

    
    local max_mag_low = 58
    local max_mag_high = 28
    local speed_cap = 250
    local t = math.min(math.max(avg_speed / speed_cap, 0), 1)
    local max_mag = max_mag_low + (max_mag_high - max_mag_low) * t

    
    local ok_est, est = pcall(function() return estimate_max_desync_ent(ent) end)
    if ok_est and est and type(est) == "number" then
        max_mag = math.min(max_mag, est)
    end

    
    local on_ground = true
    pcall(function()
        if ok_bit and entity and entity.get_prop then
            local flags = entity.get_prop(ent, "m_fFlags") or 0
            on_ground = bit.band(flags, 1) == 1
        end
    end)
    if not on_ground then max_mag = max_mag * 0.55 end

    
    local forced_val = 0

    
    local last_yaw = (features and features.last_yaw)
    local ref_yaw = features and (features.goal_feet_yaw or features.feet_yaw)
    local desync = nil
    if last_yaw and ref_yaw then
        desync = normalize_angle(last_yaw - ref_yaw)
    end

    
    if not desync then
        forced_val = 0
    else
        local absd = math.abs(desync)
        
        if absd <= 10 then
            forced_val = 0
        else
            
            if ok_est and est and type(est) == "number" and est >= 8 then
                local mag = math.min(math.floor(max_mag + 0.5), math.floor(est + 0.5))
                local desired = math.min(absd, mag)
                
                if desired >= 8 then
                    forced_val = (desync >= 0) and desired or -desired
                else
                    forced_val = 0
                end
            else
                
                forced_val = 0
            end
        end
    end

    
    forced_val = round(forced_val)
    if forced_val > 60 then forced_val = 60 end
    if forced_val < -60 then forced_val = -60 end

    
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", true)
            plist.set(ent, "Force body yaw value", forced_val)
            state.forced = true
            state.forced_value = forced_val
            state.cooldown = now_time() + 0.5

            if client and type(client.delay_call) == "function" then
                client.delay_call(0.6, function()
                    pcall(function()
                        local t = now_time()
                        if not state.cooldown or t > state.cooldown then
                            safe_unset(ent)
                            state.forced = nil
                            state.forced_value = nil
                        end
                    end)
                end)
            end
        end
    end)
end

return M
]=]
d958["require/features/misc/roll"] = [[local d486, d487= pcall(require, "require/abc/menu_setup")

local d488= {}
local d489= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local d490= {ui.reference(item[1], item[2], item[3])}
    d488[i] = d490
    for _, ref in ipairs(d490) do
        d489[ref] = true
    end
end

local function d491(d492)
end

    local d493= 0
    local d494= 1

    if d486 and d487 and d487.ui then
        if d487.ui.fakelag_settings_roll ~= nil then
            local d495, d496= pcall(ui.get, d487.ui.fakelag_settings_roll)
            if d495 and d496 ~= nil then d493 = d496 end
        end
        if d487.ui.fakelag_settings_side ~= nil then
            local d495, d496= pcall(ui.get, d487.ui.fakelag_settings_side)
            if d495 and d496 ~= nil then d494 = d496 end
        end
    end

    local d497= entity.get_local_player()
    local d498= 0
    if d497 then
        local d499= entity.get_prop(d497, 'm_vecVelocity')
        if d499 then
            local d500= d499.x or d499[1] or 0
            local d501= d499.y or d499[2] or 0
            local d502= d499.z or d499[3] or 0
            d498 = math.sqrt(d500*d500 + d501*d501 + d502*d502)
        end
    end

    if d498 > 3 then
        pcall(ui.set, d488[1] and d488[1][1], 0)
        return
    end

    if d494 == 3 then
        pcall(ui.set, d488[1] and d488[1][1], -d493)
    elseif d494 == 2 then
        local d503= (globals.tickcount() % 20) < 10
        pcall(ui.set, d488[1] and d488[1][1], (d503 and d493 or -d493))
    elseif d494 == 1 then
        pcall(ui.set, d488[1] and d488[1][1], d493)
    end

end

client.set_event_callback('setup_command', function(d492)

    d491(d492)

end)]]
d958["require/features/misc/spin_on_dead_enemies"] = [[local d489= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local d490= {ui.reference(item[1], item[2], item[3])}
    d489[i] = d490
end

local d491, d492, d493, d494= entity, globals, ui, client
local d495= require("require/abc/menu_setup")
local d496= (d494.random_int(1, 2) == 1) and 1 or -1

local function d497()
    local d498= {
        {2, 'Off'}, {3, 'Local view'}, {4, {'Spin', 45}}, {5, {'Off', 0}}, {6, {'Off', 0}},
    }
    local d496= (d494.random_int(1, 2) == 1) and 1 or -1
    for _, v in ipairs(d498) do
        local d499, d500= v[1], v[2]
        local d490= d489[d499]
        if not d490 then goto continue end
        if type(d500) ~= 'table' then
            pcall(d493.set, d490[1], d500)
        else
            if d490[1] then pcall(d493.set, d490[1], d500[1]) end
            if d490[2] then
                if type(d500[2]) == 'number' and d500[1] == 'Spin' then
                    pcall(d493.set, d490[2], d500[2] * d496)
                else
                    pcall(d493.set, d490[2], d500[2])
                end
            end
        end
        ::continue::
    end
end

local function d501()
    local d502= (d492.maxplayers and d492.maxplayers() or 64)
    local d503, d504, d505= d491.get_classname, d491.is_enemy, d491.is_alive
    if not (d503 and d504 and d505) then return 0 end
    local d506= 0
    for i=1,d502 do
        if d503(i) == 'CCSPlayer' and d504(i) and d505(i) then d506 = d506 + 1 end
    end
    return d506
end

local function d507()
    if not d493.get(d495.ui.misc_spindead) then return end
    if d501() == 0 then d497() end
end

local d508, d509= pcall(require, "require/abc/callbacks")
if d508 and d509 then
    d509.callback('run_command', d507, { alive_only = true, require_login = true })
end
]]
d958["require/features/misc/walkbot"] = [[local d492= require("require/abc/callbacks")
local d493= require("require/abc/menu_setup")

local d494= nil
local d495= 1
local d496= 0
local d497= 40
local d498= 30
local d499= 450
local d500= 200
local d501= 8
local d502= {150, 300}
local d503= nil
local d504= nil
local d505= nil
local d506= 0
local d507= 700
local d508= 3

local d509= {}
local d510= 3
local d511= 4
local d512= 0
local d513= nil
local d514= 0
local d515= 500
local d516= 1500
local d517= 30
local d518= {}
local d519= false

local d520= 500 
local d521= 0

local d522= {
    { name = "A", x = -445.0, y = -1997.7, z = -180.0 },
    { name = "B", x = -2032.4, y = 259.8, z = -160.0 },
    { name = "Mid", x = -350.3, y = -617.1, z = -269.2 },
}

local function d523(d524)
    if not d524 then return false end
    local d525, d526= pcall(ui.get, d524)
    if not d525 then return false end
    return d526
end

local function d527(d528)
    while d528 > 180 do d528 = d528 - 360 end
    while d528 < -180 do d528 = d528 + 360 end
    return d528
end

local function d529(d530,d531,d532,d533,d534,d535)
    local d536, d537, d538= d530-d533, d531-d534, d532-d535
    return math.sqrt(d536*d536 + d537*d537 + d538*d538)
end

local function d539(d540,d541,d542,d543,d544,d545,d546)
    local d525, d547, d548= pcall(function()
        return client.trace_line(d540, d541, d542, d543, d544, d545, d546)
    end)
    if not d525 then return nil end
    return d547, d548
end

local function d549(d540,d550,d551,d552)
    local d553= d552 + 1000
    local d554= d552 - 1000
    local d547= d539(d540, d550, d551, d553, d550, d551, d554)
    if not d547 then return d552 end
    if type(d547) ~= 'number' then return d552 end
    local d555= d553 + (d554 - d553) * d547
    return d555
end

local function d556(d540,d541,d542,d543,d544,d545,d546)
    local d547= d539(d540, d541, d542, d543, d544, d545, d546)
    if not d547 then return false end
    if d547 >= 1 then return true end
    return false
end

local function d557(d550,d551)
    return tostring(math.floor(d550/50))..":"..tostring(math.floor(d551/50))
end

local function d558(d550,d551)
    local d559= d557(d550, d551)
    d509[d559] = (d509[d559] or 0) + 1
    if d509[d559] >= d510 then
        d518[d559] = true
    end
    return d509[d559]
end

local function d560(d550,d551)
    local d559= d557(d550, d551)
    d509[d559] = nil
end

local function d561(d540)
    local d562, d563, d564= entity.get_origin(d540)
    if not d562 then return nil end
    for i=1,d498 do
        local d565= math.random()*math.pi*2
        local d566= 200 + math.random()*800
        local d544= d562 + math.cos(d565)*d566
        local d545= d563 + math.sin(d565)*d566
        local d546= d564
            local d547= d539(d540, d562, d563, d564 + 16, d544, d545, d546 + 16)
        if d547 and d547 >= 1 then
            local d567= d549(d540, d544, d545, d546)
            return { x = d544, y = d545, z = d567 }
        end
        if d547 and d547 < 1 then
            local d568= d562 + (d544-d562)*d547
            local d569= d563 + (d545-d563)*d547
            local d570= d564 + (d546-d564)*d547
            for _, r in ipairs(d502) do
                for s=0,d501-1 do
                    local d528= (s/d501) * math.pi * 2
                    local d571= d568 + math.cos(d528)*r
                    local d572= d569 + math.sin(d528)*r
                    local d573= d549(d540, d571, d572, d570)
                    local d574= d539(d540, d562, d563, d564+16, d571, d572, d573+16)
                    local d575= d539(d540, d571, d572, d573+16, d544, d545, d546+16)
                    if d574 and d574>=1 and d575 and d575>=1 then
                        local d567= d549(d540, d544, d545, d546)
                        return { x = d544, y = d545, z = d567 }
                    end
                end
            end
        end
    end
    return nil
end

local function d576(d577)
    local d578= {}
    while d577 do
        d578[#d578+1] = { x = d577.x, y = d577.y, z = d577.z }
        d577 = d577.parent
    end
    local d579= {}
    for i=#d578,1,-1 do d579[#d579+1] = d578[i] end
    return d579
end

local function d580(d540,d581)
    local d562, d563, d564= entity.get_origin(d540)
    if not d562 then return nil end
    local d582= { x = d562, y = d563, z = d564 }
    d582.z = d549(d540, d582.x, d582.y, d582.z)
    local d583= { { x = d582.x, y = d582.y, z = d582.z, parent = nil } }
    local d584= {}
    local function d585(d586)
        local d587= tostring(math.floor(d586.x/50))..":"..tostring(math.floor(d586.y/50))
        d584[d587] = true
    end
    local function d588(d586)
        local d587= tostring(math.floor(d586.x/50))..":"..tostring(math.floor(d586.y/50))
        if d518[d587] then return true end
        return d584[d587]
    end
    d585(d582)
    local d589= 0
    while #d583 > 0 and d589 < d500 do
        local d590= table.remove(d583, 1)
        d589 = d589 + 1
        local d547= d539(d540, d590.x, d590.y, d590.z+16, d581.x, d581.y, d581.z+16)
        if d547 and d547 >= 1 then
            local d591= d576(d590)
            d591[#d591+1] = { x = d581.x, y = d581.y, z = d581.z }
            return d591
        end
        if d547 and d547 < 1 then
            local d568= d590.x + (d581.x-d590.x)*d547
            local d569= d590.y + (d581.y-d590.y)*d547
            local d570= d590.z + (d581.z-d590.z)*d547
            for _, r in ipairs(d502) do
                for s=0,d501-1 do
                    local d528= (s/d501) * math.pi * 2
                    local d571= d568 + math.cos(d528)*r
                    local d572= d569 + math.sin(d528)*r
                    local d573= d549(d540, d571, d572, d570)
                    if not d588({x=d571,y=d572}) then
                        local d574= d539(d540, d590.x, d590.y, d590.z+16, d571, d572, d573+16)
                        if d574 and d574 >= 1 then
                            d585({x=d571,y=d572})
                            table.insert(d583, { x = d571, y = d572, z = d573, parent = d590 })
                        end
                    end
                end
            end
        end
    end
    return nil
end

local function d592(d593,d540,d544,d545,d546)
    local d562, d563, d564= entity.get_origin(d540)
    if not d562 then return end
    
    local d536, d537= d544 - d562, d545 - d563
    local d594= math.sqrt(d536*d536 + d537*d537)
    if d594 <= 0 then return end
    local d595, d596= d536 / d594, d537 / d594
    local d597= 64
    local d541= d562 + d595 * d597
    local d542= d563 + d596 * d597
    local d543= d564

    
    local d598, d599= client.camera_angles()
    local d565= math.deg(math.atan2(d537, d536))
    local d600= d527(d565 - d599)
    local d601= math.rad(d600)
    local d602= math.cos(d601) * d499
    local d603= -math.sin(d601) * d499

    
    local d604, d605, d606= client.eye_position()
    if not d604 then d604, d605, ez = d562, d563, d564 end
    if type(d604) == 'table' then d604, d605, ez = d604[1], d604[2], d604[3] end
    local d607= d562 + d595 * 24
    local d608= d563 + d596 * 24
    local d609= d564 + 16
    local d610= d539(d540, d604, d605, d606, d607, d608, d609)
    if d610 and d610 < 1 then
        
        if d519 then pcall(client.log, "move_towards: short forward blocked, sidestep") end
        pcall(function() d593.forwardmove = 0; d593.sidemove = -d499 end)
        local d611= d562 - d596 * d597
        local d612= d563 + d595 * d597
        local d613= d539(d540, d562, d563, d564 + 16, d611, d612, d543 + 16)
        if d613 and d613 >= 1 then return end
        pcall(function() d593.forwardmove = 0; d593.sidemove = d499 end)
        local d614= d562 + d596 * d597
        local d615= d563 - d595 * d597
        local d616= d539(d540, d562, d563, d564 + 16, d614, d615, d543 + 16)
        if d616 and d616 >= 1 then return end
        
        pcall(function() d558(d544, d545); d496 = client.timestamp() + 250 end)
        d494 = nil
        return
    end

    
    pcall(function()
        d593.forwardmove = d602
        d593.sidemove = d603
    end)

    if d519 then pcall(client.log, string.format("move_towards: fwd=%.1f side=%.1f yaw_diff=%.1f", d602, d603, d600)) end

    local d547= d539(d540, d562, d563, d564 + 16, d541, d542, d543 + 16)
    if d547 and d547 < 1 then
        
        if d519 then pcall(client.log, "move_towards: forward blocked, attempting sidestep") end
        
        pcall(function() d593.forwardmove = 0; d593.sidemove = -d499 end)
        local d611= d562 - d596 * d597
        local d612= d563 + d595 * d597
        local d613= d539(d540, d562, d563, d564 + 16, d611, d612, d543 + 16)
        if d613 and d613 >= 1 then return end
        
        pcall(function() d593.forwardmove = 0; d593.sidemove = d499 end)
        local d614= d562 + d596 * d597
        local d615= d563 - d595 * d597
        local d616= d539(d540, d562, d563, d564 + 16, d614, d615, d543 + 16)
        if d616 and d616 >= 1 then return end
        
        pcall(function()
            d558(d544, d545)
            d496 = client.timestamp() + 250
        end)
        d494 = nil
        return
    end
end

d492.register("setup_command", function(d593)
    local d525, d617= pcall(function()
        if not d523(d493.ui.misc_walkbot) then return end
        local d540= entity.get_local_player()
        if not d540 or not entity.is_alive(d540) then return end
        local d618= client.timestamp()
        if d618 < d496 then return end

        
        do
            local d619= client.timestamp()
            if d619 - d521 >= d520 then
                local d620, d621, d622= entity.get_origin(d540)
                if d620 then
                    pcall(function()
                        client.log(string.format("walkbot_coord: %.1f %.1f %.1f", d620, d621, d622))
                    end)
                    d521 = d619
                end
            end
        end
        if client.key_state(87) or client.key_state(65) or client.key_state(83) or client.key_state(68) or client.key_state(32) or client.key_state(16) or client.key_state(17) then
            d496 = d618 + 500
            return
        end
        
        do
            local d623= entity.get_players(true) or {}
            for i=1,#d623 do
                local d624= d623[i]
                local d620, d621, d622= entity.get_origin(d624)
                if d620 then
                    local d625= pcall(function() return client.visible(d620, d621, d622) end)
                    if d625 and client.visible(d620, d621, d622) then
                        pcall(function()
                            local d626= d593.buttons or 0
                            d593.buttons = bit.bor(d626, 4) 
                        end)
                        break
                    end
                end
            end
        end
        
        local d562, d563, d564= entity.get_origin(d540)
        if d562 then
            local d623= entity.get_players(true) or {}
            if #d623 > 0 then
                if not d503 or not entity.is_alive(d503) or entity.is_dormant(d503) then
                    
                    local d627= {}
                    for i=1,#d623 do
                        local d624= d623[i]
                        local d620, d621, d622= entity.get_origin(d624)
                        if d620 then
                            local d628= d529(d562, d563, d564, d620, d621, d622)
                            d627[#d627+1] = { ent = d624, dist = d628 }
                        end
                    end
                    table.sort(d627, function(d528,d626) return d528.dist < d626.dist end)
                    if #d627 > 0 then
                                d503 = d627[1].ent  
                        d494 = nil
                        d495 = 1
                    end
                end
            else
                d503 = nil
            end
        end

        
        if d503 and entity.is_alive(d503) and not entity.is_dormant(d503) then
            local d544, d545, d546= entity.get_origin(d503)
            if d544 then
                local d567= d549(d540, d544, d545, d546)
                d504 = { x = d544, y = d545, z = d567 }
            else
                d503 = nil
                d504 = nil
            end
        else
            d503 = nil
            d504 = nil
        end

        
        do
            local d618= client.timestamp()
            if d562 then
                if not d513 then
                    d513 = { x = d562, y = d563, z = d564 }
                    d514 = d618
                else
                    if d618 - d514 >= d515 then
                        local d629= d529(d513.x, d513.y, d513.z, d562, d563, d564)
                        if d629 >= d517 then
                            
                            d512 = 0
                            d513 = { x = d562, y = d563, z = d564 }
                            d514 = d618
                        else
                            
                            if d618 - d514 >= d516 then
                                d512 = d512 + 1
                                d494 = nil
                                d496 = d618 + 300
                                d513 = { x = d562, y = d563, z = d564 }
                                d514 = d618
                                if d512 >= d511 then
                                    
                                    d503 = nil
                                    d504 = nil
                                    d512 = 0
                                end
                            end
                        end
                    end
                end
            end
        end

        if d504 then
            local d618= client.timestamp()
            local d630= (not d494) or (d618 > d506)
            if not d505 then d630 = true end
            if d505 and d504 and d529(d505.x, d505.y, d505.z, d504.x, d504.y, d504.z) > 100 then
                d630 = true
            end
            if d630 then
                local d624= d580(d540, d504)
                if d624 then
                    d494 = d624
                    d495 = 1
                    d506 = client.timestamp() + d507
                    d505 = { x = d504.x, y = d504.y, z = d504.z }
                else
                    
                    d503 = nil
                    d504 = nil
                    d494 = nil
                end
            end
        else
            if not d494 then
                local d631= d561(d540)
                
                if not d631 and #d522 > 0 then
                    local d632= d522[ math.random(1, #d522) ]
                    if d632 then d631 = { x = d632.x, y = d632.y, z = d632.z } end
                end
                if d631 then
                    local d624= d580(d540, d631)
                    if d624 then
                        d494 = d624
                        d495 = 1
                    else
                        
                        d494 = nil
                    end
                end
            end
        end
        if not d494 then return end
        local d562, d563, d564= entity.get_origin(d540)
        if not d562 then return end
        local d633= d494[d495+1] or d494[#d494]
        if not d633 then d494 = nil return end
        local d628= d529(d562, d563, d564, d633.x, d633.y, d633.z)
        if d628 <= d497 then
            d495 = d495 + 1
            
            d560(d633.x, d633.y)
            if d495 >= #d494 then d494 = nil return end
            return
        end
        do
            local d634= false
            if d503 and d504 then
                local d544, d545, d546= d504.x, d504.y, d504.z
                local d566= d529(d562, d563, d564, d544, d545, d546)
                if d566 > 1000 then
                    
                end
            end
            if not d634 then
                d592(d593, d540, d633.x, d633.y, d633.z)
            end
        end
    end)
    if not d525 then pcall(client.error_log, "walkbot error: "..tostring(d617)) end
end)

d492.register("paint", function()
    if not d523(d493.ui.misc_walkbot) then return end
    if not d494 or #d494 == 0 then return end
    local d540= entity.get_local_player()
    if not d540 then return end
    local d562, d563, d564= entity.get_origin(d540)
    if not d562 then return end
    local d635, d636, d637= d562, d563, d564
    d637 = d549(d540, d635, d636, d637)
    local d620, d621= renderer.world_to_screen(d635, d636, d637)
    for i=d495, #d494 do
        local d579= d494[i]
        if not d579 then break end
        local d638= d549(d540, d579.x, d579.y, d579.z)
        local d541, d542= renderer.world_to_screen(d579.x, d579.y, d638)
        if d541 and d542 and d620 and d621 then
            renderer.line(d620, d621, d541, d542, 255, 180, 0, 200)
            renderer.rectangle(d541-3, d542-3, 6, 6, 255, 80, 0, 200)
        end
        d620, py = d541, d542
    end
end)

return true
]]
d958["require/features/paint/aimbot_logs"] = [[local d495= require("require/abc/menu_setup")
local d496= require("require/abc/screen_logger")


local d497= nil
pcall(function() d497 = require('require/abc/callbacks') end)
if not d497 then error("callbacks manager required: require/abc/callbacks") end
local d498= {}
local d499= {}

local function d500()
	local d501= d495.ui.paint_aimbot_logs
	if not d501 then return false end
	local d502= ui.get(d501)
	if type(d502) == "string" then
		return d502 ~= "off"
	end
	return false
end

local function d503()
	local d501= d495.ui.paint_aimbot_logs
	if not d501 then return "gamesense" end
	local d502= ui.get(d501)
	if type(d502) == "table" then
		for _, v in ipairs(d502) do
			if v == "gamesense beta" then return "gamesense beta" end
			if v == "sodium" then return "sodium" end
			if v == "gamesense" then return "gamesense" end
		end
	elseif type(d502) == "string" then
		return d502
	end
	return "gamesense"
end

local d504= require("require/help/enemies")
local d505= require("require/abc/push_logger")
local d506= require("require/help/safe")

local d507, d508= pcall(require, "require/features/misc/collect")


local function d509(d510)
	if not d510 or d510 == 0 then return 0 end
	
	if d507 and d508 then
		local d511, d512= pcall(function()
			return d508.get_goal_feet_yaw(d510) or d508.get_feet_yaw(d510) or d508.get_lower_body_yaw(d510)
		end)
		if d511 and d512 and d512 ~= 0 then return d512 end
	end
	
	local d513, d514, d515, d516= pcall(function() return entity.get_prop(d510, "m_angAbsRotation") end)
	if d513 and d514 then
		if type(d514) == "table" then
			return d514[2] or 0
		else
			return d515 or 0
		end
	end
	
	local d517, d518= pcall(function() return entity.get_prop(d510, "m_flLowerBodyYawTarget") end)
	if d517 and d518 then return d518 end
	return 0
end


local function d519(d510)
	local d511, d520= pcall(function() return _G.player_labels end)
	if not d511 or type(d520) ~= "table" then return nil end
	local d521, d522= pcall(function() return d520[d510] end)
	if not d521 then return nil end
	return d522
end


local function d523()
	local d511, d524, d525, d526= pcall(function() return client.camera_angles() end)
	if not d511 then return nil, nil, nil end
	return d524 or 0, d525 or 0, d526 or 0
end


local function d527(d510)
	if not d510 or d510 == 0 then return nil, nil, nil end
	local d511, d528, d529, d530= pcall(function() return entity.get_prop(d510, "m_angAbsRotation") end)
	if not d511 then return nil, nil, nil end
	
	if type(d528) == "table" then
		return d528[1] or 0, d528[2] or 0, d528[3] or 0
	else
		return d528 or 0, d529 or 0, d530 or 0
	end
end

local function d531(d532)
	local d501= d495.ui.paint_logger
	if not d501 then return false end
	local d502= d506.safe_get(d501)
	if type(d502) == 'table' then
		for _, v in ipairs(d502) do
			if v == d532 then return true end
		end
		return false
	elseif type(d502) == 'string' then
		return d502 == d532
	end
	return false
end

local function d533(d534,d535,d525,d524) return string.format("\a%02x%02x%02x%02x", d534 or 255, d535 or 255, d525 or 255, d524 or 255) end
local function d536(d537,d534,d535,d525,d524)
	if not d537 or d537 == "" then return d537 end
	local d538= d533(d534,d535,d525,d524)
	local d539= d533(255,255,255,255)
	local d540= "([-+]?%d+%.?%d*%%?)"
	local d511, d541= pcall(function()
		return (d537:gsub(d540, function(d542)
			return d538 .. d542 .. d539
		end))
	end)
	if d511 and d541 then return d541 end
	return d537
end

local function d543(d537)
	if not d537 then return "" end
	return d537:gsub("([%^%$%(%)%%.%[%]%*%+%-%?])", "%%%1")
end

local function d544(d545,d546,d534,d535,d525,d524)
	if not d545 or d545 == "" then return d545 end
	if not d546 or d546 == "" then
		return d536(d545, d534,d535,d525,d524)
	end
	
	local d547, d548= d545:find(d546, 1, true)
	if not d547 then
		
		return d536(d545, d534,d535,d525,d524)
	end
	local d549= d545:sub(1, d547 - 1)
	local d550= d545:sub(d547, d548)
	local d551= d545:sub(d548 + 1)
	local d552= d536(d549, d534,d535,d525,d524)
	local d553= d536(d551, d534,d535,d525,d524)
	local d538= d533(d534,d535,d525,d524)
	local d539= d533(255,255,255,255)
	local d554= d538 .. d550 .. d539
	return (d552 or "") .. d554 .. (d553 or "")
end
local function d555(d556,d557,d558,d559)
	local d560= d556.target_name or "?"
	local d561= d556.hitgroup_name or "?"
	local d562= (d559 and d559.damage) or d556.damage or 0
	local d563= d556.damage or d562
	local d564= d562 - d563
	local d565
	if d562 == d563 then
		d565 = string.format("%d dmg", d562)
	elseif d564 < 0 then
		d565 = string.format("%d(-%d) dmg", d562, math.abs(d564))
	else
		d565 = string.format("%d(+%d) dmg", d562, d564)
	end
	local d566= (d557 == "gamesense" and d559 and d559.health) or d556.health or 0
	local d546= d559 and d559.reason or ""

	local d567= d556.backtrack_ticks or (d559 and d559.backtrack_ticks) or 0
	if d567 == 0 then
		local d568, d569= pcall(function() return globals.tickcount() end)
		if d568 and d556.tick then
			d567 = math.max(0, d569 - (d556.tick or d569))
		end
	end
	local d570= d556.backtrack or (d559 and d559.backtrack) or 0
	if d570 == 0 and d567 and d567 > 0 then
		local d571, d572= pcall(function() return globals.tickinterval() end)
		local d573= (d571 and d572) or 0
		d570 = math.floor(d567 * d573 * 1000)
	end
	if d570 == 0 and d556.time then
		local d574, d575= pcall(function() return globals.realtime() end)
		if d574 and d575 and d556.time then
			d570 = math.floor((d575 - d556.time) * 1000)
		end
	end
	local d576= d559 and d559.hitchance or d556.hitchance or "hehe"
	local d577= d556.safepoint or false
	local d578= d556.tick or 0
	local d579= d556.time or globals.realtime()
	local d580= d556.move or 0
	local d581= d556.t or 0
	local d582= (d559 and d559.boneyaw) or d509(d556.target) or 0
	local d583= (d559 and d559.resolver) or d519(d556.target) or "?"
	d583 = tostring(d583):lower()
	local d584, d585= d523()
	local d586, d587= d527(d556.target)
	local d588= d556.id or 0
	if d557 == "gamesense beta" then
		if d558 == "hit" then
			return string.format("[+] Hit %s's %s for %s (%d%%) bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				d560, d561, d565, d576, d570, d567,
				d585 or 0, d584 or 0, d587 or 0, d586 or 0, d580, d581, d582)
		else
			return string.format("[-] Missed %s's %s for %s (%d%%) due to %s bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				d560, d561, d565, d576, d546, d570, d567,
				d585 or 0, d584 or 0, d587 or 0, d586 or 0, d580, d581, d582)
		end
	elseif d557 == "gamesense" then
		if d558 == "hit" then
			return string.format("[gamesense] Hit %s's %s for %s (%d%%) (%dhp remaining)",
				d560, d561, d565, d576, d566)
		else
			return string.format("[gamesense] Missed %s's %s for %s (%d%%) reason=%s",
				d560, d561, d565, d576, d546)
		end
	elseif d557 == "sodium" then
		if d558 == "hit" then
			return string.format("hit %s's %s for %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				d560, d561, d565, d576, d570, d583, d582)
		else
			return string.format("missed %s's %s due to %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				d560, d561, d546, d576, d570, d583, d582)
		end
	else
		if d558 == "hit" then
			return string.format("a",
				d560, d561, dmg, d576, d580, d581, d582)
		else
			return string.format("b",
				d560, d561, dmg, d576, d546, d580, d581, d582)
		end
	end
end

d497.register('aim_fire', function(d589)

	if not d500() then return end
	
	d499[d589.id] = {
		id = d589.id,
		target = d589.target,
		target_name = entity.get_player_name(d589.target or 0),
		hitgroup = d589.hitgroup,
		hitgroup_name = d589.hitgroup and ({"head","chest","stomach","left arm","right arm","left leg","right leg"})[d589.hitgroup] or "?",
		damage = d589.damage,
		health = d589.health,
		backtrack = (d589.backtrack or 0) * globals.tickinterval() * 1000,
		backtrack_ticks = d589.backtrack or 0,
		hitchance = d589.hit_chance or 0,
		safepoint = d589.safepoint,
		tick = globals.tickcount(),
		time = globals.realtime(),
		move = d589.move or 0,
		t = d589.t or 0,
		boneyaw = d589.boneyaw or d509(d589.target) or 0,
	}
end, { require_login = true, alive_only = true })

d497.register('aim_hit', function(d589)

	if not d500() then return end
	local d590= d499[d589.id]
	if not d590 then return end
	local d557= d503()
	local d591= entity.get_prop(d589.target, "m_iHealth") or 0
	local d582= d590.boneyaw or d509(d590.target)
	local d592= d519(d590.target)
	local d593= d555(d590, d557, "hit", {
		damage=d589.damage,
		health=d591,
		backtrack=d590.backtrack,
		backtrack_ticks=d590.backtrack_ticks,
		boneyaw=d582,
		resolver=d592
	})
	if d557 == "gamesense beta" then
		
		client.color_log(165, 202, 42, d593)
		d496(d593, 4, 165, 202, 42, 255)
	elseif d557 == "sodium" then
		local d594= d590.damage or 0
		local d595= d589.damage or d594
		local d596= d595 - d594
		if d596 == 0 then
			client.color_log(165, 202, 42, d593)
			local d597= d536(d593, 165, 202, 42, 255)
			d496(d597, 4)
		else
			client.color_log(255, 204, 51, d593)

			local d598= string.format("(%+d)", d596)
			local d599= d543(d598)
			local d549, d550, d551= d593:match("^(.-)(" .. d599 .. ")(.*)$")
			if not d549 then
				local d597= d536(d593, 165, 202, 42, 255)
				d496(d597, 4)
			else
				local d600= d536(d549, 165, 202, 42, 255)
				local d601= d536(d551, 165, 202, 42, 255)
				local d602, d603, d604
				if d596 > 0 then
					d602, d603, db = 255, 204, 51
				else
					d602, d603, db = 217, 100, 100 
				end
				local d538= d533(d602, d603, d604, 255)
				local d539= d533(255, 255, 255, 255)
				local d605= d550:sub(2, -2) or d550
				local d606= "(" .. d538 .. d605 .. d539 .. ")"
				local d597= (d600 or "") .. d606 .. (d601 or "")
				d496(d597, 4)
			end
		end
	else
		client.log(d593)
		d496(d593, 4, 255, 255, 255, 255)
	end

	
	if d531('aimbot') then
		local d560= d590.target_name or "?"
		local d607= d590.hitgroup_name or "?"
		local d608= d589.damage or 0
		local d609= d590.hitchance or 0
		local d610= string.format("Hit %s's %s for %d(%d%%)", d560, d607, d608, d609)
		d505(d610, 4, 255, 255, 255, 255)
	end

	d499[d589.id] = nil
end, { require_login = true, alive_only = true })

d497.register('aim_miss', function(d589)

	if not d500() then return end
	local d590= d499[d589.id]
	if not d590 then return end
	local d557= d503()
	local d582= d590.boneyaw or d509(d590.target)
	local d592= d519(d590.target)
	local d593= d555(d590, d557, "miss", {reason=d589.reason or "?", boneyaw=d582, resolver=d592})
		if d557 == "gamesense beta" then
			client.color_log(217, 100, 100, d593)
			d496(d593, 4, 217, 100, 100, 255)
		elseif d557 == "sodium" then
			
			local d611= d589.reason or "?"
			local d597= d544(d593, d611, 217, 100, 100, 255)
			d496(d597, 4)
			client.color_log(217, 100, 100, d593)
		else
			d496(d593, 4, 255, 255, 255, 255)
			client.log(d593)
		end

	if d531('aimbot') then
		local d560= d590.target_name or "?"
		local d607= d590.hitgroup_name or "?"
		local d608= d590.damage or 0
		local d609= d590.hitchance or 0
		local d546= d589.reason or "?"
		local d610= string.format("Missed %s's %s for %d(%d%%) due to %s", d560, d607, d608, d609, d546)
		d505(d610, 4, 255, 255, 255, 255)
	end

	d499[d589.id] = nil
end, { require_login = true, alive_only = true })]]
d958["require/features/paint/animations"] = [[


local d498= nil
pcall(function() d498 = require('require/help/safe') end)
local d499= nil
pcall(function() d499 = require('require/abc/menu_setup') end)

local d500= nil
pcall(function() d500 = require('require/abc/callbacks') end)
if not d500 then error("callbacks manager required: require/abc/callbacks") end
local d501= require("gamesense/entity") or error("You're missing a required module: gamesense/entity")


local function d502()
    local d503= entity.get_local_player()
    if not d503 then return nil, nil end
    local d504, d505= pcall(function() return d501.new(d503) end)
    if not d504 then return d503, nil end
    return d503, d505
end




local d506= {
    STRAFE_YAW = 0,
    STAND = 1,
    LEAN_YAW = 2,
    SPEED = 3,
    LADDER_YAW = 4,
    LADDER_SPEED = 5,
    JUMP_FALL = 6,
    MOVE_YAW = 7,
    MOVE_BLEND_CROUCH = 8,
    MOVE_BLEND_WALK = 9,
    MOVE_BLEND_RUN = 10,
    BODY_YAW = 11,
    BODY_PITCH = 12,
    AIM_BLEND_STAND_IDLE = 13,
    AIM_BLEND_STAND_WALK = 14,
    AIM_BLEND_STAND_RUN = 14,
    AIM_BLEND_CROUCH_IDLE = 16,
    AIM_BLEND_CROUCH_WALK = 17,
    DEATH_YAW = 18
}

local function d507(d508)
    if not d508 then return 0 end
    local d509, d510, d511= entity.get_prop(d508, 'm_vecVelocity')
    if not d509 or not d510 then
        local d512= d509
        if type(d512) == 'table' then
            d509 = d512.x or d512[1] or 0
            d510 = d512.y or d512[2] or 0
        else
            return 0
        end
    end
    return math.sqrt((d509 or 0) * (d509 or 0) + (d510 or 0) * (d510 or 0))
end

local d513= {}
local d514= {}
for i, item in ipairs({
    { 'AA', 'Other', 'Leg movement' },

}) do
    local d515= {ui.reference(item[1], item[2], item[3])}
    d513[i] = d515
    for _, ref in ipairs(d515) do
        d514[ref] = true
    end
end






local d516= require("gamesense/antiaim_funcs")


local function d517()
    local d503= entity.get_local_player()
    if not d503 then return end
    entity.set_prop(d503, "m_flPoseParameter", 1, d506.JUMP_FALL)
end

local function d518()

    if d516.get_tickbase_shifting() > 0 then
        return
    end
    
    value = 0.5
    local d503= entity.get_local_player()
    if not d503 then return end
    local d519= globals.tickcount()
    local d520= math.floor(d519 / 2) % 2
    local d521= (d520 == 0) and -0.1 or 0.9
    entity.set_prop(d503, "m_flPoseParameter", math.random(0, 10) / value, d506.SPEED)
    entity.set_prop(d503, "m_flPoseParameter", math.random(0, 10) / 10, d506.MOVE_YAW)
    entity.set_prop(d503, "m_flPoseParameter", math.random(0, 10) / 10, d506.JUMP_FALL)
end



local function d522()
    local d503, d523= d502()
    if not d503 or not d523 then return end
    local d524= d523:get_anim_state()
    local d525= d523:get_anim_overlay(12)
    entity.set_prop(d503, "m_flPoseParameter", client.random_float(0, 1), 0)
    d525.weight = client.random_float(0, 1)
    ui.set(d513[1][1], "Always slide")
end

local function d526()
    local d503, d523= d502()
    if not d503 or not d523 then return end
    local d525= d523:get_anim_overlay(12)
    d525.weight = math.random(0,10) / 10
end


local function d527()
    local d503, d523= d502()
    if not d503 or not d523 then return end
    local d524= d523:get_anim_state()
    local d525= d523:get_anim_overlay(12)
    if d525 then d525.weight = 0.999 end
end

local function d528()
    local d503, d523= d502()
    if not d503 or not d523 then return end
    local d524= d523:get_anim_state()
    if d524 and d524.hit_in_ground_animation then
        entity.set_prop(d503, "m_flPoseParameter", 0.5, d506.BODY_PITCH)
    end
end

local function d529()
    local d503, d523= d502()
    if not d503 or not d523 then return end
    local d530= d523:get_anim_overlay(6)
    entity.set_prop(d503, "m_flPoseParameter", 0, d506.MOVE_YAW)
    if d530 then d530.weight = 1 end
end

local function d531()
    local d503, d523= d502()
    if not d503 or not d523 then return end
    local d532= d523:get_anim_overlay(12)
    local d533= d523:get_anim_overlay(6)
    if d532 then d532.weight = 0 end
    if d533 then d533.weight = 1 end
end

local function d534()
    local d503= entity.get_local_player()
    if not d503 then return end
    ui.set(d513[1][1], math.random(1,2) == 1 and "Always slide" or "Never slide")
    entity.set_prop(d503, "m_flPoseParameter", 8, 0)
end


local function d535()
    local d503, d523= d502()
    if not d503 or not d523 then return end
    local d536= d523:get_anim_overlay(9)
    if d536 then
        d536.weight = 1
        d536.sequence = 224
    end
end

local function d537()
    local d503, d523= d502()
    if not d503 or not d523 then return end
    local d538= d523:get_anim_overlay(0)
    if d538 then d538.sequence = 11 end
end

local function d539()

    local d503= d502()
    if not d503 then return end
    entity.set_prop(d503, 'm_flPoseParameter', 0, d506.BODY_PITCH)
    entity.set_prop(d503, 'm_flPoseParameter', math.random(-1, 1), d506.BODY_YAW)

end




d500.register('pre_render', function()
    local d503= entity.get_local_player()
    if not d503 then return end
    local d540= d507(d503)


    local d541= nil
    if d499 and d499.ui and d499.ui.paint_animations then
        if d498 and d498.safe_get then
            d541 = d498.safe_get(d499.ui.paint_animations)
        else
            local d504, d542= pcall(function() return ui.get(d499.ui.paint_animations) end)
            if d504 then d541 = d542 end
        end
    end

    local d543= {}
    if type(d541) == 'table' then
        for _, v in ipairs(d541) do d543[v] = true end
    end

    if d543['kingaru'] and d540 > 3 then d518() end
    if d543['body lean'] and d540 > 3 then d527() end
    if d543['static legs'] and d540 > 3 then d517() end
    if d543['moonwalk'] and d540 > 3 then d529() end
    if d543['allah'] and d540 > 3 then d531() end
    if d543['no pitch on land'] and d540 > 3 then d528() end
    if d543['reversed legs'] and d540 > 3 then d534() end
    if d543['earthquake'] then d526() end
    if d543['t-pose'] then d537() end
    if d543['blind'] then d535() end
    if d543['pitch up'] then d539() end
    if d543['gamesense legs'] then d522() end
end, { require_login = true, alive_only = true })

d500.register('setup_command', function(d544)

    local d503= entity.get_local_player()
    if not d503 then return end
    local d540= d507(d503)
    if d540 < 3 then return end

    local d541= nil
    if d499 and d499.ui and d499.ui.paint_animations then
        if d498 and d498.safe_get then
            d541 = d498.safe_get(d499.ui.paint_animations)
        else
            local d504, d542= pcall(function() return ui.get(d499.ui.paint_animations) end)
            if d504 then d541 = d542 end
        end
    end

    local d543= {}
    if type(d541) == 'table' then
        for _, v in ipairs(d541) do d543[v] = true end
    end

    

end, { require_login = true, alive_only = true })]]
d958["require/features/paint/aspect_ratio"] = [[
local d501= require("require/abc/menu_setup")
local d502= require("require/help/time")
local d503= require("require/help/safe")
local d504= require("ffi")
local d505= require("require/brain/dll")
local d506= nil
pcall(function() d506 = require('require/abc/callbacks') end)

if not (d505 and d505.aspect_update) then
    error("sodiumdll aspect_update export missing")
end

local d507= d504.new("struct AspectState[1]")
local d508= d504.new("double[1]")
local d509= d504.new("int[1]")
local d510= d505.aspect_update

local function d511()
    if cvar.r_aspectratio and cvar.r_aspectratio.get_float then
        return cvar.r_aspectratio:get_float()
    end
    return nil
end

local function d512(d513)
    if cvar.r_aspectratio and cvar.r_aspectratio.set_float then
        cvar.r_aspectratio:set_float(d513)
        return true
    elseif client and client.exec then
        client.exec("r_aspectratio " .. tostring(d513))
        return true
    end
    return false
end

d506.register('paint', function()
    if not ui.is_menu_open() then return end
    local d514= d501.ui.paint_aspect_ratio
    if not d514 then return end
    local d515= d503.safe_get(d514)
    if type(d515) ~= 'number' then return end
    d510(d507, d515, d511() or 0, d502.realtime(), d508, d509)
    if d509[0] ~= 0 then
        d512(d508[0])
    end
end, { require_login = true })

client.set_event_callback('shutdown', function()
    d507[0].initialized = 0
    d507[0].original = 0
    d507[0].last = 0
    d507[0].last_update = 0
end)]]
d958["require/features/paint/bomb_esp"] = [[local d504= nil
local d505= {}
local d506= nil
local d507= 500
local d508= 1000

local d509= 1.0
local d510= true
local d511= 0.25 
local d512= 0
local d513= 2

local d514= nil
pcall(function() d514 = require('require/abc/callbacks') end)
if not d514 then error("callbacks manager required: require/abc/callbacks") end

local function d515()
    d504 = nil
end

local function d516(d517)
    if not d517 then return 650, 2275 end
    local d518= tostring(d517):lower()
    if d518:find('de_dust2') then return 500, 1750 end
    if d518:find('de_ancient') then return 650, 2275 end
    if d518:find('de_anubis') then return 450, 1575 end
    if d518:find('de_inferno') then return 620, 2170 end
    if d518:find('de_mirage') then return 650, 2275 end
    if d518:find('de_nuke') then return 650, 2275 end
    if d518:find('de_overpass') then return 650, 2275 end
    if d518:find('de_vertigo') then return 500, 1750 end
    return 650, 2275
end

local function d519(d520,d521)
    d521 = tonumber(d521) or 0
    if d521 > 0 then
        local d522= 0.5
        local d523= 0.5
        local d524= d520 * d522
        local d525= (d520 - d524) * d523
        if d525 > tonumber(d521) then
            d525 = tonumber(d521) * (1.0 / d523)
            d524 = d520 - d525
        end
        d520 = d524
    end
    return d520
end

local function d526(d527,d528,d529,d530,d531,d532,d521,d533)
    if not d527 or not d528 or not d529 or not d530 or not d531 or not d532 then return 0 end
    local d534, d535= d516(d533)
    local d536= d535 / 3.0
    local d537= d527 - d530
    local d538= d528 - d531
    local d539= d529 - d532
    local d540= math.sqrt(d537*d537 + d538*d538 + d539*d539)
    local d541= math.exp( - (d540 * d540) / (2 * d536 * d536) )
    local d520= d534 * d541
    local d542= d519(d520, d521)
    return math.floor(d542 + 0.0)
end

local function d543(d544)
    if not d544 then return "?" end
    if d544 == 454 then return "A" end
    if d544 == 455 then return "B" end
    if d544 == 0 then return "A" end
    if d544 == 1 then return "B" end
    if type(d544) == "string" then
        local d545= d544:upper()
        if d545 == "A" or d545 == "B" then return d545 end
    end
    return tostring(d544)
end

d514.register('bomb_planted', function(d546)
    local d547= d546 and d546.site

    local d548= entity.get_all("CPlantedC4") or {}
    local d549= nil
    local d550= nil

    for i = 1, #d548 do
        local d544= d548[i]
        local d551= entity.get_prop(d544, "m_flC4Blow")
        if d551 and d551 > 0 then
            d549 = d551
            d550 = d544
            break
        end
    end

    if not d549 then
        local d552= 40
        if cvar and cvar.mp_c4timer then
            local d553, d554= pcall(function()
                if type(cvar.mp_c4timer.get_float) == "function" then
                    return cvar.mp_c4timer:get_float()
                elseif type(cvar.mp_c4timer.get_int) == "function" then
                    return cvar.mp_c4timer:get_int()
                else
                    return tonumber(cvar.mp_c4timer:get_string())
                end
            end)
            if d553 and d554 and tonumber(d554) then
                d552 = tonumber(d554)
            end
        end
        d549 = globals.curtime() + (d552 or 40)
    end

    d504 = {
        site = d547,
        blow_time = d549,
        entindex = d550,
        planted_at = globals.curtime()
    }
end, { require_login = true, alive_only = true })

d514.register('bomb_defused', d515, { require_login = true, alive_only = true })
d514.register('bomb_exploded', function(d546)
    
    local d555= d504 ~= nil
    local d556= globals.curtime()
    
    local d557= nil
    local d558= entity.get_local_player()
    if d555 and d558 then
        local function d559()
            
            local d560= nil
            if d504 and d504.entindex then
                local d553, d561, d562, d536= pcall(function() return entity.get_prop(d504.entindex, "m_vecOrigin") end)
                if d553 then
                    if type(d561) == "table" then
                        d560 = d561
                    elseif d561 ~= nil and d562 ~= nil and d536 ~= nil then
                        d560 = { d561, d562, d536 }
                    end
                end
            end
            if not d560 then
                local d548= entity.get_all("CPlantedC4") or {}
                for i = 1, #d548 do
                    local d544= d548[i]
                    local d553, d561, d562, d536= pcall(function() return entity.get_prop(d544, "m_vecOrigin") end)
                    if d553 then
                        if type(d561) == "table" then
                            d560 = d561
                            break
                        elseif d561 ~= nil and d562 ~= nil and d536 ~= nil then
                            d560 = { d561, d562, d536 }
                            break
                        end
                    end
                end
            end
            if not d560 then return nil end
            local d553, d563, d564, d565= pcall(function() return client.eye_position() end)
            local d527, d528, d529
            
            local d566, d567, d568, d569= pcall(function() return entity.get_origin(d558) end)
            if d566 then
                if type(d567) == "table" then
                    if #d567 >= 3 then d527, d528, pz = d567[1], d567[2], d567[3] end
                elseif d567 ~= nil and d568 ~= nil and d569 ~= nil then
                    d527, d528, pz = d567, d568, d569
                end
            end
            
            if (not d527 or not d528 or not d529) and d553 and d563 ~= nil and d564 ~= nil and d565 ~= nil then
                d527, d528, pz = d563, d564, d565
            end
            if not d527 or not d560 or #d560 < 3 then return nil end
            local d530, d531, d532= d560[1], d560[2], d560[3]
            
            local d570, d521= pcall(function() return entity.get_prop(d558, "m_ArmorValue") end)
            d521 = tonumber(d521) or 0
            local d533= nil
            local d571, d572= pcall(function()
                if type(client.mapname) == 'function' then return client.mapname() end
                if cvar and cvar.mapname then return cvar.mapname:get_string() end
                if cvar and cvar.map then return cvar.map:get_string() end
                return nil
            end)
            if d571 then d533 = d572 end
            local d573= d526(d527, d528, d529, d530, d531, d532, d521, d533)
            local d574= math.floor((d573 * (d509 or 1.0)) + 0.5)
            return d573, d574, math.sqrt((d527-d530)^2 + (d528-d531)^2 + (d529-d532)^2)
        end
        local d575, d576, d577= d559()
        d557 = d576
    end

    
    d515()

    
    if d510 and d557 and d557 > 0 then
        local d578= 0.15
        client.delay_call(d578, function()
            local d579= globals.curtime()
            if d579 - d512 < d513 then return end
            local d580= entity.get_local_player()
            if not d580 then return end
            local d553, d581= pcall(function() return entity.get_prop(d580, "m_iHealth") end)
            d581 = tonumber(d581)
            local d582= d506
            if not d582 or not d581 then return end
            local d525= d582 - d581
            if d525 <= 0 then return end

            
            local d583= (d557 and d557 > 0) and d557 or 1
            local d584= d525 / d583
            if d584 <= 0 then return end

            
            local d585= (d509 or 1.0) * (1 + (d584 - 1) * d511)
            if d585 < 0.05 then d585 = 0.05 end
            if d585 > 10 then d585 = 10 end
            local d586= d509
            d509 = d585
            d512 = globals.curtime()
            
            pcall(function()
                client.log("[bomb_esp] auto-tuned scale %.3f -> %.3f (ratio=%.3f, predicted=%d, actual=%d)", d586, d509, d584, d557 or 0, d525)
            end)
        end)
    end
end, { require_login = true, alive_only = true })
d514.register('round_start', d515, { require_login = true, alive_only = true })
d514.register('round_start', function()
    d506 = nil
end, { require_login = true, alive_only = true })
d514.register('player_spawned', function()
    d506 = nil
end, { require_login = true, alive_only = true })


d514.register('player_hurt', function(d546)
    if not d546 then return end
    local d558= entity.get_local_player()
    if not d558 then return end
    local d587= client.userid_to_entindex(d546.userid)
    if d587 ~= d558 then return end

    
    local d588= d546.dmg_health or d546.damage or d546.hp or 0
    d588 = tonumber(d588) or 0
    if d588 <= 0 then return end

    
    local d589= string.format("-%d HP", d588)
    
    table.insert(d505, { t = globals.curtime(), text = d589 })
end, { require_login = true, alive_only = true })


d514.register('paint', function()
    local d590, d591= pcall(require, "require/abc/menu_setup")
    if not d590 or not d591 or not d591.ui then return end
    local d592, d593= pcall(ui.get, d591.ui.paint_bombwarning)
    if not d592 or not d593 then return end

    local d579= globals.curtime()

    
    local d558= entity.get_local_player()
    if d558 then
        local d553, d594= pcall(function() return entity.get_prop(d558, "m_iHealth") end)
        d594 = tonumber(d594)
        if d594 then
            if d506 == nil then
                d506 = d594
            else
                if d594 < d506 then
                    local d588= d506 - d594
                    table.insert(d505, { t = d579, text = string.format("-%d HP", d588) })
                end
                d506 = d594
            end
        end
    else
        d506 = nil
    end

    
    for i = #d505, 1, -1 do
        local d595= d505[i]
        local d596= d579 - d595.t
        local d597= 1.4
        if d596 >= d597 then
            table.remove(d505, i)
        else
            local d598= math.floor(255 * (1 - (d596 / d597)))
            if d598 < 0 then d598 = 0 end
            
            renderer.indicator(255, 210, 0, d598, d595.text)
        end
    end

    
    if d504 then
        local d558= entity.get_local_player()
        local d560= nil
        if d504.entindex then
            local d553, d561, d562, d536= pcall(function() return entity.get_prop(d504.entindex, "m_vecOrigin") end)
            if d553 then
                if type(d561) == "table" then
                    d560 = d561
                elseif d561 ~= nil and d562 ~= nil and d536 ~= nil then
                    d560 = { d561, d562, d536 }
                end
            end
        end
        
        if not d560 then
            local d548= entity.get_all("CPlantedC4") or {}
            for i = 1, #d548 do
                local d544= d548[i]
                local d553, d561, d562, d536= pcall(function() return entity.get_prop(d544, "m_vecOrigin") end)
                if d553 then
                    if type(d561) == "table" then
                        d560 = d561
                        break
                    elseif d561 ~= nil and d562 ~= nil and d536 ~= nil then
                        d560 = { d561, d562, d536 }
                        break
                    end
                end
            end
        end

        if d560 and d558 then
            local d527, d528, d529= nil, nil, nil
            local d553, d563, d564, d565= pcall(function() return client.eye_position() end)
            if d553 and d563 ~= nil and d564 ~= nil and d565 ~= nil then
                d527, d528, pz = d563, d564, d565
            else
                local d566, d567, d568, d569= pcall(function() return entity.get_origin(d558) end)
                if d566 then
                    if type(d567) == "table" then
                        if #d567 >= 3 then d527, d528, pz = d567[1], d567[2], d567[3] end
                    elseif d567 ~= nil and d568 ~= nil and d569 ~= nil then
                        d527, d528, pz = d567, d568, d569
                    end
                end
            end

            if d527 and d560 and #d560 >= 3 then
                local d530, d531, d532= d560[1], d560[2], d560[3]
                
                local d570, d521= pcall(function() return entity.get_prop(d558, "m_ArmorValue") end)
                d521 = tonumber(d521) or 0
                local d571, d572= pcall(function()
                    if type(client.mapname) == 'function' then return client.mapname() end
                    if cvar and cvar.mapname then return cvar.mapname:get_string() end
                    if cvar and cvar.map then return cvar.map:get_string() end
                    return nil
                end)
                local d533= d571 and d572 or nil
                local d575= d526(d527, d528, d529, d530, d531, d532, d521, d533)
                local d599= math.floor((d575 * (d509 or 1.0)) + 0.5)

                
                renderer.indicator(255, 210, 0, 255, string.format("-%d HP", d599))
            end
        end
    end

    
    if d504 then
        
        if d504.entindex then
            local d551= entity.get_prop(d504.entindex, "m_flC4Blow")
            if d551 and d551 > 0 then
                d504.blow_time = d551
            end
        end

        local d600= (d504.blow_time or 0) - d579
        if d600 <= 0 then
            d504 = nil
            return
        end

        local d601= d543(d504.site)
        local d589= string.format("%s - %.1fs", d601, d600)
        renderer.indicator(255, 255, 255, 255, d589)
    end
end, { require_login = true, alive_only = true })]]
d958["require/features/paint/bullet_tracer"] = [[local d507= require("ffi")
local d508= require('require/help/time')
local d509= nil
local d510= require('require/help/self')
pcall(function() d509 = require('require/help/safe') end)
pcall(function() DLL = require('require/brain/dll') end)
pcall(function() menu_setup = require('require/abc/menu_setup') end)
pcall(function() cb = require('require/abc/callbacks') end)

local d511= 10
local d512= 7.0
local d513= {255,255,255,255}
local d514= 0.05
local d515= 8192

if not (DLL and DLL.tracer_reset and DLL.tracer_push_shot and DLL.tracer_set_impact and DLL.tracer_collect) then return end
DLL.tracer_reset()

local d516= 7
local d517= d507.new("double[?]", d511 * d516)

local d518= d508.realtime

cb.register('weapon_fire', function(d519)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if d510.index() ~= client.userid_to_entindex(d519.userid) then return end
    local d520= d510.weapon()
    if d520 then
        local d521= entity.get_classname(d520) or ""
        local d522= d521:lower()
        if d522:find("knife") or d522:find("grenade") or d522:find("decoy") or d522:find("molotov") or d522:find("flash") or d522:find("smoke") or d522:find("taser") or d522:find("zeus") then
            return
        end
    end

    local d523,d524,d525= client.eye_position()
    if not d523 then d523,d524,sz = entity.get_origin(d510.index()) end
    d523,d524,sz = tonumber(d523) or 0, tonumber(d524) or 0, tonumber(d525) or 0
    DLL.tracer_push_shot(d523, d524, d525, d518())
end, { require_login = true, alive_only = true })
 
cb.register('bullet_impact', function(d519)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if d510.index() ~= client.userid_to_entindex(d519.userid) then return end
    local d526,d527,d528= tonumber(d519.x) or 0, tonumber(d519.y) or 0, tonumber(d519.z) or 0
    DLL.tracer_set_impact(d526, d527, d528, d518())
end, { require_login = true, alive_only = true })

if not cb then error("callbacks manager required: require/abc/callbacks") end

cb.register('paint', function()
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    local d529= d518()
    local d530= { client.camera_angles() }
    local d531= DLL.tracer_collect(d529, d512, d514, d530[1] or 0, d530[2] or 0, d515, d513[4] or 255, d517, d511)
    for i=0, (d531 or 0)-1 do
        local d532= i * d516
        local d523, d524, d525= d517[d532], d517[d532 + 1], d517[d532 + 2]
        local d533, d534, d535= d517[d532 + 3], d517[d532 + 4], d517[d532 + 5]
        local d536= d517[d532 + 6]
        local d537,d538= renderer.world_to_screen(d523, d524, d525)
        local d539,d540= renderer.world_to_screen(d533, d534, d535)
        if d537 and d539 then
            renderer.line(d537, d538, d539, d540, d513[1], d513[2], d513[3], d536)
        end
    end
end, { require_login = true, alive_only = true })]]
d958["require/features/paint/clantag"] = [[local d510=require("require/abc/menu_setup")
local d511=require("require/help/safe")
local d512=require("require/help/string")
local d513=require("require/help/time")
local d514=require("require/brain/dll")
local d515=require("ffi")
local d516=pcall
local d517=ui.reference
local d518=ui.set
local d519=client.set_clan_tag
local d520, d521= pcall(require, "require/abc/callbacks")
if not d520 or not d521 then error("require/abc/callbacks is required by clantag.lua") end
if not d514 or type(d514) ~= "table" or not d514.clantag_anim then return end

local d522=64
local d523=d515.new("char[?]",d522)
local d524,d525,d526=nil,0,nil
local function d527(d528)
    local d529={{"MISC","Misc","Clantag spammer"},{"MISC","Miscellaneous","Clantag spammer"},{"MISC","Misc","Clan tag spammer"},{"MISC","Miscellaneous","Clan tag spammer"},{"MISC","Misc","Clantag spamer"},{"MISC","Miscellaneous","Clantag spamer"}}
    for _,v in ipairs(d529) do
        local d530,d531=d516(d517,v[1],v[2],v[3])
        if d530 and d531 and d516(d518,d531,d528) then return true end
    end
    return false
end
local d532=function() return d527(true) end
local d533=function() return d527(false) end
d521.register('paint', function()
    local d531=d510.ui.paint_clantag if not d531 then return end
    local d534=d511.safe_get(d531) if type(d534)~='string' then return end
    local d535=d512.lower(d534) if d535==d524 and d535~='sodium' and d525==0 then return end
    if d535=='off' then d533(); d525=3; d516(d519," ")
    elseif d535=='gamesense' then if not d532() then d516(d519,"gamesense") end
    elseif d535 == 'sodium' then
        d533()

        if not d526 or type(d526) ~= 'table' or not d526.start then
            d526 = { start = d513.realtime() }
        end

        local d536= d513.realtime() or 0
        d515.fill(d523, d522, 0)
        local d537= d514.clantag_anim(d526.start or 0, d536, d523, d522)
        if d537 and d537 ~= 0 then
            d516(d519, d515.string(d523))
        else
            d516(d519, "")
        end
    end
    if d525>0 then d516(d519,"") d525=d525-1 end
    d524=d535
end, { require_login = true })]]
d958["require/features/paint/custom_scope"] = [[]]
d958["require/features/paint/damage"] = [[local d516= require("require/abc/menu_setup")
local d517= require("require/brain/api/vector/vector")
local d518= { shots = {}, last = 0 }


local d519= 5
local d520= 3
local d521= 10

local function d522()
	local d523= 0
	for i = 1, #d518.shots do
		local d524= d518.shots[i]
		if d524 and d524.impacts then d523 = d523 + #d524.impacts end
	end
	return d523
end

local function d525()
	while d522() > d521 do
		
		if #d518.shots == 0 then break end
		local d526= false
		for si = 1, #d518.shots do
			local d524= d518.shots[si]
			if d524 and d524.impacts and #d524.impacts > 0 then
				table.remove(d524.impacts, 1)
				d526 = true
				
				if #d524.impacts == 0 then
					table.remove(d518.shots, si)
				end
				break
			else
				
				table.remove(d518.shots, si)
				d526 = true
				break
			end
		end
		if not d526 then break end
	end
end

local function d527()
	local d528= d516.ui.paint_hitmarker
	if not d528 then return false end
	local d529= ui.get(d528)
	if type(d529) == "table" then
		for _, v in ipairs(d529) do
			if v == "damage" then return true end
		end
	end
	return false
end

local d530, d531= pcall(require, "require/abc/callbacks")
local function d532(d533)
	if not d527() then d518 = { shots = {}, last = 0 } return end
	if not d527() then return end
	local d534= entity.get_local_player()
	if not d534 then return end
	local d535= d533.target or d533.target_index
	if type(d535) ~= 'number' or d535 == 0 or not entity.is_enemy(d535) then return end
	local d536= d533.damage or 0
	local d537= d533.hitgroup == 1
	local d538= d533.health == 0
	local d539, d540, d541= entity.hitbox_position(d535, d533.hitgroup or 'head')
	if not d539 then d539, d540, z = entity.get_origin(d535) end
	if not d539 then return end
	local d542= d517.make(d539, d540, d541)
	local d543= globals.realtime()
	local d544= {255, 255, 255}
	if d538 then d544 = {217, 100, 100} elseif d537 then d544 = {165, 202, 42} end

	local d545
	if d518.last and d543 - d518.last < 0.05 then
		d545 = d518.shots[#d518.shots]
	else
		d518.last = d543
		d545 = { impacts = {}, finished = false, t = d543 }
		d518.shots[#d518.shots + 1] = d545
		if #d518.shots > 12 then table.remove(d518.shots, 1) end
	end

	if d545 then
		d545.impacts[#d545.impacts + 1] = { dmg = d536, x = d539, y = d540, z = d541, pos = d542, t = d543, color = d544 }
		if #d545.impacts > d520 then table.remove(d545.impacts, 1) end
		
		d525()
	end
end

local function d546(d533)
	if d527() then
		local d543= globals.realtime()
		local d547= 1.4
		local d548= 32
		local d549= 1
		while d549 <= #d518.shots do
			if d543 - (d518.shots[d549].t or 0) > (d547 + 0.5) then
				table.remove(d518.shots, d549)
			else
				d549 = d549 + 1
			end
		end
		local d550= {}
		local d551= 12
		for si = #d518.shots, 1, -1 do
			local d545= d518.shots[si]
			for ii = #d545.impacts, 1, -1 do
				table.insert(d550, d545.impacts[ii])
				if #d550 >= d551 then break end
			end
			if #d550 >= d551 then break end
		end

		local d552= math.min(4, #d550)
		for j = 1, d552 do
			local d553= d550[j]
			local d554, d555= renderer.world_to_screen(d553.pos.x, d553.pos.y, d553.pos.z)
			if d554 and d555 then
				local d556= d543 - (d553.t or 0)
				local d557= math.min(1, d556 / d547)
				local d558= d548 * (1 - math.exp(-3 * d557))
				local d559= math.floor(math.max(0, (1 - d557) * 255))
				if d559 > 0 then
					renderer.text(d554, d555 - d558, d553.color[1], d553.color[2], d553.color[3], d559, "crdb-", 0, tostring(d553.dmg))
				end
			end
		end
	else
		d518 = { shots = {}, last = 0 }
	end
end

d531.callback('aim_hit', d532, { alive_only = true, require_login = true })
d531.callback('paint', d546, { alive_only = true, require_login = true })]]
d958["require/features/paint/damage_penetration"] = [[
local function d519(d520,d521)
	if d521 and rawget(_G, d521) ~= nil then
		return rawget(_G, d521)
	end
	local d522, d523= pcall(require, d520)
	if d522 then return d523 end
	return nil
end

local d524= d519('ui', 'ui')
local d525= d519('client', 'client')
local d526= d519('entity', 'entity')
local d527= d519('renderer', 'renderer')

if not d524 or not d525 or not d526 or not d527 then
	return
end

local d528= d524.new_checkbox
local d529= d524.get
local d530= d524.reference

local d531= d525.screen_size
local d532= d525.set_event_callback
local d533= d525.unset_event_callback
local d534= d525.eye_position
local d535= d525.camera_angles
local d536= d525.trace_line
local d537= d525.trace_bullet

local d538= d526.get_local_player
local d539= d526.is_alive or function() return false end
local d540= d526.get_player_weapon or function() return nil end
local d541= d526.get_classname or function() return nil end

local d542= d527.text

local d543= math.floor
local d544= math.cos
local d545= math.sin
local d546= math.rad

sodium_SUPPRESS = sodium_SUPPRESS or false
sodium_REFS = sodium_REFS or {}
sodium_FN = sodium_FN or {}

local function d547(d548)
	if not d548 then return false end
	local d522, d549= pcall(d529, d548)
	return d522 and d549 == true
end


if type(sodium_FN.min_dmg_active) ~= 'function' then
	sodium_FN.min_dmg_active = function()
		ensure_min_damage_refs()
		local d550= sodium_REFS.min_dmg_hotkey
		if d550 then
			local d522, d549= pcall(d529, d550)
			if d522 then return d549 == true end
		end
		return false
	end
end

if type(sodium_FN.min_dmg_value) ~= 'function' then
	sodium_FN.min_dmg_value = function()
		ensure_min_damage_refs()
		local d551= sodium_REFS.min_dmg_slider
		if not d551 then return nil end
		local d522, d549= pcall(d529, d551)
		if d522 and type(d549) == 'number' then
			return d549
		end
		return nil
	end
end

local function d552(d553,d554)
	if sodium and sodium.ui and sodium.ui[d553] then
		return sodium.ui[d553]
	end
	local d555= 'ui_' .. d553
	if sodium_REFS[d555] then
		return sodium_REFS[d555]
	end
	if not d554 then return nil end
	local d548= d554()
	if d548 then
		sodium_REFS[d555] = d548
	end
	return d548
end


local d556= nil
pcall(function() d556 = require('require/abc/menu_setup') end)


local function d557(d558)
    if not d524.get(d556.ui.paint_show_damage_penetration) then return end
	if not d540 or not d541 then return false end
	local d559= d540(d558)
	if not d559 then return false end
	local d560= d541(d559)
	if not d560 then return false end
	if d560:sub(1, 7) ~= 'CWeapon' then return false end
	if d560:find('Grenade', 1, true) or d560:find('Taser', 1, true) or d560:find('C4', 1, true) then return false end
	return true
end

local function d561()
    if not d524.get(d556.ui.paint_show_damage_penetration) then return end
	if not d538 then return nil end
	local d562= d538()
	if not d562 then return nil end
	if d539 and not d539(d562) then return nil end
	return d562
end




local function d563()
    if not d524.get(d556.ui.paint_show_damage_penetration) then return end
	local d562= d561()
	if not d562 or not d557(d562) then return end
	local d564, d565, d566= d534()
	if not d564 or not d565 or not d566 then return end
	local d567, d568= d535()
	if not d567 or not d568 then return end
	local d569, d570= d544(d546(d567)), d545(d546(d567))
	local d571, d572= d544(d546(d568)), d545(d546(d568))
	local d573, d574, d575= d569 * d571, d569 * d572, -d570
	local d576= 8192
	local d577, d578, d579= d564 + d573 * d576, d565 + d574 * d576, d566 + d575 * d576
	local d580= select(1, d536(d562, d564, d565, d566, d577, d578, d579)) or 1
	if d580 < 0 then d580 = 0 end
	if d580 > 1 then d580 = 1 end

	local d581
	if d580 >= 0.999 then
		d581 = { 256, 512, 1024, 2048, 4096 }
	else
		local d582= d576 * d580
		d581 = { d582 + 4, d582 + 16, d582 + 32, d582 + 64, d582 + 128, d582 + 256 }
	end

	local d583= 0
	for i = 1, #d581 do
		local d584= d581[i]
		if d584 > d576 then d584 = d576 end
		local d585, d586, d587= d564 + d573 * d584, d565 + d574 * d584, d566 + d575 * d584
		local d588, d589= d537(d562, d564, d565, d566, d585, d586, d587, true)
		if d589 and d589 > d583 then d583 = d589 end
		if d584 == d576 then break end
	end

	local d590= d543((d583 or 0) + 0.5)
	if d590 <= 0 then return end

	local d591, d592= d531()
	if not d591 or not d592 then return end
	local d593= d591 / 2
	local d594= d592 / 2 + 8
	local d595= tostring(d590)
	local d596= false
	if sodium_FN.draw_surface_text_centered and _G.sodium_FONTS and _G.sodium_FONTS.pen then
		d596 = sodium_FN.draw_surface_text_centered(_G.sodium_FONTS.pen, d593, d594, d595, 177, 194, 89, 255) and true or false
	end
	if not d596 then
		d542(d593, d592 / 2 + 12, 177, 194, 89, 255, 'cb', 0, d595)
	end
end

local function d597()
    if not d524.get(d556.ui.paint_show_damage_penetration) then return end
	if sodium_SUPPRESS then return end
	d563()
end

local d598, d599= pcall(require, "require/abc/callbacks")
if d598 and d599 then
	if _G.sodium_B_MD_DP and type(_G.sodium_B_MD_DP) == 'number' then
		pcall(d599.unregister, _G.sodium_B_MD_DP)
	end

	local function d600()
		if sodium_SUPPRESS then return end
        if not d524.get(d556.ui.paint_show_damage_penetration) then return end
		d563()
	end

	_G.sodium_B_MD_DP = d599.register('paint', d600, { require_login = true, alive_only = true })
else
	if d533 and _G.sodium_B_MD_DP then
		d533('paint', _G.sodium_B_MD_DP)
	end

	_G.sodium_B_MD_DP = d597
	d532('paint', d597)
end]]
d958["require/features/paint/entidx"] = [[local d522= require("require/abc/menu_setup")
local d523= require("require/help/enemies")

local function d524()
	if not ui.get(d522.ui.paint_entidx) then return end

	local d525= d523.get_current_threat and d523.get_current_threat() or client.current_threat and client.current_threat() or nil
	if d525 and d525 ~= 0 then
		local d526= entity.get_player_name(d525)

		renderer.text(70, 120, 255, 0, 0, 255, "b", 0, string.format("entidx%d: %s", d525, d526))
	end
end

local d527, d528= pcall(require, "require/abc/callbacks")
if d527 and d528 and d528.callback then
	d528.callback("paint", d524, { alive_only = true, require_login = true })
else
	client.set_event_callback("paint", d524)
end]]
d958["require/features/paint/filter_console"] = [[


local d525= pcall(require, 'require/abc/menu_setup') and require('require/abc/menu_setup') or nil
local d526= d525 and d525.ui and d525.ui.paint_filter_console or nil

local d527= cvar.con_filter_enable
local d528= cvar.con_filter_text

local d529= { enable = nil, text = nil }

local function d530()
    if d529.enable == nil then
        
        local d531, d532= pcall(function() return d527:get_int() end)
        d529.enable = (d531 and d532) and d532 or nil
    end

    if d529.text == nil then
        local d531, d533= pcall(function() return d528:get_string() end)
        d529.text = (d531 and d533) and d533 or nil
    end
end

local function d534()
    if d529.enable ~= nil then
        pcall(function() d527:set_raw_int(d529.enable) end)
    end

    if d529.text ~= nil then
        pcall(function() d528:set_string(d529.text) end)
    else
        pcall(function() d528:set_string('') end)
    end

    d529.enable = nil
    d529.text = nil
end

local function d535()
    d530()
    pcall(function() d527:set_raw_int(1) end)
    pcall(function() d528:set_string('[gamesense]') end)
end




local function d536()
    if not d526 then
        return false
    end

    
    if type(d526) == 'table' and d526.get then
        local d531, d532= pcall(function() return d526:get() end)
        return d531 and d532 or false
    end

    
    local d531, d532= pcall(function() return ui.get(d526) end)
    return d531 and d532 or false
end

local function d537()
    if not d536() then
        d534()
        return
    end

    d535()
    client.delay_call(1, d537)
end


client.delay_call(0.1, d537)


client.set_event_callback('shutdown', d534)

return {
    
    get_ui_state = d536,
    restore_values = d534,
    apply_filter = d535,
}
]]
d958["require/features/paint/hit_miss_indicator"] = [[local d528=require("require/help/math")
local d529=require("require/help/self")
local d530=require("require/help/safe")
local d531=require("require/abc/menu_setup")

local d532,d533=0,0
local d534=function() return d531 and d531.ui and d530.safe_get(d531.ui.paint_hitmiss_indicator) end
local d535=function() d532,shots=0,0 end

client.set_event_callback("aim_fire", function(d536)
    if not d534() or not d529.is_alive() then return end
    local d537= nil
    if d536.userid then d537 = client.userid_to_entindex(d536.userid) end
    if (not d537 or d537 == 0) and d536.player then d537 = d536.player end
    if d537 == d529.index() then d533 = d533 + 1 end
end)

client.set_event_callback("aim_hit", function(d536)
    if not d534() or not d529.is_alive() then return end
    local d537= nil
    if d536.userid then d537 = client.userid_to_entindex(d536.userid) end
    if (not d537 or d537 == 0) and d536.attacker then d537 = client.userid_to_entindex(d536.attacker) end
    if (not d537 or d537 == 0) and d536.player then d537 = d536.player end
    if d537 == d529.index() then d532 = d532 + 1 end
end)


client.set_event_callback("paint",function()
    if not d534() then return end
    local d538=d533>0 and d528.round(d532/d533*100,1) or 0
    renderer.indicator(255,255,255,255,string.format("%d / %d (%.1f)",d532,d533,d538))
end)
defer(d535)]]
d958["require/features/paint/indicators_bold"] = [[local d531= { 0, 0, 0 }
local d532= { 3, 3, 3 }
local d533= { 6, 6, 6 }

local function d534(d535,d536,d537)
  return d535 + (d536 - d535) * d537
end

local d538, d539= pcall(require, "require/abc/menu_setup")
local d540, d541= pcall(require, "require/help/string")
local function d542(d543)
  if d543 == nil then return "" end
  if d540 and d541 and d541.lower then
    return d541.lower(tostring(d543))
  end
  return tostring(d543)
end
local d544, d545= pcall(require, "require/help/color")
local d546, d547= pcall(require, "require/help/math")
local d548= d544 and d545.rgba_to_hex or function(d549,d550,d536,d535) return string.format("\a%02x%02x%02x%02x", d549 or 0, d550 or 0, d536 or 0, d535 or 255) end

local function d551(d552,d553,d549,d550,d536,d535,d554)
  local d537= globals.realtime() or globals.curtime()
  if not d554 or #d554 == 0 then return "" end
  local d555= {}

  if d552 == 0 then
    local d556= d548(d549,d550,d536,d535)
    for i=1,#d554 do d555[#d555+1] = d556 .. d554:sub(i,i) end
    return table.concat(d555)
  end

  if d552 == 2 then
    local d557= (math.sin(d537 * d553) + 1) * 0.5
    local d558= math.floor(d535 * (0.45 + 0.55 * d557))
    local d556= d548(d549,d550,d536,d558)
    for i=1,#d554 do d555[#d555+1] = d556 .. d554:sub(i,i) end
    return table.concat(d555)
  end

  if d552 == 3 then
    for i=1,#d554 do
      local d559= math.sin(d537 * d553 - i * 0.6)
      local d560= math.max(0, d559)
      local d557= d560 * d560
      local d558= math.floor(d535 * (0.35 + 0.65 * d557))
      d555[#d555+1] = d548(d549,d550,d536,d558) .. d554:sub(i,i)
    end
    return table.concat(d555)
  end

  for i=1,#d554 do
    local d557= (math.sin(d537 * d553 - i * 0.35) + 1) * 0.5
    local d558= math.floor(d535 * (0.4 + 0.6 * d557))
    d555[#d555+1] = d548(d549,d550,d536,d558) .. d554:sub(i,i)
  end
  return table.concat(d555)
end
local function d561()
  if d538 and d539 and d539.ui and d539.ui.paint_indicators then
    local d562, d563= pcall(ui.get, d539.ui.paint_indicators)
    if d562 and d563 == "bold" then return true end
    return false
  end

  return true
end

local d564, d565= pcall(require, "require/abc/callbacks")
local function d566(d567)
  if not d561() then return end

  local d568, d569= client.screen_size()
  local d570, d571= d568 / 2, d569 / 2

  local d572, d573, d574= 200, 200, 255
  local d575, d576, d577= 255, 255, 255
  local d578= 18

  local d579= { 12, 12 }

  local d580= d571 + 18

  local d581= entity.get_local_player()
  local d582= false
  if d581 then
    local d583= entity.get_prop(d581, "m_bIsScoped")
    d582 = d583 == 1
  end

  local d584= "sodium"
  local d585= "beta"
  local d586= "DT"

  local d587= false
  do
    local d562, d588= pcall(require, "require/help/libs")
    if d562 and d588 and d588.get then
      local d589= d588.get("antiaim_funcs")
      if d589 and d589.get_double_tap then
        local d590, d591= pcall(d589.get_double_tap)
        if d590 and d591 then d587 = true end
      end
    end
  end

  local d592= 1
  if d538 and d539 and d539.ui and d539.ui.paint_indicators_animation then
    local d593, d594= pcall(ui.get, d539.ui.paint_indicators_animation)
    if d593 and type(d594) == 'number' then d592 = d594 end
  end
  local d595= d584 .. " " .. d585
  d595 = d542(d595)
  d584 = d542(d584)
  d585 = d542(d585)
  local d596= renderer.measure_text("b", d595) or 0
  local d597= renderer.measure_text("b", d584) or 0
  local d598= renderer.measure_text("b", d585) or 0
  local d599= renderer.measure_text("b", d586) or 0

  local d600= ""
  do
    local d562, d601= pcall(require, "require/aa/player_condition")
    if d562 and d601 and d601.get then
      local d590, d602= pcall(d601.get)
      if d590 and d602 then
        local d603= {
          legit = "Legit",
          fakelag = "Fakelag",
          walk = "Walk",
          move = "Move",
          stand = "Stand",
          ["duck"] = "Duck",
          ["duck+"] = "Duck+",
          jump = "Jump",
          ["jump+"] = "Jump+"
        }
        d600 = d603[d602] or tostring(d602)
        d600 = d542(d600)
      end
    end
  end

  d586 = d542(d586)
  local d604= renderer.measure_text("b", d600) or 0

  local d605, d606, d607, d608= 200, 200, 255, 255
  do
    local d609= false
    if d538 and d539 and d539.ui and d539.ui.paint_indicator_color then
      local d610, d535, d536, d611, d612= pcall(ui.get, d539.ui.paint_indicator_color)
      if d610 then
        d609 = true
        if type(d535) == 'number' then
          if d544 and d545 and d545.clamp then
            d605 = d545.clamp(d535 or d605)
            d606 = d545.clamp(d536 or d606)
            d607 = d545.clamp(d611 or d607)
            d608 = d545.clamp(d612 or d608)
          else
            d605 = math.floor(d535 or d605)
            d606 = math.floor(d536 or d606)
            d607 = math.floor(d611 or d607)
            d608 = math.floor(d612 or d608)
          end
        elseif type(d535) == 'string' and #d535 == 12 then
          local d562
          d562, mr = pcall(function() return tonumber(d535:sub(1,3)) end)
          d562, mg = pcall(function() return tonumber(d535:sub(4,6)) end)
          d562, mb = pcall(function() return tonumber(d535:sub(7,9)) end)
          d562, ma = pcall(function() return tonumber(d535:sub(10,12)) end)
          if d544 and d545 and d545.clamp then
            d605 = d545.clamp(d605 or 200)
            d606 = d545.clamp(d606 or 200)
            d607 = d545.clamp(d607 or 255)
            d608 = d545.clamp(d608 or 255)
          else
            d605 = d605 or 200; d606 = d606 or 200; d607 = d607 or 255; d608 = d608 or 255
          end
        end
      end
    end

    if not d609 then
      local d613, d614= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if d613 and d614 then
        local d610, d535, d536, d611, d612= pcall(ui.get, d614)
        if d610 then
          if type(d535) == 'number' then
            if d544 and d545 and d545.clamp then
              d605 = d545.clamp(d535 or d605)
              d606 = d545.clamp(d536 or d606)
              d607 = d545.clamp(d611 or d607)
              d608 = d545.clamp(d612 or d608)
            else
              d605 = math.floor(d535 or d605)
              d606 = math.floor(d536 or d606)
              d607 = math.floor(d611 or d607)
              d608 = math.floor(d612 or d608)
            end
          elseif type(d535) == 'string' and #d535 == 12 then
            local d562
            d562, mr = pcall(function() return tonumber(d535:sub(1,3)) end)
            d562, mg = pcall(function() return tonumber(d535:sub(4,6)) end)
            d562, mb = pcall(function() return tonumber(d535:sub(7,9)) end)
            d562, ma = pcall(function() return tonumber(d535:sub(10,12)) end)
            if d544 and d545 and d545.clamp then
              d605 = d545.clamp(d605 or 200)
              d606 = d545.clamp(d606 or 200)
              d607 = d545.clamp(d607 or 255)
              d608 = d545.clamp(d608 or 255)
            else
              d605 = d605 or 200; d606 = d606 or 200; d607 = d607 or 255; d608 = d608 or 255
            end
          end
        end
      end
    end
  end

  for i = 1, 3 do
    local d615= (i == 1) and d596 or ((i == 2) and d599 or d604)
    local d616= d532[i] or 0
    local d617= d582 and (d616 + (d615 / 2)) or 0
    local d553= d533[i] or 10
    local d618= globals.frametime()
    local d537= 1 - math.exp(-d553 * d618)
    d531[i] = d534(d531[i], d617, d537)
  end

  local d619= d570 - (d596 / 2)
  local d620= d619 + (d531[1] or 0)
  renderer.text(d620, d580, 255, 255, 255, 255, "b", 0, d584)
  local d621= renderer.measure_text("b", " ") or 0
  local d622= d620 + (d597 or 0) + d621
  
  local d623= d551(d592, 3.5, d605, d606, d607, d608, d585)
  renderer.text(d622, d580, d605, d606, d607, d608, "b", 0, d623)
  d580 = d580 + (d579[1] or d578)

  local d624= d570 - (d599 / 2)
  local d625= d624 + (d531[2] or 0)
  local d626, d627, d628= 255, 80, 80
  if d587 then d626, d627, dt_b = 155, 255, 155 end
  renderer.text(d625, d580, d626, d627, d628, 255, "b", 0, d586)
  d580 = d580 + (d579[2] or d578)

  local d629= d570 - (d604 / 2)
  local d630= d629 + (d531[3] or 0)
  renderer.text(d630, d580, d575, d576, d577, 255, "b", 0, d600)
end

if d564 and d565 and d565.callback then
  d565.callback("paint", d566, { alive_only = true, require_login = true })
end]]
d958["require/features/paint/indicators_small"] = [[local d534= { 0, 0 }
local d535= { 4, 0.8 }
local d536= { 5, 5 }
local d537= 0
local d538= 8

local function d539(d540,d541,d542)
  return d540 + (d541 - d540) * d542
end

local d543, d544= pcall(require, "require/abc/menu_setup")
local d545, d546= pcall(require, "require/help/string")
local d547= require('require/abc/callbacks')
local function d548(d549)
  if d549 == nil then return "" end
  if d545 and d546 and d546.upper then
    return d546.upper(tostring(d549))
  end
  return tostring(d549)
end

local d550, d551= pcall(require, "require/help/color")
local d552, d553= pcall(require, "require/help/math")
local d554= d550 and d551.rgba_to_hex or function(d555,d556,d541,d540) return string.format("\a%02x%02x%02x%02x", d555 or 0, d556 or 0, d541 or 0, d540 or 255) end

local function d557(d558,d559,d555,d556,d541,d540,d560)
  local d542= globals.realtime() or globals.curtime()
  if not d560 or #d560 == 0 then return "" end
  local d561= {}

  if d558 == 0 then
    local d562= d554(d555,d556,d541,d540)
    for i=1,#d560 do d561[#d561+1] = d562 .. d560:sub(i,i) end
    return table.concat(d561)
  end

  if d558 == 2 then
    local d563= (math.sin(d542 * d559) + 1) * 0.5
    local d564= math.floor(d540 * (0.45 + 0.55 * d563))
    local d562= d554(d555,d556,d541,d564)
    for i=1,#d560 do d561[#d561+1] = d562 .. d560:sub(i,i) end
    return table.concat(d561)
  end

  if d558 == 3 then
    for i=1,#d560 do
      local d565= math.sin(d542 * d559 - i * 0.6)
      local d566= math.max(0, d565)
      local d563= d566 * d566
      local d564= math.floor(d540 * (0.35 + 0.65 * d563))
      d561[#d561+1] = d554(d555,d556,d541,d564) .. d560:sub(i,i)
    end
    return table.concat(d561)
  end

  for i=1,#d560 do
    local d563= (math.sin(d542 * d559 - i * 0.35) + 1) * 0.5
    local d564= math.floor(d540 * (0.4 + 0.6 * d563))
    d561[#d561+1] = d554(d555,d556,d541,d564) .. d560:sub(i,i)
  end
  return table.concat(d561)
end
local function d567()
  if d543 and d544 and d544.ui and d544.ui.paint_indicators then
    local d568, d569= pcall(ui.get, d544.ui.paint_indicators)
    if d568 and d569 == "small" then return true end
    return false
  end

  return true
end



local function d570()
  if not (d543 and d544 and d544.ui) then return true end
  local d571= d544.ui.paint_indicators_bar
  if not d571 then return true end
  local d568, d569= pcall(ui.get, d571)
  if not d568 then return true end
  return not (d569 == false or d569 == nil) 
end

d547.register("paint", function()
  if not entity.is_alive(entity.get_local_player()) then return end
  if not d567() then return end

  local d572, d573= client.screen_size()
  local d574, d575= d572 / 2, d573 / 2

  local d576, d577, d578= 200, 200, 255
  local d579, d580, d581= 255, 255, 255
  local d582= 18

  local d583= { 12, 13 }

  local d584= d575 + 18

  
  local d585= entity.get_local_player()
  local d586= false
  if d585 then
    local d587= entity.get_prop(d585, "m_bIsScoped")
    d586 = d587 == 1
  end

  local d588= "sodium"
  local d589= "beta"
  local d590= "DT"

  local d591= false
  do
    local d568, d592= pcall(require, "require/help/libs")
    if d568 and d592 and d592.get then
      local d593= d592.get("antiaim_funcs")
      if d593 and d593.get_double_tap then
        local d594, d595= pcall(d593.get_double_tap)
        if d594 and d595 then d591 = true end
      end
    end
  end

  local d596= d548(d588)
  local d597= d548(d589)
  d596 = tostring(d596)
  d597 = tostring(d597)
  local d598= renderer.measure_text("b", d596) or 0
  local d599= renderer.measure_text("b", d597) or 0

  d590 = d548(d590)
  local d600= renderer.measure_text("b", d590) or 0

  for i = 1, 2 do
    local d601= (i == 1) and d598 or d600
    local d602= d535[i] or 0
    local d603= d586 and (d602 + (d601 / 2)) or 0
    local d559= d536[i] or 10
    local d604= globals.frametime()
    local d542= 1 - math.exp(-d559 * d604)
    d534[i] = d539(d534[i], d603, d542)
  end

  local d605= 4.5
  local d606= d574 - ((d598 + d605 + (d599 or 0)) / 2)
  local d607= d606 + (d534[1] or 0)
  local d608= 22
  local d609= d608 - d605
  local d610= math.floor((d609 + 1) / 2)
  local d611= d609 - d610
  local d612= d610 
  local d613= -d611 

  local d614, d615, d616, d617= d576, d577, d578, 255
  do
    local d618= false
    
    if d543 and d544 and d544.ui and d544.ui.paint_indicator_color then
      local d619, d540, d541, d620, d621= pcall(ui.get, d544.ui.paint_indicator_color)
      if d619 then
        d618 = true
        if type(d540) == 'number' then
          if d550 and d551 and d551.clamp then
            d614 = d551.clamp(d540 or d614)
            d615 = d551.clamp(d541 or d615)
            d616 = d551.clamp(d620 or d616)
            d617 = d551.clamp(d621 or d617)
          else
            d614 = math.floor(d540 or d614)
            d615 = math.floor(d541 or d615)
            d616 = math.floor(d620 or d616)
            d617 = math.floor(d621 or d617)
          end
        elseif type(d540) == 'string' and #d540 == 12 then
          local d568
          d568, mr = pcall(function() return tonumber(d540:sub(1,3)) end)
          d568, mg = pcall(function() return tonumber(d540:sub(4,6)) end)
          d568, mb = pcall(function() return tonumber(d540:sub(7,9)) end)
          d568, ma = pcall(function() return tonumber(d540:sub(10,12)) end)
          if d550 and d551 and d551.clamp then
            d614 = d551.clamp(d614 or d576)
            d615 = d551.clamp(d615 or d577)
            d616 = d551.clamp(d616 or d578)
            d617 = d551.clamp(d617 or 255)
          else
            d614 = d614 or d576; d615 = d615 or d577; d616 = d616 or d578; d617 = d617 or 255
          end
        end
      end
    end

    
    if not d618 then
      local d622, d571= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if d622 and d571 then
        local d619, d540, d541, d620, d621= pcall(ui.get, d571)
        if d619 then
          if type(d540) == 'number' then
            if d550 and d551 and d551.clamp then
              d614 = d551.clamp(d540 or d614)
              d615 = d551.clamp(d541 or d615)
              d616 = d551.clamp(d620 or d616)
              d617 = d551.clamp(d621 or d617)
            else
              d614 = math.floor(d540 or d614)
              d615 = math.floor(d541 or d615)
              d616 = math.floor(d620 or d616)
              d617 = math.floor(d621 or d617)
            end
          elseif type(d540) == 'string' and #d540 == 12 then
            local d568
            d568, mr = pcall(function() return tonumber(d540:sub(1,3)) end)
            d568, mg = pcall(function() return tonumber(d540:sub(4,6)) end)
            d568, mb = pcall(function() return tonumber(d540:sub(7,9)) end)
            d568, ma = pcall(function() return tonumber(d540:sub(10,12)) end)
            if d550 and d551 and d551.clamp then
              d614 = d551.clamp(d614 or d576)
              d615 = d551.clamp(d615 or d577)
              d616 = d551.clamp(d616 or d578)
              d617 = d551.clamp(d617 or 255)
            else
              d614 = d614 or d576; d615 = d615 or d577; d616 = d616 or d578; d617 = d617 or 255
            end
          end
        end
      end
    end
  end

  local d623= 1
  if d543 and d544 and d544.ui and d544.ui.paint_indicators_animation then
    local d624, d625= pcall(ui.get, d544.ui.paint_indicators_animation)
    if d624 and type(d625) == 'number' then d623 = d625 end
  end

  local d626= (function()
    local d562= d554(255,255,255,255)
    local d561= {}
    for i=1,#d596 do d561[#d561+1] = d562 .. d596:sub(i,i) end
    return table.concat(d561)
  end)()

  local d627= d557(d623, 3.5, d614, d615, d616, d617, d597)
  local d628= d607 + (d612 or 0)
  local d629= d586 and 3 or 0
  d628 = d628 + d629
  renderer.text(d628, d584, 255,255,255,255, "-", 0, d626)
  local d630= d607 + (d598 or 0) + d605
  local d631= d630 + (d613 or 0) + d629
  renderer.text(d631, d584, d614, d615, d616, d617, "-", 0, d627)

  local d632= false
  if d570() then
    d632 = true
    do
      local d633= (d598 or 0) + d605 + (d599 or 0)
      local d634= 16
      local d635= math.max(8, d633 - d634)
      local d636= d586 and math.floor((d534[1] or 0) * 0.35) or 0
      local d637= d607 + math.floor((d633 - d635) / 2) - 2 + d636
      local d638= 2
      local d639= d584 + math.max(2, (d583[1] or d582) - (d638 + 4)) + 5
      local d640= math.floor((d617 or 255) * 0.7)
      renderer.rectangle(d637 - 1, d639 - 1, d635 + 2, d638 + 2, d614, d615, d616, d640)
      renderer.rectangle(d637, d639, d635, d638, 0, 0, 0, 255)
      local d641= d591 and d635 or 0
      local d642= globals.frametime()
      local d643= 1 - math.exp(-d538 * d642)
      d537 = d539(d537, d641, d643)
      local d644= math.floor(math.max(0, math.min(d537, d635)))
      if d644 > 0 then
        renderer.rectangle(d637, d639, d644, d638, d614, d615, d616, d617)
      end
    end
  end

  
  local d645= (d583[1] or d582)
  local d646= d645
  if not d632 then
    
    d646 = math.max(0, d645 - 7)
  end
  d584 = d584 + d646

  local d647= d574 - (d600 / 2)
  local d648= d647 + (d534[2] or 0)
  local d649, d650, d651= 255, 80, 80
  if d591 then d649, d650, dt_b = 155, 255, 155 end
  renderer.text(d648, d584 + 2, d649, d650, d651, 255, "-", 0, d590)
  d584 = d584 + (d583[2] or d582)

end, { alive_only = true, require_login = true })]]
d958["require/features/paint/insults"] = [[local d537= client
local d538= entity
local d539= ui

local d540= require("require/abc/menu_setup")
local d541, d542= pcall(require, "require/help/string")
local d543, d544= pcall(require, "require/help/math")
local d545, d546= pcall(require, "require/help/time")

local d547= {
    "buy sodium",
    "sodium is the bestest lua",
    "SODIUMMMM >__<",
    "you just got sodiumed",
    "sodium beta > all other lues",
    "₴ØĐłɄ₥ ₮₳₴₮ɆĐ Vł₵₮ØⱤɎ, ł₮ ₩₳₴ ₴ØɄⱤ",
    "₴ØĐłɄ₥ ₳ⱤⱤ₳₦₲ɆĐ ₮ⱧɆ ₴₮₳Ɽ₴ ₣ØⱤ ₮Ⱨ₳₮ ⱧɆ₳Đ₴ⱧØ₮",
    "₴ØĐłɄ₥ ₴Ⱡł₱₱ɆĐ ł₦ ₳ ฿₳₦₳₦₳ ₱ɆɆⱠ Ø₣ ₣₳₮Ɇ",
    "₴ØĐłɄ₥ ₩Ⱨł₴₱ɆⱤɆĐ ₴Ɇ₵ⱤɆ₮₴ ł₦₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ₥₳₭Ɇ₴ ₣ⱤłɆ₦Đ₴ ₩ł₮Ⱨ Ⱡ₳₲, ₮ⱧɆ₦ ฿Ɇ₮Ɽ₳Ɏ₴ ł₮",
    "₴ØĐłɄ₥ ₣ØⱠĐɆĐ ɎØɄⱤ ₵ØɄⱤ₳₲Ɇ ł₦₮Ø ₳ ₱₳₱ɆⱤ ₱Ⱡ₳₦Ɇ",
    "₴ØĐłɄ₥ ₱₳ł₦₮₴ ł₦ ⱤɆĐ ₩ⱧɆ₦ ł₮ ł₴ ⱧɄ₦₲ⱤɎ",
    "₴ØĐłɄ₥ ł₴ ₴₵ⱧłⱫØ₱ⱧⱤɆ₦ł₵ ฿Ʉ₮ ₵Ⱨ₳Ɽ₥ł₦₲",
    "₴ØĐłɄ₥ ₳₮Ɇ ₥Ɏ ₴₳₦Đ₩ł₵Ⱨ ฿Ʉ₮ ⱠɆ₣₮ ₳ ₮ⱤØ₱ⱧɎ",
    "₴ØĐłɄ₥ ⱧɄ₥₴ ⱠɄⱠⱠ₳฿łɆ₴ ₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ĐØɆ₴ ₮ⱧɆ ₵Ⱨ₳-₵Ⱨ₳ ₩ł₮Ⱨ ɎØɄⱤ ₳ł₥",
    "₴ØĐłɄ₥ ₣ØⱤ₲Ø₮ ₮Ø ฿Ɇ ₱ØⱠł₮Ɇ, ₴ØⱤⱤɎ ₦Ø₮ ₴ØⱤⱤɎ",
    "₴ØĐłɄ₥ ₳₦Đ ł ₴Ⱨ₳ⱤɆ ₮ØØ₮Ⱨ฿ⱤɄ₴ⱧɆ₴ (₥Ɇ₮₳₱ⱧØⱤ)",
    "₴ØĐłɄ₥ ₮Ɏ₱ɆĐ 'ɎØɄ' ł₦ ⱠØ₩ɆⱤ₵₳₴Ɇ ₳₦Đ ₥Ɇ₳₦₮ ł₮",
    "₴ØĐłɄ₥ ₵ØⱠⱠɆ₵₮₴ ₴₥₳ⱠⱠ ₮ⱤØ₱ⱧłɆ₴ (ɎØɄ ł₦₵ⱠɄĐɆĐ)",
    "₴ØĐłɄ₥ ₭ɆɆ₱₴ ⱤɆ₵Ɇł₱₮₴ ₣ØⱤ ɎØɄⱤ ₥ł₴₮₳₭Ɇ₴",
    "₴ØĐłɄ₥ ł₴ ₳ ₲ØØĐ ⱠɄ₳ ₳₦Đ ₳Ⱡ₴Ø ₳ Ⱡł₮₮ⱠɆ ₥₳Đ",
    "₴ØĐłɄ₥, ₮Ⱨ₳₦₭ ₣ØⱤ ₳ⱠⱠ₳Ⱨ ₲ØĐ, Đ₳Đ :)",
    "₴ØĐłɄ₥ ₴Ɇ₦ĐɆⱤ ₲ⱤɆɆ₮ł₦₲ ₣ⱤØ₥ ₭Ʉ฿₳₦",
    "₥łⱠⱠłØ₦₳łⱤɆ ฿ɄɎ₴ ₲ⱧØ₴₮ ツ Ⱨ₳₳₳Ⱨ₳Ⱨ₳",
    "₴ Ø Đ ł Ʉ ₥ ⱠɄ₳ Ⱨ₳₴ ₮ⱧɆ ฿Ɇ₴₮ ⱧɆ₳Đ₴ⱧØ₮₮₮",
    "₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ <3",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ",
    "ł₣ ₣ⱠɎł₦₲ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐØ₦₮ ₭₦Ø₩ł₦₲ ӾĐĐ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₥Ɏ ₳ł₥ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ɆⱤVɆⱤ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ, ฿Ɇ₲ ₮Ø ₱ⱤØ₵Ⱡ₳ł₥",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄ ₵₳₦ ₥₳₮₵Ⱨ Ⱡ₥Ⱨ ł ⱤɆ₵ØĐɆĐ",
    "ł ₱Ⱡ₳₵Ɇ ɎØɄ Ø₦ ₦Ɇ₩ ⱠɆ₣Ɇ₦Đ ⱠɆ₵₮ɆĐ ₥₳₱ ₩ł₮Ⱨ ØĐł₣ł₵ ⱤɆ₵ØĐɆ",
    "♡ ₴ØĐłɄ₥ ł₴ ₥Ɏ ₵Ø₵₭ Ø₣ ⱠɄ₳ ♡",
    "ł ⱤØ₳₴₮ɆĐ ɎØɄ ₴Ø ₣Ʉ₵₭ł₦₲ Ⱨ₳ⱤĐ ɆVɆⱤ ₴ɆⱤɆĐ",
    "ɎØɄ ₮ⱤłɆĐ ₮Ø ₱ⱤɆ₮Ɇ₦Đ, ฿Ʉ₮ ₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ₭łⱠⱠɆĐ ₮Ⱨ₳₮",
    "ɎØɄ ⱠØ₴Ɇ ₮Ø ₥Ɇ ₣ØⱤ ₦ł₵Ɇ ₣ØⱠ₭",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱ØɆ₥",
    "ł ₣Ⱡł₲Ⱨ₮ ɎØɄ Ø₣₣ ₮ⱧɆ ₥₳₱ ₩ł₮Ⱨ ₥Ɏ ₴ɆⱤVɆⱤ ₩ł₣Ɇ",
    "₴ɆⱤł₳Ⱡ ฿ɄⱠⱠɎ Ø₣ ⱠɄ₳ ₳ⱠⱠ Đ₳Ɏ",
    "₥Ɏ ₴ØĐłɄ₥ ฿ⱤɆ₳₭₴ ₥ØⱤɆ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ₴ØĐłɄ₥ ❤",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ, ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₣ⱠɎ ₳ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ, ₮ⱧɆ₦ ₴₮łⱠⱠ ฿Ɇ₳₮ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐłĐ₦’₮ ₭₦Ø₩ł₦₲ ӾĐĐĐ, ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳ ₣₮₩",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ₴Ɇ₦Đ ₲ⱤɆɆ₮ł₦₲₴ ₱₳Ɽ₳ ₳ ₵Ø₦₳ Đ₳ ₮Ʉ₳ ₥₳₮Ɇ",
    "₳ĐĐɆĐ ₮Ⱨł₴ ₮Ø ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₳₦Đ ł₮ ₥₳ĐɆ ł₮ ₴Ø ₥Ʉ₵Ⱨ ฿Ɇ₮₮ɆⱤ",
    "ł ₴₥Ø₭ɆĐ ɎØɄ ɎɆ₴₮ɆⱤĐ₳Ɏ ₩ł₮Ⱨ ₴ØĐłɄ₥, ₮ØĐ₳Ɏ ł ₣ⱠɆӾ ₳₲₳ł₦",
    "₴ØĐłɄ₥ ⱠɄ₳ JɄ₴₮ Ø₩₦ɆĐ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄⱤ ₴₵Ɽł₱₮ ₵₳₦ ₥₳₮₵Ⱨ ₴ØĐłɄ₥? ⱠØⱠ ₦Ø₱Ɇ",
    "ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ ₥ØĐɆ ₳₵₮łV₳₮ɆĐ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ = 100% ₩ł₦ ₲Ʉ₳Ɽ₳₦₮ɆɆĐ",
    "ł ฿ⱤɆ₳₭ ɎØɄⱤ ⱠɄ₳, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₥ł₦Đ, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₴ɆⱤVɆⱤ — ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "(‿ˠ‿)",
    "₣ØⱤ ₲₳₦₲₴₮ɆⱤ ₩Ɇ Ⱨ₳VɆ ₩Ø₦, ₮Ⱨł₴ ₥₳₮₵Ⱨ",
    "https://discord.gg/8nMMVgqdHk",
    "BUY SODIUM NOW!!! ₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ BUY SODIUM NOW!!! AT DISCORD ;;;",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥ ⱠɄ₳ ",
}


local d548= {
    ""
}

pcall(function()
    local d549= nil
    if d545 and d546 and d546.unix_time then
        d549 = math.floor((d546.unix_time() or 0) % (2^31))
    else
        local d550= nil
        pcall(function() d550 = d537.timestamp() end)
        if not d550 or d550 == 0 then
            d550 = globals.tickcount() or 0
        end
        d549 = math.floor((d550 or 0) % (2^31))
    end
    math.randomseed(d549)
end)
local d551= 1
local d552= {}
local d553= false

local function d554(d555)
    if d537 and d537.exec then
        pcall(d537.exec, d555)
    end
end

local function d556()
    if #d552 == 0 then
        d553 = false
        return
    end

    local d557= table.remove(d552, 1)
    if not d557 or d557 == "" then
        if #d552 > 0 then
            if d537 and d537.delay_call then
                pcall(function() d537.delay_call(d551, d556) end)
            else
                d556()
            end
        else
            d553 = false
        end
        return
    end

    local d555= string.format('say "%s"', d557)
    if d537 and d537.delay_call then
        pcall(function()
            d537.delay_call(0, function()
                d554(d555)
            end)
        end)
    else
        d554(d555)
    end

    if #d552 > 0 then
        if d537 and d537.delay_call then
            pcall(function() d537.delay_call(d551, d556) end)
        else
            d556()
        end
    else
        d553 = false
    end
end

local function d558(d559)
    if not d559 or d559 == "" then return end
    local d560= tostring(d559)
    local d561
    if d541 and d542 and d542.replace then
        d561 = d542.replace(d560, '"', '')
        if d542.trim then d561 = d542.trim(d561) end
    else
        d561 = d560:gsub('"','')
    end

    table.insert(d552, d561)
    if not d553 then
        d553 = true
        if d537 and d537.delay_call then
            pcall(function() d537.delay_call(d551, d556) end)
        else
            d556()
        end
    end
end

local function d562(d563)
	if not d540 or not d540.ui or not d540.ui.paint_insults then
		return
	end
	local d564, d565= pcall(d539.get, d540.ui.paint_insults)
	if not d564 or not d565 then return end

	if not d563 then return end
	local d566= d563.userid
	local d567= d563.attacker
	if not d566 or not d567 then return end

	local d568= d538.get_local_player and d538.get_local_player()
	if not d568 or d568 == 0 then return end

	local d569= d537.userid_to_entindex and d537.userid_to_entindex(d566) or nil
	local d570= d537.userid_to_entindex and d537.userid_to_entindex(d567) or nil
	if d567 == d566 then return end
	if d570 == d568 and d569 ~= d568 then
        if #d547 > 0 then
            local d571= 1
            if d543 and d544 and d544.random_int then
                d571 = d544.random_int(1, #d547)
            else
                d571 = math.random(1, #d547)
            end
            local d557= d547[d571]
            d558(d557)
        end
		return
	end
	if d569 == d568 and d570 ~= d568 then
        if #d548 > 0 then
            local d571= 1
            if d543 and d544 and d544.random_int then
                d571 = d544.random_int(1, #d548)
            else
                d571 = math.random(1, #d548)
            end
            local d557= d548[d571]
            d558(d557)
        end
		return
	end
end

local d572, d573= pcall(require, "require/abc/callbacks")
if d572 and d573 and d573.callback then
    d573.callback('player_death', d562, { alive_only = true, require_login = true })
end]]
d958["require/features/paint/lagcomp_box"] = [=[


local g_net_data = {}
local g_sim_ticks = {}
local g_esp_data = {}


local menu_setup = require('require/abc/menu_setup')
local DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A = 47, 117, 221, 255


local floor = math.floor

local function length_sqr(x, y, z)
    return (x or 0) * (x or 0) + (y or 0) * (y or 0) + (z or 0) * (z or 0)
end

local function time_to_ticks(seconds)
    local ti = globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return floor((seconds or 0) / ti + 0.5)
end

local function extrapolate(ent, ticks)
    local ti = globals.tickinterval()
    if not ti then return nil end

    local g = (cvar.sv_gravity and cvar.sv_gravity:get_float() or 800) * ti
    local jump = (cvar.sv_jump_impulse and cvar.sv_jump_impulse:get_float() or 301) * ti

    local ox, oy, oz = entity.get_origin(ent)
    if not ox then return nil end

    local vx, vy, vz = entity.get_prop(ent, "m_vecVelocity")
    vx, vy, vz = vx or 0, vy or 0, vz or 0

    local gravity = (vz > 0) and -g or jump

    for i = 1, (ticks or 0) do
        local px, py, pz = ox, oy, oz

        ox = ox + (vx * ti)
        oy = oy + (vy * ti)
        oz = oz + (vz + gravity) * ti

        local frac = select(1, client.trace_line(ent or 0, px, py, pz, ox, oy, oz))
        if frac and frac <= 0.99 then
            return px, py, pz
        end
    end

    return ox, oy, oz
end


local edges = {
    {0, 1}, {1, 2}, {2, 3}, {3, 0}, {5, 6}, {6, 7}, {1, 4}, {4, 8},
    {0, 4}, {1, 5}, {2, 6}, {3, 7}, {5, 8}, {7, 8}, {3, 4}
}


local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
    local me = entity.get_local_player()
    if not me or not entity.is_alive(me) then return end

    
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box then
        local ok, enabled = pcall(ui.get, menu_setup.ui.paint_lagcomp_box)
        if ok and enabled == false then
            return
        end
    end

    
    local players = entity.get_players(true)
    for i = 1, #players do
        local ent = players[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local prev = g_sim_ticks[ent]
            local sim_time = entity.get_prop(ent, 'm_flSimulationTime')
            local ox, oy, oz = entity.get_origin(ent)

            if sim_time and ox then
                local sim_ticks = time_to_ticks(sim_time)

                if prev ~= nil then
                    local delta = sim_ticks - prev.tick
                    if delta < 0 or (delta > 0 and delta <= 64) then
                        local dx, dy, dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
                        local teleport_distance = length_sqr(dx, dy, dz)

                        local ex_ticks = math.max(delta - 1, 0)
                        local ex_x, ex_y, ex_z = extrapolate(ent, ex_ticks)
                        if delta < 0 then
                            g_esp_data[ent] = 1
                        end

                        g_net_data[ent] = {
                            tick = ex_ticks,
                            player = ent,
                            delta = delta,
                            origin = { x = ox, y = oy, z = oz },
                            extrapolated = (ex_x and { x = ex_x, y = ex_y, z = ex_z } or { x = ox, y = oy, z = oz }),
                            lagcomp = teleport_distance > 4096,
                            tickbase = delta < 3
                        }
                    end
                end

                if g_esp_data[ent] == nil then g_esp_data[ent] = 0 end
                g_sim_ticks[ent] = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
            else
                g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
            end
        else
            g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
        end
    end

    
    local r, g, b, a = DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box_color then
        local ok, rr, gg, bb, aa = pcall(ui.get, menu_setup.ui.paint_lagcomp_box_color)
        if ok and rr then
            r, g, b, a = rr, gg, bb, aa
        end
    end
    for ent, data in pairs(g_net_data) do
        if data and data.player and entity.is_alive(data.player) and not entity.is_dormant(data.player) and data.lagcomp then
            local minsx, minsy, minsz = entity.get_prop(data.player, 'm_vecMins')
            local maxsx, maxsy, maxsz = entity.get_prop(data.player, 'm_vecMaxs')
            if not minsx or not maxsx then goto continue_box end

            local ex = data.extrapolated.x
            local ey = data.extrapolated.y
            local ez = data.extrapolated.z

            local min = { x = (minsx or 0) + ex, y = (minsy or 0) + ey, z = (minsz or 0) + ez }
            local max = { x = (maxsx or 0) + ex, y = (maxsy or 0) + ey, z = (maxsz or 0) + ez }

            local points = {
                min,
                { x = min.x, y = max.y, z = min.z },
                { x = max.x, y = max.y, z = min.z },
                { x = max.x, y = min.y, z = min.z },
                { x = min.x, y = min.y, z = max.z },
                { x = min.x, y = max.y, z = max.z },
                max,
                { x = max.x, y = min.y, z = max.z }
            }

            for k, v in pairs(edges) do
                
                if k == 1 then
                    local ox, oy = renderer.world_to_screen(data.origin.x, data.origin.y, data.origin.z)
                    local mx, my = renderer.world_to_screen(min.x, min.y, min.z)
                    if ox and mx then
                        renderer.line(ox, oy, mx, my, r, g, b, 255)
                    end
                end
                local p1 = points[v[1]]
                local p2 = points[v[2]]
                if p1 and p2 then
                    local x1, y1 = renderer.world_to_screen(p1.x, p1.y, p1.z)
                    local x2, y2 = renderer.world_to_screen(p2.x, p2.y, p2.z)
                    if x1 and x2 then
                        renderer.line(x1, y1, x2, y2, r, g, b, 255)
                    end
                end
            end
            ::continue_box::
        end
    end

    
    for i = 1, #players do
        local ent = players[i]
        if not entity.is_alive(ent) or entity.is_dormant(ent) then goto continue_label end

        local x1, y1, x2, y2, alpha = entity.get_bounding_box(ent)
        if alpha == 0 then goto continue_label end

        local palpha = 0
        if g_esp_data[ent] ~= nil and g_esp_data[ent] > 0 then
            g_esp_data[ent] = g_esp_data[ent] - globals.frametime() * 2
            if g_esp_data[ent] < 0 then g_esp_data[ent] = 0 end
            palpha = g_esp_data[ent]
        end

        local tag = ''
        local data = g_net_data[ent]
        if data then
            local tb = data.tickbase
            local lc = data.lagcomp
            if (not tb) or lc then
                palpha = alpha
            end
            tag = tb and 'SHIFTING TICKBASE' or (lc and 'LAG COMP BREAKER' or '')
        end

        
            local name = entity.get_player_name(ent)
            local y_add = (name == '  ' or name == ' ' or name == '' or name == '   ') and 8 or 0
            local mid_x = x1 + (x2 - x1) / 2
            renderer.text(mid_x, y1 - 18 + y_add, 255, 45, 45, floor((palpha or 0) * 255), 'cb', 0, tag)
        

        ::continue_label::
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end

local function round_start_handler(ev)
    g_net_data = {}
    g_sim_ticks = {}
    g_esp_data = {}
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('round_start', round_start_handler, { alive_only = true, require_login = true })
end]=]
d958["require/features/paint/minimum_damage"] = [[local d543= require("require/abc/menu_setup")
local d544= require("require/help/drag")

local d545= {
    minimum_damage = ui.reference("RAGE", "Aimbot", "Minimum damage"),
    minimum_damage_override = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}

local d546= { client.screen_size() }

local d547= nil
do
    local d548, d549= client.screen_size()
    local d550= math.floor((d546[1] or d548 or 0) / 2 + 2)
    local d551= math.floor((d546[2] or d549 or 0) / 2 - 14)
    local d552= 30
    local d553, d554= 10, 18
    d547 = d544.new("minimum_damage_indicator", {
        x = d550 - math.floor(d553 / 2),
        y = d551 - math.floor(d554 / 2),
        w = d553,
        h = d554,
        snap = true,
        snap_threshold = 24,
        require_menu_open = true,
        constraint_center = { cx = d550, cy = d551, radius = d552 },
        default_center = { x = d550, y = d551 },
    })
end

local d555, d556= pcall(require, "require/abc/callbacks")
local function d557(d558)

    if not ui.get(d543.ui.paint_minimum_damage) then return end
    
    local d559= entity.get_local_player()
    if d559 == nil or not entity.is_alive(d559) then return end
    if d547 then
        pcall(function()
            d547:handle()
            d547:draw()
        end)
    end

    

    if ui.get(d545.minimum_damage_override[2]) then
        local d560, d561= d546[1] / 2 + 2, d546[2] / 2 - 14
        if d547 then
            pcall(function()
                d560 = d547.x + math.floor(d547.w / 2)
                d561 = d547.y + math.floor(d547.h / 2)
            end)
        end
        renderer.text(d560, d561, 255, 255, 255, 225, "d", 0, ui.get(d545.minimum_damage_override[3]) .. "")
    end

end

if d555 and d556 and d556.callback then
    d556.callback('paint', d557, { alive_only = true, require_login = true })
end]]
d958["require/features/paint/molotov_particles"] = [[local d546= ui
local d547= client
local d548= entity
local d549= renderer
local d550= globals
local d551= require("require/abc/menu_setup")
local d552= require('require/brain/api/vector/vector')
local d553= require('require/abc/callbacks')


local d554= {}


local d555= d552.make(0, 0, 0)
local d556= d552.make(0, 0, 0)

local d557= 128
local d558= 158
local d559= 48


local function d560()
    local d561= {}
    local d562= d548.get_all('inferno') or {}
    for _, v in ipairs(d562) do table.insert(d561, v) end
    local d563= d548.get_all('CInferno') or {}
    for _, v in ipairs(d563) do table.insert(d561, v) end
    return d561
end


local function d564(d565,d566,d567)
    offsets_templates = offsets_templates or {}
    local d568= tostring(d566) .. ':' .. tostring(d567)
    if offsets_templates[d568] then return offsets_templates[d568] end

    local d569= {}
    local d570= math.pi * (3 - math.sqrt(5))
    for i = 1, d566 do
        local d571= d567 * math.sqrt(i / d566)
        local d572= i * d570
        local d573= math.cos(d572) * d571
        local d574= math.sin(d572) * d571
        local d575= ((i % 24) - 12) 
        d569[i] = {d573, d574, d575}
    end
    offsets_templates[d568] = d569
    return d569
end

d553.register('paint', function()

    local d576= d548.get_local_player()
    if not d576 then return end
    if d551 and d551.ui and d551.ui.paint_molotov then
        local d577, d578= pcall(d546.get, d551.ui.paint_molotov)
        if d577 and not d578 then return end
    end

    local d566= math.max(1, math.floor(d557 or 24))
    local d567= math.max(1, math.floor(d558 or 100))
    local d579= math.max(1, math.floor(d559 or 6))

    
    local d580, d581, d582= d547.camera_position()
    d555.x = d580 or 0
    d555.y = d581 or 0
    d555.z = d582 or 0

    local d583= d560()
    if #d583 == 0 then return end

    for _, d565 in ipairs(d583) do
        local d584, d585, d586= d548.get_origin(d565)
        if d584 then
            local d568= tostring(d565) .. ":" .. tostring(d566) .. ":" .. tostring(d567)
            local d587= d554[d568]

            
            if not d587 or not d587.origin or
               math.abs(d587.origin[1] - d584) > 0.01 or
               math.abs(d587.origin[2] - d585) > 0.01 or
               math.abs(d587.origin[3] - d586) > 0.01 then
                local d569= d564(d565, d566, d567)
                local d588= {}
                for _, off in ipairs(d569) do
                    local d589= d584 + (off[1] or 0)
                    local d590= d585 + (off[2] or 0)
                    local d591= d586 + (off[3] or 0)
                    table.insert(d588, {d589, d590, d591})
                end
                d587 = { origin = {d584, d585, d586}, pts = d588 }
                d554[d568] = d587
            end

            for _, p in ipairs(d587.pts) do
                local d589, d590, d591= p[1], p[2], p[3]
                local d592, d593= d549.world_to_screen(d589, d590, d591)
                if d592 and d593 then
                    
                    d556.x = d589 - d555.x
                    d556.y = d590 - d555.y
                    d556.z = d591 - d555.z

                    local d594= d556.x
                    local d595= d556.y
                    local d596= d556.z
                    local d597= math.sqrt(d594*d594 + d595*d595 + d596*d596)

                    local d598= math.max(1, math.floor((200 / (d597 + 1)) * (d579 / 6)))
                    local d599= math.max(1, math.floor(d598 / 2))
                    d549.rectangle(d592 - d599, d593 - d599, d598, d598, 255, 24, 24, 255)
                end
            end
        end
    end
end, { alive_only = true, require_login = true })]]
d958["require/features/paint/onshot_skeleton"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")


local function find(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x, y, z = entity.hitbox_position(ent, def.names[i])
        if x then return x, y, z end
    end
    for i = 1, #(def.idx or {}) do
        local x, y, z = entity.hitbox_position(ent, def.idx[i])
        if x then return x, y, z end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local sk = {list = {}}

local function is_skeleton_enabled()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_hitmarker then
        local ok, sel = pcall(ui.get, menu_setup.ui.paint_hitmarker)
        if not ok then return false end
        if type(sel) == "table" then
            for _, v in ipairs(sel) do
                if v == "skeleton" then return true end
            end
        end
        return false
    end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function aim_fire_handler(ev)
    if not is_skeleton_enabled() then sk.list = {} return end
    if not is_skeleton_enabled() then return end
    local target = ev and (ev.target or ev.target_index)
    if type(target) ~= 'number' or target == 0 then return end
    local pts = snap(target)
    if not pts then return end
    local now = globals.realtime and globals.realtime() or 0
    sk.list[#sk.list + 1] = {pts = pts, t = now}
    if #sk.list > 5 then table.remove(sk.list, 1) end
end

local function paint_handler(ev)
    if is_skeleton_enabled() then
        local now = globals.realtime and globals.realtime() or 0
        local hold = 2.2 * 0.8 * 3
        local fade = 2.2 * 0.8
        local total = hold + fade
        local i = 1
        while i <= #sk.list do
            if now - (sk.list[i].t or 0) > total then
                table.remove(sk.list, i)
            else
                i = i + 1
            end
        end
        table.sort(sk.list, function(a, b) return (a.t or 0) < (b.t or 0) end)
        local start = math.max(1, #sk.list - 2)
        for j = start, #sk.list do
            local it = sk.list[j]
            local age = now - (it.t or 0)
            local alpha = age <= hold and 220 or math.floor(math.max(0, (1 - math.max(0, age - hold) / fade) * 220))
            if alpha > 0 then
                local pts = it.pts or {}
                for c = 1, #chains do
                    local chain = chains[c]
                    local from, to = pts[chain[1]], pts[chain[2]]
                    if from and to then
                        local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                        local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                        if fx and tx then renderer.line(fx, fy, tx, ty, 255, 255, 255, alpha) end
                    end
                end
            end
        end
    else
        sk.list = {}
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('aim_fire', aim_fire_handler, { alive_only = true, require_login = true })
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
else
    client.set_event_callback('aim_fire', aim_fire_handler)
    client.set_event_callback('paint', paint_handler)
end]=]
d958["require/features/paint/performance_mode"] = [[



local d552, d553= pcall(require, "require/abc/menu_setup")


local d554= nil
pcall(function() d554 = require('require/abc/callbacks') end)
if not d554 then error("callbacks manager required: require/abc/callbacks") end


local d555= {
    captured = false
}

local d556= {
    blood = nil,
    ragdolls = nil,
    particles = nil,
    lensflare = nil,
    animations = nil,
    features = nil,
}

local function d557()
    if d555.captured then return end
    local function d558(d559,d560)
        local d552, d561= pcall(client.get_cvar, d559)
        if d552 and d561 then return d561 end
        return d560
    end

    d555.violence_hblood = d558('violence_hblood', '1')
    d555.cl_ragdoll_physics_enable = d558('cl_ragdoll_physics_enable', '1')
    d555.r_drawparticles = d558('r_drawparticles', '1')
    d555.mat_disable_bloom = d558('mat_disable_bloom', '0')
    d555.captured = true
end

local function d562(d559,d563)
    
    pcall(client.exec, string.format('%s %s', d559, tostring(d563)))
end

local function d564(d565,d566)
    if d565 == 'blood' then
        if d566 then d562('violence_hblood', 0) else d562('violence_hblood', d555.violence_hblood or 1) end
    elseif d565 == 'ragdolls' then
        if d566 then d562('cl_ragdoll_physics_enable', 0) else d562('cl_ragdoll_physics_enable', d555.cl_ragdoll_physics_enable or 1) end
    elseif d565 == 'particles' then
        if d566 then d562('r_drawparticles', 0) else d562('r_drawparticles', d555.r_drawparticles or 1) end
    elseif d565 == 'lensflare' then
        if d566 then d562('mat_disable_bloom', 1) else d562('mat_disable_bloom', d555.mat_disable_bloom or 0) end
    end
end

local function d567(d568)
    
    
    if d568['animations'] then
        _G.PERFORMANCE_ANIMATIONS = false
    else
        
        _G.PERFORMANCE_ANIMATIONS = true
    end

    if d568['feature updates'] then
        _G.PERFORMANCE_FEATURE_UPDATES = false
    else
        _G.PERFORMANCE_FEATURE_UPDATES = true
    end
end

local function d569(d570)
    local d571= {}
    if type(d570) == 'table' then
        for _, d561 in ipairs(d570) do d571[d561] = true end
    end
    return d571
end


d554.register('paint', function()
    if not d552 or not d553 or not d553.ui or not d553.ui.paint_performance_mode then return end
    d557()

    local d572= ui.get(d553.ui.paint_performance_mode)
    local d568= d569(d572)

    
    local d573= d568['blood'] or false
    if d573 ~= d556.blood then
        d564('blood', d573)
        d556.blood = d573
    end

    
    d573 = d568['ragdolls'] or false
    if d573 ~= d556.ragdolls then
        d564('ragdolls', d573)
        d556.ragdolls = d573
    end

    
    d573 = d568['particles'] or false
    if d573 ~= d556.particles then
        d564('particles', d573)
        d556.particles = d573
    end

    
    d573 = d568['lens flare'] or false
    if d573 ~= d556.lensflare then
        d564('lensflare', d573)
        d556.lensflare = d573
    end

    
    d573 = d568['animations'] or false
    if d573 ~= d556.animations then
        
        d567(d568)
        d556.animations = d573
        d556.features = d568['feature updates'] or false
    end

    
    local d574= d568['feature updates'] or false
    if d574 ~= d556.features then
        d567(d568)
        d556.features = d574
    end
end, { require_login = true, alive_only = true })


d554.register('shutdown', function()
    if d555.captured then
        pcall(d562, 'violence_hblood', d555.violence_hblood)
        pcall(d562, 'cl_ragdoll_physics_enable', d555.cl_ragdoll_physics_enable)
        pcall(d562, 'r_drawparticles', d555.r_drawparticles)
        pcall(d562, 'mat_disable_bloom', d555.mat_disable_bloom)
    end
    
    _G.PERFORMANCE_ANIMATIONS = true
    _G.PERFORMANCE_FEATURE_UPDATES = true
end, { require_login = true, alive_only = true })


if _G.PERFORMANCE_ANIMATIONS == nil then _G.PERFORMANCE_ANIMATIONS = true end
if _G.PERFORMANCE_FEATURE_UPDATES == nil then _G.PERFORMANCE_FEATURE_UPDATES = true end

return {
    _internal = {
        orig = d555,
        last_state = d556,
    }
}
]]
d958["require/features/paint/presmoke_warning"] = [[local d555= { start = nil, limit = nil }

client.set_event_callback("round_start", function(d556)
	d555.start = globals.curtime()
	d555.limit = tonumber(d556.timelimit) or tonumber(d556.round_time) or 115
end)

local function d557()
	local d558= entity.get_game_rules()
	if not d558 then return nil end
	local d559= {
		"m_flGameTimeRemaining",
		"m_flRoundTimeRemaining",
		"m_fRoundStartTime",
		"m_flRoundStartTime",
		"m_iRoundTime",
		"m_iRoundTimeLimit",
	}
	for _, name in ipairs(d559) do
		local d560, d561= pcall(entity.get_prop, d558, name)
		if d560 and d561 and type(d561) == "number" then
			if name:lower():find("remain") then
				return math.max(0, d561)
			end
		end
	end
	local d562= nil
	for _, name in ipairs({"m_fRoundStartTime", "m_flRoundStartTime"}) do
		local d560, d561= pcall(entity.get_prop, d558, name)
		if d560 and d561 and type(d561) == "number" then
			d562 = d561
			break
		end
	end
	if d562 then
		local d563= nil
		local d560, d564= pcall(entity.get_prop, d558, "m_iRoundTime")
		if d560 and d564 and type(d564) == "number" then d563 = d564 end
		if not d563 then
			d563 = tonumber(client.get_cvar("mp_roundtime")) or tonumber(client.get_cvar("mp_roundtime_defuse"))
		end
		if d563 and type(d563) == "number" then
			local d565= d563 - (globals.curtime() - d562)
			return math.max(0, d565)
		end
	end
	return nil
end

local function d566()
	if d555.start and d555.limit then
		local d567= globals.curtime() - d555.start
		local d565= d555.limit - d567
		if d565 < 0 then d565 = 0 end
		return d565
	end
	return d557()
end

client.set_event_callback("paint", function()
	local d568, d569= pcall(require, "require/abc/menu_setup")
	if not d568 or not d569 or not d569.ui then return end
	local d570, d571= pcall(ui.get, d569.ui.paint_presmoke)
	if not d570 or not d571 then return end

	local d565= d566()
	if not d565 then return end
	if d565 <= 18 then
		local d572, d573= client.screen_size()
		local d574= d572 * 0.5
		local d575= math.floor(d573 * 0.3)
		local d576= string.format("%.2f", d565)
		local d577= string.format("PRESMOKE NOW PRESMOKE NOW %s", d576)
		renderer.text(d574, d575, 255, 30, 30, 255, "cb+", 0, d577)
	end
end)

client.set_event_callback("round_end", function()
	d555.start = nil
	d555.limit = nil
end)

client.set_event_callback("cs_game_disconnected", function()
	d555.start = nil
	d555.limit = nil
end)

]]
d958["require/features/paint/self_boxes"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end


local ui_extrap_check, ui_extrap_ticks, ui_extrap_color
local ui_pred3d_check
local ui_pred3d_scale
if not (menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation) then
  
  ui_extrap_check = ui.new_checkbox('LUA', 'B', 'Self: Extrapolation Line')
  ui_extrap_ticks = ui.new_slider('LUA', 'B', 'Extrapolation ticks', 1, 64, 6)
  ui_extrap_color = ui.new_color_picker('LUA', 'B', 'Extrapolation color', 255, 200, 0, 220)
  ui_pred3d_check = ui.new_checkbox('LUA', 'B', 'Self: Predicted 3D Box')
  ui_pred3d_scale = ui.new_slider('LUA', 'B', 'Predicted 3D Box Scale %', 0, 200, 20)
end

local function is_self_extrapolation_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation)
    if ok then return val end
  elseif ui_extrap_check then
    local ok, val = pcall(ui.get, ui_extrap_check)
    if ok then return val end
  end
  return false
end

local function get_extrap_ticks()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_ticks then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_ticks)
    if ok then return val end
  elseif ui_extrap_ticks then
    local ok, val = pcall(ui.get, ui_extrap_ticks)
    if ok then return val end
  end
  return 6
end

local function get_extrap_color()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_color then
    local ok, r,g,b,a = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_color)
    if ok then return r,g,b,a end
  elseif ui_extrap_color then
    local ok, r,g,b,a = pcall(ui.get, ui_extrap_color)
    if ok then return r,g,b,a end
  end
  return 255,200,0,220
end

local function is_predicted_3d_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d)
    if ok then return val end
  elseif ui_pred3d_check then
    local ok, val = pcall(ui.get, ui_pred3d_check)
    if ok then return val end
  end
  return false
end

local function get_pred3d_scale()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d_scale then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d_scale)
    if ok then return val end
  elseif ui_pred3d_scale then
    local ok, val = pcall(ui.get, ui_pred3d_scale)
    if ok then return val end
  end
  return 20
end

client.set_event_callback('paint',function()
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  
  local _lp_state = client.globals and client.globals.__self_lc_state or nil
  if not _lp_state then
    _lp_state = {}
    client.globals = client.globals or {}
    client.globals.__self_lc_state = _lp_state
  end
  local function length_sqr(x,y,z)
    x = x or 0; y = y or 0; z = z or 0
    return x*x + y*y + z*z
  end
  local function time_to_ticks(seconds)
    local ti = globals.tickinterval and globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return math.floor((seconds or 0) / ti + 0.5)
  end
  local function is_local_breaking_lagcomp()
    local sim_time = entity.get_prop(lp, 'm_flSimulationTime')
    local ox,oy,oz = entity.get_origin(lp)
    if not sim_time or not ox then return false end
    local sim_ticks = time_to_ticks(sim_time)
    local prev = _lp_state.prev
    local breaking = false
    if prev then
      local delta = sim_ticks - prev.tick
      if delta > 0 and delta <= 64 then
        local dx,dy,dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
        local teleport_distance = length_sqr(dx,dy,dz)
        if teleport_distance > 4096 then breaking = true end
      end
    end
    _lp_state.prev = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
    return breaking
  end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end

  
  if is_self_extrapolation_enabled() then
    local ox,oy,oz = entity.get_origin(lp)
    if ox and oy and oz then
      local vx,vy,vz = entity.get_prop(lp, "m_vecVelocity")
      if vx and vy and vz then
        local ticks = get_extrap_ticks() or 6
        local tickint = (globals.tickinterval and globals.tickinterval()) or 0.015625
        local dt = tickint * ticks
        local px,py,pz = ox + vx * dt, oy + vy * dt, oz + vz * dt
        local sx1,sy1 = renderer.world_to_screen(ox,oy,oz)
        local sx2,sy2 = renderer.world_to_screen(px,py,pz)
        if sx1 and sx2 then
          local r,g,b,a = get_extrap_color()
          renderer.line(sx1,sy1,sx2,sy2, r, g, b, a)
          renderer.circle(sx2,sy2, r, g, b, a, 6, 0, 1.0)
          renderer.text(sx2, sy2 - 10, r, g, b, a, 'c+', 0, tostring(ticks) .. 't')
          
          local bx1,by1,bx2,by2,alpha_mult = entity.get_bounding_box(lp)
          if bx1 and alpha_mult and alpha_mult ~= 0 then
            local sx_orig, sy_orig = sx1, sy1
            if sx_orig and sy_orig then
              local dx, dy = sx2 - sx_orig, sy2 - sy_orig
              local bw, bh = (bx2 - bx1), (by2 - by1)
              local pbx, pby = bx1 + dx, by1 + dy
              
              renderer.rectangle(pbx, pby, bw, bh, 255,255,255,40)
              renderer.rectangle(pbx-1, pby-1, bw+2, bh+2, 255,255,255,200)
            end
          end

          
          if is_predicted_3d_enabled() and is_local_breaking_lagcomp() then
            
            local o = {x = ox, y = oy, z = oz}
            local offs = {}
            local keys = {'head','pelvis','l_shoulder','r_shoulder','l_hip','r_hip'}
            for i=1,#keys do
              local def = boxes[keys[i]]
              if def then
                local ok, hx, hy, hz = pcall(function() return find(lp, def) end)
                if ok and hx then
                  table.insert(offs, {x = hx - o.x, y = hy - o.y, z = hz - o.z})
                end
              end
            end
            if #offs > 0 then
              local minx,miny,minz = offs[1].x,offs[1].y,offs[1].z
              local maxx,maxy,maxz = offs[1].x,offs[1].y,offs[1].z
              for i=2,#offs do
                local v = offs[i]
                if v.x < minx then minx = v.x end
                if v.y < miny then miny = v.y end
                if v.z < minz then minz = v.z end
                if v.x > maxx then maxx = v.x end
                if v.y > maxy then maxy = v.y end
                if v.z > maxz then maxz = v.z end
              end
              
              local scale_pct = 105
              local cx = (minx + maxx) * 0.5
              local cy = (miny + maxy) * 0.5
              local cz = (minz + maxz) * 0.5
              local ex = (maxx - minx) * 0.5 * (1 + scale_pct / 100)
              local ey = (maxy - miny) * 0.5 * (1 + scale_pct / 100)
              local ez = (maxz - minz) * 0.5 * (1 + scale_pct / 100)
              minx = cx - ex; maxx = cx + ex
              miny = cy - ey; maxy = cy + ey
              minz = cz - ez; maxz = cz + ez

              
              local corners = {
                {x = px + minx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + maxy, z = pz + maxz},
                {x = px + minx, y = py + maxy, z = pz + maxz},
              }
              
              local sc = {}
              local all_on_screen = true
              for i=1,8 do
                local sx, sy = renderer.world_to_screen(corners[i].x, corners[i].y, corners[i].z)
                if not sx then all_on_screen = false break end
                sc[i] = {x = sx, y = sy}
              end
              if all_on_screen then
                
                local rr,gg,bb,aa = 255,255,255,200
                
                renderer.line(sc[1].x,sc[1].y,sc[2].x,sc[2].y, rr,gg,bb,aa)
                renderer.line(sc[2].x,sc[2].y,sc[3].x,sc[3].y, rr,gg,bb,aa)
                renderer.line(sc[3].x,sc[3].y,sc[4].x,sc[4].y, rr,gg,bb,aa)
                renderer.line(sc[4].x,sc[4].y,sc[1].x,sc[1].y, rr,gg,bb,aa)
                
                renderer.line(sc[5].x,sc[5].y,sc[6].x,sc[6].y, rr,gg,bb,aa)
                renderer.line(sc[6].x,sc[6].y,sc[7].x,sc[7].y, rr,gg,bb,aa)
                renderer.line(sc[7].x,sc[7].y,sc[8].x,sc[8].y, rr,gg,bb,aa)
                renderer.line(sc[8].x,sc[8].y,sc[5].x,sc[5].y, rr,gg,bb,aa)
                
                for i=1,4 do renderer.line(sc[i].x,sc[i].y,sc[i+4].x,sc[i+4].y, rr,gg,bb,aa) end
              end
            end
          end
        end
      end
    end
  end
end)]=]
d958["require/features/paint/self_skeleton"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end
end

if cb_ok and callbacks and callbacks.callback then
  callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end]=]
d958["require/features/paint/skeletons"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}


local time = require("require/help/time")
local enemies = require("require/help/enemies")
local color = require("require/help/color")
local math_help = require("require/help/math")




local function find(ent, def)
    if not ent or not def then return end
    local names = def.names
    if names then
        for i = 1, #names do
            local x, y, z = entity.hitbox_position(ent, names[i])
            if x then return x, y, z end
        end
    end
    local idx = def.idx
    if idx then
        for i = 1, #idx do
            local x, y, z = entity.hitbox_position(ent, idx[i])
            if x then return x, y, z end
        end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    return pts
end


client.set_event_callback("paint", function()
    local enemy_list = entity.get_players(true)
    for i = 1, #enemy_list do
        local ent = enemy_list[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local pts = snap(ent)
            for _, chain in ipairs(chains) do
                local from = pts[chain[1]]
                local to = pts[chain[2]]
                if from and to then
                    local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                    local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                    if fx and fy and tx and ty then
                        renderer.line(fx, fy, tx, ty, 255, 0, 0, 255)
                    end
                end
            end
        end
    end
end)

]=]
d958["require/features/paint/target_info"] = [[local d567= require("require/abc/menu_setup")
local d568= renderer
local d569= client


local d570= nil
local function d571()
	if d570 then return d570 end
	if d568.load_rgba then
		local d572, d573= pcall(d568.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if d572 and d573 then d570 = d573 end
	end
	return d570
end




local d574= state or {
	fl_val = math.random(0, 14),
	fl_target = math.random(0, 14),
	by_val = math.random(-58, 58),
	by_target = math.random(-58, 58),
	last_update = d569.system_time()
}


local function d575()
	d574.fl_val = math.random(0, 14)
	d574.by_val = math.random(-58, 58)
end



local function d576()
	local d577= d569.system_time()
	if d577 - d574.last_update > 1 then
		d574.fl_target = math.random(0, 14)
		d574.by_target = math.random(-58, 58)
		d574.last_update = d577
	end
end

local function d578()
	d574.fl_val = d574.fl_val + (d574.fl_target - d574.fl_val) * 0.08
	d574.by_val = d574.by_val + (d574.by_target - d574.by_val) * 0.08
end

local function d579()
	if not ui.get(d567.ui.paint_target_info) then return end

	d576()
	d578()
	d575() 

	
	local d580, d581= d569.screen_size()
	local d582= 170
	local d583= 80
	local d584= 30
	local d585= math.floor(d581 / 2 - d583 / 2)

	
	d568.rectangle(d584 - 7, d585 - 5, d582 + 14, d583 + 10, 0, 0, 0, 200)
	d568.rectangle(d584 - 6, d585 - 4, d582 + 12, d583 + 8, 60, 60, 60, 255)
	d568.rectangle(d584 - 5, d585 - 3, d582 + 10, d583 + 6, 40, 40, 40, 255)
	d568.rectangle(d584 - 3, d585 - 1, d582 + 6, d583 + 2, 60, 60, 60, 255)
	d568.rectangle(d584 - 2, d585, d582 + 4, d583, 12, 12, 12, 255)
	d568.rectangle(d584 - 2, d585, d582 + 4, d583, 32, 32, 32, 255)

	
	local d586= d571()
	if d586 and d568.texture then
		d568.texture(d586, d584 - 2, d585, d582 + 4, d583, 255,255,255,60, 'r')
	end

	
	local d587= d585
	local d588= 1
	local d589= math.floor((d582 + 4) / 2)
	local d590= math.ceil((d582 + 4) / 2)
	
	d568.rectangle(d584 - 2, d587 - 1, d582 + 4, d588 + 2, 0, 0, 0, 255)
	if d568.gradient then
		d568.gradient(d584 - 2, d587, d589, d588, 59,175,222,255, 202,70,205,255, true)
		d568.gradient(d584 - 2 + d589, d587, d590, d588, 202,70,205,255, 204,227,53,255, true)
	end

	
	local d591= d584 + 12
	local d592= d585 + 13  
	local d593= 18
	local d594= d582 - 60 
	local d595= 7 

	
	local d596= math.floor(d574.fl_val + 0.5)
	
	local d597= d595 / 2 - 7
	d568.text(d591 - 8, d592 + d597, 255,255,255,255, '', 0, "Fake lag")
	local d598= d591 + 42 
	local d599= d592 + 6  
	local d600= 14
	local d601= math.floor(d594 * (d574.fl_val / d600))
	
	local d602= d594 + 2
	local d603= d595 + 2
	local d604= d598 + 1
	local d605= d599 + 1
	local d606= d594 - 2
	local d607= d595 - 2
	d568.rectangle(d598 - 1, d599 - 1, d602, d603, 0, 0, 0, 255)
	d568.rectangle(d598, d599, d594, d595, 60, 60, 60, 255)
	d568.rectangle(d604, d605, math.max(0, math.floor(d606 * (d574.fl_val / d600))), d607, 180, 220, 80, 255)
	local d608= d598 + d601 - 4
	local d609= d599 + d595 / 2
	d568.circle(d608, d609, 5, 180,220,80,255, 16)
	
	local d610= tostring(d596)
	local d611= d598 + d601 + 8 
	local d612= d599 + d595 + 0 
	d568.text(d611 + 1, d612 + 1, 0,0,0,255, '-', 0, d610)
	d568.text(d611, d612, 255,255,255,255, '-', 0, d610)

	
	local d613= math.floor(d574.by_val + 0.5)
	d568.text(d591 - 8, d592 + d593 + d597, 255,255,255,255, '', 0, "Body yaw")
	local d614= d591 + 42 
	local d615= d592 + d593 + 6  
	local d616= -58
	local d617= 58
	local d618= d617 - d616
	
	local d619= math.floor(d594 * ((d574.by_val - d616) / d618))
	
	local d620= d594 + 2
	local d621= d595 + 2
	local d622= d614 + 1
	local d623= d615 + 1
	local d624= d594 - 2
	local d625= d595 - 2
	d568.rectangle(d614 - 1, d615 - 1, d620, d621, 0, 0, 0, 255)
	d568.rectangle(d614, d615, d594, d595, 60, 60, 60, 255)
	
	local d626= d614 + d594 / 2
	local d627= d614 + d619
	if d574.by_val < 0 then
		d568.rectangle(d627 + 1, d623, d626 - d627, d625, 180, 220, 80, 255)
	else
		d568.rectangle(d626 + 1, d623, d627 - d626, d625, 180, 220, 80, 255)
	end
	local d628= d627 - 4
	local d629= d615 + d595 / 2
	d568.circle(d628, d629, 5, 180,220,80,255, 16)
	
	local d630= tostring(d613)
	local d631= d614 + d619
	local d632= d631 + 8 
	local d633= d615 + d595 + 0 
	d568.text(d632 + 1, d633 + 1, 0,0,0,255, '-', 0, d630)
	d568.text(d632, d633, 255,255,255,255, '-', 0, d630)

	
	local d634= 22
	local d635= 14

	
	local d636= math.random() > 0.5 and "[Offensive]" or "[Defensive]"
	local d637= d636 == "[Offensive]" and {204,227,53,255} or {202,70,205,255}
	d568.text(d591 - 8, d592 + d593 * 2 + d597, 255,255,255,255, '', 0, "Double tap")
	local d638= d591 + d594 + 32
	local d639= d592 + d593 * 2 - 2
	d568.text(d638 + 4, d639 + 2, table.unpack(d637), '', 0, d636)

	
	local d640= math.random() > 0.5 and "[On]" or "[Off]"
	local d641= d640 == "[On]" and {80,255,80,255} or {255,255,80,255}
	d568.text(d591 - 8, d592 + d593 * 3 + d597, 255,255,255,255, '', 0, "Freestanding")
	local d642= d591 + d594 + 32
	local d643= d592 + d593 * 3 - 2
	d568.text(d642 + 4, d643 + 2, table.unpack(d641), '', 0, d640)
end

local d644= require("require/abc/callbacks")
d644.callback('paint', d579, { alive_only = true, require_login = true })
]]
d958["require/features/paint/text_watermark"] = [[local d570= require("require/help/string")
local d571= require("require/help/time")
local d572= require("require/help/color")
local d573= d572.rgba_to_hex
local d574= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local d575= nil

local function d576(d577,d578,d579,d580,d581,d582,d583)
    local d584= d571.realtime() or globals.curtime()
    if not d583 or #d583 == 0 then return "" end
    local d585= {}

    if d577 == 0 then
        local d586= d573(d579,d580,d581,d582)
        for i=1,#d583 do d585[#d585+1] = d586 .. d583:sub(i,i) end
        return table.concat(d585)
    end

    if d577 == 2 then
        local d587= (math.sin(d584 * d578) + 1) * 0.5
        local d588= d572.clamp(math.floor(d582 * (0.45 + 0.55 * d587)))
        local d586= d573(d579,d580,d581,d588)
        for i=1,#d583 do d585[#d585+1] = d586 .. d583:sub(i,i) end
        return table.concat(d585)
    end

    if d577 == 3 then
        for i=1,#d583 do
            local d589= math.sin(d584 * d578 - i * 0.6)
            local d590= math.max(0, d589)
            local d587= d590 * d590
            local d588= d572.clamp(math.floor(d582 * (0.35 + 0.65 * d587)))
            d585[#d585+1] = d573(d579,d580,d581,d588) .. d583:sub(i,i)
        end
        return table.concat(d585)
    end

    for i=1,#d583 do
        local d587= (math.sin(d584*d578 - i*0.35) + 1) * 0.5
        local d588= d572.clamp(math.floor(d582 * (0.4 + 0.6 * d587)))
        d585[#d585+1] = d573(d579,d580,d581,d588) .. d583:sub(i,i)
    end
    return table.concat(d585)
end

local d591= {}
local d592= {}
for i, item in ipairs({
    { 'misc', 'settings', 'menu color' },
}) do
    local d593= {ui.reference(item[1], item[2], item[3])}
    d591[i] = d593
    for _, ref in ipairs(d593) do
        d592[ref] = true
    end
end

local d594, d595= pcall(require, "require/abc/callbacks")
local function d596(d597)
    local d598, d599= client.screen_size()
    if not d598 or not d599 then return end
    local d600, d601, d602, d603= 255, 255, 255, 255
    
    local d604= false
    local d605, d606= pcall(require, "require/abc/menu_setup")
    if d605 and d606 and d606.ui and d606.ui.paint_advertisement_color then
        local d607, d582, d581, d608, d609= pcall(ui.get, d606.ui.paint_advertisement_color)
        if d607 then
            d604 = true
            if type(d582) == 'number' then
                d600 = d572.clamp(d582 or d600)
                d601 = d572.clamp(d581 or d601)
                d602 = d572.clamp(d608 or d602)
                d603 = d572.clamp(d609 or d603)
            elseif type(d582) == 'string' and #d582 == 12 then
                local d610
                d610, mr = pcall(function() return tonumber(d582:sub(1,3)) end)
                d610, mg = pcall(function() return tonumber(d582:sub(4,6)) end)
                d610, mb = pcall(function() return tonumber(d582:sub(7,9)) end)
                d610, ma = pcall(function() return tonumber(d582:sub(10,12)) end)
                d600 = d572.clamp(d600 or 255); d601 = d572.clamp(d601 or 255); d602 = d572.clamp(d602 or 255); d603 = d572.clamp(d603 or 255)
            end
        end
    end

    if not d604 then
        local d607, d582, d581, d608, d609= pcall(ui.get, d591[1][1])
        if d607 then
            if type(d582) == 'number' then
                d600 = d572.clamp(d582 or d600)
                d601 = d572.clamp(d581 or d601)
                d602 = d572.clamp(d608 or d602)
                d603 = d572.clamp(d609 or d603)
            elseif type(d582) == 'string' and #d582 == 12 then
                local d610
                d610, mr = pcall(function() return tonumber(d582:sub(1,3)) end)
                d610, mg = pcall(function() return tonumber(d582:sub(4,6)) end)
                d610, mb = pcall(function() return tonumber(d582:sub(7,9)) end)
                d610, ma = pcall(function() return tonumber(d582:sub(10,12)) end)
                d600 = d572.clamp(d600 or 255); d601 = d572.clamp(d601 or 255); d602 = d572.clamp(d602 or 255); d603 = d572.clamp(d603 or 255)
            end
        end
    end

    local d605, d606= pcall(require, "require/abc/menu_setup")
    if not d605 or not d606 or not d606.ui then return end
    if not ui.get(d606.ui.paint_advertisement) then return end
    local d584= d571.realtime() or globals.curtime()
    local d611= 0
    local d612= math.floor(200 + 55 * (math.sin(d584*2)+1)/2)
    local d613, d614, d615= "sodium", "[BETA]", 3

    local d616, d617= renderer.measure_text("", d613)
    d616 = d616 or 0; d617 = d617 or 16
    local d618= (renderer.measure_text("", d614) or 0)

    if d574 and not d575 then
        local d619= math.floor(d598/2 - (d616 + d615 + d618)/2)
        local d620= math.floor(d599 - 15)
        d575 = d574.new('sodium_watermark', {
            x = d619,
            y = d620,
            w = d616 + d615 + d618,
            h = d617,
                default_pos = { x = d619, y = d620 },
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
        })
    end

    if d575 then
        d575:handle()
    end

    local d621, d622
    if d575 then
        d621 = d575.x
        d622 = d575.y + d611
    else
        d621 = math.floor(d598/2 - (d616 + d615 + d618)/2)
        d622 = d599 - 15 + d611
    end

    local d623= math.floor(math.max(0, d612 - 140) * 0.6)
    local d624= { {-1,0},{1,0},{0,-1},{0,1} }

    if d575 then d575:draw() end

    for _,o in ipairs(d624) do renderer.text(d621+o[1], d622+o[2], 0,0,0, d623, "", 0, d613) end
    renderer.text(d621, d622, 255,255,255, d612, "", 0, d613)

    local d625= 1
    local d626, d627= pcall(require, "require/abc/menu_setup")
    if d626 and d627 and d627.ui and d627.ui.paint_advertisement_animation then
        local d628, d629= pcall(ui.get, d627.ui.paint_advertisement_animation)
        if d628 and type(d629) == 'number' then d625 = d629 end
    end

    local d630= d621 + d616 + d615
    local d631= d576(d625, 3.5, d600, d601, d602, d603, d614)
    renderer.text(d630, d622, d600, d601, d602, d603, "", 0, d631)
end

if d594 and d595 and d595.callback then
    d595.callback('paint', d596, { alive_only = true, require_login = true })
end]]
d958["require/features/paint/third_person_distance"] = [[local d573= require("require/abc/menu_setup")
local d574= require("require/help/time")
local d575= require("require/help/math")
local d576= require("require/help/safe")
local d577= { original = nil, last = nil, last_update = nil }

local function d578()
    if cvar.cam_idealdist and cvar.cam_idealdist.get_float then
        return cvar.cam_idealdist:get_float()
    end
    return nil
end

local function d579(d580)
    if cvar.cam_idealdist and cvar.cam_idealdist.set_float then
        cvar.cam_idealdist:set_float(d580)
        return true
    elseif client and client.exec then
        client.exec("cam_idealdist " .. tostring(d580))
        return true
    end
    return false
end

local d581= require("require/abc/callbacks")
d581.callback('paint', function()
    local d582= d573.ui and d573.ui.paint_third_person_distance
    if not d582 then
        client.log('third_person_distance: menu ref missing')
        return
    end
    local d583= d576.safe_get(d582)
    if type(d583) ~= 'number' then
        client.log('third_person_distance: invalid slider value', tostring(d583))
        return
    end
    local d584= d575.clamp(d583, 29, 180)
    d584 = d575.round(d584, 2)
    if d577.original == nil then
        d577.original = d578()
        if d577.original == nil then
            client.log('third_person_distance: cam_idealdist cvar not available')
        end
    end
    if d577.last == nil then
        d577.last = d578() or d584
    end
    local d585= d574.realtime()
    local d586= d577.last_update or d585
    local d587= d585 - d586
    d577.last_update = d585
    local d588= 300
    local d589= d588 * d587
    if math.abs(d577.last - d584) > 0.01 then
        local d590= d575.clamp(d589 / math.max(math.abs(d584 - d577.last), 0.01), 0, 1)
        d577.last = d575.lerp(d577.last, d584, d590)
        d577.last = d575.round(d577.last, 2)
        d579(d577.last)
    end
end, { require_login = true })]]
d958["require/features/paint/warnings"] = [[local d576, d577= client.screen_size()
local d578, d579= pcall(require, "require/abc/menu_setup")


local function d580()
    
    if not d578 or not d579 or not d579.ui or not d579.ui.paint_warnings then return end
    local d581= ui.get(d579.ui.paint_warnings)
    local d582= false
    if type(d581) == "table" then
        for _, v in ipairs(d581) do
            if v == "lethal" then d582 = true break end
        end
    end
    if not d582 then return end

    if entity.get_prop(entity.get_local_player(), 'm_iHealth') and entity.get_prop(entity.get_local_player(), 'm_iHealth') > 0 and entity.get_prop(entity.get_local_player(), 'm_iHealth') < 93 then
        renderer.text(d576 / 2, d577 * 0.3, 255, 0, 0, 255, "c, -", 0, "YOU'RE LETHAL:   " .. entity.get_prop(entity.get_local_player(), 'm_iHealth') .. " HP REMAINING")
    end
    
end

local d583, d584= pcall(require, "require/abc/callbacks")
if d583 and d584 then
    d584.callback('paint', d580, { alive_only = true, require_login = true })
end]]
d958["require/features/paint/watermark_gamesense"] = [[local d579= renderer
local d580= client
local d581= globals
local d582= require('require/help/color')

local d583= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local d584= nil

local function d585()
	local d586= d581 and d581.frametime and d581.frametime() or 0.016
	if d586 > 0 then
		return math.floor(1 / d586 + 0.5)
	end
	return 0
end

local d587= nil
local function d588()
	if d587 then return d587 end
	if d579.load_rgba then
		local d589, d590= pcall(d579.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if d589 and d590 then d587 = d590 end
	end
	return d587
end

local d591= d582.hex_to_rgba

local d592= {
	green  = "a5ca2aFF",
	red    = "d96464FF",
	yellow = "ccb854FF",
	blue   = "5462ccFF",
	purple = "7054ccFF",
	white  = "ffffffFF",
	grey   = "757575FF",
	black  = "000000FF",
	pink   = "c8a2deFF",
}


local d593= require("require/abc/login_system")
local d594= require("require/abc/menu_setup")
local d595= require("require/help/self")

local d596= require("require/help/time")
local d597= 0
local d598= d596.new(0.25)

local function d599()
	if not d594 or not d594.ui then return end
	
	local d600, d601= pcall(ui.get, d594.ui.paint_watermark)
	if not d600 or not d601 then return end
	
	local d602, d603= pcall(ui.get, d594.ui.paint_watermark_type)
	if not d602 or d603 ~= 0 then return end
	local d604, d605= d580 and d580.screen_size and d580.screen_size() or 800, 600

	local d606
	if d593.logged_in then
		local d607= database.read and database.read('cached_credentials')
		if d607 and d607.username then
			d606 = d607.username
		end
	else
		local d608= d593.load_credentials and d593.load_credentials()
		if d608 and d608.username then
			d606 = d608.username
		end
	end
	if not d606 or d606 == "" then
		d606 = d595.player_name and d595.player_name() or "unknown"
	end
	if d596.expired(d598) then
		d597 = d585()
		d596.reset(d598)
	end
	local d609= d597

	local d610= 0
	if d595 and d595.ping then
		local d611= d595.ping()
		if type(d611) == 'number' then d610 = d611 end
	elseif d580 and d580.latency then
		local d611= d580.latency()
		if type(d611) == 'number' then d610 = d611 end
	end
	local d612= math.floor((d610 or 0) * 1000 + 0.5)

	local d613= ''
	local d614= {
		{text = "game", style = d613, color = d592.white},
		{text = "sense", style = d613, color = d592.green},
		{text = " ", style = d613, color = d592.white},
		{text = "[beta]", style = d613, color = d592.white},
		{text = " | ", style = d613, color = d592.white},
		{text = d606, style = d613, color = d592.white},
		{text = " | ", style = d613, color = d592.white},
		{text = tostring(d612) .. " ms", style = d613, color = d592.white},
		{text = " | ", style = d613, color = d592.white},
		{text = tostring(d609) .. " fps", style = d613, color = d592.white},
	}

	local d615, d616= 0, 0
	for _, seg in ipairs(d614) do
		local d617, d618= d579.measure_text and d579.measure_text(seg.style, seg.text) or 0, 13
		d615 = d615 + d617
		if d618 > d616 then d616 = d618 end
	end
	local d619, d620= 5, 2
	local d621= d615 + d619 * 2
	local d622= d616 + d620 * 2
	local d623= d604 - d621 - 16
	local d624= 16

	if d583 and not d584 then
		local d625= d623
		local d626= d624
		d584 = d583.new('gamesense_watermark', {
			x = d625,
			y = d626,
			w = d621,
			h = d622,
			snap = true,
			snap_threshold = 24,
			require_menu_open = true,
			box_color = {255,255,255,100},
			default_pos = { x = d625, y = d626 },
		})
	end

	if d584 then d584:handle() end

	if d584 then
		d623 = d584.x
		d624 = d584.y
	end

	d579.rectangle(d623 - 7, d624 - 5, d621 + 14, d622 + 10, 0, 0, 0, 200)
	d579.rectangle(d623 - 6, d624 - 4, d621 + 12, d622 + 8, 60, 60, 60, 255)
	d579.rectangle(d623 - 5, d624 - 3, d621 + 10, d622 + 6, 40, 40, 40, 255)
	d579.rectangle(d623 - 3, d624 - 1, d621 + 6, d622 + 2, 60, 60, 60, 255)
	d579.rectangle(d623 - 2, d624, d621 + 4, d622, 12, 12, 12, 255)
	d579.rectangle(d623 - 2, d624, d621 + 4, d622, 32, 32, 32, 255)

	local d627= d588()
	if d627 and d579.texture then
		d579.texture(d627, d623 - 2, d624, d621 + 4, d622, 255,255,255,60, 'r')
	end

	if d579.gradient then
		d579.gradient(d623 - 2, d624, d621 / 2 + 1, 1, 59,175,222,255, 202,70,205,255, true)
		d579.gradient(d623 - 2 + d621 / 2, d624, d621 / 2 + 4.5, 1, 202,70,205,255, 204,227,53,255, true)
	end

	local d628= d623 + d619
	local d629= d624 + d620
    if d584 then d584:draw() end
	for _, seg in ipairs(d614) do
		local d617, d618= d579.measure_text and d579.measure_text(seg.style, seg.text) or 0, 13
			local d630,d631,d632,d633= d591(seg.color)
			d630,d631,d632,a = d582.normalize(d630,d631,d632,d633)
			d579.text(d628, d629, d630,d631,d632,d633, seg.style, nil, seg.text)
		d628 = d628 + d617
	end
end

local d634, d635= pcall(require, "require/abc/callbacks")
if d634 and d635 and d635.callback then
	d635.callback('paint', d599, { alive_only = true, require_login = true })
end
]]
d958["require/features/paint/watermark_solus"] = [[local d582= renderer
local d583= client
local d584= require('require/help/color')
local d585, d586= pcall(require, "require/abc/callbacks")
local d587, d588= pcall(require, "require/abc/menu_setup")
local d589, d590= pcall(ui.reference, 'misc', 'settings', 'menu color')
local d591= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local d592= nil
local function d593(d594,d595,d596,d597,d598,d599,d600,d601,d602)
    d582.rectangle(d594+d598, d595, d596-(d598*2), d597, d599,d600,d601,d602)
    d582.rectangle(d594, d595+d598, d596, d597-(d598*2), d599,d600,d601,d602)
    d582.circle(d594+d598, d595+d598, d599,d600,d601,d602, d598, 0, 1)
    d582.circle(d594+d596-d598, d595+d598, d599,d600,d601,d602, d598, 0, 1)
    d582.circle(d594+d598, d595+d597-d598, d599,d600,d601,d602, d598, 0, 1)
    d582.circle(d594+d596-d598, d595+d597-d598, d599,d600,d601,d602, d598, 0, 1)
end

local d603= globals
local d604= 0
local d605= 0
local d606= 0.1

local function d607(d608)
    local d609, d610= pcall(require, d608)
    if d609 then return d610 end
    return nil
end

local function d611()
    if not d587 or not d588 or not d588.ui then return end
    local d612, d613= pcall(ui.get, d588.ui.paint_watermark)
    if not d612 or not d613 then return end
    local d614, d615= pcall(ui.get, d588.ui.paint_watermark_type)
    if not d614 or d615 ~= 1 then return end

    local d616, d617= d583.screen_size()
    if not d616 or not d617 then return end

    local d618= "unknown"
    local d619= d607('require/abc/login_system')
    local d620= (pcall(require, 'require/help/self') and require('require/help/self')) or nil
    if d619 then
        if d619.logged_in then
            local d621= database and database.read and database.read('cached_credentials')
            if d621 and d621.username then d618 = d621.username end
        else
            if d619.load_credentials then
                local d622= d619.load_credentials()
                if d622 and d622.username then d618 = d622.username end
            end
        end
    end
    if (not d618 or d618 == "") and d620 and d620.player_name then
        d618 = d620.player_name()
    end

    local d623= d604 or 0
    pcall(function()
        local d624= d603 and d603.realtime and d603.realtime() or os.clock()
        if (d624 - (d605 or 0)) >= d606 then
            local d625= d603 and d603.frametime and d603.frametime() or 0.016
            if d625 and d625 > 0 then
                d604 = math.floor(1 / d625 + 0.5)
            end
            d605 = d624
        end
        d623 = d604 or d623
    end)

    local d626= 0
    if d620 and d620.ping then
        local d627= d620.ping()
        if type(d627) == 'number' then d626 = math.floor(d627 * 1000 + 0.5) end
    elseif d583 and d583.latency then
        local d627= d583.latency()
        if type(d627) == 'number' then d626 = math.floor(d627 * 1000 + 0.5) end
    end

    local d628= {
        { text = "gamesense ", bold = true },
        { text = " | ", bold = false },
        { text = d618 or "unknown", bold = false },
        { text = " | ", bold = false },
        { text = tostring(d626) .. " ms", bold = false },
        { text = " | ", bold = false },
        { text = tostring(d623) .. " fps", bold = false },
    }

    local d629, d630= 0, 0
    for _, seg in ipairs(d628) do
        local d596, d597= 0, 13
        if d582.measure_text then
            local d609, d631, d632= pcall(d582.measure_text, '', seg.text)
            if d609 and d631 then d596, h = d631, d632 or d597 end
        end
        d629 = d629 + (d596 or 0)
        if d597 and d597 > d630 then d630 = d597 end
    end

    local d633, d634= 12, 6
    local d635= d629 + d633 * 2
    local d636= d630 + d634 * 2
    local d637= 18
    local d594= d616 - d635 - d637
    local d595= d637
    local d598= 8
    if d591 and not d592 then
        local d638= d594
        local d639= d595
        d592 = d591.new('solus_watermark', {
            x = d638,
            y = d639,
            w = d635,
            h = d636,
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
            default_pos = { x = d638, y = d639 },
        })
    end

    if d592 then d592:handle() end

    if d592 then
        d594 = d592.x
        d595 = d592.y
    end
    local d640, d641, d642, d643= 255, 140, 0, 255
    do
        
        if d587 and d588 and d588.ui and d588.ui.paint_watermark_color then
            local d644, d645, d646, d647, d648= pcall(ui.get, d588.ui.paint_watermark_color)
            if d644 then
                if type(d645) == 'number' then
                    d640 = d584.clamp(d645 or d640)
                    d641 = d584.clamp(d646 or d641)
                    d642 = d584.clamp(d647 or d642)
                    d643 = d584.clamp(d648 or d643)
                elseif type(d645) == 'string' and #d645 == 12 then
                    local d609
                    d609, mr = pcall(function() return tonumber(d645:sub(1,3)) end)
                    d609, mg = pcall(function() return tonumber(d645:sub(4,6)) end)
                    d609, mb = pcall(function() return tonumber(d645:sub(7,9)) end)
                    d609, ma = pcall(function() return tonumber(d645:sub(10,12)) end)
                    d640 = d584.clamp(d640 or 255); d641 = d584.clamp(d641 or 140); d642 = d584.clamp(d642 or 0); d643 = d584.clamp(d643 or 255)
                end
                
            else
                
                if d589 and d590 then
                    local d649, d650, d651, d652, d653= pcall(ui.get, d590)
                    if d649 then
                        if type(d650) == 'number' then
                            d640 = d584.clamp(d650 or d640)
                            d641 = d584.clamp(d651 or d641)
                            d642 = d584.clamp(d652 or d642)
                            d643 = d584.clamp(d653 or d643)
                        elseif type(d650) == 'string' and #d650 == 12 then
                            local d609
                            d609, mr = pcall(function() return tonumber(d650:sub(1,3)) end)
                            d609, mg = pcall(function() return tonumber(d650:sub(4,6)) end)
                            d609, mb = pcall(function() return tonumber(d650:sub(7,9)) end)
                            d609, ma = pcall(function() return tonumber(d650:sub(10,12)) end)
                            d640 = d584.clamp(d640 or 255); d641 = d584.clamp(d641 or 140); d642 = d584.clamp(d642 or 0); d643 = d584.clamp(d643 or 255)
                        end
                    end
                end
            end
        else
            
            if d589 and d590 then
                local d644, d645, d646, d647, d648= pcall(ui.get, d590)
                if d644 then
                    if type(d645) == 'number' then
                        d640 = d584.clamp(d645 or d640)
                        d641 = d584.clamp(d646 or d641)
                        d642 = d584.clamp(d647 or d642)
                        d643 = d584.clamp(d648 or d643)
                    elseif type(d645) == 'string' and #d645 == 12 then
                        local d609
                        d609, mr = pcall(function() return tonumber(d645:sub(1,3)) end)
                        d609, mg = pcall(function() return tonumber(d645:sub(4,6)) end)
                        d609, mb = pcall(function() return tonumber(d645:sub(7,9)) end)
                        d609, ma = pcall(function() return tonumber(d645:sub(10,12)) end)
                        d640 = d584.clamp(d640 or 255); d641 = d584.clamp(d641 or 140); d642 = d584.clamp(d642 or 0); d643 = d584.clamp(d643 or 255)
                    end
                end
            end
        end
    end

    local function d654(d655,d656,d657,d599,d658,d659,d660)
        local d661= math.rad(d658)
        local d662= math.rad(d659)
        for i=0,d660 do
            local d663= i / d660
            local d602= d661 + (d662 - d661) * d663
            d655[#d655+1] = { d656 + math.cos(d602) * d599, d657 + math.sin(d602) * d599 }
        end
    end

    local function d664(d594,d595,d596,d597,d665,d666)
        local d667= {}
        d666 = d666 or 6
        local d668= d594
        local d669= d594 + d596
        local d670= d595
        local d671= d595 + d597
        local d672= d668 + d665
        local d673= d669 - d665
        local function d674(d675,d676)
            local d677= #d667
            if d677 == 0 then d667[#d667+1] = { d675, d676 }; return end
            local d678= d667[d677]
            if not (math.abs(d678[1] - d675) < 0.001 and math.abs(d678[2] - d676) < 0.001) then
                d667[#d667+1] = { d675, d676 }
            end
        end

        if d673 > d672 then
            for xx = d672, d673, d666 do d674(xx, d670) end
            
            d674(d673, d670)
        end

        d654(d667, d669 - d665, d670 + d665, d665, -90, 0, 6)

        local d679= d670 + d665
        local d680= d671 - d665
        if d680 > d679 then
            for yy = d679, d680, d666 do d674(d669, yy) end
            d674(d669, d680)
        end

        d654(d667, d669 - d665, d671 - d665, d665, 0, 90, 6)

        if d673 > d672 then
            for xx = d673, d672, -d666 do d674(xx, d671) end
            d674(d672, d671)
        end

        d654(d667, d668 + d665, d671 - d665, d665, 90, 180, 6)

        if d680 > d679 then
            for yy = d680, d679, -d666 do d674(d668, yy) end
            d674(d668, d679)
        end

        d654(d667, d668 + d665, d670 + d665, d665, 180, 270, 6)

        return d667
    end

    local d681= 3
    local d667= d664(d594-1, d595-1, d635+2, d636+2, d598+1, d681)
    local d677= #d667

    if d592 then d592:draw() end

    d593(d594-1, d595-1, d635+2, d636+2, d598+1, 0, 0, 0, 255)
    d593(d594, d595, d635, d636, d598, 0, 0, 0, 200)

    
    if d677 > 2 then
        local d663= (d603 and d603.realtime and d603.realtime() or 0)
        local d682= 7
        d682 = d682 * 4
        local d683= d682 / 60
        local d684= math.max(0.5, d683 * d677)
        local d685= math.floor((d663 * d684) % d677)

        local d686= math.max(6, math.floor(d677 * 0.25))

        local d687= d584.clamp(math.floor((d643 or 255) * 1.15))
        for j = d686 - 1, 0, -1 do
            local d688= ((d685 + j) % d677) + 1
            local d689= ((d685 + j + 1) % d677) + 1
            local d690= d667[d688]
            local d691= d667[d689]
            if d690 and d691 then
                local d692= 1 - (j / d686)
                local d602= d584.clamp(math.floor(d687 * d692))
                d582.line(d690[1], d690[2], d691[1], d691[2], d640, d641, d642, d602)
            end
        end
    end

    local d693= d594 + d633
    local d694= d595 + math.floor((d636 - d630) / 2)
    for i, seg in ipairs(d628) do
        local d596= 0
        if d582.measure_text then
            local d609, d631= pcall(d582.measure_text, '', seg.text)
            if d609 and d631 then d596 = d631 end
        end
        local d695= seg.bold and 'b' or ''
        d582.text(d693, d694, 255,255,255,255, d695, 0, seg.text)
        d693 = d693 + d596
    end
end

if d585 and d586 and d586.callback then
    d586.callback('paint', d611, { alive_only = true, require_login = true })
end

return true]]
d958["require/features/paint/world_hitmarker_plus"] = [[
local d585= require("require/abc/menu_setup")
local d586= {shots = {}, last = 0}
local d587, d588= pcall(require, "require/brain/api/vector/vector")

local function d589()
	local d590= ui.get(d585.ui.paint_hitmarker)
	if type(d590) == "table" then
		for _, v in ipairs(d590) do
			if v == "world +" then return true end
		end
	end
	return false
end

local d591, d592= pcall(require, "require/abc/callbacks")
local function d593(d594)
	if not d589() then d586.shots = {} return end
	if not d589() then return end
	local d595= globals.realtime()
	
	if d586.last and d595 - d586.last < 0.05 then return end
	d586.last = d595
	d586.shots[#d586.shots + 1] = {impacts = {}, finished = false, t = d595}
	if #d586.shots > 12 then table.remove(d586.shots, 1) end
end

local function d596(d594)
	if not d589() then d586 = {shots = {}, last = 0} return end
	local d597= entity.get_local_player()
	if not d597 then return end
	local d598= client.userid_to_entindex(d594.userid or 0)
	if d598 ~= d597 then return end
	local d595= globals.realtime()
	local d599
	for i = #d586.shots, 1, -1 do
		if not d586.shots[i].finished and d595 - (d586.shots[i].t or 0) < 1.2 then
			d599 = d586.shots[i]
			break
		end
	end
	if not d599 then return end
	local d600, d601, d602= d594.x, d594.y, d594.z
	local d603, d604, d605, d606= pcall(client.eye_position)
	local d607, d608, d609= 0, 0, 0
	if d603 and d604 and d605 and d606 then
		if d587 and d588 and d588.make and d588.normalized and d588.sub then
			local d610= d588.make(d600, d601, d602)
			local d611= d588.make(d604, d605, d606)
			local d612= d588.normalized(d588.sub(d610, d611))
			d607, d608, dirz = d612.x, d612.y, d612.z
		else
			d607 = d600 - d604; d608 = d601 - d605; d609 = d602 - d606
			local d613= math.sqrt(d607*d607 + d608*d608 + d609*d609)
			if d613 > 0 then d607, d608, dirz = d607/d613, d608/d613, d609/d613 end
		end
	end
	local d614= false
	local d615, d616, d617= pcall(client.trace_line, d597, d600 - (d607 or 0) * 1, d601 - (d608 or 0) * 1, d602 - (d609 or 0) * 1, d600 + (d607 or 0) * 1, d601 + (d608 or 0) * 1, d602 + (d609 or 0) * 1)
	if d615 and d617 and d617 > 0 and d617 ~= d597 then
		if entity.is_enemy(d617) then d614 = true end
	end
	local d618, d619, d620, d621
	local d622, d623, d624, d625, d626= pcall(ui.get, d585.ui.paint_hitmarker_color)
	if d622 and d623 then
		d618, d619, d620, ca = d623 or 0, d624 or 235, d625 or 235, d626 or 255
	else
		d618, d619, d620, ca = 0, 235, 235, 255
	end
	d599.impacts[#d599.impacts + 1] = {x = d600, y = d601, z = d602, t = d595, r = d618, g = d619, b = d620, a = d621, dir = {d607, d608, d609}, hit = d614}
	
	if #d599.impacts > 5 then table.remove(d599.impacts, 1) end
	if d614 then
		d599.finished = true
	end
end

local function d627(d594)
	if d589() then
		local d595= globals.realtime()
		local d628= 5.5 * 3 * 0.8
		local d629= 0.25 * 0.8
		local d630= d628 + d629
		local d631= 1
		while d631 <= #d586.shots do
			if d595 - (d586.shots[d631].t or 0) > d630 then
				table.remove(d586.shots, d631)
			else
				d631 = d631 + 1
			end
		end
		
		local d632= {}
		local d633= 12
		for si = #d586.shots, 1, -1 do
			local d599= d586.shots[si]
			for ii = #d599.impacts, 1, -1 do
				table.insert(d632, d599.impacts[ii]) 
				if #d632 >= d633 then break end
			end
			if #d632 >= d633 then break end
		end
		local d634= math.min(4, #d632)
		for j = 1, d634 do
			local d635= d632[j]
			local d636, d637, d638= d635.x, d635.y, d635.z
			if not d635.hit and d635.dir then
				local d604= d635.x + (d635.dir[1] or 0) * 24
				local d605= d635.y + (d635.dir[2] or 0) * 24
				local d606= d635.z + (d635.dir[3] or 0) * 24
				d636, d637, draw_z = d604, d605, d606
			end
			local d639, d640= renderer.world_to_screen(d636, d637, d638)
			if d639 and d640 then
				local d641= d595 - (d635.t or 0)
				local d642= d641 <= d628 and 255 or math.floor(math.max(0, (1 - math.max(0, d641 - d628) / d629) * 255))
				if d642 > 0 then
					local d613= 4
					local d643= d635.r or 200
					local d644= d635.g or 200
					local d645= d635.b or 200
					renderer.line(d639 - d613, d640, d639 + d613, d640, d643, d644, d645, d642)
					renderer.line(d639, d640 - d613, d639, d640 + d613, d643, d644, d645, d642)
				end
			end
		end
	else
		d586 = {shots = {}, last = 0}
	end
end

if d591 and d592 and d592.callback then
	d592.callback('aim_fire', d593, { alive_only = true, require_login = true })
	d592.callback('bullet_impact', d596, { alive_only = true, require_login = true })
	d592.callback('paint', d627, { alive_only = true, require_login = true })
end
]]
d958["require/help/bit"] = [[local d588= {}

local d589= 0xFFFFFFFF
local d590= 4294967296

local function d591(d592)
	d592 = tonumber(d592) or 0
	d592 = math.floor(d592) % d590
	if d592 < 0 then d592 = d592 + d590 end
	return d592
end

function d588.tobit(d592)
	local d593= d591(d592)
	if d593 >= 2147483648 then
		return d593 - d590
	end
	return d593
end

function d588.tohex(d592,d594)
	local d593= d591(d592)
	local d595= 8
	local d596= false
	if d594 then
		if d594 < 0 then
			d596 = true
			d595 = -d594
		else
			d595 = d594
		end
	end
	if d595 < 1 then d595 = 1 end
	if d595 > 8 then d595 = 8 end
	d593 = d593 % (2^(4 * d595))
	if d596 then
		return string.format(string.format("%%0%uX", d595), d593)
	else
		return string.format(string.format("%%0%ux", d595), d593)
	end
end

local function d597(d593,d598)
	return math.floor(d593 / 2^d598) % 2
end

function d588.band(d599,...)
	local d600= {d599, ...}
	if #d600 == 0 then return 0 end
	local d601= 0
	for d598 = 0, 31 do
		local d602= 1
		for j = 1, #d600 do
			if d597(d591(d600[j]), d598) == 0 then
				d602 = 0
				break
			end
		end
		if d602 == 1 then d601 = d601 + 2^d598 end
	end
	return d588.tobit(d601)
end

function d588.bor(d599,...)
	local d600= {d599, ...}
	if #d600 == 0 then return 0 end
	local d601= 0
	for d598 = 0, 31 do
		for j = 1, #d600 do
			if d597(d591(d600[j]), d598) == 1 then
				d601 = d601 + 2^d598
				break
			end
		end
	end
	return d588.tobit(d601)
end

function d588.bxor(d599,...)
	local d600= {d599, ...}
	if #d600 == 0 then return 0 end
	local d601= 0
	for d598 = 0, 31 do
		local d603= 0
		for j = 1, #d600 do
			if d597(d591(d600[j]), d598) == 1 then d603 = d603 + 1 end
		end
		if (d603 % 2) == 1 then d601 = d601 + 2^d598 end
	end
	return d588.tobit(d601)
end

function d588.bnot(d592)
	local d593= d591(d592)
	local d601= d589 - d593
	return d588.tobit(d601)
end

function d588.lshift(d592,d594)
	d594 = tonumber(d594) or 0
	d594 = d594 % 32
	local d593= d591(d592)
	local d601= (d593 * 2^d594) % d590
	return d588.tobit(d601)
end

function d588.rshift(d592,d594)
	d594 = tonumber(d594) or 0
	d594 = d594 % 32
	local d593= d591(d592)
	local d601= math.floor(d593 / 2^d594) % d590
	return d588.tobit(d601)
end

function d588.arshift(d592,d594)
	d594 = tonumber(d594) or 0
	d594 = d594 % 32
	local d604= d588.tobit(d592)
	local d601= math.floor(d604 / 2^d594)
	return d588.tobit(d601)
end

function d588.rol(d592,d594)
	d594 = tonumber(d594) or 0
	d594 = d594 % 32
	if d594 == 0 then return d588.tobit(d592) end
	local d593= d591(d592)
	local d605= (d593 * 2^d594) % d590
	local d606= math.floor(d593 / 2^(32 - d594))
	local d601= (d605 + d606) % d590
	return d588.tobit(d601)
end

function d588.ror(d592,d594)
	d594 = tonumber(d594) or 0
	d594 = d594 % 32
	if d594 == 0 then return d588.tobit(d592) end
	local d593= d591(d592)
	local d606= math.floor(d593 / 2^d594)
	local d605= (d593 * 2^(32 - d594)) % d590
	local d601= (d605 + d606) % d590
	return d588.tobit(d601)
end

function d588.bswap(d592)
	local d593= d591(d592)
	local d607= d593 % 256
	local d608= math.floor(d593 / 256) % 256
	local d609= math.floor(d593 / 65536) % 256
	local d610= math.floor(d593 / 16777216) % 256
	local d601= d607 * 16777216 + d608 * 65536 + d609 * 256 + d610
	return d588.tobit(d601)
end

return d588]]
d958["require/help/client"] = [[local d591= {}

function d591.camera_angles(d592,d593)
  if d592 == nil and d593 == nil then
    return client.camera_angles()
  end
  return client.camera_angles(d592, d593)
end

function d591.camera_position()
  return client.camera_position()
end

function d591.color_log(d594,d595,d596,...)
  return client.color_log(d594, d595, d596, ...)
end

function d591.create_interface(d597,d598)
  return client.create_interface(d597, d598)
end

function d591.current_threat()
  return client.current_threat()
end

function d591.delay_call(d599,d600,...)
  return client.delay_call(d599, d600, ...)
end

function d591.draw_debug_text(d601,d602,d603,d604,d605,d594,d595,d596,d606,...)
  return client.draw_debug_text(d601, d602, d603, d604, d605, d594, d595, d596, d606, ...)
end

function d591.draw_hitboxes(d607,d605,d608,d594,d595,d596,d606,d609)
  return client.draw_hitboxes(d607, d605, d608, d594, d595, d596, d606, d609)
end

function d591.error_log(d610)
  return client.error_log(d610)
end

function d591.exec(...)
  return client.exec(...)
end

function d591.eye_position()
  return client.eye_position()
end

function d591.find_signature(d597,d611)
  return client.find_signature(d597, d611)
end

function d591.fire_event(d612,...)
  return client.fire_event(d612, ...)
end

function d591.get_cvar(d613)
  return client.get_cvar(d613)
end

function d591.get_model_name(d614)
  return client.get_model_name(d614)
end

function d591.key_state(d615)
  return client.key_state(d615)
end

function d591.latency()
  return client.latency()
end

function d591.log(...)
  return client.log(...)
end

function d591.random_float(d616,d617)
  return client.random_float(d616, d617)
end

function d591.random_int(d616,d617)
  return client.random_int(d616, d617)
end

function d591.real_latency()
  return client.real_latency()
end

function d591.register_esp_flag(d618,d594,d595,d596,d600)
  return client.register_esp_flag(d618, d594, d595, d596, d600)
end

function d591.reload_active_scripts()
  return client.reload_active_scripts()
end

function d591.request_full_update()
  return client.request_full_update()
end

function d591.scale_damage(d607,d619,d620)
  return client.scale_damage(d607, d619, d620)
end

function d591.screen_size()
  return client.screen_size()
end

function d591.set_clan_tag(...)
  return client.set_clan_tag(...)
end

function d591.set_event_callback(d612,d600)
  return client.set_event_callback(d612, d600)
end

function d591.system_time()
  return client.system_time()
end

function d591.timestamp()
  return client.timestamp()
end

function d591.trace_bullet(d621,d622,d623,d624,d625,d626,d627,d628)
  return client.trace_bullet(d621, d622, d623, d624, d625, d626, d627, d628)
end

function d591.trace_line(d629,d622,d623,d624,d625,d626,d627)
  return client.trace_line(d629, d622, d623, d624, d625, d626, d627)
end

function d591.unix_time()
  return client.unix_time()
end

function d591.unset_event_callback(d612,d600)
  return client.unset_event_callback(d612, d600)
end

function d591.update_player_list()
  return client.update_player_list()
end

function d591.userid_to_entindex(d630)
  return client.userid_to_entindex(d630)
end

function d591.visible(d601,d602,d603)
  return client.visible(d601, d602, d603)
end

return d591]]
d958["require/help/color"] = [[local function d594(d595)
    d595 = tostring(d595 or "")
    local d596= d595:match("([0-9A-Fa-f]+)$")
    if not d596 or #d596 ~= 8 then
        return 255,255,255,255
    end
    local d597= tonumber(d596:sub(1,2), 16)
    local d598= tonumber(d596:sub(3,4), 16)
    local d599= tonumber(d596:sub(5,6), 16)
    local d600= tonumber(d596:sub(7,8), 16)
    return d597,d598,d599,d600
end

local function d601(d597,d598,d599,d600)
    return string.format("\a%02x%02x%02x%02x", tonumber(d597) or 0, tonumber(d598) or 0, tonumber(d599) or 0, tonumber(d600) or 255)
end

local function d602(d603)
    local d604= tonumber(d603) or 0
    if d604 < 0 then return 0 end
    if d604 > 255 then return 255 end
    return math.floor(d604 + 0.5)
end

local function d605(d597,d598,d599,d600,d606)
    d606 = tonumber(d606) or 32
    return d602((d597 or 0) + d606), d602((d598 or 0) + d606), d602((d599 or 0) + d606), d602(d600 or 255)
end

local function d607(d597,d598,d599,d600,d606)
    d606 = tonumber(d606) or 32
    return d602((d597 or 0) - d606), d602((d598 or 0) - d606), d602((d599 or 0) - d606), d602(d600 or 255)
end

local d608= {
    default = "d6d6d6FF", 
    green  = "a5ca2aFF", 
    red    = "d96464FF", 
    reddark = "b22222FF", 
    orange = "dca53aFF", 
    yellow = "ccb854FF", 
    blue   = "5462ccFF", 
    cyan   = "54ccccFF", 
    purple = "7054ccFF", 
    white  = "ffffffFF", 
    grey   = "757575FF", 
    black  = "000000FF", 
    pink   = "c8a2deFF", 
    discord = "7289daFF", 
    youtube = "FF0000FF", 
    sellhub = "FFC107FF", 

}


local d609= {}
for name, d595 in pairs(d608) do
    local d597,d598,d599,d600= d594(d595)
    d609[name] = {
        base = d595,
        lighter = d601(d605(d597,d598,d599,d600,32)),
        darker  = d601(d607(d597,d598,d599,d600,32)),
        light2  = d601(d605(d597,d598,d599,d600,64)),
        dark2   = d601(d607(d597,d598,d599,d600,64)),
        rgb = {d597,d598,d599,d600},
        log = {d597,d598,d599},
        ui = d595,
    }
end

function d609.get(d610,d611)
    d611 = d611 or "base"
    local d612= d609[d610]
    if not d612 then return nil end
    if d611 == "log" and d612.log then
        return unpack(d612.log)
    elseif d611 == "ui" and d612.ui then
        return "\a"..entry.ui
    elseif d612[d611] then
        return d612[d611]
    end
    return nil
end

function d609.blend(d613,d614,d615)
    local d616,d617,d618,d619= unpack(d609[d613].rgb)
    local d620,d621,d622,d623= unpack(d609[d614].rgb)
    d615 = d615 or 0.5
    local d597= d602(d616 + (d620-d616)*d615)
    local d598= d602(d617 + (d621-d617)*d615)
    local d599= d602(d618 + (d622-d618)*d615)
    local d600= d602(d619 + (d623-d619)*d615)
    return d601(d597,d598,d599,d600)
end

function d609.hex_to_rgba(d595)
    return d594(d595)
end

function d609.rgba_to_hex(d597,d598,d599,d600)
    return d601(d597,d598,d599,d600)
end

function d609.clamp(d597,d598,d599,d600)
    return d602(d597), d602(d598), d602(d599), d602(d600)
end

function d609.normalize(d597,d598,d599,d600)
    return d602(d597), d602(d598), d602(d599), d602(d600 or 255)
end

function d609.modulate(d597,d598,d599,d600,d624,d625,d626,d627)
    d624 = tonumber(d624) or 1
    d625 = tonumber(d625) or d624
    d626 = tonumber(d626) or d624
    d627 = tonumber(d627) or 1
    local d628= d602((tonumber(d597) or 0) * d624)
    local d629= d602((tonumber(d598) or 0) * d625)
    local d630= d602((tonumber(d599) or 0) * d626)
    local d631= d602((tonumber(d600) or 255) * d627)
    return d628, d629, d630, d631
end

function d609.alpha_modulate(d600,d632)
    d632 = tonumber(d632) or 1
    return d602((tonumber(d600) or 255) * d632)
end

return d609]]
d958["require/help/drag"] = [[local d597= {}
local d598= {}
local d599= false

local d600= {
	['top-left'] = function(d601,d602,d603,d604) return 0, 0 end,
	['top-center'] = function(d601,d602,d603,d604) return math.floor(d601/2 - d603/2), 0 end,
	['top-right'] = function(d601,d602,d603,d604) return math.floor(d601 - d603), 0 end,
	['center-left'] = function(d601,d602,d603,d604) return 0, math.floor(d602/2 - d604/2) end,
	['center'] = function(d601,d602,d603,d604) return math.floor(d601/2 - d603/2), math.floor(d602/2 - d604/2) end,
	['center-right'] = function(d601,d602,d603,d604) return math.floor(d601 - d603), math.floor(d602/2 - d604/2) end,
	['bottom-left'] = function(d601,d602,d603,d604) return 0, math.floor(d602 - d604) end,
	['bottom-center'] = function(d601,d602,d603,d604) return math.floor(d601/2 - d603/2), math.floor(d602 - d604) end,
	['bottom-right'] = function(d601,d602,d603,d604) return math.floor(d601 - d603), math.floor(d602 - d604) end,
}

local function d605(d606,d607,d603,d604,d608,d609)
	if not d608 or not d609 then return false end
	return d608 >= d606 and d608 <= d606 + d603 and d609 >= d607 and d609 <= d607 + d604
end

local function d610(d611,d612,d613)
	if not d611 then return d612 end
	if d611 < d612 then return d612 end
	if d611 > d613 then return d613 end
	return d611
end

function d597.new(d614,d615)
	if not d614 then error('drag.new requires id') end
	d615 = d615 or {}
	local d616= {}
	d616.id = d614
	d616.x = d615.x or 0
	d616.y = d615.y or 0
	d616.w = d615.w or 100
	d616.h = d615.h or 20
	d616.snap = d615.snap == nil and true or d615.snap
	d616.snap_threshold = d615.snap_threshold or 24
	d616.snap_positions = d615.snap_positions or nil
	d616.require_menu_open = d615.require_menu_open == nil and true or d615.require_menu_open
	d616.locked = d615.lock or false
	d616.box_color = d615.box_color or {255,255,255,100}
	d616.show_alignment = d615.show_alignment == nil and true or d615.show_alignment
	d616.align_color = d615.align_color or {255,255,255,100}
	d616.align_cross_size = d615.align_cross_size or 6
	d616.show_screen_guides = d615.show_screen_guides == nil and true or d615.show_screen_guides
	d616.line_snap_threshold = d615.line_snap_threshold or 6
	d616.bounds = d615.bounds or nil
	d616.constraint_center = d615.constraint_center or nil
	d616.constraint_box = d615.constraint_box or nil
	d616.default_pos = d615.default_pos or nil
	d616.default_center = d615.default_center or nil

	local d617= {
		obj = d616,
		dragging = false,
		drag_offset_x = 0,
		drag_offset_y = 0,
		last_left = false,
		last_right = false,
		locked_to = nil,
		snap_progress = 0,
		snap_target = 0,
		line_snap_progress_x = 0,
		line_snap_progress_y = 0,
		line_snap_target_x = 0,
		line_snap_target_y = 0,
		drag_button = nil,
		disable_snap = false,
	}
	d598[d614] = d617

	local d618, d619= pcall(database.read, 'drag_positions')
	if d618 and type(d619) == 'table' and d619[d614] then
		local d620= d619[d614]
		if type(d620.x) == 'number' and type(d620.y) == 'number' then
			d616.x = d620.x
			d616.y = d620.y
		end
	end

	if not d599 then
		client.set_event_callback('setup_command', function(d621)
			for _, st in pairs(d598) do
				if st.dragging then
					pcall(function()
						d621.in_attack = false
						d621.in_attack2 = false
					end)
					break
				end
			end
		end)
		d599 = true
	end

	function d616:set_pos(d606,d607)
		self.x = d606
		self.y = d607
	end
	function d616:set_size(d603,d604)
		self.w = d603; self.h = d604
	end
	function d616:set_bounds(d606,d607,d603,d604)
		self.bounds = { x = d606, y = d607, w = d603, h = d604 }
	end
	function d616:clear_bounds()
		self.bounds = nil
	end
	function d616:get_pos()
		return self.x, self.y
	end
	function d616:is_dragging()
		return not not d617.dragging
	end
	function d616:get_bounds()
		return self.bounds
	end
	function d616:set_locked(d622)
		self.locked = not not d622
	end
	function d616:set_snap(d622)
		self.snap = not not d622
	end
	function d616:toggle_snap()
		self.snap = not self.snap
	end
	function d616:reset_to_anchor(d623)
		local d601, d602= client.screen_size()
		if not d601 or not d602 then return end
		local d624= d600[d623]
		if type(d624) == 'function' then
			local d625, d626= d624(d601,d602,self.w,self.h)
			self.x = d625; self.y = d626
			d617.locked_to = d623
		end
	end

	function d616:handle()
		if self.locked then return end
		local d601, d602= client.screen_size()
		if not d601 or not d602 then return end
		if self.require_menu_open and not ui.is_menu_open() then d617.last_left = false; return end

		local d608, d609= ui.mouse_position()
		local d627= client.key_state(1)
		local d628= client.key_state(2)

		if d627 and d628 and (d605(self.x, self.y, self.w, self.h, d608, d609) or d617.dragging) then
			if self.default_pos then
				self.x = self.default_pos.x
				self.y = self.default_pos.y
				return
			elseif self.default_center then
				self.x = (self.default_center.x or 0) - math.floor(self.w/2)
				self.y = (self.default_center.y or 0) - math.floor(self.h/2)
				return
			end
		end
		if d627 and not d617.last_left and d605(self.x, self.y, self.w, self.h, d608, d609) then
			d617.dragging = true
			d617.drag_button = 1
			d617.disable_snap = false
			d617.drag_offset_x = d608 - self.x
			d617.drag_offset_y = d609 - self.y
			d617.locked_to = nil
		elseif d628 and not d617.last_right and d605(self.x, self.y, self.w, self.h, d608, d609) then
			d617.dragging = true
			d617.drag_button = 2
			d617.disable_snap = true
			d617.drag_offset_x = d608 - self.x
			d617.drag_offset_y = d609 - self.y
			d617.locked_to = nil
			d617.snap_target = 0
			d617.line_snap_target_x = 0
			d617.line_snap_target_y = 0
		end

		if (d627 and d617.dragging and d617.drag_button == 1) or (d628 and d617.dragging and d617.drag_button == 2) then
			local d625= d608 - d617.drag_offset_x
			local d626= d609 - d617.drag_offset_y
			local d629, d630= 0, math.max(0, d601 - self.w)
			local d631, d632= 0, math.max(0, d602 - self.h)
			if self.constraint_center then
				local d633= self.constraint_center
				local d634= d633.cx or math.floor(d601/2)
				local d635= d633.cy or math.floor(d602/2)
				local d636= d633.radius or 0
				d629 = (d634 - d636) - math.floor(self.w/2)
				d630 = (d634 + d636) - math.floor(self.w/2)
				d631 = (d635 - d636) - math.floor(self.h/2)
				d632 = (d635 + d636) - math.floor(self.h/2)
			elseif self.bounds or self.constraint_box then
				local d637= self.bounds or self.constraint_box
				local d638= d637.x or d637[1] or 0
				local d639= d637.y or d637[2] or 0
				local d640= d637.w or d637[3] or (d601 - d638)
				local d641= d637.h or d637[4] or (d602 - d639)
				d629 = d638
				d630 = math.max(d638, d638 + d640 - self.w)
				d631 = d639
				d632 = math.max(d639, d639 + d641 - self.h)
			end
			d625 = d610(d625, d629, d630)
			d626 = d610(d626, d631, d632)
			self.x = d625; self.y = d626
			if self.snap and not d617.disable_snap then
				local d642= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and d600[p] then
							local d624= d600[p]
							local d643, d644= d624(d601,d602,self.w,self.h)
							table.insert(d642, {x=d643,y=d644})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(d642, {x=p[1], y=p[2]})
						end
					end
				else
					for k,d624 in pairs(d600) do
						local d643, d644= d624(d601,d602,self.w,self.h)
						table.insert(d642, {x=d643,y=d644})
					end
				end
				local d645= math.huge
				for _,d633 in ipairs(d642) do
					local d646= (d633.x - self.x)
					local d647= (d633.y - self.y)
					local d648= math.sqrt(d646*d646 + d647*d647)
					if d648 < d645 then d645 = d648 end
				end
				if d645 <= self.snap_threshold then d617.snap_target = 1 else d617.snap_target = 0 end
				local d649= math.floor(d601/2)
				local d650= math.floor(d602/2)
				local d634= math.floor(self.x + self.w/2)
				local d635= math.floor(self.y + self.h/2)
				if math.abs(d634 - d649) <= (self.line_snap_threshold or 6) then d617.line_snap_target_x = 1 else d617.line_snap_target_x = 0 end
				if math.abs(d635 - d650) <= (self.line_snap_threshold or 6) then d617.line_snap_target_y = 1 else d617.line_snap_target_y = 0 end
			end
		end

		local d651= false
		if d617.dragging then
			if d617.drag_button == 1 and not d627 and d617.last_left then d651 = true end
			if d617.drag_button == 2 and not d628 and d617.last_right then d651 = true end
		end
		if d651 then
			if not d617.disable_snap then
				local d649, d650= math.floor(d601/2), math.floor(d602/2)
				local d634= math.floor(self.x + self.w/2)
				local d635= math.floor(self.y + self.h/2)
				if self.show_screen_guides then
					if math.abs(d634 - d649) <= (self.line_snap_threshold or 6) then
						self.x = d649 - math.floor(self.w/2)
					end
					if math.abs(d635 - d650) <= (self.line_snap_threshold or 6) then
						self.y = d650 - math.floor(self.h/2)
					end
				end
			end
			d617.dragging = false
			local d652, d653= pcall(database.read, 'drag_positions')
			local d654= (d652 and type(d653) == 'table') and d653 or {}
			d654[self.id] = { x = self.x, y = self.y }
			pcall(function() database.write('drag_positions', d654) end)
			if self.snap and not d617.disable_snap then
				local d642= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and d600[p] then
							local d624= d600[p]
							local d643, d644= d624(d601,d602,self.w,self.h)
							table.insert(d642, {x=d643,y=d644, key=p})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(d642, {x=p[1], y=p[2], key=nil})
						end
					end
				else
					for k,d624 in pairs(d600) do
						local d643, d644= d624(d601,d602,self.w,self.h)
						table.insert(d642, {x=d643,y=d644, key=k})
					end
				end
				local d655, d645= nil, math.huge
				for _,d633 in ipairs(d642) do
					local d646= (d633.x - self.x)
					local d647= (d633.y - self.y)
					local d648= math.sqrt(d646*d646 + d647*d647)
					if d648 < d645 then d645 = d648; d655 = d633 end
				end
				if d655 and d645 <= self.snap_threshold then
					self.x = d655.x; self.y = d655.y
					d617.locked_to = d655.key
				end
			end
		end

		d617.last_left = d627
		d617.last_right = d628
	end

	function d616:draw()
		local d617= d598[self.id]
		if not d617 then return end
		if d617.dragging then
			local d636,d656,d637,d657= unpack(self.box_color)
			local d658,d659,d660,d661= unpack(self.align_color)
			local d662= globals.frametime() or 0.016
			local d663= math.min(1, 12 * d662)
			d617.snap_progress = d617.snap_progress + (d617.snap_target - d617.snap_progress) * d663
			d617.line_snap_progress_x = d617.line_snap_progress_x + (d617.line_snap_target_x - d617.line_snap_progress_x) * d663
			d617.line_snap_progress_y = d617.line_snap_progress_y + (d617.line_snap_target_y - d617.line_snap_progress_y) * d663
			local d664= math.floor(d636 + (0 - d636) * d617.snap_progress)
			local d665= math.floor(d656 + (0 - d656) * d617.snap_progress)
			local d666= math.floor(d637 + (0 - d637) * d617.snap_progress)
			local d667= math.floor(d657 + (200 - d657) * d617.snap_progress)
			renderer.rectangle(self.x, self.y, self.w, self.h, d664, d665, d666, d667)
			renderer.line(self.x, self.y, self.x + self.w, self.y, 200,200,200,150)
			renderer.line(self.x + self.w, self.y, self.x + self.w, self.y + self.h, 200,200,200,150)
			renderer.line(self.x + self.w, self.y + self.h, self.x, self.y + self.h, 200,200,200,150)
			renderer.line(self.x, self.y + self.h, self.x, self.y, 200,200,200,150)
			if self.show_alignment then
				local d601, d602= client.screen_size()
				if d601 and d602 then
					if self.show_screen_guides then
						local d649= math.floor(d601/2)
						local d650= math.floor(d602/2)
						local d634= math.floor(self.x + self.w/2)
						local d635= math.floor(self.y + self.h/2)
						local d668= math.abs(d634 - d649) <= (self.line_snap_threshold or 6)
						local d669= math.abs(d635 - d650) <= (self.line_snap_threshold or 6)
						local d670= math.floor(d661 * 0.35)
						renderer.line(d649, d650, 0, d650, d658,d659,d660, d670)
						renderer.line(d649, d650, d649, 0, d658,d659,d660, d670)
						renderer.line(d649, d650, d601, d650, d658,d659,d660, d670)
						renderer.line(d649, d650, d649, d602, d658,d659,d660, d670)
						local d671= math.floor(d661 * d617.line_snap_progress_x)
						local d672= math.floor(d661 * d617.line_snap_progress_y)
						if d671 > 0 then renderer.line(d649, 0, d649, d602, d658,d659,d660, d671) end
						if d672 > 0 then renderer.line(0, d650, d601, d650, d658,d659,d660, d672) end
					end
				end
			end
			if self.constraint_center then
				local d633= self.constraint_center
				local d634= d633.cx or math.floor((client.screen_size()) / 2)
				local d635= d633.cy or math.floor((client.screen_size()) / 2)
				local d636= d633.radius or 0
				local d638= d634 - d636
				local d639= d635 - d636
				local d640= d636 * 2
				local d641= d636 * 2
				renderer.rectangle(d638, d639, d640, d641, 255, 255, 255, 60)
				renderer.line(d638, d639, d638 + d640, d639, 255, 255, 255, 160)
				renderer.line(d638 + d640, d639, d638 + d640, d639 + d641, 255, 255, 255, 160)
				renderer.line(d638 + d640, d639 + d641, d638, d639 + d641, 255, 255, 255, 160)
				renderer.line(d638, d639 + d641, d638, d639, 255, 255, 255, 160)
			end
		end
	end

	return d616
end

function d597.get(d614)
	local d617= d598[d614]
	if not d617 then return nil end
	return d617.obj
end

function d597.ids()
	local d673= {}
	for k,_ in pairs(d598) do table.insert(d673, k) end
	return d673
end

return d597]]
d958["require/help/emojis"] = [[local d600= {

    chat = { "" },
    rewind = { "" },
    thumbsup = { "" },
    mail = { "U+E135" },
    square = { "" },
    square2 = { "" },
    square_hollow = { "" },
    play = { "" },
    pause = { "" },
    sun = { "" },
    pc = { "" },
    pc2 = { "" },
    phone = { "U+E1C9" },
    trash = { "" },
    reject = { "" },
    accept = { "" },
    config = { "" },
    config_write = { "U+E28F" },
    gear = { "" },
    arrow_right = { "" },
    arrow_left = { "" },
    arrow_up = { "" },
    arrow_down = { "" },
    star = { "U+E0B4" },
    minus = { "" },
    plus = { "" },
    plus_in_brackets = { "U+E0C5" },
    pen = { "" },
    recycle = { "" },
    camera = { "" },
    download = { "" },
    upload = { "" },
    question = { "" },
    search = { "" },
    globe = { "" },
    globe2 = { "" },
    id = { "" },
    phone = { "" },
    user = { "" },
    user2 = { "U+E2AF" },
    user3 = { "U+E13D" },
    users = { "" },
    users2 = { "U+E125" },
    user_no = { "U+E1E0" },
    pin = { "" },
    unpin = { "U+E196" },
    windows = { "" },
    turning = { "" },
    turning2 = { "" },
    arrow_double = { "" },
    clip = { "" },
    clipboard = { "U+E16D" },
    exclamation = { "" },
    time = { "" },
    clock = { "U+E2AD" },
    paper = { "" },
    paper2 = { "" },
    link = { "" },
    link2 = { "U+E167" },
    wrench = { "" },
    url = { "" },
    speaker = { "" },
    house = { "" },
    pallete = { "" },
    lock = { "" },
    lock_open = { "" },
    tsarrow_left = { "" },
    tsarrow_right = { "" },
    tsarrow_up = { "" },
    tsarrow_up = { "" },
    warning = { "⚠︎" },
    video = { "" },
    connection = { "" },
    heart = { "" },
    triangle_upside = { "⛛" },
    music_note = { "U+E142" },
    test = { "U+E2B1" },
    keyboard = { "U+E0D2" },
    latency0 = { "U+E1E5" },
    latency1 = { "U+E1E6" },
    latency2 = { "U+E1E7" },
    latency3 = { "U+E1E8" },
    latency4 = { "U+E1E9" },
    expand = { "U+E1D9" },
    monitor = { "U+E2F0" },
    rain = { "U+E28A" },
    likedislike = { "U+E19D" },
    text = { "U+E1C8" },
    back = { "U+E10E" },
    folder = { "U+E1C1" },
    menu = { "U+E179" },
    menu2 = { "U+E1A0" },
    at = { "U+E168" },
    circle = { "U+E235" },
    updown = { "U+E174" },

}

local d601= {}

local function d602(d603)
    if d603 == nil then return "ERROR" end
    if type(d603) ~= "string" then d603 = tostring(d603) end
    if d603 == "ERROR" then return "ERROR" end
    local d604= d603:match('^U%+([0-9A-Fa-f]+)$') or d603:match('^u%+([0-9A-Fa-f]+)$') or d603:match('^0x([0-9A-Fa-f]+)$')
    if d604 then
        local d605= tonumber(d604, 16)
        if d605 then
            local d606= nil
            if type(utf8) == 'table' and type(utf8.char) == 'function' then
                pcall(function() d606 = utf8.char(d605) end)
            end
            if not d606 then
                local function d607(d608)
                    if d608 < 0x80 then return string.char(d608) end
                    if d608 < 0x800 then return string.char(0xC0 + math.floor(d608 / 0x40), 0x80 + (d608 % 0x40)) end
                    if d608 < 0x10000 then return string.char(0xE0 + math.floor(d608 / 0x1000), 0x80 + (math.floor(d608 / 0x40) % 0x40), 0x80 + (d608 % 0x40)) end
                    if d608 < 0x110000 then return string.char(0xF0 + math.floor(d608 / 0x40000), 0x80 + (math.floor(d608 / 0x1000) % 0x40), 0x80 + (math.floor(d608 / 0x40) % 0x40), 0x80 + (d608 % 0x40)) end
                    return '?'
                end
                d606 = d607(d605)
            end
            d603 = d606 or d603
        end
    end
    if d603:sub(-1) == " " then return d603 end
    return d603 .. " "
end

function d601.get(d609,d610,d611)
    if not d609 then return "ERROR" end
    local d612= d600[d609]
    if d612 == nil then return "ERROR" end
    if type(d612) == "string" then return d602(d612) end
    if type(d612) == "table" then
        if d611 == nil then
            return d602(d612[1])
        end
        local d613= tonumber(d611) or 1
        return d602(d612[d613])
    end
    return "ERROR"
end

function d601.set(d609,d614)
	if not d609 then return false end
	if type(d614) == "string" then
		d600[d609] = { d614 }
	else
		d600[d609] = d614
	end
	return true
end

function d601.list()
	local d615= {}
	for k, d612 in pairs(d600) do
		if type(d612) == "table" then
			local d616= {}
			for d613 = 1, #d612 do d616[d613] = d612[d613] end
			d615[k] = d616
		else
			d615[k] = d612
		end
	end
	return d615
end

setmetatable(d601, {
    __index = function(d617,d618)
        local d612= d600[d618]
        if d612 == nil then return "ERROR" end
        if type(d612) == "table" then return d602(d612[1]) end
        return d602(d612)
    end,
})

return d601]]
d958["require/help/enemies"] = [[local d603= {}

local d604= entity
local d605= client
local d606= globals

function d603.list()
    return d604 and d604.get_players and d604.get_players(true) or {}
end

function d603.is_alive(d607)
    return d607 and d604.is_alive and d604.is_alive(d607) or false
end

function d603.is_dormant(d607)
    return d607 and d604.is_dormant and d604.is_dormant(d607) or false
end

function d603.player_name(d607)
    return d607 and d604.get_player_name and d604.get_player_name(d607) or nil
end

function d603.steam64(d607)
    return d607 and d604.get_steam64 and d604.get_steam64(d607) or nil
end

function d603.health(d607)
    return d607 and d604.get_prop and d604.get_prop(d607, 'm_iHealth') or 0
end

function d603.current_threat()
    return d605 and d605.current_threat and d605.current_threat() or nil
end

local d608= {}

function d603.is_afk(d607,d609,d610)
    d609 = d609 or 5
    d610 = d610 or 20
    local d611, d612, d613= d604.get_prop(d607, 'm_vecVelocity')
    local d614= 0
    if d611 and d612 and d613 then
        d614 = math.sqrt(d611 * d611 + d612 * d612 + d613 * d613)
    end
    local d615= d606 and d606.realtime and d606.realtime() or os.clock()
    if not d608[d607] then
        d608[d607] = { last_active = d615, last_check = d615 }
    end
    if d614 >= d609 then
        d608[d607].last_active = d615
    end
    d608[d607].last_check = d615
    return (d615 - d608[d607].last_active) > d610
end

function d603.distance(d607,d616)
    if not d607 or not d604.get_origin then return nil end
    local d617, d618, d619= d604.get_origin(d607)
    if not d617 then return nil end
    if not d616 then
        d616 = d604.get_local_player and d604.get_local_player()
    end
    local d620, d621, d622= d604.get_origin(d616)
    if not d620 then return nil end
    local d623, d624, d625= d617 - d620, d618 - d621, d619 - d622
    return math.sqrt(d623 * d623 + d624 * d624 + d625 * d625)
end


local function d626(d627)
    if not d627 then return "" end
    return tostring(d627):lower()
end

local function d628(d629)
    local d630= ""
    if d629 and d604.get_classname then d630 = d604.get_classname(d629) or "" end
    if d630 == "" and d629 and d605.get_model_name then
        d630 = d605.get_model_name(d629) or ""
    end
    return d626(d630)
end

function d603.has_knife(d607)
    if not d607 or not d604.get_player_weapon then return false end
    local d629= d604.get_player_weapon(d607)
    if not d629 then return false end
    local d631= d628(d629)
    return d631:find('knife') ~= nil
end

function d603.has_nade(d607)
    if not d607 or not d604.get_player_weapon then return false end
    local d629= d604.get_player_weapon(d607)
    if not d629 then return false end
    local d631= d628(d629)
    local d632= {'grenade', 'hegrenade', 'flashbang', 'smoke', 'molotov', 'incendiary', 'decoy', 'frag', 'nade'}
    for i = 1, #d632 do
        if d631:find(d632[i]) then return true end
    end
    return false
end

function d603.has_taser(d607)
    if not d607 or not d604.get_player_weapon then return false end
    local d629= d604.get_player_weapon(d607)
    if not d629 then return false end
    local d631= d628(d629)
    return d631:find('taser') ~= nil or d631:find('zeus') ~= nil
end

return d603]]
d958["require/help/ffi"] = [[local d606= rawget(_G, 'ffi')
local d607= {}

function d607.available()
  return d606 ~= nil
end

function d607.cdef(d608)
  if not d606 then error('ffi not available') end
  return d606.cdef(d608)
end

function d607.typeof(d609)
  if not d606 then error('ffi not available') end
  return d606.typeof(d609)
end

function d607.new(d609,...)
  if not d606 then error('ffi not available') end
  return d606.new(d609, ...)
end

function d607.cast(d609,d610)
  if not d606 then error('ffi not available') end
  return d606.cast(d609, d610)
end

function d607.string(d611,d612)
  if not d606 then error('ffi not available') end
  return d606.string(d611, d612)
end

function d607.copy(d613,d614,d612)
  if not d606 then error('ffi not available') end
  return d606.copy(d613, d614, d612)
end

function d607.fill(d613,d615,d612)
  if not d606 then error('ffi not available') end
  return d606.fill(d613, d615, d612)
end

function d607.sizeof(d609)
  if not d606 then error('ffi not available') end
  return d606.sizeof(d609)
end

function d607.alignof(d609)
  if not d606 then error('ffi not available') end
  return d606.alignof(d609)
end

function d607.errno()
  if not d606 then error('ffi not available') end
  return d606.errno()
end

function d607.gc(d611,d616)
  if not d606 then error('ffi not available') end
  return d606.gc(d611, d616)
end

function d607.load(d617,d618)
  if not d606 then error('ffi not available') end
  return d606.load(d617, d618)
end

function d607.metatype(d609,d619)
  if not d606 then error('ffi not available') end
  return d606.metatype(d609, d619)
end

function d607.offsetof(d609,d620)
  if not d606 then error('ffi not available') end
  return d606.offsetof(d609, d620)
end

function d607.istype(d609,d610)
  if not d606 then error('ffi not available') end
  return d606.istype(d609, d610)
end

d607.raw = d606

return d607]]
d958["require/help/globals"] = [[local d609= {}

d609.raw = globals

function d609.absoluteframetime()
  return globals.absoluteframetime()
end

function d609.chokedcommands()
  return globals.chokedcommands()
end

function d609.commandack()
  return globals.commandack()
end

function d609.curtime()
  return globals.curtime()
end

function d609.framecount()
  return globals.framecount()
end

function d609.frametime()
  return globals.frametime()
end

function d609.lastoutgoingcommand()
  return globals.lastoutgoingcommand()
end

function d609.mapname()
  return globals.mapname()
end

function d609.maxplayers()
  return globals.maxplayers()
end

function d609.oldcommandack()
  return globals.oldcommandack()
end

function d609.realtime()
  return globals.realtime()
end

function d609.servertickcount()
  return globals.servertickcount()
end

function d609.tickcount()
  return globals.tickcount()
end

function d609.tickinterval()
  return globals.tickinterval()
end

return d609]]
d958["require/help/json"] = [[local d612= rawget(_G, 'json')
local d613= {}

function d613.available()
  return d612 ~= nil
end

function d613.decode_invalid_numbers(d614)
  if not d612 then error('json not available') end
  if d614 == nil then
    return d612.decode_invalid_numbers()
  end
  return d612.decode_invalid_numbers(d614)
end

function d613.decode_max_depth(d615)
  if not d612 then error('json not available') end
  if d615 == nil then
    return d612.decode_max_depth()
  end
  return d612.decode_max_depth(d615)
end

function d613.encode_invalid_numbers(d614)
  if not d612 then error('json not available') end
  if d614 == nil then
    return d612.encode_invalid_numbers()
  end
  return d612.encode_invalid_numbers(d614)
end

function d613.encode_max_depth(d615)
  if not d612 then error('json not available') end
  if d615 == nil then
    return d612.encode_max_depth()
  end
  return d612.encode_max_depth(d615)
end

function d613.encode_number_precision(d616)
  if not d612 then error('json not available') end
  if d616 == nil then
    return d612.encode_number_precision()
  end
  return d612.encode_number_precision(d616)
end

function d613.encode_sparse_array(...)
  if not d612 then error('json not available') end
  return d612.encode_sparse_array(...)
end

function d613.parse(d617)
  if not d612 then error('json not available') end
  if d612.parse then
    return d612.parse(d617)
  end
  if d612.decode then
    return d612.decode(d617)
  end
  error('json.parse / json.decode not available')
end

function d613.stringify(d618)
  if not d612 then error('json not available') end
  if d612.stringify then
    return d612.stringify(d618)
  end
  if d612.encode then
    return d612.encode(d618)
  end
  error('json.stringify / json.encode not available')
end

d613.raw = d612

return d613]]
d958["require/help/libs"] = [[local function d615(d616)
	local d617, d618= pcall(require, d616)
	return d617 and d618 or nil
end

local d619= {
	antiaim_funcs   = 'gamesense/antiaim_funcs',
	base64          = 'gamesense/base64',
	clipboard       = 'gamesense/clipboard',
	http            = 'gamesense/http',
	csgo_weapons    = 'gamesense/csgo_weapons',
	icons           = 'gamesense/icons',
	entity          = 'gamesense/entity',
	vector          = 'vector',
	bit             = 'bit',
	ffi             = 'ffi',
	pui             = 'gamesense/pui',
	trace           = 'gamesense/trace',
	md5             = 'gamesense/md5',
	websocket       = 'gamesense/websocket',
	surface         = 'gamesense/surface',
	color           = 'gamesense/color',
}

local d620= {}
for k, v in pairs(d619) do
	d620[k] = d615(v)
end

local d621= {
	antiaim_funcs = {
		get_tickbase_shifting = "Returns true if tickbase shifting is active.",
		get_fake_lag = "Returns current fake lag value.",
		get_desync = "Returns current desync value.",
		get_manual_direction = "Returns manual anti-aim direction.",
		get_antiaim_condition = "Returns current anti-aim condition.",
		get_body_yaw = "Returns current body yaw value.",
		get_yaw_base = "Returns current yaw base value.",
		get_pitch = "Returns current pitch value.",
		get_yaw_jitter = "Returns current yaw jitter value.",
		get_enabled = "Returns if anti-aim is enabled.",
		get_fakelag_mode = "Returns fakelag mode.",
		get_fakelag_limit = "Returns fakelag limit.",
		get_fakelag_variance = "Returns fakelag variance.",
		get_fakelag_enabled = "Returns if fakelag is enabled.",
		get_double_tap = "Returns true if double tap exploit is active.",
		get_overlap = "Returns overlap value (exploit related).",
	},
	base64 = {
		encode = "Encodes a string to base64.",
		decode = "Decodes a base64 string.",
	},
	clipboard = {
		get = "Gets clipboard contents as string.",
		set = "Sets clipboard contents to string.",
	},
	http = {
		get = "Performs HTTP GET request.",
		post = "Performs HTTP POST request.",
		download = "Downloads a file from URL.",
	},
	csgo_weapons = {
		get_weapon_name = "Returns weapon name by id.",
		get_weapon_id = "Returns weapon id by name.",
		get_weapon_type = "Returns weapon type by id.",
		get_weapon_group = "Returns weapon group by id.",
		get_weapon_slot = "Returns weapon slot by id.",
		get_weapon_price = "Returns weapon price by id.",
	},
	icons = {
		hero = "Table of hero icons.",
		get_texture = "Returns texture id for icon name.",
		get_icon = "Returns icon object by name.",
		get_all_icons = "Returns all available icons.",
	},
	entity = {
		get_local_player = "Returns entindex of local player.",
		get_all = "Returns array of entindices for all entities.",
		get_players = "Returns array of player entindices.",
		get_game_rules = "Returns entindex of game rules proxy.",
		get_player_resource = "Returns entindex of player resource.",
		get_classname = "Returns classname of entity.",
		set_prop = "Sets netvar property.",
		get_prop = "Gets netvar property.",
		is_enemy = "Returns true if entity is enemy.",
		is_alive = "Returns true if entity is alive.",
		is_dormant = "Returns true if entity is dormant.",
		get_player_name = "Returns player name.",
		get_player_weapon = "Returns active weapon entindex.",
		hitbox_position = "Returns world position of hitbox.",
		get_steam64 = "Returns SteamID3.",
		get_bounding_box = "Returns bounding box coordinates.",
		get_origin = "Returns world origin of entity.",
		get_esp_data = "Returns ESP data for player.",
	},
	vector = {
		new = "Creates a new vector object.",
		dot = "Returns dot product of two vectors.",
		cross = "Returns cross product of two vectors.",
		length = "Returns length of vector.",
		normalize = "Normalizes vector.",
		add = "Adds two vectors.",
		sub = "Subtracts two vectors.",
		mul = "Multiplies vector by scalar.",
		div = "Divides vector by scalar.",
		dist = "Returns distance between two vectors.",
	},
	bit = {
		arshift = "Arithmetic right shift.",
		band = "Bitwise AND.",
		bnot = "Bitwise NOT.",
		bor = "Bitwise OR.",
		bswap = "Byte swap (endian conversion).",
		bxor = "Bitwise XOR.",
		lshift = "Logical left shift.",
		rol = "Bitwise left rotation.",
		ror = "Bitwise right rotation.",
		rshift = "Logical right shift.",
		tobit = "Normalize to 32-bit signed.",
		tohex = "Convert to hexadecimal string.",
	},
	ffi = {
		cdef = "Define C types/functions.",
		cast = "Cast value to C type.",
		new = "Allocate new C object.",
		typeof = "Get C type object.",
		string = "Convert C data to Lua string.",
	},
	pui = {
		create_panel = "Creates a custom UI panel.",
		add_icon = "Adds an icon to a panel.",
		set_icon = "Sets the icon for a panel.",
		set_panel_visible = "Shows/hides a panel.",
		set_panel_position = "Sets panel position.",
		set_panel_size = "Sets panel size.",
	},
	trace = {
		trace_line = "Performs a line trace.",
		trace_bullet = "Performs a bullet trace.",
		trace_hull = "Performs a hull trace.",
	},
	md5 = {
		sumhexa = "Returns MD5 hash as hex string.",
		sum = "Returns MD5 hash as raw bytes.",
	},
	websocket = {
		connect = "Connects to a WebSocket server.",
		send = "Sends data over WebSocket.",
		close = "Closes the WebSocket connection.",
		on_message = "Callback for incoming messages.",
	},
	surface = {
		text = "Draws text on screen.",
		rectangle = "Draws a rectangle.",
		line = "Draws a line.",
		circle = "Draws a circle.",
		gradient = "Draws a gradient rectangle.",
		load_texture = "Loads a texture from file.",
	},
	color = {
		blend = "Blends two colors.",
		lighten = "Lightens a color.",
		darken = "Darkens a color.",
		hex_to_rgba = "Converts hex to RGBA.",
		rgba_to_hex = "Converts RGBA to hex.",
	},
}

local function d622(d616)
	return d620[d616]
end

function d623()
	local d624= {}
	for k, v in pairs(_G) do
		if type(v) == "table" or type(v) == "userdata" then
			d624[#d624+1] = k
		end
	end
	return d624
end

function d625(d626)
	local d627= d621[d626]
	if not d627 then return {} end
	local d624= {}
	for k, v in pairs(d627) do
		d624[#d624+1] = k .. " - " .. v
	end
	return d624
end

return {
	get = d622,
	list = d623,
	list_features = d625,
	features = d621,
	libs = d620,
	lib_defs = d619
}
]]
d958["require/help/math"] = [[local d618= {}

function d618.clamp(d619,d620,d621)
    if not d620 and not d621 then return d619 end
    d620 = tonumber(d620) or 0
    d621 = tonumber(d621) or d620
    if d620 > d621 then d620, max = d621, d620 end
    d619 = tonumber(d619) or d620
    if d619 < d620 then return d620 end
    if d619 > d621 then return d621 end
    return d619
end

function d618.clamp01(d619)
    return d618.clamp(d619, 0, 1)
end

function d618.abs(d619)
    d619 = tonumber(d619) or 0
    return math.abs(d619)
end

function d618.max(...)
    local d622= {...}
    if #d622 == 0 then return 0 end
    local d623= nil
    for i = 1, #d622 do
        local d624= tonumber(d622[i]) or 0
        if d623 == nil or d624 > d623 then d623 = d624 end
    end
    return d623
end

function d618.min(...)
    local d622= {...}
    if #d622 == 0 then return 0 end
    local d623= nil
    for i = 1, #d622 do
        local d624= tonumber(d622[i]) or 0
        if d623 == nil or d624 < d623 then d623 = d624 end
    end
    return d623
end

function d618.atan2(d625,d626)
    d625 = tonumber(d625) or 0
    d626 = tonumber(d626) or 0
    return math.atan(d625, d626)
end

function d618.floor(d619)
    d619 = tonumber(d619) or 0
    return math.floor(d619)
end

function d618.round(d619,d627)
    d619 = tonumber(d619) or 0
    d627 = tonumber(d627) or 0
    local d628= 10 ^ d627
    return math.floor(d619 * d628 + 0.5) / d628
end

function d618.lerp(d629,d630,d631)
    d629 = tonumber(d629) or 0
    d630 = tonumber(d630) or 0
    d631 = tonumber(d631) or 0
    return d629 + (d630 - d629) * d631
end

function d618.distance2d(d632,d633,d634,d635)
    d632 = tonumber(d632) or 0
    d633 = tonumber(d633) or 0
    d634 = tonumber(d634) or 0
    d635 = tonumber(d635) or 0
    return math.sqrt((d634 - d632)^2 + (d635 - d633)^2)
end

function d618.distance3d(d632,d633,d636,d634,d635,d637)
    d632 = tonumber(d632) or 0
    d633 = tonumber(d633) or 0
    d636 = tonumber(d636) or 0
    d634 = tonumber(d634) or 0
    d635 = tonumber(d635) or 0
    d637 = tonumber(d637) or 0
    return math.sqrt((d634 - d632)^2 + (d635 - d633)^2 + (d637 - d636)^2)
end

function d618.sign(d619)
    d619 = tonumber(d619) or 0
    return (d619 > 0 and 1) or (d619 < 0 and -1) or 0
end

function d618.frac(d619)
    d619 = tonumber(d619) or 0
    return d619 - math.floor(d619)
end

function d618.is_even(d619)
    d619 = tonumber(d619) or 0
    return d619 % 2 == 0
end

function d618.is_odd(d619)
    d619 = tonumber(d619) or 0
    return d619 % 2 ~= 0
end

function d618.sqr(d619)
    d619 = tonumber(d619) or 0
    return d619 * d619
end

function d618.cube(d619)
    d619 = tonumber(d619) or 0
    return d619 * d619 * d619
end

function d618.approximately(d629,d630,d638)
    d629 = tonumber(d629) or 0
    d630 = tonumber(d630) or 0
    d638 = tonumber(d638) or 1e-6
    return math.abs(d629 - d630) < d638
end

function d618.rad_to_deg(d639)
    d639 = tonumber(d639) or 0
    return d639 * (180 / math.pi)
end

function d618.deg_to_rad(d640)
    d640 = tonumber(d640) or 0
    return d640 * (math.pi / 180)
end

function d618.wrap_degrees(d641)
    local d629= tonumber(d641) or 0
    d629 = d629 % 360
    if d629 < 0 then d629 = d629 + 360 end
    return d629
end

function d618.normalize_angle(d641)
    local d629= tonumber(d641) or 0
    d629 = d629 % 360
    if d629 > 180 then d629 = d629 - 360 end
    return d629
end

function d618.angle_diff(d629,d630)
    d629 = tonumber(d629) or 0
    d630 = tonumber(d630) or 0
    local d642= (d629 - d630) % 360
    if d642 > 180 then d642 = d642 - 360 end
    return d642
end

function d618.lerp_angle(d629,d630,d631)
    d629 = tonumber(d629) or 0
    d630 = tonumber(d630) or 0
    d631 = tonumber(d631) or 0
    local d642= d618.angle_diff(d630, d629)
    return (d629 + d642 * d631) % 360
end

function d618.map(d619,d643,d644,d645,d646)
    d619 = tonumber(d619) or 0
    d643 = tonumber(d643) or 0
    d644 = tonumber(d644) or d643
    d645 = tonumber(d645) or 0
    d646 = tonumber(d646) or d645
    if d644 == d643 then return d645 end
    return (d619 - d643) * (d646 - d645) / (d644 - d643) + d645
end

function d618.smoothstep(d647,d648,d626)
    d647 = tonumber(d647) or 0
    d648 = tonumber(d648) or d647
    d626 = tonumber(d626) or 0
    if d648 == d647 then return 0 end
    local d631= d618.clamp((d626 - d647) / (d648 - d647), 0, 1)
    return d631 * d631 * (3 - 2 * d631)
end

function d618.random_float(d620,d621)
    d620 = tonumber(d620) or 0
    d621 = tonumber(d621) or d620
    if d620 > d621 then d620, max = d621, d620 end
    return d620 + math.random() * (d621 - d620)
end

function d618.random_int(d620,d621)
    d620 = tonumber(d620) or 0
    d621 = tonumber(d621) or d620
    if d620 > d621 then d620, max = d621, d620 end
    return math.random(d620, d621)
end

function d618.mean(d649)
    if type(d649) ~= 'table' or #d649 == 0 then return 0 end
    local d650= 0
    for i = 1, #d649 do d650 = d650 + (tonumber(d649[i]) or 0) end
    return d650 / #d649
end

function d618.swap(d629,d630)
    return d630, d629
end

return d618]]
d958["require/help/panorama"] = [[local d621= {}

d621.raw = panorama

function d621.loadstring(d622,d623)
  return panorama.loadstring(d622, d623)
end

function d621.open(d623)
  return panorama.open(d623)
end

return d621]]
d958["require/help/plist"] = [[local d624= {}

d624.raw = plist

function d624.get(d625,d626)
  return plist.get(d625, d626)
end

function d624.set(d625,d626,d627)
  return plist.set(d625, d626, d627)
end

return d624]]
d958["require/help/reference"] = [[local d627= {}

d627.known_items = {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

function d627.add_known(d628)
    for _, it in ipairs(d628 or {}) do
        table.insert(d627.known_items, it)
    end
end

function d627.get(d629,d630,d631)
    return ui.reference(d629, d630, d631)
end

function d627.build(d632)
    local d633= {}
    local d634= {}
    for i, item in ipairs(d632) do
        local d635= {ui.reference(item[1], item[2], item[3])}
        d633[i] = d635
        for _, ref in ipairs(d635) do
            if ref ~= nil then
                d634[ref] = true
            end
        end
    end
    return d633, d634
end

function d627.build_known()
    return d627.build(d627.known_items)
end

function d627.get_all_known()
    return d627.known_items
end

return d627]]
d958["require/help/references_old"] = [[

local d630= {}

local function d631(d632)
    
    if type(d632) ~= 'table' then
        local d633= d632
        return {
            raw = d633,
            get = function()
                local d634, d635= pcall(ui.get, d633)
                if d634 then return d635 end
                return nil
            end
        }
    end

    
    
    
    local d636= d632
    return {
        raw = d636,
        get = function()
            if d636[2] ~= nil then
                local d634, d635= pcall(ui.get, d636[2])
                if d634 then return d635 end
            end
            if d636[1] ~= nil then
                local d634, d635= pcall(ui.get, d636[1])
                if d634 then return d635 end
            end
            return nil
        end
    }
end


d630.minimum_damage = d631(ui.reference("RAGE", "Aimbot", "Minimum damage"))
d630.minimum_damage_override = d631({ ui.reference("RAGE", "Aimbot", "Minimum damage override") })
d630.doubletap = d631({ ui.reference("RAGE", "Aimbot", "Double tap") })
d630.force_body_aim = d631({ ui.reference("RAGE", "Aimbot", "Force body aim") })
d630.force_safe_point = d631({ ui.reference("RAGE", "Aimbot", "Force safe point") })
d630.duck_peek_assist = d631({ ui.reference("RAGE", "Other", "Duck peek assist") })
d630.quick_peek_assist = d631({ ui.reference("RAGE", "Aimbot", "Quick peek assist") })


d630.pitch = d631(ui.reference("AA", "Anti-aimbot angles", "Pitch"))
d630.yaw_base = d631(ui.reference("AA", "Anti-aimbot angles", "Yaw base"))
d630.yaw = d631(ui.reference("AA", "Anti-aimbot angles", "Yaw"))
d630.yaw_jitter = d631(ui.reference("AA", "Anti-aimbot angles", "Yaw jitter"))
d630.body_yaw = d631(ui.reference("AA", "Anti-aimbot angles", "Body yaw"))
d630.roll = d631(ui.reference("AA", "Anti-aimbot angles", "Roll"))

return d630]]
d958["require/help/renderer"] = [[local d633= {}

d633.raw = renderer

function d633.blur(d634,d635,d636,d637,d638,d639)
  return renderer.blur(d634, d635, d636, d637, d638, d639)
end

function d633.circle(d634,d635,d640,d641,d642,d643,d644,d645,d646)
  return renderer.circle(d634, d635, d640, d641, d642, d643, d644, d645, d646)
end

function d633.circle_outline(d634,d635,d640,d641,d642,d643,d644,d645,d646,d647)
  return renderer.circle_outline(d634, d635, d640, d641, d642, d643, d644, d645, d646, d647)
end

function d633.gradient(d634,d635,d636,d637,d648,d649,d650,d651,d652,d653,d654,d655,d656)
  return renderer.gradient(d634, d635, d636, d637, d648, d649, d650, d651, d652, d653, d654, d655, d656)
end

function d633.indicator(d640,d641,d642,d643,...)
  return renderer.indicator(d640, d641, d642, d643, ...)
end

function d633.line(d657,d658,d659,d660,d640,d641,d642,d643)
  return renderer.line(d657, d658, d659, d660, d640, d641, d642, d643)
end

function d633.load_jpg(d661,d662,d663)
  return renderer.load_jpg(d661, d662, d663)
end

function d633.load_png(d661,d662,d663)
  return renderer.load_png(d661, d662, d663)
end

function d633.load_rgba(d661,d662,d663)
  return renderer.load_rgba(d661, d662, d663)
end

function d633.load_svg(d661,d662,d663)
  return renderer.load_svg(d661, d662, d663)
end

function d633.measure_text(d664,...)
  return renderer.measure_text(d664, ...)
end

function d633.rectangle(d634,d635,d636,d637,d640,d641,d642,d643)
  return renderer.rectangle(d634, d635, d636, d637, d640, d641, d642, d643)
end

function d633.text(d634,d635,d640,d641,d642,d643,d664,d665,...)
  return renderer.text(d634, d635, d640, d641, d642, d643, d664, d665, ...)
end

function d633.texture(d666,d634,d635,d636,d637,d640,d641,d642,d643,d667)
  return renderer.texture(d666, d634, d635, d636, d637, d640, d641, d642, d643, d667)
end

function d633.triangle(d657,d658,d659,d660,d668,d669,d640,d641,d642,d643)
  return renderer.triangle(d657, d658, d659, d660, d668, d669, d640, d641, d642, d643)
end

function d633.world_to_screen(d634,d635,d670)
  return renderer.world_to_screen(d634, d635, d670)
end

function d633.rectangle_outline(d634,d635,d636,d637,d640,d641,d642,d643,d647)
  d647 = d647 or 1
  for i = 0, d647 - 1 do
    renderer.line(d634 + i, d635 + i, d634 + d636 - i, d635 + i, d640, d641, d642, d643)
    renderer.line(d634 + i, d635 + d637 - i, d634 + d636 - i, d635 + d637 - i, d640, d641, d642, d643)
    renderer.line(d634 + i, d635 + i, d634 + i, d635 + d637 - i, d640, d641, d642, d643)
    renderer.line(d634 + d636 - i, d635 + i, d634 + d636 - i, d635 + d637 - i, d640, d641, d642, d643)
  end
end

function d633.text_centered(d634,d635,d640,d641,d642,d643,d664,d665,...)
  local d636, d637= renderer.measure_text(d664, ...)
  if not d636 or not d637 then return end
  return renderer.text(d634 - d636 / 2, d635 - d637 / 2, d640, d641, d642, d643, d664, d665, ...)
end

function d633.texture_from_file(d671)
  local d661= readfile(d671)
  if not d661 then return nil end
  local d666= renderer.load_png(d661)
  if not d666 then
    d666 = renderer.load_jpg(d661)
  end
  return d666
end

return d633]]
d958["require/help/safe"] = [[local d636= {}

function d636.safe_call(d637,...)
	local d638, d639= pcall(d637, ...)
	return d638 and d639 or nil
end

function d636.safe_set(d640,d641)
	local d638= pcall(function() ui.set(d640, d641) end)
	return d638
end

function d636.safe_get(d640)
	local d638, d639= pcall(function() return ui.get(d640) end)
	return d638 and d639 or nil
end

return d636]]
d958["require/help/self"] = [[local d639= {}

local d640= entity
local d641= globals
local d642= client

function d639.index()
	return d640 and d640.get_local_player and d640.get_local_player() or nil
end

function d639.exists()
	return d639.index() ~= nil
end

function d639.is_alive()
	local d643= d639.index()
	return d643 and d640.is_alive and d640.is_alive(d643) or false
end

function d639.health()
	local d643= d639.index()
	return d643 and d640.get_prop and d640.get_prop(d643, 'm_iHealth') or 0
end

function d639.ping()
	return d642 and d642.latency and d642.latency() or 0
end

function d639.velocity()
	local d643= d639.index()
	if not d643 or not d640.get_prop then return 0 end
	local d644, d645, d646= d640.get_prop(d643, 'm_vecVelocity')
	if d644 and d645 and d646 then
		return math.sqrt(d644 * d644 + d645 * d645 + d646 * d646)
	end
	return 0
end

function d639.velocity2d()
	local d643= d639.index()
	if not d643 or not d640.get_prop then return 0 end
	local d644, d645= d640.get_prop(d643, 'm_vecVelocity')
	if d644 and d645 then
		return math.sqrt(d644 * d644 + d645 * d645)
	end
	return 0
end

function d639.weapon()
	local d643= d639.index()
	return d643 and d640.get_player_weapon and d640.get_player_weapon(d643) or nil
end

function d639.tickbase_shifted()
	
	return false
end

function d639.simtime()
	local d643= d639.index()
	return d643 and d640.get_prop and d640.get_prop(d643, 'm_flSimulationTime') or 0
end

function d639.eye_angles()
	return d642 and d642.camera_angles and d642.camera_angles() or nil
end

function d639.fps()
	local d647= d641 and d641.absoluteframetime and d641.absoluteframetime() or d641.frametime and d641.frametime() or 0.01
	if d647 > 0 then
		return math.floor(1 / d647 + 0.5)
	end
	return 0
end

function d639.map()
	return d641 and d641.mapname and d641.mapname() or nil
end

function d639.is_dormant()
	local d643= d639.index()
	return d643 and d640.is_dormant and d640.is_dormant(d643) or false
end

function d639.team_number()
	local d643= d639.index()
	return d643 and d640.get_prop and d640.get_prop(d643, 'm_iTeamNum') or 0
end

function d639.player_name()
	local d643= d639.index()
	return d643 and d640.get_player_name and d640.get_player_name(d643) or nil
end

function d639.steam64()
	local d643= d639.index()
	return d643 and d640.get_steam64 and d640.get_steam64(d643) or nil
end

function d639.ammo_count()
	local d648= d639.weapon()
	return d648 and d640.get_prop and d640.get_prop(d648, 'm_iClip1') or 0
end

function d639.has_armor()
	local d643= d639.index()
	return d643 and d640.get_prop and d640.get_prop(d643, 'm_ArmorValue') > 0 or false
end

function d639.has_helmet()
	local d643= d639.index()
	return d643 and d640.get_prop and d640.get_prop(d643, 'm_bHasHelmet') == 1 or false
end

function d639.current_tick()
	return d641 and d641.tickcount and d641.tickcount() or 0
end

function d639.tick_interval()
	return d641 and d641.tickinterval and d641.tickinterval() or 0
end

function d639.current_frame()
	return d641 and d641.framecount and d641.framecount() or 0
end

function d639.current_time()
	return d641 and d641.curtime and d641.curtime() or 0
end

function d639.real_latency()
	return d642 and d642.real_latency and d642.real_latency() or 0
end

function d639.system_time()
	return d642 and d642.system_time and d642.system_time() or {0,0,0,0}
end

function d639.unix_time()
	return d642 and d642.unix_time and d642.unix_time() or 0
end

function d639.kills()
	local d643= d639.index()
	if not d643 or not d640.get_prop then return 0 end
	local d649= d640.get_player_resource and d640.get_player_resource()
	if d649 then
		return d640.get_prop(d649, 'm_iKills', d643) or 0
	end
	return 0
end

function d639.deaths()
	local d643= d639.index()
	if not d643 or not d640.get_prop then return 0 end
	local d649= d640.get_player_resource and d640.get_player_resource()
	if d649 then
		return d640.get_prop(d649, 'm_iDeaths', d643) or 0
	end
	return 0
end

function d639.assists()
	local d643= d639.index()
	if not d643 or not d640.get_prop then return 0 end
	local d649= d640.get_player_resource and d640.get_player_resource()
	if d649 then
		return d640.get_prop(d649, 'm_iAssists', d643) or 0
	end
	return 0
end

return d639
]]
d958["require/help/string"] = [[local d642= {}

function d642.lower(d643)
	return string.lower(d643)
end

function d642.upper(d643)
	return string.upper(d643)
end

function d642.capitalize(d643)
	return (d643:gsub("^%l", string.upper):gsub("^(%u)(.*)", function(d644,d645) return d644 .. string.lower(d645) end))
end

function d642.title(d643)
	return (d643:gsub("%S+", function(d646)
		return d646:sub(1,1):upper() .. d646:sub(2):lower()
	end))
end

function d642.random_case(d643)
	local d647= {}
	for i = 1, #d643 do
		local d648= d643:sub(i,i)
		if math.random() < 0.5 then
			d647[i] = string.lower(d648)
		else
			d647[i] = string.upper(d648)
		end
	end
	return table.concat(d647)
end

function d642.startswith(d643,d649)
	return d643:sub(1, #d649) == d649
end

function d642.endswith(d643,d650)
	return d650 == '' or d643:sub(-#d650) == d650
end

function d642.byte(d643,d651,d652)
	return string.byte(tostring(d643 or ""), d651, d652)
end

function d642.char(...)
	return string.char(...)
end

function d642.find(d643,d653,d654,d655)
	return string.find(tostring(d643 or ""), d653, d654, d655)
end

function d642.format(d656,...)
	return string.format(d656, ...)
end

function d642.gmatch(d643,d653)
	return string.gmatch(tostring(d643 or ""), d653)
end

function d642.gsub(d643,d653,d657,d658)
	return string.gsub(tostring(d643 or ""), d653, d657, d658)
end

function d642.split(d643,d659)
	local d660= {}
	if d659 == '' then
		for d651 = 1, #d643 do d660[d651] = d643:sub(d651,d651) end
		return d660
	end
	local d653= string.format("([^%s]+)", d659)
	for part in d643:gmatch(d653) do
		d660[#d660+1] = part
	end
	return d660
end

function d642.join(d661,d659)
	return table.concat(d661, d659)
end

function d642.replace(d643,d653,d657)
	return d643:gsub(d653, d657)
end

function d642.reverse(d643)
	return string.reverse(d643)
end

function d642.repeat_str(d643,d658)
	return string.rep(d643, d658)
end

function d642.rep(d643,d658)
	return string.rep(tostring(d643 or ""), d658)
end

function d642.contains(d643,d662)
	return d643:find(d662, 1, true) ~= nil
end

function d642.count(d643,d662)
	if d662 == '' then return 0 end
	local d663= 0
	local d664= 1
	while true do
		local d665= d643:find(d662, d664, true)
		if not d665 then break end
		d663 = d663 + 1
		d664 = d665 + #d662
	end
	return d663
end

function d642.is_empty(d643)
	return d643 == nil or d643 == ''
end

function d642.is_digit(d643)
	return d643:match("^%d+$") ~= nil
end

function d642.is_alpha(d643)
	return d643:match("^%a+$") ~= nil
end

function d642.random_string(d666)
	local d667= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local d647= {}
	for d651 = 1, d666 do
		local d668= math.random(1, #d667)
		d647[d651] = d667:sub(d668, d668)
	end
	return table.concat(d647)
end

function d642.safe_substr(d643,d651,d652)
	local d669= tostring(d643 or "")
	local d658= #d669
	local d665= tonumber(d651) or 1
	if d665 < 0 then d665 = d658 + 1 + d665 end
	if d665 < 1 then d665 = 1 end
	if d652 == nil then
		return d669:sub(d665)
	end
	local d670= tonumber(d652)
	if not d670 then
		return d669:sub(d665)
	end
	if d670 >= 0 then
		return d669:sub(d665, math.min(d658, d665 + d670 - 1))
	else
		local d671= d658 + d670
		if d671 < d665 then return "" end
		return d669:sub(d665, d671)
	end
end

function d642.sub(d643,d669,d672)
	return string.sub(tostring(d643 or ""), d669, d672)
end

function d642.len(d643)
	return string.len(tostring(d643 or ""))
end

function d642.match(d643,d653,d654)
	return string.match(tostring(d643 or ""), d653, d654)
end

function d642.trim(d643)
	return (tostring(d643 or ""):gsub("^%s*(.-)%s*$", "%1"))
end

function d642.ltrim(d643)
	return (tostring(d643 or ""):gsub("^%s*(.-)$", "%1"))
end

function d642.rtrim(d643)
	return (tostring(d643 or ""):gsub("^(.-)%s*$", "%1"))
end

function d642.escape_pattern(d643)
	return tostring(d643 or ""):gsub("([%%%$%(%)%.%[%]%*%+%-%?%^])", "%%%1")
end

function d642.ensure_prefix(d643,d649)
	local d669= tostring(d643 or "")
	local d673= tostring(d649 or "")
	if d673 == "" then return d669 end
	if d669:sub(1, #d673) == d673 then return d669 end
	return d673 .. d669
end

function d642.ensure_suffix(d643,d650)
	local d669= tostring(d643 or "")
	local d674= tostring(d650 or "")
	if d674 == "" then return d669 end
	if d669:sub(-#d674) == d674 then return d669 end
	return d669 .. d674
end

function d642.truncate(d643,d675,d676)
	local d669= tostring(d643 or "")
	local d677= tonumber(d675) or 0
	if d677 <= 0 or #d669 <= d677 then return d669 end
	local d672= tostring(d676 or "...")
	local d678= d677 - #d672
	if d678 <= 0 then return d672:sub(1, d677) end
	return d669:sub(1, d678) .. d672
end

local d679= {
	a = '4', A = '4', e = '3', E = '3', i = '1', I = '1', o = '0', O = '0',
	s = '5', S = '5', t = '7', T = '7', b = '8', B = '8', g = '6', G = '6',
	z = '2', Z = '2', l = '1', L = '1'
}

function d642.leet(d643,d680)
	local d669= tostring(d643 or "")
	local d673= tonumber(d680) or 1
	if d673 <= 0 then return d669 end
	local d647= {}
	for d651 = 1, #d669 do
		local d648= d669:sub(d651,d651)
		local d645= d679[d648]
		if d645 and math.random() <= d673 then d647[#d647+1] = d645 else d647[#d647+1] = d648 end
	end
	return table.concat(d647)
end

function d642.pipeline(d643,...)
	local d669= tostring(d643 or "")
	for d651 = 1, select('#', ...) do
		local d681= select(d651, ...)
		if type(d681) == 'function' then
			d669 = d681(d669)
		elseif type(d681) == 'string' and d642[d681] then
			d669 = d642[d681](d669)
		end
	end
	return d669
end

return d642]]
d958["require/help/time"] = [[local d645= {}

local d646= client
local d647= globals

local function d648()
	if d647 and d647.realtime then
		return d647.realtime()
	end
	if d646 and d646.timestamp then
		local d649= d646.timestamp()
		if d649 then return d649 / 1000 end
	end
	return 0
end

function d645.simtime()
	if d647 and d647.curtime then return d647.curtime() end
	return d648()
end

function d645.realtime()
	return d648()
end

function d645.tickcount()
	if d647 and d647.tickcount then return d647.tickcount() end
	local d650= d645.tickinterval()
	if d650 and d650 > 0 then return math.floor(d648() / d650) end
	return 0
end

function d645.tickinterval()
	if d647 and d647.tickinterval then return d647.tickinterval() end
	return 0.015625
end

function d645.seconds_to_ticks(d651)
	local d652= d645.tickinterval()
	if d652 and d652 > 0 then return math.floor(d651 / d652 + 0.5) end
	return math.floor(d651 * 64 + 0.5)
end

function d645.ticks_to_seconds(d653)
	local d652= d645.tickinterval()
	if d652 then return d653 * d652 end
	return d653 * 0.015625
end

function d645.frametime()
	if d647 and d647.frametime then return d647.frametime() end
	return 0
end

function d645.absoluteframetime()
	if d647 and d647.absoluteframetime then return d647.absoluteframetime() end
	return 0
end

function d645.framecount()
	if d647 and d647.framecount then return d647.framecount() end
	return 0
end

function d645.framecount_to_seconds(d654)
	local d655= d645.frametime()
	return d654 * (d655 or 0)
end

function d645.seconds_to_framecount(d651)
	local d655= d645.frametime()
	if d655 and d655 > 0 then return math.floor(d651 / d655 + 0.5) end
	return math.floor(d651 * 60 + 0.5)
end

function d645.new(d656)
	return { start = d648(), duration = d656 or 0 }
end

function d645.expired(d657)
	return d648() - (d657.start or 0) >= (d657.duration or 0)
end

function d645.reset(d657,d656)
	d657.start = d648()
	if d656 then d657.duration = d656 end
end

function d645.elapsed(d657)
	return d648() - (d657.start or 0)
end

function d645.interval(d652,d658)
	local d659= d648()
	return function(...)
		local d660= d648()
		if d660 - d659 >= d652 then
			d659 = d660
			d658(...)
		end
	end
end

function d645.timeout(d661,d658)
	local d662= false
	local d663= d648()
	return function(...)
		if not d662 and d648() - d663 >= d661 then
			d662 = true
			d658(...)
		end
	end
end

function d645.debounce(d652,d658)
	local d659= 0
	return function(...)
		local d660= d648()
		if d660 - d659 >= d652 then
			d659 = d660
			d658(...)
		end
	end
end

function d645.throttle(d652,d658)
	local d659= 0
	return function(...)
		local d660= d648()
		if d660 - d659 >= d652 then
			d659 = d660
			d658(...)
		end
	end
end

function d645.wait(d661)
	local d663= d648()
	return function()
		return d648() - d663 >= d661
	end
end

function d645.stopwatch()
	local d664= { running = false, start = 0, elapsed = 0 }
	function d664:start()
		if not self.running then
			self.running = true
			self.start = d648()
		end
	end
	function d664:stop()
		if self.running then
			self.running = false
			self.elapsed = self.elapsed + (d648() - (self.start or 0))
		end
	end
	function d664:reset()
		self.running = false
		self.start = 0
		self.elapsed = 0
	end
	function d664:get()
		if self.running then
			return self.elapsed + (d648() - (self.start or 0))
		else
			return self.elapsed
		end
	end
	return d664
end

d645.Scheduler = {}
d645.Scheduler.__index = d645.Scheduler

function d645.Scheduler.new()
    return setmetatable({ tasks = {} }, d645.Scheduler)
end

function d645.Scheduler:add(d652,d658)
	self.tasks[#self.tasks+1] = { interval = d652, callback = d658, last = d648() }
end

function d645.Scheduler:remove(d658)
    for i = #self.tasks, 1, -1 do
        if self.tasks[i].callback == d658 then
            table.remove(self.tasks, i)
        end
    end
end

function d645.Scheduler:run(...)
	local d660= d648()
	for _, task in ipairs(self.tasks) do
		if d660 - task.last >= task.interval then
			task.last = d660
			task.callback(...)
		end
	end
end

function d645.safe_timeout(d661,d658)
	local d663= d648()
	local d662= false
	return function(...)
		if not d662 and d648() - d663 >= d661 then
			d662 = true
			d658(...)
		end
	end
end

function d645.lerp(d665,d666,d660)
	return d665 + (d666 - d665) * d660
end

function d645.ease_in_out(d660)
	if d660 < 0 then d660 = 0 end
	if d660 > 1 then d660 = 1 end
	return d660 < 0.5 and 2 * d660 * d660 or -1 + (4 - 2 * d660) * d660
end

function d645.ping_pong(d660,d667)
	if d667 <= 0 then return 0 end
	local d668= d660 % (d667 * 2)
	if d668 < d667 then return d668 / d667 end
	return 1 - ((d668 - d667) / d667)
end

function d645.apply_animation(d656,d669,d670)
	local d663= d648()
	return function()
		local d660= (d648() - d663) / (d656 or 1)
		if d660 >= 1 then
			d669(1)
			if d670 then d670() end
			return true
		else
			d669(d660)
			return false
		end
	end
end

function d645.within_ticks_window(d671,d672)
	local d673= d645.tickcount()
	if not d673 or not d671 then return false end
	return d673 - d671 <= (d672 or 0)
end

return d645]]
d958["require/help/trace"] = [[]]
d958["require/help/ui"] = [[local d651= {}

d651.raw = ui

local function d652()
    if type(ui) ~= 'table' then
        error('ui library is not available in this environment')
    end
end

function d651.available()
    return type(ui) == 'table'
end

function d651.get(d653)
    d652()
    return ui.get(d653)
end

function d651.is_menu_open()
    d652()
    return ui.is_menu_open()
end

function d651.menu_position()
    d652()
    return ui.menu_position()
end

function d651.menu_size()
    d652()
    return ui.menu_size()
end

function d651.mouse_position()
    d652()
    return ui.mouse_position()
end

function d651.name(d653)
    d652()
    return ui.name(d653)
end


function d651.new_button(d654,d655,d656,d657)
    d652()
    return ui.new_button(d654, d655, d656, d657)
end

function d651.new_checkbox(d654,d655,d656)
    d652()
    return ui.new_checkbox(d654, d655, d656)
end

function d651.new_color_picker(d654,d655,d656,d658,d659,d660,d661)
    d652()
    return ui.new_color_picker(d654, d655, d656, d658 or 0, d659 or 0, d660 or 0, d661 or 255)
end

function d651.new_combobox(d654,d655,d656,...)
    d652()
    return ui.new_combobox(d654, d655, d656, ...)
end

function d651.new_hotkey(d654,d655,d656,d662,d663)
    d652()
    return ui.new_hotkey(d654, d655, d656, d662 and true or false, d663)
end

function d651.new_label(d654,d655,d656)
    d652()
    return ui.new_label(d654, d655, d656)
end

function d651.new_listbox(d654,d655,d656,d664)
    d652()
    return ui.new_listbox(d654, d655, d656, d664)
end

function d651.new_multiselect(d654,d655,d656,...)
    d652()
    return ui.new_multiselect(d654, d655, d656, ...)
end

function d651.new_slider(d654,d655,d656,d665,d666,d667,d668,d669,d670,d671)
    d652()
    return ui.new_slider(d654, d655, d656, d665, d666, d667, d668, d669, d670, d671)
end

function d651.new_string(d656,d672)
    d652()
    return ui.new_string(d656, d672)
end

function d651.new_textbox(d654,d655,d656)
    d652()
    return ui.new_textbox(d654, d655, d656)
end

function d651.reference(d654,d655,d656)
    d652()
    return ui.reference(d654, d655, d656)
end


function d651.set(d653,...)
    d652()
    return ui.set(d653, ...)
end

function d651.set_callback(d653,d657)
    d652()
    return ui.set_callback(d653, d657)
end

function d651.set_enabled(d653,d673)
    d652()
    return ui.set_enabled(d653, d673)
end

function d651.set_visible(d653,d674)
    d652()
    return ui.set_visible(d653, d674)
end

function d651.type(d653)
    d652()
    return ui.type(d653)
end

function d651.update(d653,...)
    d652()
    if ui.update then
        return ui.update(d653, ...)
    end
    error('ui.update is not supported in this environment')
end

function d651.get_color(d653)
    d652()
    local d658,d659,d660,d661= ui.get(d653)
    if d658 == nil then return nil end
    return { r = d658, g = d659, b = d660, a = d661 }
end

function d651.set_color(d653,d675)
    d652()
    if type(d675) == 'table' then
        return ui.set(d653, d675.r or 0, d675.g or 0, d675.b or 0, d675.a or 255)
    else
        error('color must be a table {r,g,b,a}')
    end
end

function d651.get_multiselect(d653)
    d652()
    local d676= ui.get(d653)
    return d676
end

function d651.list_refs(d654,d655)
    d652()
    local d677= {}
    for _, d656 in ipairs(ui.get_children and ui.get_children(d654, d655) or {}) do
        d677[#d677+1] = ui.reference(d654, d655, d656)
    end
    return d677
end

return d651]]
d958["require/help/vector"] = [[local d654
do
    local function d655(d656,d657,d658)
        local d659= { x = 0, y = 0, z = 0 }
        if type(d656) == "table" then
            d659.x = d656.x or d656[1] or 0
            d659.y = d656.y or d656[2] or 0
            d659.z = d656.z or d656[3] or 0
        elseif type(d656) == "number" then
            d659.x = d656
            d659.y = d657 or 0
            d659.z = d658 or 0
        elseif d656 ~= nil then
            d659.x = (d656.x or d656[1]) or 0
            d659.y = (d656.y or d656[2]) or 0
            d659.z = (d656.z or d656[3]) or 0
        end
        return setmetatable(d659, vector_mt)
    end

    local d660= {}

    vector_mt = {
        __index = function(d661,d662)
            if d662 == 1 then return rawget(d661,"x") end
            if d662 == 2 then return rawget(d661,"y") end
            if d662 == 3 then return rawget(d661,"z") end
            local d659= rawget(d661,d662)
            if d659 ~= nil then return d659 end
            return d660[d662]
        end,
        __sub = function(d656,d657)
            return d655((d656.x or 0) - (d657.x or 0), (d656.y or 0) - (d657.y or 0), (d656.z or 0) - (d657.z or 0))
        end,
        __add = function(d656,d657)
            return d655((d656.x or 0) + (d657.x or 0), (d656.y or 0) + (d657.y or 0), (d656.z or 0) + (d657.z or 0))
        end,
        __mul = function(d656,d657)
            if type(d656) == 'number' then return d655(d656 * (d657.x or 0), d656 * (d657.y or 0), d656 * (d657.z or 0)) end
            if type(d657) == 'number' then return d655((d656.x or 0) * d657, (d656.y or 0) * d657, (d656.z or 0) * d657) end
            return nil
        end,
        __div = function(d656,d657)
            if type(d657) == 'number' and d657 ~= 0 then return d655((d656.x or 0) / d657, (d656.y or 0) / d657, (d656.z or 0) / d657) end
            return nil
        end,
        __unm = function(d656) return d655(-(d656.x or 0), -(d656.y or 0), -(d656.z or 0)) end,
        __tostring = function(d656) return string.format("vec(%.3f, %.3f, %.3f)", d656.x or 0, d656.y or 0, d656.z or 0) end
    }

    d660.length = function(d663) return math.sqrt((d663.x or 0)^2 + (d663.y or 0)^2 + (d663.z or 0)^2) end
    d660.dot = function(d656,d657) return (d656.x or 0)*(d657.x or 0) + (d656.y or 0)*(d657.y or 0) + (d656.z or 0)*(d657.z or 0) end
    d660.cross = function(d656,d657)
        return d655((d656.y or 0)*(d657.z or 0) - (d656.z or 0)*(d657.y or 0),
                        (d656.z or 0)*(d657.x or 0) - (d656.x or 0)*(d657.z or 0),
                        (d656.x or 0)*(d657.y or 0) - (d656.y or 0)*(d657.x or 0))
    end
    d660.normalized = function(d663)
        local d664= d660.length(d663)
        if d664 == 0 or d664 == nil then return d655(0,0,0) end
        return d655((d663.x or 0)/d664, (d663.y or 0)/d664, (d663.z or 0)/d664)
    end
    d660.normalize = function(d663)
        local d664= d660.length(d663)
        if d664 == 0 or d664 == nil then return d663 end
        d663.x = (d663.x or 0)/d664
        d663.y = (d663.y or 0)/d664
        d663.z = (d663.z or 0)/d664
        return d663
    end
    d660.copy = function(d663) return d655(d663.x or 0, d663.y or 0, d663.z or 0) end
    d660.distance_to = function(d663,d665)
        local d666= d665
        if type(d665) == 'number' then d666 = d654(d665) end
        local d667= (d663.x or 0) - (d666.x or 0)
        local d668= (d663.y or 0) - (d666.y or 0)
        local d669= (d663.z or 0) - (d666.z or 0)
        return math.sqrt(d667*d667 + d668*d668 + d669*d669)
    end
    d660.to_screen = function(d663)
        if not renderer or not renderer.world_to_screen then return nil end
        return renderer.world_to_screen(d663.x or 0, d663.y or 0, d663.z or 0)
    end
    d660.to_angles = function(d663,d665)
        local d666= d665
        if not d666 then return nil end
        local d667= (d666.x or 0) - (d663.x or 0)
        local d668= (d666.y or 0) - (d663.y or 0)
        local d669= (d666.z or 0) - (d663.z or 0)
        local d670= math.deg(math.atan2(d668, d667))
        local d671= math.sqrt(d667*d667 + d668*d668)
        local d672= -math.deg(math.atan2(d669, d671))
        return d672, d670
    end

    d654 = setmetatable({}, {
        __call = function(d673,d656,d657,d658)
            return d655(d656, d657, d658)
        end
    })
end
return d654]]
d958["main"] = [[


local function d657(d658)
    local d659, d660= pcall(require, d658)
    if d659 then
        return d660
    else
        return nil
    end
end




d657("require/brain/dll")





local function d661()

    d657("require/brain/test")

    local d662= {
        menu = d657("require/abc/menu_header"),
        login = d657("require/abc/login_system"),
        config = d657("require/abc/config_system"),
        player_condition = d657("require/aa/player_condition"),
        menu_setup = d657("require/abc/menu_setup"),
        gc = d657("require/abc/garbage_collector"),
        pushlog = d657("require/abc/push_logger"),
        screenlog = d657("require/abc/screen_logger"),
        self = d657("require/help/self"),
        enemies = d657("require/help/enemies"),
        COLORS = d657("require/help/color"),
        str = d657("require/help/string"),
        safe = d657("require/help/safe"),
        build_menu = d657("require/abc/build_menu"),
        menu_visibility = d657("require/abc/menu_visibility"),
        config_system = d657("require/abc/config_system"),
    }

    
    d657("require/abc/register")

    
    d657("require/features/aa/antiaim")

    
    
    d657("require/features/misc/resolver")
    d657("require/features/misc/analyze")
    d657("require/features/misc/dormant_aimbot")
    d657("require/features/misc/fakelag")
    d657("require/features/misc/hotkeys")
    d657("require/features/misc/freestand_helper")
    d657("require/features/misc/enhance_osaa")
    
    d657("require/features/misc/exploit_fakelag")
    d657("require/features/misc/walkbot")
    d657("require/features/misc/backstab_assist")
    d657("require/features/misc/spin_on_dead_enemies")
    d657("require/features/misc/localdebug")

    
    d657("require/features/paint/world_hitmarker_plus")
    d657("require/features/paint/onshot_skeleton")
    d657("require/features/paint/damage")
    d657("require/features/paint/damage_penetration")
    d657("require/features/paint/aimbot_logs")
    d657("require/features/paint/aspect_ratio")
    d657("require/features/paint/third_person_distance")
    d657("require/features/paint/watermark_solus")
    d657("require/features/paint/watermark_gamesense")
    d657("require/features/paint/entidx")
    d657("require/features/paint/target_info")
    d657("require/features/paint/clantag")
    d657("require/features/paint/indicators_bold")
    d657("require/features/paint/indicators_small")
    d657("require/features/paint/hit_miss_indicator")
    d657("require/features/paint/bomb_esp")
    d657("require/features/paint/presmoke_warning")
    d657("require/features/paint/self_skeleton")
    d657("require/features/paint/performance_mode")
    
    d657("require/features/paint/minimum_damage")
    d657("require/features/paint/filter_console")
    d657("require/features/paint/warnings")
    d657("require/features/paint/text_watermark")
    d657("require/features/paint/bullet_tracer")
    d657("require/features/paint/animations")
    d657("require/features/paint/lagcomp_box")
    d657("require/features/paint/insults")
    d657("require/features/paint/molotov_particles")
    
    

    
    d662.pushlog("The lua has initialized", 4, 255, 255, 0, 255)
    d662.screenlog("The lua has initialized", 4, 255, 255, 255, 255)

    
    local function d663()
        local d664= database.read('cached_credentials')
        if d664 and d664.username and d664.password then
            d662.safe.safe_set(d662.menu_setup.ui.login_username, d664.username)
            d662.safe.safe_set(d662.menu_setup.ui.login_password, d664.password)
            d662.safe.safe_set(d662.menu_setup.ui.cache_credentials, true)
            
            local d665= d662.login.login(d664.username, d664.password)
            if d665 then
                local d666,d667,d668= d662.COLORS.get("green", "log")
                d662.screenlog("Auto-login successful!", 3, d666, d667, d668, 255)
                d662.pushlog("Auto-login successful!", 3, 255, 255, 0, 255)
            else
                local d666,d667,d668= d662.COLORS.get("red", "log")
                d662.screenlog("Auto-login failed!", 3, d666, d667, d668, 255)
                d662.pushlog("Auto-login failed!", 3, 255, 255, 0, 255)
            end
        end
    end

    
    d662.build_menu(d662)
    d662.menu_visibility.setup_callbacks(d662)

    
    local function d669()
        local d670= d662.login.logged_in
        if not d670 then return end
        d662.menu.draw_menu()
        if d662.menu.is_menu_open() then
            local d671= d662.menu.tab_sections()
            local d672, d673= d662.menu.mouse_position()
            local d674= d662.menu.current_tab_index()
            local d675= d662.menu.current_tab()
            local d676, d677= d662.menu.menu_position()
            local d678, d679= d662.menu.menu_size()
        end
    end

    
    local function d680(d681)
        if not d662.menu.is_menu_open() then return end
        if not d662.menu.is_mouse_outside_menu() then
            d681.in_attack = false
        end
    end

    
    local function d682()
        if d662.gc then
            if d662.gc.dynamic then
                d662.gc.dynamic()
            elseif d662.gc.step then
                d662.gc.step(100)
            end
        end
    end

    
    local function d683()
        d663()
        d662.menu_visibility.update(d662)
    end

    d683()

    local d684

    
    client.set_event_callback('setup_command', function(d681)
        d680(d681)
    end)

    client.set_event_callback('paint', function()
        d669()
        
    end)

    client.set_event_callback('paint_ui', function()

        if not d662.menu.is_menu_open() then return end
        local d675= d662.menu.current_tab()

        d662.menu_setup.toggle_gamesense_menu(false)

        if d675 ~= d684 then
            d684 = d675
            d662.menu_visibility.update(d662)
        end

    end)

    client.set_event_callback('shutdown', function(d681)
        d662.menu_setup.toggle_gamesense_menu(true)
    end)
end

_G.loader_init_after_hwid = d661
d657("require/abc/hwid_check")]]

return d961("main")
