
local c927= {}
local c928= {}
local c929= require

local function c930(c931)
    if c928[c931] then
        return c928[c931]
    end

    local c932= c927[c931]
    if not c932 then
        return c929(c931)
    end
    local c933= {}
    setmetatable(c933, { __index = _G })
    c933.require = c930

    local c934, c935
    if type(setfenv) == "function" then
        c934, err = load(c932, c931)
        if not c934 then
            error("Failed to load module: " .. c931 .. " (" .. tostring(c935) .. ")")
        end
        setfenv(c934, c933)
    else
        c934, err = load(c932, c931, nil, c933)
        if not c934 then
            error("Failed to load module: " .. c931 .. " (" .. tostring(c935) .. ")")
        end
    end

    local c936= c934()
    c928[c931] = c936 or true
    return c928[c931]
end

c927["require/aa/player_condition"] = [[
local c311= require("require/help/libs")
local c312= c311.get("antiaim_funcs")
local c313= c311.get("entity") or c313
local c314= c311.get("bit") or c314
local c315= require('require/abc/menu_setup')
local c316= { last_air = false, last_tick = 0, last_cond = nil }

local function c317(c318)
    if c318 == 'global' then return true end
    if not c315 or not c315.ui then return true end
    local c319= 'enable_' .. c318
    local c320= c315.ui[c319]
    if not c320 then
        return true
    end
    local c321, c322= pcall(ui.get, c320)
    return c321 and c322 == true
end


local function c323()
    local c324= c313.get_local_player()
    if not c324 or not c313.is_alive(c324) then
        return nil
    end
    
    if client.key_state(0x45) then
        if c317('legit') then return "legit" end
    end

    local c325= false
    if c312 and c312.get_double_tap then
        c325 = c312.get_double_tap()
    else
        c325 = true
    end

    if c325 == false then
        if c317('fakelag') then return "fakelag" end
    end

    if misc_gs_hotkey_slowmotion and ui.get(misc_gs_hotkey_slowmotion) == true then
        if c317('walk') then return "walk" end
    end
    
    if client.key_state(0x10) then
        local c326, c327= c313.get_prop(c324, 'm_vecVelocity')
        local c328= math.sqrt((c326 or 0)^2 + (c327 or 0)^2)
        if c328 >= 20 and c328 <= 140 then
            if c317('walk') then return "walk" end
        end
    end

    local c326, c327= c313.get_prop(c324, 'm_vecVelocity')
    local c328= math.sqrt((c326 or 0)^2 + (c327 or 0)^2)
    local c329= c313.get_prop(c324, 'm_flDuckAmount') > 0.5
    local c330= c314.band(c313.get_prop(c324, 'm_fFlags') or 0, 1) == 1
    local c331= globals.tickcount()

    if not c330 then
        if c329 then
            c316.last_air = true
            c316.last_tick = c331
            c316.last_cond = "jump+"
            if c317('jump+') then return "jump+" end
        else
            c316.last_air = true
            c316.last_tick = c331
            c316.last_cond = "jump"
            if c317('jump') then return "jump" end
        end
    else
        if c316.last_air and (c331 - c316.last_tick <= 2) then
            if c316.last_cond and c317(c316.last_cond) then
                return c316.last_cond
            end
        end
        c316.last_air = false
        c316.last_cond = nil
    end

    if c329 then
        if c328 >= 2 then
            if c317('duck+') then return "duck+" end
        else
            if c317('duck') then return "duck" end
        end
    else
        if c328 >= 2 then
            if c317('move') then return "move" end
        else
            if c317('stand') then return "stand" end
        end
    end

    return "global"
end

return {
    get = c323
}]]
c927["require/abc/build_menu"] = [[tab = {
    "RAGE",
    "AA",
    "LEGIT",
    "VISUALS",
    "MISC",
    "PLIST",
    "CONFIG",
    "LUA"
}

cont = {
    {
        "Aimbot",
        "Other"
    },
    {
        "Anti-aimbot angles",
        "Fake lag",
        "Other"
    },
    {},
    {
        "Player ESP",
        "Other ESP",
        "Colored models",
        "Effects"
    },
    {},
    {},
    {},
    {
        "A",
        "B",
    }
}

local c314= {
    "global",
    "stand",
    "move",
    "duck",
    "duck+",
    "jump",
    "jump+",
    "walk",
    "fakelag",
    "legit",
}

local c315= require("require/abc/menu_setup")
local c316= require("require/help/color")
local c317= require("require/abc/screen_logger")
local c318= require("require/help/emojis")

local function c319(c320)
    local c321= 'inDGnidgdisgndsin'

    local function c322()
        local c323= database.read(c321)
        return type(c323) == 'table' and c323 or {}
    end

    local function c324(c323)
        database.write(c321, c323)
    end

    local function c325(c323,c326)
        for i = 1, #c323 do if c323[i] == c326 then return i end end
        return nil
    end

    local function c327()
        if not (c320 and c320.menu_setup and c320.menu_setup.ui and c320.menu_setup.ui.paint_logger) then
            return false
        end
        local c328, c329= pcall(ui.get, c320.menu_setup.ui.paint_logger)
        if not c328 or not c329 then return false end
        if type(c329) == 'table' then
            for _, v in ipairs(c329) do
                if tostring(v) == 'config' then return true end
            end
            return false
        else
            return tostring(c329) == 'config'
        end
    end

    local function c330(c331)
        local c332= c322()
        if #c332 == 0 then c332 = {'(empty)'} end
            if c315.ui.cfg_listbox then
                pcall(ui.set_visible, c315.ui.cfg_listbox, false)
            end
            c315.ui.cfg_listbox = c315.register_ui(
                ui.new_listbox(tab[2], cont[2][1], 'Configs', c332),
                { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
            )
        if c331 then
            local c333= c325(c332, c331)
            if c333 then ui.set(c315.ui.cfg_listbox, c333-1) end
        end
    end
 
    
    
    
    c315.ui.cache_credentials = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("pin") .. c316.get("default", "ui") .. 'Cache credentials'),
        { requires_login = false, key = 'cache_credentials', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    c315.ui.login_username = c315.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Username', 'username'),
        { requires_login = false, key = 'login_username', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    c315.ui.login_password = c315.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Password', 'password'),
        { requires_login = false, key = 'login_password', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    c315.ui.login_howto_header = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], c316.get("grey", "ui") .. '───────[ ' .. c316.get("white", "ui") .. 'How to ' .. c316.get("green", "ui") .. 'log in' .. c316.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'login_howto_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.login_console_register = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], c316.get("grey", "ui") .. '1. In console -> "register ' .. c316.get("green", "ui") .. 'user' .. c316.get("grey", "ui") .. ' ' .. c316.get("red", "ui") .. 'pass' .. c316.get("grey", "ui") .. ' ' .. c316.get("blue", "ui") .. 'code' .. c316.get("grey", "ui") .. '"'),
        { requires_login = false, key = 'login_console_register', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.login_menu_credentials = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], c316.get("grey", "ui") .. '2. Write password & username in the menu.'),
        { requires_login = false, key = 'login_menu_credentials', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.login_press_login = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], c316.get("grey", "ui") .. '3. Press log in and enjoy ' .. c316.get("green", "ui") .. 'premium features' .. c316.get("grey", "ui") .. '.'),
        { requires_login = false, key = 'login_press_login', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.login_spacer1 = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer1', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.reset_header = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], c316.get("grey", "ui") .. '───────[ ' .. c316.get("white", "ui") .. 'How to ' .. c316.get("yellow", "ui") .. 'reset pass' .. c316.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'reset_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.reset_step1 = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], c316.get("grey", "ui") .. '1. Write username -> press reset.'),
        { requires_login = false, key = 'reset_step1', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.reset_step2 = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], c316.get("grey", "ui") .. '2. Login with your oldest password.'),
        { requires_login = false, key = 'reset_step2', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.login_spacer2 = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer2', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.support_header = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], c316.get("grey", "ui") .. '───────[ ' .. c316.get("red", "ui") .. 'Support & Other' .. c316.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'support_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.support_discord = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], c316.get("grey", "ui") .. '1. Join the ' .. c316.get("discord", "ui") .. 'discord ' .. c316.get("grey", "ui") .. 'for support.'),
        { requires_login = false, key = 'support_discord', tab = 'AA', visible = true, config_type = 'label' }
    )

    c315.ui.login_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("lock_open") .. c316.get("default", "ui") .. 'Login', function()
            local c334= c320.safe.safe_get(c315.ui.login_username)
            local c335= c320.safe.safe_get(c315.ui.login_password)
            local c336= c320.safe.safe_get(c315.ui.cache_credentials)
            if c334 ~= '' and c335 ~= '' then
                local c337= c320.login.login(c334, c335)
                if c337 then
                    c320.pushlog("Welcome back, " .. c320.str.capitalize(c334) .. ". You logged in successfully.", 3, 75, 145, 55, 255)
                    if c336 then
                        database.write('cached_credentials', { username = c334, password = c335 })
                    else
                        database.write('cached_credentials', nil)
                    end
                    local c338,c339,c340= c316.get("green", "log")
                    c320.screenlog("Login successful!", 4, c338, c339, c340, 255)
                else
                    local c338,c339,c340= c316.get("red", "log")
                    c320.screenlog("Login failed!", 4, c338, c339, c340, 255)
                end
            end
                if c320.menu_visibility and c320.menu_visibility.update then
                    c320.menu_visibility.update(c320)
                end
        end),
        { requires_login = false, key = 'login_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    c315.ui.logout_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][3], c316.get("red", "ui") .. c318.get("lock") .. c316.get("default", "ui") .. 'Logout', function()
            c320.login.logout()
            local c338,c339,c340= c316.get("red", "log")
            c320.screenlog("Logged out!", 4, c338, c339, c340, 255)
                if c320.menu_visibility and c320.menu_visibility.update then
                    c320.menu_visibility.update(c320)
                end
        end),
        { requires_login = true, key = 'logout_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    c315.ui.reset_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][1], c316.get("yellow", "ui") .. c318.get("warning") .. c316.get("default", "ui") .. 'Reset', function()
            local c334= c320.safe.safe_get(c315.ui.login_username)
            c320.login.reset_password(c334)
            local c338,c339,c340= c316.get("yellow", "log")
            c320.screenlog("Password reset.", 4, c338, c339, c340, 255)
            c320.pushlog("Password reset for user: " .. c334, 5, 255, 255, 0, 255)
                if c320.menu_visibility and c320.menu_visibility.update then
                    c320.menu_visibility.update(c320)
                end
        end),
        { requires_login = true, key = 'reset_button', tab = 'AA', visible = true, config_type = 'button' }
    )

    c315.ui.discord_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][3], c316.get("discord", "ui") .. c318.get("chat") .. c316.get("default", "ui") .. 'Discord', function()
            local c341= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            c320.safe.safe_set(c341, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://discord.gg/a2bFbVWWg9')
        end),
        { requires_login = true, key = 'discord_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    c315.ui.youtube_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][3], c316.get("youtube", "ui") .. c318.get("play") .. c316.get("default", "ui") .. 'YouTube', function()
            local c341= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            c320.safe.safe_set(c341, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://www.youtube.com/@vile-gs/videos')
        end),
        { requires_login = true, key = 'youtube_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    c315.ui.sellhub_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][3], c316.get("sellhub", "ui") .. c318.get("folder") .. c316.get("default", "ui") .. 'Sellhub', function()
            local c341= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            c320.safe.safe_set(c341, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://sodium.sellhub.cx/#products-list')
        end),
        { requires_login = true, key = 'sellhub_button', tab = 'AA', visible = true, config_type = 'button' }
    )


    
    
    
    c315.ui.condition_label = c315.register_ui(
        ui.new_label(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("menu") .. c316.get("default", "ui") .. 'Condition', unpack(c314)),
        { requires_login = true, key = 'condition_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.condition = c315.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nCondition', unpack(c314)),
        { requires_login = true, key = 'condition', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    c315.ui.condition_label2 = c315.register_ui(
        ui.new_label(tab[2], cont[2][1], '\ncondition label'),
        { requires_login = true, key = 'condition_label2', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.misc_resolver = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("wrench") .. c316.get("default", "ui") .. 'Resolver'),
        { requires_login = true, key = 'misc_resolver', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    c315.ui.misc_ragebot = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("arrow_double") .. c316.get("default", "ui") .. 'Ragebot'),
        { requires_login = true, key = 'misc_ragebot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    c315.ui.misc_dormantaimbot = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("time") .. c316.get("default", "ui") .. 'Dormant aimbot'),
        { requires_login = true, key = 'misc_dormantaimbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    c315.ui.misc_dormantaimbot_key = c315.register_ui(
        ui.new_hotkey(tab[2], cont[2][1], '\ndormant aimbot key', true),
        { requires_login = true, key = 'misc_dormantaimbot_key', tab = 'MISC', visible = true, config_type = 'hotkey' }
    )
    c315.ui.misc_dormantaimbot_value = c315.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\ndormant aimbot value', 60, 100, 0, true, '%'),
        { requires_login = true, key = 'misc_dormantaimbot_value', tab = 'MISC', visible = true, config_type = 'slider' }
    )
    c315.ui.misc_exploit_fakelag = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("latency3") .. c316.get("default", "ui") .. 'Limit exploit fakelag'),
        { requires_login = true, key = 'misc_exploit_fakelag', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    c315.ui.misc_walkbot = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("arrow_up") .. c316.get("default", "ui") .. 'Walkbot'),
        { requires_login = true, key = 'misc_walkbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    c315.ui.misc_backstab = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("triangle_upside") .. c316.get("default", "ui") .. 'Backstab Assist'),
        { requires_login = true, key = 'misc_backstab', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    c315.ui.misc_spindead = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("turning2") .. c316.get("default", "ui") .. 'Spin on dead enemies'),
        { requires_login = true, key = 'misc_spindead', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    c315.ui.aa_gskey_freestandh = c315.register_ui(
        ui.new_label(tab[2], cont[2][3], c316.get("green", "ui") .. c318.get("turning2") .. c316.get("default", "ui") .. 'Freestand'),
        { requires_login = false, key = 'aa_gskey_freestandh', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.aa_gskey_freestand = c315.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'freestand', true),
        { requires_login = true, key = 'aa_gskey_freestand', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    c315.ui.aa_gskey_slowmotionh = c315.register_ui(
        ui.new_label(tab[2], cont[2][3], c316.get("green", "ui") .. c318.get("gear") .. c316.get("default", "ui") .. 'Slowmotion'),
        { requires_login = false, key = 'aa_gskey_slowmotionh', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.aa_gskey_slowmotion = c315.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'slowmotion', true),
        { requires_login = true, key = 'aa_gskey_slowmotion', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    c315.ui.aa_gskey_edgeyawh = c315.register_ui(
        ui.new_label(tab[2], cont[2][3], c316.get("green", "ui") .. c318.get("recycle") .. c316.get("default", "ui") .. 'Edge Yaw'),
        { requires_login = false, key = 'aa_gskey_edgeyawh', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.aa_gskey_edgeyaw = c315.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'edge yaw', true),
        { requires_login = true, key = 'aa_gskey_edgeyaw', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    c315.ui.aa_gskey_onshoth = c315.register_ui(
        ui.new_label(tab[2], cont[2][3], c316.get("green", "ui") .. c318.get("arrow_double") .. c316.get("default", "ui") .. 'On-shot aa'),
        { requires_login = false, key = 'aa_gskey_onshoth', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.aa_gskey_onshot = c315.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'on-shot aa', true),
        { requires_login = true, key = 'aa_gskey_onshot', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    
    for _, cond in ipairs(c314) do
        local c342= 'enable_' .. cond
        c315.ui[c342] = c315.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("accept") .. c316.get("default", "ui") .. 'Enable ' .. cond),
            { requires_login = true, key = c342, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        c315.ui['pitch_' .. cond] = c315.register_ui(
            ui.new_combobox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("triangle_upside") .. c316.get("default", "ui") .. 'Pitch', 'off', 'up', 'down', 'minimal', 'ideal'),
            { requires_login = true, key = 'pitch_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        c315.ui['yaw_base_' .. cond] = c315.register_ui(
            ui.new_combobox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("recycle") .. c316.get("default", "ui") .. 'Yaw Base', 'target', 'view', 'threat', 'distance', 'smart'),
            { requires_login = true, key = 'yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        c315.ui['yaw_' .. cond] = c315.register_ui(
            ui.new_combobox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("turning2") .. c316.get("default", "ui") .. 'Yaw', 'off', 'spin', '180', '3way', 'ideal'),
            { requires_login = true, key = 'yaw_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        c315.ui['label1_' .. cond] = c315.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label1_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        c315.ui['body_yaw_base_' .. cond] = c315.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Base', -90, 90, 0, true, '°'),
            { requires_login = true, key = 'body_yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        c315.ui['body_yaw_left_' .. cond] = c315.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Left', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_left_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        c315.ui['body_yaw_right_' .. cond] = c315.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Right', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_right_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        c315.ui['randomize_yaw_' .. cond] = c315.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Randomize Yaw', 0, 30, 0, true, '%', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'randomize_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        c315.ui['label2_' .. cond] = c315.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label2_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        c315.ui['yaw_jitter_' .. cond] = c315.register_ui(
            ui.new_combobox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("turning") .. c316.get("default", "ui") .. 'Yaw Jitter', 'off', 'center', 'skitter'),
            { requires_login = true, key = 'yaw_jitter_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        c315.ui['yaw_jitter_base_' .. cond] = c315.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Yaw Jitter - Base', 0, 120, 0, true, '°', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'yaw_jitter_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        c315.ui['body_yaw_mode_' .. cond] = c315.register_ui(
            ui.new_combobox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("gear") .. c316.get("default", "ui") .. 'Body Yaw Mode', 'off', 'static', 'opposite', 'jitter'),
            { requires_login = true, key = 'body_yaw_mode_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        c315.ui['static_body_yaw_' .. cond] = c315.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Static Body Yaw', -58, 58, 0, true, '°'),
            { requires_login = true, key = 'static_body_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        c315.ui['body_yaw_value_' .. cond] = c315.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw Value', 1, 3, 2, true, '', 2, {
                [1] = 'left', [2] = 'back', [3] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_value_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        c315.ui['delay_' .. cond] = c315.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Delay', 0, 17, 1, true, 't', 1, {
                [0] = 'jitter'
            }),
            { requires_login = true, key = 'delay_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        c315.ui['label3_' .. cond] = c315.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label3_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        c315.ui['fifty_fifty_' .. cond] = c315.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("question") .. c316.get("default", "ui") .. '50/50'),
            { requires_login = true, key = 'fifty_fifty_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        c315.ui['only_flip_on_0_choke_' .. cond] = c315.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("time") .. c316.get("default", "ui") .. 'Only Flip on 0 Choke'),
            { requires_login = true, key = 'only_flip_on_0_choke_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        c315.ui['aa_label_space' .. cond] = c315.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n abc'),
            { requires_login = true, key = 'aa_label_space', tab = 'AA', visible = true, config_type = 'label' }
        )
        c315.ui['aa_label_combo' .. cond] = c315.register_ui(
            ui.new_label(tab[2], cont[2][1], 'Send state -> state'),
            { requires_login = true, key = 'aa_label_combo', tab = 'AA', visible = true, config_type = 'label' }
        )
        c315.ui['send_combo' .. cond] = c315.register_ui(
            ui.new_combobox(tab[2], cont[2][1], '\n', unpack(c314)),
            { requires_login = true, key = 'send_combo' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        c315.ui['send_button' .. cond] = c315.register_ui(
            ui.new_button(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("upload") .. c316.get("default", "ui") .. 'Send', function() end),
            { requires_login = true, key = 'send_button', tab = 'AA', visible = true, config_type = 'button' }
        )

    end


    
    
    
    c315.ui.fakelag_mode = c315.register_ui(
        ui.new_combobox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("gear") .. c316.get("default", "ui") .. 'Mode', 'defensive', 'stealer', 'fakelag', 'settings'),
        { requires_login = true, key = 'fakelag_mode', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    c315.ui.fakelag_defensive = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("turning2") .. c316.get("default", "ui") .. 'Defensive'),
        { requires_login = true, key = 'fakelag_defensive', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    c315.ui.fakelag_force = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("exclamation") .. c316.get("default", "ui") .. 'Force'),
        { requires_login = true, key = 'fakelag_force', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    c315.ui.fakelag_fakedef = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("globe") .. c316.get("default", "ui") .. 'Unmatched.gg'),
        { requires_login = true, key = 'fakelag_fakedef', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    c315.ui.fakelag_force_on = c315.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("clip") .. c316.get("default", "ui") .. 'Force whilst', 'peek', 'reload', 'shot', 'damaged'),
        { requires_login = true, key = 'fakelag_force_on', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    
    
    
    c315.ui.cfg_load_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("arrow_double") .. c316.get("default", "ui") .. 'Load', function()
            local c332= c322()
            local c333= ui.get(c315.ui.cfg_listbox)
            local c343= c332[(c333 or 0) + 1]
            local c344= ui.get(c315.ui.cfg_input_box)
            local c326= (c343 and c343 ~= '(empty)' and c343 ~= '') and c343 or c344

            if c326 and c326 ~= '' and c326 ~= '(empty)' then
                local c345= require("require/abc/config_system")
                local function c346()
                    if not c315.ui.cfg_selection then return nil end
                    local c328, c347= pcall(ui.get, c315.ui.cfg_selection)
                    if not c328 or not c347 or type(c347) ~= 'table' or #c347 == 0 then return nil end
                    local c348= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local c349= {}
                    for _, v in ipairs(c347) do
                        local c323= c348[tostring(v)]
                        if c323 then c349[#c349+1] = c323 end
                    end
                    if #c349 == 0 then return nil end
                    return c349
                end
                local c350= c346()
                c345.load(c326, c350)
                c320.screenlog('[Config] Loaded config: ' .. c326, 4, 120, 180, 255, 255)
                if c320 and c320.pushlog and c327() then
                    c320.pushlog('Loaded config: ' .. c326, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for load.')
                if c320 and c320.pushlog and c327() then
                    c320.pushlog('No config name selected for load.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_load_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    c315.ui.cfg_save_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("config") .. c316.get("default", "ui") .. 'Save', function()
            local c332= c322()
            local c333= ui.get(c315.ui.cfg_listbox)
            local c343= c332[(c333 or 0) + 1]
            local c344= ui.get(c315.ui.cfg_input_box)
            local c326= (c343 and c343 ~= '(empty)' and c343 ~= '') and c343 or c344

            if c326 and c326 ~= '' then
                local c345= require("require/abc/config_system")
                local function c346()
                    if not c315.ui.cfg_selection then return nil end
                    local c328, c347= pcall(ui.get, c315.ui.cfg_selection)
                    if not c328 or not c347 or type(c347) ~= 'table' or #c347 == 0 then return nil end
                    local c348= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local c349= {}
                    for _, v in ipairs(c347) do
                        local c323= c348[tostring(v)]
                        if c323 then c349[#c349+1] = c323 end
                    end
                    if #c349 == 0 then return nil end
                    return c349
                end
                local c350= c346()
                c345.save(c326, c350)
                local c332= c322()
                if not c325(c332, c326) then
                    c332[#c332+1] = c326
                    c324(c332)
                end
                c330(c326)
                c320.screenlog('[Config] Saved config: ' .. c326, 4, 120, 180, 255, 255)
                if c320 and c320.pushlog and c327() then
                    c320.pushlog('Saved config: ' .. c326, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name provided for save.')
                if c320 and c320.pushlog and c327() then
                    c320.pushlog('No config name provided for save.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_save_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    c315.ui.cfg_create_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("plus") .. c316.get("default", "ui") .. 'Create', function()
            local c344= ui.get(c315.ui.cfg_input_box)
            if not c344 or c344 == '' then
                client.error_log('[Config] No config name provided for create.')
                if c320 and c320.pushlog and c327() then
                    c320.pushlog('No config name provided for create.', 4, 255, 255, 255, 255)
                end
                return
            end

            local c332= c322()
            if c325(c332, c344) then
                client.error_log('[Config] Config with that name already exists: ' .. c344)
                if c320 and c320.pushlog and c327() then
                    c320.pushlog('Config already exists: ' .. c344, 4, 255, 255, 255, 255)
                end
                return
            end

            local c345= require("require/abc/config_system")
            local function c346()
                if not c315.ui.cfg_selection then return nil end
                local c328, c347= pcall(ui.get, c315.ui.cfg_selection)
                if not c328 or not c347 or type(c347) ~= 'table' or #c347 == 0 then return nil end
                local c348= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local c349= {}
                for _, v in ipairs(c347) do
                    local c323= c348[tostring(v)]
                    if c323 then c349[#c349+1] = c323 end
                end
                if #c349 == 0 then return nil end
                return c349
            end
            local c350= c346()
            c345.save(c344, c350)
            c332[#c332+1] = c344
            c324(c332)
            c330(c344)
            c320.screenlog('[Config] Created config: ' .. c344, 4, 120, 180, 255, 255)
            if c320 and c320.pushlog and c327() then
                c320.pushlog('Created config: ' .. c344, 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_create_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    c315.ui.cfg_delete_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][1], c316.get("red", "ui") .. c318.get("trash") .. c316.get("default", "ui") .. 'Delete', function()
            local c332= c322()
            local c333= ui.get(c315.ui.cfg_listbox)
            local c343= c332[(c333 or 0) + 1]
            local c344= ui.get(c315.ui.cfg_input_box)
            local c326= (c343 and c343 ~= '(empty)' and c343 ~= '') and c343 or c344

            if c326 and c326 ~= '' and c326 ~= '(empty)' then
                local c345= require("require/abc/config_system")
                c345.delete(c326)
                local c332= c322()
                local c333= c325(c332, c326)
                if c333 then
                    table.remove(c332, c333)
                    c324(c332)
                end
                c330()
                c320.screenlog('[Config] Deleted config: ' .. c326, 4, 255, 80, 80, 255)
                if c320 and c320.pushlog and c327() then
                    c320.pushlog('Deleted config: ' .. c326, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for delete.')
                if c320 and c320.pushlog and c327() then
                    c320.pushlog('No config name selected for delete.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_delete_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    c315.ui.cfg_refresh_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("turning") .. c316.get("default", "ui") ..'Refresh', function()
            c330()
            c320.screenlog('[Config] Refreshed config list.', 4, 120, 180, 255, 255)
            if c320 and c320.pushlog and c327() then
                c320.pushlog('Refreshed config list.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_refresh_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    
    local c345= require("require/abc/config_system")
    local c351, c352= pcall(require, 'gamesense/clipboard')
    local c353= c352
    if not c351 or not c353 then
        c353 = {
            set = function(c354) end,
            get = function() return '' end,
        }
    end


    c315.ui.cfg_export_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("upload") .. c316.get("default", "ui") .. 'Export', function()
            local function c346()
                if not c315.ui.cfg_selection then return nil end
                local c328, c347= pcall(ui.get, c315.ui.cfg_selection)
                if not c328 or not c347 or type(c347) ~= 'table' or #c347 == 0 then return nil end
                local c348= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local c349= {}
                for c354, v in ipairs(c347) do
                    local c323= c348[tostring(v)]
                    if c323 then c349[#c349+1] = c323 end
                end
                if #c349 == 0 then return nil end
                return c349
            end
            local c350= c346()
            local c355= c345.build(c350)
            c353.set(c355)
            client.log('[Config] Exported config string:')
            client.log(c355)
            c320.screenlog('[Config] Exported config string to clipboard and console.', 4, 120, 180, 255, 255)
            if c320 and c320.pushlog and c327() then
                c320.pushlog('Exported config string to clipboard.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_export_button', tab = 'CFG', visible = true, config_type = 'button' }
    )

    c315.ui.cfg_import_button = c315.register_ui(
        ui.new_button(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("download") .. c316.get("default", "ui") .. 'Import', function()
            local c356= c353.get()
            if c356 and c356 ~= '' then
                local function c346()
                    if not c315.ui.cfg_selection then return nil end
                    local c328, c347= pcall(ui.get, c315.ui.cfg_selection)
                    if not c328 or not c347 or type(c347) ~= 'table' or #c347 == 0 then return nil end
                    local c348= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local c349= {}
                    for c354, v in ipairs(c347) do
                        local c323= c348[tostring(v)]
                        if c323 then c349[#c349+1] = c323 end
                    end
                    if #c349 == 0 then return nil end
                    return c349
                end
                local c350= c346()
                c345.apply(c356, c350)
                c320.screenlog('[Config] Imported config string from clipboard.', 4, 120, 180, 255, 255)
                if c320 and c320.pushlog and c327() then
                    c320.pushlog('Imported config string from clipboard.', 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config string found in clipboard.')
                if c320 and c320.pushlog and c327() then
                    c320.pushlog('No config string found in clipboard for import.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_import_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    c315.ui.cfg_selection = c315.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\n selection', 'antiaim', 'paint', 'misc'),
        { requires_login = true, key = 'cfg_selection', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    c315.ui.cfg_input_box = c315.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Config name'),
        { requires_login = true, key = 'cfg_input_box', tab = 'CFG', visible = true, config_type = 'textbox' }
    )
    c315.ui.cfg_listbox = c315.register_ui(
        ui.new_listbox(tab[2], cont[2][1], 'Configs', {}),
        { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    c330()

    c315.ui.cfg_cloud_apply = c315.register_ui(
        ui.new_button(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("globe") .. c316.get("default", "ui") .. ' Apply cloud', function()
            local c328, c347= pcall(ui.get, c315.ui.cfg_cloud)
            if not c328 then
                client.log('cfg_cloud_apply: failed to read selection')
                return
            end

            local c357= { 'Reset', 'Defensive', 'Unmatched', 'Community' }
            local c326= nil

            if type(c347) == 'number' then
                local c333= c347 + 1
                c326 = c357[c333]
            elseif type(c347) == 'table' then
                if #c347 > 0 and type(c347[1]) == 'number' then
                    c326 = c357[c347[1] + 1]
                else
                    c326 = tostring(c347[1])
                end
            else
                c326 = tostring(c347)
            end

            if not c326 or c326 == '' then
                client.log('cfg_cloud_apply: no selection')
                return
            end

            local c358, c359= pcall(require, 'require/abc/config_cloud')
            if not c358 or not c359 then
                client.log('cfg_cloud_apply: failed to load config_cloud module')
                return
            end

            local c360= c359[c326]
            if not c360 then
                client.log('cfg_cloud_apply: no cloud config string for', tostring(c326))
                return
            end

            local c361, c345= pcall(require, 'require/abc/config_system')
            if not c361 or not c345 or not c345.apply then
                client.log('cfg_cloud_apply: config_system.apply not available')
                return
            end

            c345.apply(c360)
            client.log('cfg_cloud_apply: applied cloud config', tostring(c326))
        end),
        { requires_login = true, key = 'cfg_cloud_apply', tab = 'AA', visible = true, config_type = 'button' }
    )

    c315.ui.cfg_cloud = c315.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'Cloud', { c316.get("red", "ui") .. 'Reset', c316.get("reddark", "ui") .. 'Defensive', c316.get("yellow", "ui") .. 'Unmatched', c316.get("grey", "ui") .. 'Community'}),
        { requires_login = true, key = 'cfg_cloud', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    c315.ui.fakelag_stealer = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("download") .. c316.get("default", "ui") .. 'Stealer' .. c316.get("blue", "ui") .. ' [BETA]' ),
        { requires_login = true, key = 'fakelag_stealer', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    c315.ui.fakelag_stealer_type = c315.register_ui(
        ui.new_combobox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("gear") .. c316.get("default", "ui") .. 'Type', 'mimic', 'import'),
        { requires_login = true, key = 'fakelag_stealer_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    c315.ui.fakelag_stealer_target = c315.register_ui(
        ui.new_combobox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("id") .. c316.get("default", "ui") .. 'Target', 'threat', 'closest', 'random', 'best kdas'),
        { requires_login = true, key = 'fakelag_stealer_target', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    c315.ui.fakelag_stealer_list = c315.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'target list', {'-'}),
        { requires_login = true, key = 'fakelag_stealer_list', tab = 'AA', visible = true, config_type = 'listbox' }
    )
    c315.ui.fakelag_stealer_refresh = c315.register_ui(
        ui.new_button(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("refresh") .. c316.get("default", "ui") .. 'Refresh', function() end),
        { requires_login = true, key = 'fakelag_stealer_refresh', tab = 'AA', visible = true, config_type = 'button' }
    )
    c315.ui.fakelag_stealer_steal = c315.register_ui(
        ui.new_button(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("clip") .. c316.get("default", "ui") .. 'Steal', function() end),
        { requires_login = true, key = 'fakelag_stealer_steal', tab = 'AA', visible = true, config_type = 'button' }
    )
    c315.ui.fakelag_fakelag = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("latency3") .. c316.get("default", "ui") .. 'Fakelag'),
        { requires_login = true, key = 'fakelag_fakelag', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    c315.ui.fakelag_fakelag_type = c315.register_ui(
        ui.new_combobox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("gear") .. c316.get("default", "ui") .. 'Type', 'gamesense', 'sodium'),
        { requires_login = true, key = 'fakelag_fakelag_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    c315.ui.fakelag_fakelag_amount = c315.register_ui(
        ui.new_combobox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("plus") .. c316.get("default", "ui") .. 'Amount', 'dynamic', 'maximum', 'fluctuate'),
        { requires_login = true, key = 'fakelag_fakelag_amount', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    c315.ui.fakelag_fakelag_variance = c315.register_ui(
        ui.new_slider(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("recycle") .. c316.get("default", "ui") .. 'Variance', 0, 100, 0, true, '%'),
        { requires_login = true, key = 'fakelag_fakelag_variance', tab = 'AA', visible = true, config_type = 'slider' }
    )
    c315.ui.fakelag_fakelag_limit = c315.register_ui(
        ui.new_slider(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("lock") .. c316.get("default", "ui") .. 'Limit', 1, 15, 1, true, 't'),
        { requires_login = true, key = 'fakelag_fakelag_limit', tab = 'AA', visible = true, config_type = 'slider' }
    )
    c315.ui.fakelag_fakelag_type2 = c315.register_ui(
        ui.new_combobox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("config") .. c316.get("default", "ui") .. 'Preset', 'jitter', 'max'),
        { requires_login = true, key = 'fakelag_fakelag_type2', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    c315.ui.fakelag_settings_freestanding = c315.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("turning2") .. c316.get("default", "ui") .. 'Freestanding options', 'static', 'zero pitch', 'defensive', 'side flip', 'pitch flip'),
        { requires_login = true, key = 'fakelag_settings_freestanding', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    c315.ui.fakelag_settings_enhance_onshot = c315.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("arrow_double") .. c316.get("default", "ui") .. 'Enhance on-shot aa', 'defensive', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_enhance_onshot', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    c315.ui.fakelag_settings_antibrute = c315.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("exclamation") .. c316.get("default", "ui") .. 'Antibrute', 'defensive', 'flip', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_antibrute', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    c315.ui.fakelag_settings_roll_checkbox = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], '\nuse roll'),
        { requires_login = true, key = 'fakelag_settings_roll_checkbox', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    c315.ui.fakelag_settings_roll_label = c315.register_ui(
        ui.new_label(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("recycle") .. c316.get("default", "ui") .. 'Roll'),
        { requires_login = false, key = 'label_roll', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.fakelag_settings_roll = c315.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nroll', 0, 45, 0, true, '°'),
        { requires_login = true, key = 'fakelag_settings_roll', tab = 'AA', visible = true, config_type = 'slider' }
    )
    c315.ui.fakelag_settings_side = c315.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nside', 1, 3, 1, true, '', 1, {
            [1] = 'left', [2] = 'swap', [3] = 'right'
        }),
        { requires_login = true, key = 'fakelag_settings_side', tab = 'AA', visible = true, config_type = 'slider' }
    )

    
    
    
    c315.ui.paint_advertisement = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nadvertisement', true),
        { requires_login = true, key = 'paint_advertisement', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_advertisement_animation = c315.register_ui(
        ui.new_slider(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("speaker") .. c316.get("default", "ui") .. 'Advertisement', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_advertisement_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    c315.ui.paint_advertisement_color = c315.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'rizz546456', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_advertisement_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    c315.ui.paint_watermark = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nwatermark'),
        { requires_login = true, key = 'paint_watermark', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_watermark_type = c315.register_ui(
        ui.new_slider(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("text") .. c316.get("default", "ui") .. 'Watermark', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_watermark_type', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    c315.ui.paint_watermark_color = c315.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'sigma9745', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_watermark_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    c315.ui.label_space2 = c315.register_ui(
        ui.new_label(tab[2], cont[2][1], '\n abc'),
        { requires_login = false, key = 'label_space2', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.label_space3 = c315.register_ui(
        ui.new_label(tab[2], cont[2][1], c316.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space3', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.paint_entidx = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'entidx'),
        { requires_login = true, key = 'paint_entidx', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_target_info = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'target info'),
        { requires_login = true, key = 'paint_target_info', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_filter_console = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'filter console'),
        { requires_login = true, key = 'paint_filter_console', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_minimum_damage = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'minimum damage'),
        { requires_login = true, key = 'paint_minimum_damage', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_show_damage_penetration = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'show damage penetration'),
        { requires_login = true, key = 'paint_show_damage_penetration', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_hitmiss_indicator = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'hit/miss indicator'),
        { requires_login = true, key = 'paint_hitmiss_indicator', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_self_skeleton = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'self skeleton'),
        { requires_login = true, key = 'paint_self_skeleton', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_bullet_tracer = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'bullet tracer'),
        { requires_login = true, key = 'paint_bullet_tracer', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_lagcomp_box = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lagcomp box'),
        { requires_login = true, key = 'paint_lagcomp_box', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_lagcomp_box_color = c315.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'lagcomp box color', 47, 117, 221, 255),
        { requires_login = true, key = 'paint_lagcomp_box_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    c315.ui.paint_presmoke = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'presmoke warning'),
        { requires_login = true, key = 'paint_presmoke', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_bombwarning = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'c4 warning'),
        { requires_login = true, key = 'paint_bombwarning', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_insults = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'insults'),
        { requires_login = true, key = 'paint_insults', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_rainbow_esp = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'rainbow esp'),
        { requires_login = true, key = 'paint_rainbow_esp', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_molotov = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'molotov particles'),
        { requires_login = true, key = 'paint_molotov', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_lag_record = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lag record'),
        { requires_login = true, key = 'paint_lag_record', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.label_space4 = c315.register_ui(
        ui.new_label(tab[2], cont[2][1], c316.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space4', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.paint_clantag = c315.register_ui(
        ui.new_combobox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("id") .. c316.get("default", "ui") .. 'Clantag', 'off', 'gamesense', 'sodium'),
        { requires_login = true, key = 'paint_clantag', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    c315.ui.paint_aimbot_logs = c315.register_ui(
        ui.new_combobox(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("clipboard") .. c316.get("default", "ui") .. 'Aimbot logs', 'off', 'gamesense', 'gamesense beta', 'sodium'),
        { requires_login = true, key = 'paint_aimbot_logs', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    c315.ui.label_space1 = c315.register_ui(
        ui.new_label(tab[2], cont[2][1], '\nextra space'),
        { requires_login = false, key = 'label_space1', tab = 'AA', visible = true, config_type = 'label' }
    )
    
    c315.ui.paint_indicators_enable = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n enable'),
        { requires_login = true, key = 'paint_indicators_enable', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_indicators_label = c315.register_ui(
        ui.new_label(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("pallete") .. c316.get("default", "ui") .. 'Indicators'),
        { requires_login = false, key = 'paint_indicators_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.paint_indicators = c315.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nIndicators', 'off', 'small', 'bold'),
        { requires_login = true, key = 'paint_indicators', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    c315.ui.paint_indicator_color = c315.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_indicator_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    c315.ui.paint_indicators_bar = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n bar'),
        { requires_login = true, key = 'paint_indicators_bar', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_indicators_animation = c315.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_indicators_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    c315.ui.paint_logger_checkbox = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n abc'),
        { requires_login = true, key = 'paint_logger_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_logger_label = c315.register_ui(
        ui.new_label(tab[2], cont[2][1], c316.get("green", "ui") .. c318.get("pen") .. c316.get("default", "ui") .. 'Logger'),
        { requires_login = false, key = 'paint_logger_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    c315.ui.paint_logger = c315.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\nLogger', 'aimbot', 'config', 'anti-aim', 'other'),
        { requires_login = true, key = 'paint_logger', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    c315.ui.paint_logger_color = c315.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_logger_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    c315.ui.paint_logger_animation = c315.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_logger_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    c315.ui.paint_hitmarker = c315.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("reject") .. c316.get("default", "ui") .. 'Hitmarkers', 'world +', 'skeleton', 'damage'),
        { requires_login = true, key = 'paint_hitmarker', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    c315.ui.paint_hitmarker_color = c315.register_ui(
        ui.new_color_picker(tab[2], cont[2][2], '\n + color', 0, 225, 225, 255),
        { requires_login = true, key = 'paint_hitmarker_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    c315.ui.paint_warnings = c315.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("warning") .. c316.get("default", "ui") .. 'Warnings', 'lethal', 'cant fire', 'low bullets'),
        { requires_login = true, key = 'paint_warnings', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    c315.ui.paint_performance_mode = c315.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("latency4") .. c316.get("default", "ui") .. 'Performance mode', 'blood', 'ragdolls', 'particles', 'lens flare', 'animations', 'feature updates'),
        { requires_login = true, key = 'paint_performance_mode', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    c315.ui.paint_animations = c315.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], c316.get("green", "ui") .. c318.get("turning2") .. c316.get("default", "ui") .. 'Animations', 'kingaru', 'body lean', 'gamesense legs', 'moonwalk', 'allah', 'static legs', 'no pitch on land', 'reversed legs', 'earthquake', 't-pose', 'blind', 'pitch up'),
        { requires_login = true, key = 'paint_animations', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    c315.ui.paint_aspect_ratio_checkbox = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], c316.get("green", "ui") .. c318.get("expand") .. c316.get("default", "ui") .. 'Aspect ratio'),
        { requires_login = true, key = 'paint_aspect_ratio_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_aspect_ratio = c315.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\naspect ratio', 0, 300, 0, true, '', 0.01, {
            [0] = 'default', [125] = '5:4', [133] = '4:3', [150] = '3:2', [160] = '16:10', [177] = '16:9'
        }),
        { requires_login = true, key = 'paint_aspect_ratio', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    c315.ui.paint_third_person_distance_checkbox = c315.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], c316.get("green", "ui") .. c318.get("camera") .. c316.get("default", "ui") .. 'Third person distance'),
        { requires_login = true, key = 'paint_third_person_distance_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    c315.ui.paint_third_person_distance = c315.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\nthird person distance', 30, 166, 150, true, '', 1, {
            [150] = 'default'
        }),
        { requires_login = true, key = 'paint_third_person_distance', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    
    
    
    
    local c362= {
        checkbox = 'c',
        slider = 's',
        combobox = 'o',
        multiselect = 'm',
    }
    for key, item in pairs(c315.ui) do
        for c354, entry in ipairs(c315.registered_items or {}) do
            if entry.key == key and entry.config_type and c362[entry.config_type] then
                c345.register(key, item, c362[entry.config_type], entry.tab)
            end
        end
    end
end

return c319]]
c927["require/abc/callbacks"] = [[




local c317= {}

local c318= 1
local c319= {}          
local c320= {}      
local c321= {}   

local function c322()
	local c323, c324= pcall(require, "require/abc/login_system")
	if not c323 or not c324 then return false end
	return c324.logged_in == true
end

local function c325(c326)
	if not c326 then return true end
	if c326.menu_only and not (ui and ui.is_menu_open and ui.is_menu_open()) then return false end
	if c326.alive_only then
		local c327= (entity and entity.get_local_player) and entity.get_local_player()
		if not c327 or not entity.is_alive(c327) then return false end
	end
	if c326.require_login then
		if not c322() then return false end
	end
	return true
end

local function c328(c329)
	return function(c330)
		local c331= c320[c329]
		if not c331 then return end
		local c332= {}
		for i=1,#c331 do c332[i] = c331[i] end
		for i=1,#c332 do
			local c333= c332[i]
			local c334= c319[c333]
			if c334 and c334.wrapper then
				local c323, c335= pcall(c334.wrapper, c330)
				if not c323 then
					local c336= nil
					pcall(function()
						c336 = debug.getinfo(c334.user_fn, "Sln")
					end)
					local c337= c336 and c336.short_src or "<unknown>"
					local c338= c336 and (c336.linedefined or -1) or -1
					pcall(client.error_log, string.format("callback[%d] error: %s (source=%s:%d)", c333, tostring(c335), c337, c338))
				end
			end
		end
	end
end



function c317.register(c329,c339,c340,c341,c342)
	if type(c329) ~= 'string' then error('event must be a string') end
	if type(c339) ~= 'function' then error('callback must be a function') end

	local c326= nil
	if type(c340) == 'table' then c326 = c340
	else
		c326 = { menu_only = (c340 == true), alive_only = (c341 == true), require_login = (c342 == true) }
	end

	local c333= c318; c318 = c318 + 1
	local c343= function(c330)
		if c325(c326) then
			return c339(c330)
		end
	end

	c319[c333] = { event = c329, wrapper = c343, user_fn = c339, opts = c326 }
	c320[c329] = c320[c329] or {}
	c320[c329][#c320[c329] + 1] = c333

	
	if not c321[c329] then
		local c344= c328(c329)
		c321[c329] = c344
		pcall(client.set_event_callback, c329, c344)
	end

	return c333
end

function c317.callback(c329,c340,c341,c342,c345)
	if type(c340) == 'function' then
		return c317.register(c329, c340, c341)
	end
	if type(c345) == 'function' then
		local c339= c345
		local c326= { menu_only = (c340 == true), alive_only = (c341 == true), require_login = (c342 == true) }
		return c317.register(c329, c339, c326)
	end
	error('invalid callback signature')
end

function c317.unregister(c333)
	local c334= c319[c333]
	if not c334 then return false end
	local c329= c334.event
	c319[c333] = nil
	local c346= c320[c329]
	if c346 then
		for i=#c346,1,-1 do if c346[i] == c333 then table.remove(c346, i) end end
		if #c346 == 0 then
			c320[c329] = nil
			local c344= c321[c329]
			if c344 then pcall(client.unset_event_callback, c329, c344) end
			c321[c329] = nil
		end
	end
	return true
end

function c317.clear_all()
	for c329, c344 in pairs(c321) do
		pcall(client.unset_event_callback, c329, c344)
	end
	c319 = {}
	c320 = {}
	c321 = {}
end

function c317._list()
	return { regs = c319, by_event = c320 }
end

pcall(function()
	if lua and lua.defer then
		lua.defer(c317.clear_all)
	else
		pcall(client.set_event_callback, 'shutdown', c317.clear_all)
	end
end)

return c317
]]
c927["require/abc/config_cloud"] = [[local c320= {
    Reset = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfbW92ZXx0PW98dj1vZmYKeWF3X2Zha2VsYWd8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wK3x0PXN8dj0wCmZha2VsYWdfc2V0dGluZ3Nfc2lkZXx0PXN8dj0xCnBpdGNoX21vdmV8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbW92ZXx0PXN8dj0wCmZha2VsYWdfZm9yY2Vfb258dD1tfHY9CmZha2VsYWdfZGVmZW5zaXZlfHQ9Y3x2PWZhbHNlCnlhd193YWxrfHQ9b3x2PW9mZgpzdGF0aWNfYm9keV95YXdfZmFrZWxhZ3x0PXN8dj0wCnBpdGNoX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfanVtcHx0PXN8dj0yCmJvZHlfeWF3X21vZGVfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXArfHQ9c3x2PTIKeWF3X2ppdHRlcl9iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfYmFzZV9kdWNrK3x0PW98dj10YXJnZXQKb25seV9mbGlwX29uXzBfY2hva2VfZHVjayt8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PWZhbHNlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9MApib2R5X3lhd19sZWZ0X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19zdGFuZHx0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19nbG9iYWx8dD1zfHY9MApwaXRjaF9kdWNrfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PW9mZgp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRhcmdldApmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wfHQ9c3x2PTAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PQpzZW5kX2NvbWJvanVtcHx0PW98dj1nbG9iYWwKc2VuZF9jb21ib2p1bXArfHQ9b3x2PWdsb2JhbApvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj1mYWxzZQpzdGF0aWNfYm9keV95YXdfbW92ZXx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVjayt8dD1zfHY9MAp5YXdfYmFzZV9nbG9iYWx8dD1vfHY9dGFyZ2V0CmVuYWJsZV9sZWdpdHx0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PQpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9kdWNrK3x0PXN8dj0yCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfdmFsdWVfbGVnaXR8dD1zfHY9Mgpib2R5X3lhd19iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfanVtcCt8dD1vfHY9b2ZmCmRlbGF5X3dhbGt8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdHlwZTJ8dD1vfHY9aml0dGVyCnlhd19sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9zdGFuZHx0PXN8dj0wCmVuYWJsZV9qdW1wK3x0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZmFrZWxhZ3x0PW98dj1nbG9iYWwKeWF3X2ppdHRlcl9iYXNlX2R1Y2t8dD1zfHY9MApmaWZ0eV9maWZ0eV9qdW1wfHQ9Y3x2PWZhbHNlCnBpdGNoX2xlZ2l0fHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfc3RhbmR8dD1zfHY9MAp5YXdfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfanVtcHx0PW98dj1vZmYKYm9keV95YXdfcmlnaHRfZHVja3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVjayt8dD1zfHY9MApib2R5X3lhd19tb2RlX3dhbGt8dD1vfHY9b2ZmCmJvZHlfeWF3X3JpZ2h0X2p1bXArfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10YXJnZXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj1mYWxzZQp5YXdfanVtcHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV93YWxrfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19nbG9iYWx8dD1zfHY9MApmaWZ0eV9maWZ0eV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfbW92ZXx0PW98dj1vZmYKeWF3X2Jhc2VfanVtcCt8dD1vfHY9dGFyZ2V0CnBpdGNoX2R1Y2srfHQ9b3x2PW1pbmltYWwKYm9keV95YXdfbW9kZV9qdW1wK3x0PW98dj1vZmYKc2VuZF9jb21ib2R1Y2t8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfZmFrZWxhZ3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVja3x0PW98dj1vZmYKZmFrZWxhZ19zdGVhbGVyX3RhcmdldHx0PW98dj10aHJlYXQKZmlmdHlfZmlmdHlfZHVjayt8dD1jfHY9ZmFsc2UKb25seV9mbGlwX29uXzBfY2hva2VfanVtcHx0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTAKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0wCmRlbGF5X2R1Y2srfHQ9c3x2PTEKYm9keV95YXdfbW9kZV9sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfZHVja3x0PXN8dj0yCmVuYWJsZV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PW9mZgp5YXdfYmFzZV9zdGFuZHx0PW98dj10YXJnZXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PW9mZgp5YXdfaml0dGVyX3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2xlZ2l0fHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19iYXNlX2xlZ2l0fHQ9b3x2PXRhcmdldApzdGF0aWNfYm9keV95YXdfd2Fsa3x0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X2Zha2VsYWd8dD1zfHY9MApkZWxheV9kdWNrfHQ9c3x2PTEKZmFrZWxhZ19zZXR0aW5nc19yb2xsfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2xpbWl0fHQ9c3x2PTEKZmFrZWxhZ19mYWtlbGFnX3ZhcmlhbmNlfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2Ftb3VudHx0PW98dj1keW5hbWljCmZha2VsYWdfZmFrZWxhZ190eXBlfHQ9b3x2PWdhbWVzZW5zZQpyYW5kb21pemVfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9nbG9iYWx8dD1zfHY9MApyYW5kb21pemVfeWF3X3dhbGt8dD1zfHY9MApjZmdfc2VsZWN0aW9ufHQ9bXx2PWFudGlhaW0KYm9keV95YXdfdmFsdWVfbW92ZXx0PXN8dj0yCmZpZnR5X2ZpZnR5X21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfbW92ZXx0PWN8dj1mYWxzZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ3x0PWN8dj1mYWxzZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfd2Fsa3x0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9zdGFuZHx0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZHVjayt8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnlhd19qaXR0ZXJfanVtcCt8dD1vfHY9b2ZmCnlhd19iYXNlX2p1bXB8dD1vfHY9dGFyZ2V0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKcGl0Y2hfanVtcCt8dD1vfHY9b2ZmCnlhd19kdWNrfHQ9b3x2PW9mZgpkZWxheV9qdW1wK3x0PXN8dj0xCmRlbGF5X3N0YW5kfHQ9c3x2PTEKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj0wCmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVja3x0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10YXJnZXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9MApib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgpib2R5X3lhd19sZWZ0X2dsb2JhbHx0PXN8dj0wCmRlbGF5X21vdmV8dD1zfHY9MQpkZWxheV9qdW1wfHQ9c3x2PTEKZW5hYmxlX2p1bXB8dD1jfHY9ZmFsc2UKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PTAKYm9keV95YXdfbGVmdF9qdW1wK3x0PXN8dj0wCnlhd19tb3ZlfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PWZhbHNlCmZha2VsYWdfZmFrZWRlZnx0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX2dsb2JhbHx0PW98dj1vZmYKZmlmdHlfZmlmdHlfanVtcCt8dD1jfHY9ZmFsc2UKY29uZGl0aW9ufHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X21vdmV8dD1zfHY9MApkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PWZhbHNl0000',
    Defensive = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9dHJ1ZQp5YXdfd2Fsa3x0PW98dj0xODAKc3RhdGljX2JvZHlfeWF3X2Zha2VsYWd8dD1zfHY9MApwaXRjaF9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXB8dD1zfHY9Mgpib2R5X3lhd19tb2RlX3N0YW5kfHQ9b3x2PWppdHRlcgpib2R5X3lhd192YWx1ZV9qdW1wK3x0PXN8dj0yCnlhd19qaXR0ZXJfYmFzZV9mYWtlbGFnfHQ9c3x2PTAKeWF3X2Jhc2VfZHVjayt8dD1vfHY9dGhyZWF0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2srfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PXRydWUKZGVsYXlfbGVnaXR8dD1zfHY9MQp5YXdfc3RhbmR8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVja3x0PXN8dj0wCmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKcGl0Y2hfZHVja3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfZHVjayt8dD1vfHY9aml0dGVyCnlhd19iYXNlX21vdmV8dD1vfHY9dGhyZWF0CmZha2VsYWdfbW9kZXx0PW98dj1zZXR0aW5ncwpwaXRjaF93YWxrfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9iYXNlX2p1bXB8dD1zfHY9MTIwCnNlbmRfY29tYm93YWxrfHQ9b3x2PWdsb2JhbApmYWtlbGFnX3NldHRpbmdzX2ZyZWVzdGFuZGluZ3x0PW18dj1zdGF0aWMJemVybyBwaXRjaAlkZWZlbnNpdmUJc2lkZSBmbGlwCnNlbmRfY29tYm9qdW1wfHQ9b3x2PWdsb2JhbApzZW5kX2NvbWJvanVtcCt8dD1vfHY9Z2xvYmFsCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXArfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9dHJ1ZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PWRlZmVuc2l2ZQlyb2xsCWppdHRlcgpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9MgpzZW5kX2NvbWJvbGVnaXR8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfbGVnaXR8dD1zfHY9LTU4Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTQKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9MApyYW5kb21pemVfeWF3X2R1Y2srfHQ9c3x2PTAKYm9keV95YXdfbW9kZV93YWxrfHQ9b3x2PXN0YXRpYwpib2R5X3lhd19yaWdodF9qdW1wK3x0PXN8dj0zNwpvbmx5X2ZsaXBfb25fMF9jaG9rZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmZha2VsYWdfc2V0dGluZ3NfYW50aWJydXRlfHQ9bXx2PQp5YXdfYmFzZV93YWxrfHQ9b3x2PXRocmVhdApmYWtlbGFnX3N0ZWFsZXJ8dD1jfHY9ZmFsc2UKZW5hYmxlX3N0YW5kfHQ9Y3x2PXRydWUKeWF3X2p1bXB8dD1vfHY9MTgwCmJvZHlfeWF3X2Jhc2Vfd2Fsa3x0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19zdGFuZHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZ2xvYmFsfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZHVja3x0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX21vdmV8dD1vfHY9aml0dGVyCnlhd19iYXNlX2p1bXArfHQ9b3x2PXRocmVhdApwaXRjaF9kdWNrK3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2p1bXB8dD1zfHY9MTgKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0tMwpkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjcKc2VuZF9jb21ib21vdmV8dD1vfHY9Z2xvYmFsCnJhbmRvbWl6ZV95YXdfbW92ZXx0PXN8dj0wCnBpdGNoX2p1bXB8dD1vfHY9ZG93bgp5YXdfYmFzZV9zdGFuZHx0PW98dj10aHJlYXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9zdGFuZHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2dsb2JhbHx0PWN8dj1mYWxzZQp5YXdfYmFzZV9sZWdpdHx0PW98dj10aHJlYXQKc3RhdGljX2JvZHlfeWF3X3dhbGt8dD1zfHY9MApib2R5X3lhd19yaWdodF9mYWtlbGFnfHQ9c3x2PTAKZGVsYXlfZHVja3x0PXN8dj01CmZha2VsYWdfc2V0dGluZ3Nfcm9sbHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19saW1pdHx0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ192YXJpYW5jZXx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19hbW91bnR8dD1vfHY9ZHluYW1pYwpmYWtlbGFnX2Zha2VsYWdfdHlwZXx0PW98dj1zb2RpdW0KcmFuZG9taXplX3lhd19qdW1wfHQ9c3x2PTAKeWF3X2ppdHRlcl9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKcmFuZG9taXplX3lhd193YWxrfHQ9c3x2PTAKY2ZnX3NlbGVjdGlvbnx0PW18dj1hbnRpYWltCmJvZHlfeWF3X3ZhbHVlX21vdmV8dD1zfHY9MgpmaWZ0eV9maWZ0eV9tb3ZlfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfYmFzZV9kdWNrK3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX21vdmV8dD1jfHY9dHJ1ZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0yNApmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV93YWxrfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCnNlbmRfY29tYm9kdWNrK3x0PW98dj1nbG9iYWwKYm9keV95YXdfcmlnaHRfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9qdW1wK3x0PW98dj1vZmYKeWF3X2Jhc2VfanVtcHx0PW98dj10aHJlYXQKb25seV9mbGlwX29uXzBfY2hva2VfbGVnaXR8dD1jfHY9dHJ1ZQpib2R5X3lhd19tb2RlX2R1Y2t8dD1vfHY9c3RhdGljCnN0YXRpY19ib2R5X3lhd19sZWdpdHx0PXN8dj0wCnBpdGNoX2p1bXArfHQ9b3x2PWRvd24KeWF3X2R1Y2t8dD1vfHY9MTgwCmRlbGF5X2p1bXArfHQ9c3x2PTMKZGVsYXlfc3RhbmR8dD1zfHY9NApmYWtlbGFnX2ZvcmNlfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X3JpZ2h0X2R1Y2srfHQ9c3x2PTQ0CmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0tMTUKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTE0Cnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9NTgKYm9keV95YXdfdmFsdWVfZ2xvYmFsfHQ9c3x2PTIKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApkZWxheV9tb3ZlfHQ9c3x2PTEKZGVsYXlfanVtcHx0PXN8dj0xCmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTQKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PS0xNgpib2R5X3lhd19sZWZ0X2p1bXArfHQ9c3x2PS05Cnlhd19tb3ZlfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PS0xNQpzdGF0aWNfYm9keV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3dhbGt8dD1jfHY9dHJ1ZQpmYWtlbGFnX2Zha2VkZWZ8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9nbG9iYWx8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmNvbmRpdGlvbnx0PW98dj1zdGFuZApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfbW92ZXx0PXN8dj00MgpkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PXRydWU00=',
    Unmatched = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9MgplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9ZmFsc2UKeWF3X3dhbGt8dD1vfHY9MTgwCnN0YXRpY19ib2R5X3lhd19mYWtlbGFnfHQ9c3x2PTAKcGl0Y2hfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9qdW1wfHQ9c3x2PTIKYm9keV95YXdfbW9kZV9zdGFuZHx0PW98dj1qaXR0ZXIKYm9keV95YXdfdmFsdWVfanVtcCt8dD1zfHY9Mgp5YXdfaml0dGVyX2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19iYXNlX2R1Y2srfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV9kdWNrK3x0PWN8dj10cnVlCnlhd19iYXNlX2Zha2VsYWd8dD1vfHY9dGFyZ2V0CnNlbmRfY29tYm9nbG9iYWx8dD1vfHY9Z2xvYmFsCnN0YXRpY19ib2R5X3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3dhbGt8dD1zfHY9MgplbmFibGVfd2Fsa3x0PWN8dj10cnVlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9LTM0CmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIxCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX3dhbGt8dD1zfHY9MApib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PWppdHRlcgpmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9ZG93bgp5YXdfaml0dGVyX2Jhc2VfanVtcHx0PXN8dj0xMjAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PXN0YXRpYwlkZWZlbnNpdmUKc2VuZF9jb21ib2p1bXB8dD1vfHY9Z2xvYmFsCnNlbmRfY29tYm9qdW1wK3x0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9ZmFsc2UKZmFrZWxhZ19zZXR0aW5nc19lbmhhbmNlX29uc2hvdHx0PW18dj1kZWZlbnNpdmUJcm9sbAlqaXR0ZXIKc3RhdGljX2JvZHlfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2Jhc2VfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF93YWxrfHQ9c3x2PTIzCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTIKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9NDQKcmFuZG9taXplX3lhd19kdWNrK3x0PXN8dj0wCmJvZHlfeWF3X21vZGVfd2Fsa3x0PW98dj1zdGF0aWMKYm9keV95YXdfcmlnaHRfanVtcCt8dD1zfHY9NTQKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10aHJlYXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj10cnVlCnlhd19qdW1wfHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3dhbGt8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfc3RhbmR8dD1zfHY9MApyYW5kb21pemVfeWF3X2dsb2JhbHx0PXN8dj0wCmZpZnR5X2ZpZnR5X2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9tb3ZlfHQ9b3x2PWppdHRlcgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9zdGFuZHx0PWN8dj10cnVlCmJvZHlfeWF3X2Jhc2VfanVtcHx0PXN8dj03CmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTI0CnJhbmRvbWl6ZV95YXdfZmFrZWxhZ3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfanVtcCt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9zdGFuZHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfanVtcCt8dD1zfHY9MApkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PWRvd24KeWF3X2Jhc2Vfc3RhbmR8dD1vfHY9dGhyZWF0Cnlhd19qaXR0ZXJfZmFrZWxhZ3x0PW98dj1vZmYKc2VuZF9jb21ib3N0YW5kfHQ9b3x2PWdsb2JhbApwaXRjaF9zdGFuZHx0PW98dj1kb3duCnlhd19qaXR0ZXJfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbGVnaXR8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV9nbG9iYWx8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfbGVnaXR8dD1vfHY9dGFyZ2V0CnN0YXRpY19ib2R5X3lhd193YWxrfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfZmFrZWxhZ3x0PXN8dj0wCmRlbGF5X2R1Y2t8dD1zfHY9NQpmYWtlbGFnX3NldHRpbmdzX3JvbGx8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfbGltaXR8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdmFyaWFuY2V8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfYW1vdW50fHQ9b3x2PWR5bmFtaWMKZmFrZWxhZ19mYWtlbGFnX3R5cGV8dD1vfHY9c29kaXVtCnlhd19qaXR0ZXJfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2dsb2JhbHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfd2Fsa3x0PXN8dj0wCmNmZ19zZWxlY3Rpb258dD1tfHY9YW50aWFpbQpib2R5X3lhd192YWx1ZV9tb3ZlfHQ9c3x2PTIKZmlmdHlfZmlmdHlfbW92ZXx0PWN8dj1mYWxzZQpkZWxheV9tb3ZlfHQ9c3x2PTMKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmZha2VsYWdfc3RlYWxlcl90eXBlfHQ9b3x2PW1pbWljCmJvZHlfeWF3X3JpZ2h0X3N0YW5kfHQ9c3x2PTQwCnBpdGNoX2R1Y2t8dD1vfHY9ZG93bgpmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQplbmFibGVfbW92ZXx0PWN8dj10cnVlCmVuYWJsZV9nbG9iYWx8dD1jfHY9ZmFsc2UKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApib2R5X3lhd19yaWdodF9tb3ZlfHQ9c3x2PTQyCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXArfHQ9b3x2PW9mZgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj10cnVlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1qaXR0ZXIKZGVsYXlfc3RhbmR8dD1zfHY9MQp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApwaXRjaF9qdW1wK3x0PW98dj1kb3duCmRlbGF5X2p1bXArfHQ9c3x2PTUKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQplbmFibGVfZmFrZWxhZ3x0PWN8dj1mYWxzZQpvbmx5X2ZsaXBfb25fMF9jaG9rZV9tb3ZlfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX21vdmV8dD1zfHY9MAp5YXdfZ2xvYmFsfHQ9b3x2PW9mZgpjYWNoZV9jcmVkZW50aWFsc3x0PWN8dj10cnVlCnJhbmRvbWl6ZV95YXdfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF9sZWdpdHx0PXN8dj0wCmRlbGF5X2dsb2JhbHx0PXN8dj0xCmRlbGF5X2p1bXB8dD1zfHY9MQpib2R5X3lhd19sZWZ0X2p1bXB8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2xlZnRfd2Fsa3x0PXN8dj0tMTYKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcCt8dD1zfHY9LTE4Cnlhd19kdWNrfHQ9b3x2PTE4MAp5YXdfYmFzZV9qdW1wK3x0PW98dj10aHJlYXQKeWF3X21vdmV8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVjayt8dD1zfHY9LTE1CmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKZmFrZWxhZ19mYWtlZGVmfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZ2xvYmFsfHQ9b3x2PW9mZgp5YXdfYmFzZV9qdW1wfHQ9b3x2PXRocmVhdApjb25kaXRpb258dD1vfHY9ZHVjaysKc2VuZF9jb21ib2R1Y2srfHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj00NAp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX2R1Y2srfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2Zha2VsYWd8dD1vfHY9b2ZmCmRlbGF5X2Zha2VsYWd8dD1zfHY9MQpzdGF0aWNfYm9keV95YXdfZHVjayt8dD1zfHY9MAp5YXdfaml0dGVyX2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXB8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X3dhbGt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfZmFrZWxhZ3x0PWN8dj1mYWxzZQpwaXRjaF9kdWNrK3x0PW98dj1kb3du0000',
    Community = '',
}
return c320]]
c927["require/abc/config_system"] = [[


local c323='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

local function c324(c325)
    return ((c325:gsub('.', function(c326)
        local c327,c323='',c326:byte()
        for i=8,1,-1 do c327=c327..(c323%2^i-c323%2^(i-1)>0 and '1' or '0') end
        return c327
    end)..'0000'):gsub('%d%d%d%d%d%d', function(c326)
        if (#c326 < 6) then return '' end
        return c323:sub(tonumber(c326,2)+1,tonumber(c326,2)+1)
    end)..({ '', '==', '=' })[#c325%3+1])
end

local function c328(c325)
    c325 = string.gsub(c325, '[^'..b..'=]', '')
    return (c325:gsub('.', function(c326)
        if c326 == '=' then return '' end
        local c327,c329='',(c323:find(c326)-1)
        for i=6,1,-1 do c327=c327..(c329%2^i-c329%2^(i-1)>0 and '1' or '0') end
        return c327
    end):gsub('%d%d%d%d%d%d%d%d', function(c326)
        if (#c326 ~= 8) then return '' end
        local c330=0
        for i=1,8 do c330=c330+(c326:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c330)
    end))
end





local c331= database

local c332= {}
local c333= {}

local function c334(c335,c336,c337,c338)
    if not c335 or c335 == '' or not c336 or c333[c335] then return end
    c332[#c332+1] = { key = c335, ref = c336, type = c337, tab = c338 }
    c333[c335] = c332[#c332]
end

local function c339(c340)
    local function c341(c342,c340)
        if not c340 or #c340 == 0 then return true end
        if c342 == 'CFG' then return true end
        if not c342 then return true end
        for _, t in ipairs(c340) do if t == c342 then return true end end
        return false
    end

    local c343= { 'v=1' }
    for i = 1, #c332 do
        local c344= c332[i]
        if c341(c344.tab, c340) then
            local c345= c344.type
            local c346= ui.get(c344.ref)
            if c345 == 'c' then
                c343[#c343+1] = c344.key .. '|t=c|v=' .. (c346 and 'true' or 'false')
            elseif c345 == 's' then
                c343[#c343+1] = c344.key .. '|t=s|v=' .. tostring(c346 or 0)
            elseif c345 == 'o' then
                c343[#c343+1] = c344.key .. '|t=o|v=' .. tostring(c346 or '')
            elseif c345 == 'm' then
                if type(c346) == 'table' then
                    c343[#c343+1] = c344.key .. '|t=m|v=' .. table.concat(c346, '\t')
                end
            end
        end
    end
    return c324(table.concat(c343, '\n'))
end

local function c347(c348,c340)
    if not c348 or c348 == '' then return end
    local c349, c350= pcall(c328, c348)
    if not c349 or not c350 or c350 == '' then return end
    local function c341(c342,c340)
        if not c340 or #c340 == 0 then return true end
        if c342 == 'CFG' then return true end
        if not c342 then return true end
        for _, c345 in ipairs(c340) do if c345 == c342 then return true end end
        return false
    end
    for line in c350:gmatch('([^\n]+)') do
        if line ~= 'v=1' then
            local c335, c351, c352= line:match('^(.-)|t=(.)|v=(.*)$')
            if c335 and c351 and c352 then
                local c344= c333[c335]
                if c344 and c344.type == c351 and c341(c344.tab, c340) then
                    if c351 == 'c' then
                        ui.set(c344.ref, vseg == 'true')
                    elseif c351 == 's' then
                        local c353= tonumber(c352)
                        if c353 ~= nil then
                            ui.set(c344.ref, c353)
                        end
                    elseif c351 == 'o' then
                        pcall(ui.set, c344.ref, c352)
                    elseif c351 == 'm' then
                        local c354= {}
                        for token in c352:gmatch('[^\t]+') do c354[#c354+1] = token end
                        ui.set(c344.ref, c354)
                    end
                end
            end
        end
    end
end


local function c355(c356,c340)
    if not c356 or c356 == '' then return end
    local c348= c339(c340)
    c331.write('cfg:' .. c356, c348)
end


local function c357(c356,c340)
    if not c356 or c356 == '' then return end
    local c348= c331.read('cfg:' .. c356)
    if c348 then c347(c348, c340) end
end


local function c358(c356)
    if not c356 or c356 == '' then return end
    c331.write('cfg:' .. c356, nil)
end


local c359= {
    register = c334,
    build = c339,
    apply = c347,
    save = c355,
    load = c357,
    delete = c358,
}

return c359]]
c927["require/abc/garbage_collector"] = [[local c326= {}

local c327= {
    pause = 200,
    stepmul = 600,
    mode = "collect"
}

function c326.tune(c328)
	if type(c328) == "table" then
		if c328.pause then
			collectgarbage("setpause", c328.pause)
			c327.pause = c328.pause
		end
		if c328.stepmul then
			collectgarbage("setstepmul", c328.stepmul)
			c327.stepmul = c328.stepmul
		end
		if c328.mode then
			c327.mode = c328.mode
		end
	end
end

function c326.collect(c329)
	collectgarbage(c329 or c327.mode)
end

function c326.step(c330)
	return collectgarbage("step", c330 or 0)
end

function c326.stop()
	collectgarbage("stop")
end

function c326.restart()
	collectgarbage("restart")
end

function c326.memory()
	return collectgarbage("count")
end

function c326.status()
	return {
		memory = c326.memory(),
		pause = c327.pause,
		stepmul = c327.stepmul,
		mode = c327.mode
	}
end

local c331= 0
function c326.dynamic(c328)
	c328 = type(c328) == "table" and c328 or {}
	local c332= c328.min_interval or 0.6
	local c333= (globals and globals.realtime) and globals.realtime() or (c331 + c332)
	if c333 - c331 < c332 then
		return
	end
	c331 = c333

	local c330= c328.step_size or 20
	local c334= c328.full_threshold_kb or 65536
	local c335= c328.aggressive_threshold_kb or 12288

	local c336, c337= pcall(collectgarbage, "count")
	if not c336 or type(c337) ~= "number" then
		pcall(collectgarbage, "step", c330)
		return
	end

	if c337 >= c334 then
		pcall(collectgarbage, "collect")
		return
	end

	if c337 >= c335 then
		pcall(collectgarbage, "step", c330)
		pcall(collectgarbage, "step", c330)
		return
	end

	pcall(collectgarbage, "step", c330)
end

if lua and lua.defer then
	lua.defer(function()
		c326.collect()
	end)
end

return c326]]
c927["require/abc/hwid_check"] = [[local c329= require("ffi")
local c330= require("require/brain/dll")
local c331= 1
local c332= 1

local function c333()
    return globals.curtime and globals.curtime() or 0
end

local function c334()
    local shared= rawget(_G, "loader_shared")
    if not shared or type(shared) ~= "table" then
    return nil, "missing"
    end
    local c335= tonumber(shared.expires) or 0
    if c333() > c335 then
    return nil, "expired"
    end
    if type(shared.hwids) ~= "table" then
    return nil, "bad_hwids"
    end
    return shared, nil
end

local c336= false

local function c337()
    if not c330 or type(c330) ~= "table" or type(c330.get_hwid) ~= "function" then
        print("invalid hwid 1")
    return
    end

    local c338
    
    local c339, c340= pcall(c330.get_hwid)
    if c339 and c340 and c340 ~= c329.NULL then
    if type(c340) == "cdata" then
        local c341, c342= pcall(c329.string, c340)
        if c341 then c338 = c342 end
    else
        c338 = tostring(c340)
    end
    end

    if not c338 or c338 == "" then
        print("invalid hwid 2")
    end

    local shared, c343= c334()
    if not shared then
        print("invalid hwid 3")
    end

    local c344= shared.hwids
    local c345= false
    for i = 1, #c344 do
    local c346= tostring(c344[i] or "")
    if c346:find(tostring(c338), 1, true) then
        c345 = true
        break
    end
    end


    if c345 then
        local c347= rawget(_G, "loader_init_after_hwid")
        if not c336 and type(c347) == "function" then
        c336 = true
        local c348, c349= pcall(c347)
        if not c348 then
            print("invalid hwid 4")
        end
        end
    else
        print("invalid hwid 5")
    end
end

local c350= 0
local function c351()
    c350 = c350 + 1
    local shared= rawget(_G, "loader_shared")
    if shared then
    c337()
    return
    end
    if c350 > c331 then
        print("invalid hwid 6")
        return
    end

    if type(client.delay_call) == "function" then
        client.delay_call(c332, c351)
    else
        c337()
    end

end


c351()]]
c927["require/abc/login_system"] = [[local c332= {}


local function c333(c334)
	if client.hash_sha256 then
		return client.hash_sha256(c334)
	end
	
	return tostring(c334):reverse()
end


local c335= "acc_" .. "897ntv45ynvttyjt980745nyv0t485vn87t6"

local function c336()
	local c337= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local c338= ""
	for i = 1, 16 do
		local c339= math.random(1, #c337)
		c338 = c338 .. c337:sub(c339, c339)
	end
	return c338
end

function c332.hash_password(c340,c338)
	return c333(c338 .. c340)
end

function c332.verify_password(c340,c341,c338)
	return c332.hash_password(c340, c338) == c341
end

function c332.get_hwid()
	
	return tostring(client.userid_to_entindex(client.userid_to_entindex(1)))
end

function c332.store_credentials(c342,c340)
	local c338= c336()
	local c341= c332.hash_password(c340, c338)
	database.write("login_credentials", { username = c342, hash = c341, salt = c338 })
end

function c332.load_credentials()
	return database.read("login_credentials")
end


function c332.login(c342,c340)
	
	local c343= database.read(c335) or {}
	local c344= c343[c342]
	if c344 and c344.enabled ~= false then
		if c332.verify_password(c340, c344.hash, c344.salt) then
			c332.logged_in = true
			return true
		end
	end
	
	local c345= c332.load_credentials()
	if c345 and c345.username == c342 then
		if c332.verify_password(c340, c345.hash, c345.salt) then
			c332.logged_in = true
			return true
		end
	end
	c332.logged_in = false
	return false
end

function c332.logout()
	c332.logged_in = false
end

function c332.reset_password(c346)
	
	database.write("login_credentials", nil)
end



function c332.is_valid_invite(c347)
	if not c347 or c347 == "" then
		return false, nil
	end
	local c348= database.read(c335 .. ":invites") or {}
	local c349= c348[c347]
	if not c349 then
		return false, nil
	end
	if c349.used then
		return false, c349
	end
	return true, c349
end

function c332.add_account(c342,c340)
	local c338= c336()
	local c341= c332.hash_password(c340, c338)
	local c343= database.read(c335) or {}
	c343[c342] = { hash = c341, salt = c338, role = "user", enabled = true, orig_password = c340 }
	database.write(c335, c343)
end

function c332.register_with_invite(c347,c342,c340)
	if not c347 or c347 == '' then return false, 'no invite provided' end
	local c348= database.read(c335 .. ":invites") or {}
	local c349= c348[c347]
	if not c349 then return false, 'invalid invite' end
	if c349.used then return false, 'invite already used' end

	c332.add_account(c342, c340)

	c349.used = true
	c349.used_by = c342
	c349.redeemed_at = client.unix_time()
	c348[c347] = c349
	database.write(c335 .. ":invites", c348)

	return true
end

function c332.invalidate_invite(c347)
	local c348= database.read(c335 .. ":invites") or {}
	if c348[c347] then
		c348[c347] = nil
		database.write(c335 .. ":invites", c348)
		return true
	end
	return false
end

return c332
]]
c927["require/abc/menu_header"] = [[local c335, c336, c337= 1, 398, 49
local c338= 0.85 
local c339= { "AA", "PAINT", "MISC", "CFG" }
local c340= c339[c335]
local c341= {}
local c342= {
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS1.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS2.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS3.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS4.png"
}
local c343

local c344= {
    size = {
        x = 6,
        y = 6,
        w = 120,
        h = 72, 
    },
    skeet_cur_tab = 8,
}

local function c345()
    local c346= { ui.menu_position() }
    local c347= { ui.mouse_position() }
    if not c346[1] or not c346[2] or not c347[1] or not c347[2] then
        return c344.skeet_cur_tab
    end

    for i = 1, 9 do
        local c348= { c344.size.x, c344.size.y + c344.size.h * (i - 1) }
        if c347[1] >= c346[1] + c348[1]
           and c347[1] <= c346[1] + c344.size.w + c348[1]
           and c347[2] >= c346[2] + c348[2]
           and c347[2] <= c346[2] + c344.size.h + c348[2] then
            return i
        end
    end

    return c344.skeet_cur_tab
end

local function c349()
    if not renderer.load_png or not readfile then return end
    for i, path in ipairs(c342) do
        if not c341[i] then
            local c350= readfile(path)
            if c350 then
                c341[i] = renderer.load_png(c350, c336, c337)
            end
        end
    end
end


local function c351()
    local c352= ui.is_menu_open()
    local c353, c354= ui.menu_position()
    local c355, c356= ui.menu_size()
    c355 = c355-2
    c353 = c353+1
    if c352 and c353 and c354 and c355 and c356 then
        local c357= (c344.skeet_cur_tab == 2)
        local c358= math.floor(90 * c338)
        local c359= math.max(1, math.floor(4 * c338))
        local c360= math.max(1, math.floor(3 * c338))
        local c361= math.max(1, math.floor(2 * c338))
        local c362= math.max(0, math.floor(1 * c338))
        local c363= 0
        local c364= c353 + c359
        local c365= c354 - math.floor(7 * c338) - c358
        local c366= c355 - 2 * c359

        if c357 then
            renderer.rectangle(c364-c359*1.3, c365-8, c366+2*c359*1.5-1, c358+16, 12, 12, 12, 255)
            renderer.rectangle(c364-c360*1.5, c365-7, c366+2*c360*1.5, c358+14, 60, 60, 60, 255)
            renderer.rectangle(c364-c361*1.51, c365-6, c366+2*c361*2, c358+12, 40, 40, 40, 255)
            renderer.rectangle(c364-c362, c365-3, c366+2*c362, c358+6, 60, 60, 60, 255)
            renderer.rectangle(c364-c363, c365-2, c366+2*c363, c358+4, 12, 12, 12, 255)

            local c367= nil
            if renderer.load_rgba then
                local c368, c369= pcall(renderer.load_rgba,
                    string.char(
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
                    ), 4, 4)
                if c368 and c369 then c367 = c369 end
            end
            if c367 and renderer.texture then
                renderer.texture(c367, c364-c363, c365-2, c366+2*c363, c358+4, 255,255,255,255, 'r')
            end

            if renderer.gradient then
                renderer.gradient(c364-c363, c365-2, (c366+2*c363)/2+1, 1, 59,175,222,255, 202,70,205,255, true)
                renderer.gradient(c364-c363+(c366+2*c363)/2+1, c365-2, (c366+2*c363)/2-1, 1, 202,70,205,255, 204,227,53,255, true)
            end

            local c370= math.max(1, math.floor(2 * c338))
            local c371= c365 - math.floor(8 * c338)

            local c372= math.max(1, math.floor(5 * c338))
            local c373= 60
            renderer.circle(c364-c359+c372, c371+c370/2, c372, 59,175,222, c373, 16)
            renderer.circle(c364+c366-c359-c363-c372, c371+c370/2, c372, 204,227,53, c373, 16)
        end

        local c374= 4
        local c375= c365 + c358 / 2
        local c376, c377= ui.mouse_position()
        local c378= {}
        local c379= c358
            local c380= math.max(1, math.floor(59 * c338))
            local c381= math.max(1, math.floor(c336 * c338))
            local c382= math.max(1, math.floor(c337 * c338))
            local c383= c374 * c381 + (c374 - 1) * c380
            local c384= math.max(0, c366 * 0.5)
            local c385= c364 + c384 + (c366 - 2 * c384 - c383) / 2
            if c383 > c366 then
                c380 = math.max(0, math.floor((c366 - c374 * c381) / (c374 - 1)))
                c383 = c374 * c381 + (c374 - 1) * c380
                c385 = c364 + (c366 - c383) / 2
            end
        c349()
        local c386= c366 / c374
        for i=1,c374 do
            local c387= c364 + (i-1) * c386
            local c388= c365
            c378[i] = {x=c387, y=c388, w=c386, h=c379}
            if c357 then
                if c335 == i then
                    renderer.rectangle(c387, c388, c386, c379+1, 32,32,32, 85)
                end
                local c389= c387 + c386/2 - c381/2
                local c390= c388 + c379/2 - c382/2
                if c341[i] then
                    renderer.texture(c341[i], c389, c390, c381, c382, 255,255,255,255, "f")
                else
                    renderer.text(c389 + c381/2, c390 + c382/2, 255,255,255,255, '+c', 0, tostring(i))
                end
            end
        end

        local c391= client.key_state(1)
        if c352 and c376 and c377 and ui.is_menu_open() then
            if c391 and not prev_mouse_down then
                for i=1,c374 do
                    local c392= c378[i]
                    if c376 >= c392.x and c376 <= c392.x+c392.w and c377 >= c392.y and c377 <= c392.y+c392.h then
                        c335 = i
                        c340 = c339[c335]
                    end
                end
                local c393= { ui.menu_position() }
                if c393[1] and c393[2] then
                    for si = 1, 9 do
                        local c348= { c344.size.x, c344.size.y + c344.size.h * (si - 1) }
                        if c376 >= c393[1] + c348[1]
                           and c376 <= c393[1] + c344.size.w + c348[1]
                           and c377 >= c393[2] + c348[2]
                           and c377 <= c393[2] + c344.size.h + c348[2] then
                            c344.skeet_cur_tab = si
                            break
                        end
                    end
                end
            end
            prev_mouse_down = c391
        else
            prev_mouse_down = false
        end
        local c394= c345()
        local c395= c344.skeet_cur_tab or 0
        local c396= "Skeet sel: " .. tostring(c395)
        if c394 and c394 ~= c395 then
            c396 = c396 .. "  (hover: " .. tostring(c394) .. ")"
        end
        if c357 then
            if renderer.measure_text then
                pcall(function() renderer.measure_text(nil, c396) end)
            end
            renderer.text(c364 + 6, c365 + c358 + 6, 200,200,200,255, nil, 0, c396)
        end
    end
end

local function c397()
    if not ui.is_menu_open() then return false end
    local c376, c377= ui.mouse_position()
    local c398, c399= ui.menu_position()
    local c400, c401= ui.menu_size()
    local c358= math.floor(90 * c338)
    local c359= math.max(1, math.floor(4 * c338))
    local c364, c365, c366= c398 + c359, c399 - math.floor(7 * c338) - c358, c400 - 2 * c359
    return not (
        c376 >= c398 and c376 <= c398 + c400 and c377 >= c399 and c377 <= c399 + c401
        or c376 >= c364 and c376 <= c364 + c366 and c377 >= c365 and c377 <= c365 + c358
    )
end

return {
    current_tab = function() return c340 end,
    current_tab_index = function() return c335 end,
    tab_names = c339,
    tab_sections = function() return c343 end,
    menu_position = function() return ui.menu_position() end,
    menu_size = function() return ui.menu_size() end,
    is_menu_open = function() return ui.is_menu_open() end,
    mouse_position = function() return ui.mouse_position() end,
    is_mouse_outside_menu = c397,
    draw_menu = c351
}]]
c927["require/abc/menu_setup"] = [[local c338= {
    ui = {},
    registered_items = {},
}

function c338.register_ui(c339,c340)
    
    
    
    if c340 and c340.key then
        for i = #c338.registered_items, 1, -1 do
            local c341= c338.registered_items[i]
            if c341 and c341.key == c340.key then
                
                pcall(function()
                    if c341.item then ui.set_visible(c341.item, false) end
                end)
                table.remove(c338.registered_items, i)
            end
        end
    end

    table.insert(c338.registered_items, {
        item = c339,
        key = c340.key,
        requires_login = c340.requires_login,
        tab = c340.tab,
        visible = c340.visible ~= false,
        config_type = c340.config_type,
        show_condition = c340.show_condition,
    })
    return c339
end

function c338.update_visibility(c342)
    for _, c341 in ipairs(c338.registered_items) do
        local c343= c341.visible
        if c341.requires_login and not c342 then
            c343 = false
        end
        if c341.show_condition then
            c343 = c341.show_condition()
        end
        if c341.item then
            ui.set_visible(c341.item, c343)
        end
    end
end

function c338.save_config()
    local c344= {}
    for _, c341 in ipairs(c338.registered_items) do
        if c341.key and c341.item then
            c344[c341.key] = ui.get(c341.item)
        end
    end
    return c344
end

function c338.load_config(c345)
    for _, c341 in ipairs(c338.registered_items) do
        if c341.key and c341.item and c345[c341.key] ~= nil then
            ui.set(c341.item, c345[c341.key])
        end
    end
end

local c346= {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

local c347= {

    { 'Rage', 'other', 'accuracy boost' },
    { 'Rage', 'other', 'anti-aim correction' },
    { 'rage', 'other', 'automatic fire' },
    { 'Rage', 'other', 'automatic penetration' },
    { 'Rage', 'other', 'silent aim' },
    { 'Rage', 'other', 'remove recoil' },
    { 'Rage', 'other', 'reduce aimstep' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'log misses due to spread' },
    { 'Rage', 'other', 'low fps mitigations ' },
    { 'rage', 'other', 'delay shot' },
    { 'Rage', 'other', 'quick peek assist' },
    { 'Rage', 'other', 'quick peek assist mode' },
    { 'Rage', 'other', 'quick peek assist distance' },
    { 'Rage', 'other', 'reduce aim step' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'low fps mitigations' },
    { 'Rage', 'other', 'duck peek assist' },


}

function c338.toggle_gamesense_menu(c343)
    c338.state = c338.state or {}
    c338.hidden_refs = c338.hidden_refs or {}
    for _, c341 in ipairs(c346) do
        local c348, c349, c350, c351, c352= pcall(ui.reference, c341[1], c341[2], c341[3], c341[4])
        if c348 then
            if c341[1] == 'AA' and c341[2] == 'Anti-aimbot angles' and c341[3] == 'Enabled' then
                c338.state.gs_enabled_ref = c349
                if c349 ~= nil and c343 then
                    if c338.state.gs_enabled_previous ~= nil then
                        ui.set(c349, c338.state.gs_enabled_previous)
                    end
                elseif c349 ~= nil and not c343 then
                    c338.state.gs_enabled_previous = ui.get(c349)
                    ui.set(c349, true)
                end
            end
            local c353= { c349, c350, c351, c352 }
            local c354= {}
            for _, ref in ipairs(c353) do
                if ref ~= nil then
                    ui.set_visible(ref, c343)
                    c354[#c354 + 1] = ref
                end
            end
            if not c343 and #c354 > 0 then
                table.insert(c338.hidden_refs, c354)
            end
        end
    end
    c338.state.gs_hidden = not c343
end

function c338.toggle_rage_menu(c343)
    c338.state = c338.state or {}
    c338.hidden_rage_refs = c338.hidden_rage_refs or {}
    c338.hidden_rage_refs = {} 

    for _, c341 in ipairs(c347) do
        local c348, c349, c350, c351, c352= pcall(ui.reference, c341[1], c341[2], c341[3])
        if c348 then
            local c353= { c349, c350, c351, c352 }
            local c354= {}
            for _, ref in ipairs(c353) do
                if ref ~= nil then
                    pcall(function() ui.set_visible(ref, c343) end)
                    c354[#c354 + 1] = ref
                end
            end
            if not c343 and #c354 > 0 then
                table.insert(c338.hidden_rage_refs, c354)
            end
        end
    end
    c338.state.rage_hidden = not c343
end

return c338]]
c927["require/abc/menu_visibility"] = [[local c341= {
	"global",
	"stand",
	"move",
	"duck",
	"duck+",
	"jump",
	"jump+",
	"walk",
	"fakelag",
	"legit",
}

local c342= require("require/abc/login_system")

local function c343(c344)
	if c344.menu_setup and c344.menu_setup.refresh_cfg_listbox then
		c344.menu_setup.refresh_cfg_listbox()
	end

	if c344 and not c344.login then
		c344.login = c342
	end
	c344.menu_setup.toggle_gamesense_menu(false)
	c344.menu_setup.toggle_rage_menu(true)
	c344.menu_setup.update_visibility(c344.login and c344.login.logged_in)
	local c345= (c344.login and c344.login.logged_in) or false

	local c346= not c345
	local c347= (c344.menu_header and c344.menu_header.current_tab and c344.menu_header.current_tab()) or c344.menu.current_tab()
	 	
	ui.set_visible(c344.menu_setup.ui.login_howto_header, c346)
	ui.set_visible(c344.menu_setup.ui.login_console_register, c346)
	ui.set_visible(c344.menu_setup.ui.login_menu_credentials, c346)
	ui.set_visible(c344.menu_setup.ui.login_press_login, c346)
	ui.set_visible(c344.menu_setup.ui.login_spacer1, c346)
	ui.set_visible(c344.menu_setup.ui.reset_header, c346)
	ui.set_visible(c344.menu_setup.ui.reset_step1, c346)
	ui.set_visible(c344.menu_setup.ui.reset_step2, c346)
	ui.set_visible(c344.menu_setup.ui.login_spacer2, c346)
	ui.set_visible(c344.menu_setup.ui.support_header, c346)
	ui.set_visible(c344.menu_setup.ui.support_discord, c346)
	ui.set_visible(c344.menu_setup.ui.login_username, c346)
	ui.set_visible(c344.menu_setup.ui.login_password, c346)
	ui.set_visible(c344.menu_setup.ui.cache_credentials, c346)
	ui.set_visible(c344.menu_setup.ui.login_button, c346)
	ui.set_visible(c344.menu_setup.ui.reset_button, c346)
	ui.set_visible(c344.menu_setup.ui.discord_button, c346)
	ui.set_visible(c344.menu_setup.ui.youtube_button, c346)
	ui.set_visible(c344.menu_setup.ui.sellhub_button, c346)
	ui.set_visible(c344.menu_setup.ui.logout_button, c345 and c347 == "CFG")

	if c344.menu_setup.ui.condition then
		local c348= ui.get(c344.menu_setup.ui.condition)
		for _, cond in ipairs(c341) do
			local c349= c345 and c347 == "AA" and c348 == cond
			local c350= 'enable_' .. cond
			if c344.menu_setup.ui[c350] then
				ui.set_visible(c344.menu_setup.ui[c350], c349)
				local c351= c344.safe.safe_get(c344.menu_setup.ui[c350])

				local c352= c344.menu_setup.ui['yaw_' .. cond] and ui.get(c344.menu_setup.ui['yaw_' .. cond]) or nil
				local c353= c344.menu_setup.ui['yaw_jitter_' .. cond] and ui.get(c344.menu_setup.ui['yaw_jitter_' .. cond]) or nil
				local c354= c344.menu_setup.ui['body_yaw_mode_' .. cond] and ui.get(c344.menu_setup.ui['body_yaw_mode_' .. cond]) or nil
				local c355= c344.menu_setup.ui['delay_' .. cond] and ui.get(c344.menu_setup.ui['delay_' .. cond]) or nil
				ui.set_visible(c344.menu_setup.ui['pitch_' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['yaw_base_' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['yaw_' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['label1_' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['label2_' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['label3_' .. cond], c349 and c351)
				local c356= c349 and c351 and (c352 ~= 'off' and c352 ~= 'ideal' and c352 ~= '3way')
				ui.set_visible(c344.menu_setup.ui['body_yaw_base_' .. cond], c356)
				local c357= c349 and c351 and (c352 == '180' or c352 == '3way')
				ui.set_visible(c344.menu_setup.ui['body_yaw_left_' .. cond], c357)
				ui.set_visible(c344.menu_setup.ui['body_yaw_right_' .. cond], c357)
				local c358= c349 and c351 and (c352 ~= 'off' and c352 ~= 'ideal')
				ui.set_visible(c344.menu_setup.ui['randomize_yaw_' .. cond], c358)
				local c359= c349 and c351 and (c353 ~= 'off')
				ui.set_visible(c344.menu_setup.ui['yaw_jitter_base_' .. cond], c359)
				local c360= c349 and c351 and (c354 == 'static')
				ui.set_visible(c344.menu_setup.ui['static_body_yaw_' .. cond], c360)
				local c361= c349 and c351 and (c354 == 'jitter' and c355 and c355 <= 0)
				ui.set_visible(c344.menu_setup.ui['body_yaw_value_' .. cond], c361)
				local c362= c349 and c351 and (c354 == 'jitter')
				ui.set_visible(c344.menu_setup.ui['delay_' .. cond], c362)
				ui.set_visible(c344.menu_setup.ui['yaw_jitter_' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['body_yaw_mode_' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['fifty_fifty_' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['only_flip_on_0_choke_' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['aa_label_space' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['aa_label_combo' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['send_button' .. cond], c349 and c351)
				ui.set_visible(c344.menu_setup.ui['send_combo' .. cond], c349 and c351)
			end
		end
		ui.set_visible(c344.menu_setup.ui.condition, c345 and c347 == "AA")
		ui.set_visible(c344.menu_setup.ui.condition_label, c345 and c347 == "AA")
		ui.set_visible(c344.menu_setup.ui.condition_label2, c345 and c347 == "AA")


		ui.set_visible(c344.menu_setup.ui.fakelag_mode, c345 and c347 == "AA")
		if c344.menu_setup.ui.fakelag_mode then
			local c363= ui.get(c344.menu_setup.ui.fakelag_mode)
			local c364= c345 and c347 == "AA"
			local c365= c364 and c363 == "defensive"
			local c366= c344.safe.safe_get(c344.menu_setup.ui.fakelag_defensive) == true
			ui.set_visible(c344.menu_setup.ui.fakelag_defensive, c365)
			ui.set_visible(c344.menu_setup.ui.fakelag_force, c365 and c366)
			ui.set_visible(c344.menu_setup.ui.fakelag_force_on, c365 and c366)
			ui.set_visible(c344.menu_setup.ui.fakelag_fakedef, c365 and c366)

			local c367= c364 and c363 == "stealer"
			local c368= c344.safe.safe_get(c344.menu_setup.ui.fakelag_stealer) == true
			ui.set_visible(c344.menu_setup.ui.fakelag_stealer, c367)
			ui.set_visible(c344.menu_setup.ui.fakelag_stealer_type, c367 and c368)
			ui.set_visible(c344.menu_setup.ui.fakelag_stealer_target, c367 and c368)
			ui.set_visible(c344.menu_setup.ui.fakelag_stealer_list, c367 and c368)
			ui.set_visible(c344.menu_setup.ui.fakelag_stealer_refresh, c367 and c368)
			ui.set_visible(c344.menu_setup.ui.fakelag_stealer_steal, c367 and c368)

			local c369= c364 and c363 == "fakelag"
			local c370= c344.safe.safe_get(c344.menu_setup.ui.fakelag_fakelag) == true
			local c371= c344.safe.safe_get(c344.menu_setup.ui.fakelag_fakelag_type) == "sodium"
			ui.set_visible(c344.menu_setup.ui.fakelag_fakelag, c369)
			ui.set_visible(c344.menu_setup.ui.fakelag_fakelag_type, c369 and c370)
			ui.set_visible(c344.menu_setup.ui.fakelag_fakelag_amount, c369 and c370 and not c371)
			ui.set_visible(c344.menu_setup.ui.fakelag_fakelag_variance, c369 and c370 and not c371)
			ui.set_visible(c344.menu_setup.ui.fakelag_fakelag_limit, c369 and c370 and not c371)
			ui.set_visible(c344.menu_setup.ui.fakelag_fakelag_type2, c369 and c370 and c371)

			local c372= c364 and c363 == "settings"
			ui.set_visible(c344.menu_setup.ui.fakelag_settings_freestanding, c372)
			ui.set_visible(c344.menu_setup.ui.fakelag_settings_enhance_onshot, c372)
			ui.set_visible(c344.menu_setup.ui.fakelag_settings_antibrute, c372)
			ui.set_visible(c344.menu_setup.ui.fakelag_settings_roll_label, c372)
			ui.set_visible(c344.menu_setup.ui.fakelag_settings_roll_checkbox, c372)
			local c373= c372 and c344.safe.safe_get(c344.menu_setup.ui.fakelag_settings_roll_checkbox) == true
			ui.set_visible(c344.menu_setup.ui.fakelag_settings_roll, c373)
			ui.set_visible(c344.menu_setup.ui.fakelag_settings_side, c373)
		end

		local c374= c345 and c347 == "PAINT" and ui.get(c344.menu_setup.ui.paint_indicators_enable) == true
		local c375= c345 and c347 == "PAINT" and c374 and ui.get(c344.menu_setup.ui.paint_indicators) ~= "off"
		local c376= c345 and c347 == "PAINT" and c374 and ui.get(c344.menu_setup.ui.paint_indicators) == "small"
		ui.set_visible(c344.menu_setup.ui.paint_indicators, c374)
		ui.set_visible(c344.menu_setup.ui.paint_indicators_enable, c375)
		ui.set_visible(c344.menu_setup.ui.paint_indicators_animation, c375)
		ui.set_visible(c344.menu_setup.ui.paint_indicators_bar, c376)
		ui.set_visible(c344.menu_setup.ui.paint_indicator_color, c375)

		local c377= c345 and c347 == "PAINT" and ui.get(c344.menu_setup.ui.paint_advertisement) == true
		ui.set_visible(c344.menu_setup.ui.paint_advertisement_color, c377)

		local c378= c345 and c347 == "PAINT" and ui.get(c344.menu_setup.ui.paint_watermark) == true
		ui.set_visible(c344.menu_setup.ui.paint_watermark_color, c378)

		local c379= c345 and c347 == "MISC" and c344.safe.safe_get(c344.menu_setup.ui.misc_dormantaimbot) == true
		ui.set_visible(c344.menu_setup.ui.misc_dormantaimbot_key, c379)
		ui.set_visible(c344.menu_setup.ui.misc_dormantaimbot_value, c379)

		local c380= c345 and c347 == "PAINT" and c344.safe.safe_get(c344.menu_setup.ui.paint_logger_checkbox) == true
		ui.set_visible(c344.menu_setup.ui.paint_logger, c380)
		ui.set_visible(c344.menu_setup.ui.paint_logger_animation, c380)
		ui.set_visible(c344.menu_setup.ui.paint_logger_color, c380)

		local c381= c345 and c347 == "PAINT" and c344.safe.safe_get(c344.menu_setup.ui.paint_aspect_ratio_checkbox) == true
		ui.set_visible(c344.menu_setup.ui.paint_aspect_ratio, c381)

		local c382= c345 and c347 == "PAINT" and c344.safe.safe_get(c344.menu_setup.ui.paint_third_person_distance_checkbox) == true
		ui.set_visible(c344.menu_setup.ui.paint_third_person_distance, c382)

	end

	local c383= {
		'aa_gskey_freestand',
		'aa_gskey_freestandh',
		'aa_gskey_slowmotion',
		'aa_gskey_slowmotionh',
		'aa_gskey_edgeyaw',
		'aa_gskey_edgeyawh',
		'aa_gskey_onshot',
		'aa_gskey_onshoth',
	}
	for _, key in ipairs(c383) do
		if c344.menu_setup.ui[key] then
			ui.set_visible(c344.menu_setup.ui[key], tab_name == "AA")
		end
	end

	local c384= {
		'misc_resolver',
		'misc_ragebot',
		'misc_dormantaimbot',
		'misc_exploit_fakelag',
		'misc_walkbot',
		'misc_backstab',
		'misc_spindead',
	}
	for _, key in ipairs(c384) do
		if c344.menu_setup.ui[key] then
			ui.set_visible(c344.menu_setup.ui[key], tab_name == "MISC")
		end
	end

	local c385= {
		'paint_target_info',
		'label_space2',
		'label_space3',
		'label_space4',
		'paint_entidx',
		'paint_filter_console',
		'paint_minimum_damage',
		'paint_show_damage_penetration',
		'paint_hitmiss_indicator',
		'paint_self_skeleton',
		'paint_bullet_tracer',
		'paint_lagcomp_box',
		'paint_lagcomp_box_color',
		'paint_presmoke',
		'paint_bombwarning',
		'paint_insults',
		'paint_rainbow_esp',
		'paint_molotov',
		'paint_lag_record',
		'paint_advertisement',
		'paint_advertisement_animation',
		'paint_clantag',
		'paint_aimbot_logs',
		'paint_indicators_label',
		'paint_indicators_enable',
		'label_space1',
		'paint_watermark',
		'paint_watermark_type',
		'paint_logger_label',
		'paint_logger_checkbox',
		'paint_hitmarker',
		'paint_hitmarker_color',
		'paint_warnings',
		'paint_animations',
		'paint_performance_mode',
		'paint_aspect_ratio_checkbox',
		'paint_third_person_distance_checkbox',
	}
	for _, key in ipairs(c385) do
		if c344.menu_setup.ui[key] then
			ui.set_visible(c344.menu_setup.ui[key], tab_name == "PAINT")
		end
	end

		local c386= {
			'cfg_load_button',
			'cfg_save_button',
			'cfg_delete_button',
			'cfg_refresh_button',
			'cfg_create_button',
			'cfg_export_button',
			'cfg_import_button',
			'cfg_input_box',
			'cfg_listbox',
			'cfg_selection',
			'cfg_cloud',
			'cfg_cloud_apply',
		}
		for _, key in ipairs(c386) do
			if c344.menu_setup.ui[key] then
				ui.set_visible(c344.menu_setup.ui[key], c345 and c347 == "CFG")
			end
		end

end

local function c387(c344)
	local c388= {
		c344.menu_setup.ui.condition,
		c344.menu_setup.ui.fakelag_mode,
	}
	for _, item in ipairs(c388) do
		if item then
			ui.set_callback(item, function()
				c343(c344)
			end)
		end
	end

	for _, cond in ipairs(c341) do
		local c389= {
			'enable_' .. cond,
			'yaw_' .. cond,
			'yaw_jitter_' .. cond,
			'body_yaw_mode_' .. cond,
			'fifty_fifty_' .. cond,
			'only_flip_on_0_choke_' .. cond,
			'aa_label_space' .. cond,
			'aa_label_combo' .. cond,
			'send_button' .. cond,
			'send_combo' .. cond,
		}
		for _, key in ipairs(c389) do
			local c390= c344.menu_setup.ui[key]
			if c390 then
				ui.set_callback(c390, function()
					c343(c344)
				end)
			end
		end
	end

	local c391= {
		'fakelag_defensive',
		'fakelag_stealer',
		'fakelag_fakelag',
		'fakelag_fakelag_type',
		'fakelag_settings_roll_label',
		'fakelag_settings_roll_checkbox',
	}
	for _, key in ipairs(c391) do
		local c390= c344.menu_setup.ui[key]
		if c390 then
			ui.set_callback(c390, function()
				c343(c344)
			end)
		end
	end

	if c344.menu_setup.ui.paint_indicators then
		ui.set_callback(c344.menu_setup.ui.paint_indicators, function()
			c343(c344)
		end)
	end

	if c344.menu_setup.ui.paint_advertisement then
		ui.set_callback(c344.menu_setup.ui.paint_advertisement, function()
			c343(c344)
		end)
	end
	
	if c344.menu_setup.ui.paint_watermark then
		ui.set_callback(c344.menu_setup.ui.paint_watermark, function()
			c343(c344)
		end)
	end

	if c344.menu_setup.ui.misc_dormantaimbot then
		ui.set_callback(c344.menu_setup.ui.misc_dormantaimbot, function()
			c343(c344)
		end)
	end

	if c344.menu_setup.ui.paint_logger_checkbox then
		ui.set_callback(c344.menu_setup.ui.paint_logger_checkbox, function()
			c343(c344)
		end)
	end

	if c344.menu_setup.ui.paint_aspect_ratio_checkbox then
		ui.set_callback(c344.menu_setup.ui.paint_aspect_ratio_checkbox, function()
			c343(c344)
		end)
	end

	if c344.menu_setup.ui.paint_third_person_distance_checkbox then
		ui.set_callback(c344.menu_setup.ui.paint_third_person_distance_checkbox, function()
			c343(c344)
		end)
	end

	if c344.menu_setup.ui.paint_indicators_enable then
		ui.set_callback(c344.menu_setup.ui.paint_indicators_enable, function()
			c343(c344)
		end)
	end

	if c344.login and type(c344.login.add_state_callback) == 'function' then
		c344.login.add_state_callback(function()
			c343(c344)
		end)
	end
end

return {
	update = c343,
	setup_callbacks = c387
}]]
c927["require/abc/push_gamesense"] = [[local c344= renderer
local c345= globals
local c346= string.char

local c347= nil
local function c348()
    if c347 then return c347 end
    if c344.load_rgba then
        local c349, c350= pcall(c344.load_rgba,
            string.char(
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
            ), 4, 4)
        if c349 and c350 then c347 = c350 end
    end
    return c347
end


local function c351(c352,c353,c354,c355,c356,c357)
    local c358= c352 - 3
    local c359= c353 - 40
    local c360= c354 + 5
    local c361= c355 + 1
    c344.rectangle(c352 - 10, c353 - 48, c354 + 20, c355 + 16, 0, 0, 0, 200)
    c344.rectangle(c352 - 9, c353 - 47, c354 + 18, c355 + 14, 60, 60, 60, 255)
    c344.rectangle(c352 - 8, c353 - 46, c354 + 16, c355 + 12, 40, 40, 40, 255)
    c344.rectangle(c352 - 5, c353 - 43, c354 + 10, c355 + 6, 60, 60, 60, 255)
    c344.rectangle(c352 - 4, c353 - 42, c354 + 8, c355 + 4, 12, 12, 12, 255)
    c344.rectangle(c352 - 4, c353 - 42, c354 + 8, c355 + 4, 32, 32, 32, 255)
    local c362= c348()
    if c362 and c344.texture then
        c344.texture(c362, c358, c359, c360, c361, 255,255,255,c356, 'r')
    else
        c344.rectangle(c358, c359, c360, c361, 0, 0, 0, 0)
    end

    
    if c344.gradient then
        c344.gradient(c352 - 4, c353 - 42, c354 / 2 + 1, 1, 59, 175, 222, 255, 202, 70, 205, 255, true)
        c344.gradient(c352 - 4 + c354 / 2, c353 - 42, c354 / 2 + 8.5, 1, 202, 70, 205, 255, 204, 227, 53, 255, true)
    end
    c344.text(c352, c353 - 40, 255, 255, 255, 255, '', nil, c357)
end

return c351
]]
c927["require/abc/push_logger"] = [[local c347= renderer
local c348= globals
local c349= client
local c350= entity
local c351= table.insert
local c352= table.remove
local c353= math.floor
local c354= math.sqrt
local c355= string.char


local c356, c357= pcall(require, "require/abc/menu_setup")


local c358, c359= pcall(ui.reference, 'misc', 'settings', 'menu color')

local c360= {}
local c361= 5

local function c362(c363,c364,c365,c366,c367,c368)
    if #c360 >= c361 then
        c352(c360, 1)
    end
    c351(c360, {
        text = tostring(c363),
        duration = c364 or 5,
        color = { c365 or 255, c366 or 255, c367 or 255, c368 or 255 },
        timestamp = c348 and c348.curtime and c348.curtime() or os.clock(),
    })
end

local function c369(c370)
    local c371, c372, c373= pcall(c347.measure_text, '', c370)
    if c371 and type(c372) == 'number' then return c372, c373 or 0 end
    c371, c372, h = pcall(c347.measure_text, c370)
    if c371 and type(c372) == 'number' then return c372, c373 or 0 end
    return 0, 0
end

local function c374(c375,c376,c377)
    if c375 < c376 then return c376 end
    if c375 > c377 then return c377 end
    return c375
end


local function c378()
    if c356 and c357 and c357.ui and c357.ui.paint_logger then
        local c371, c379= pcall(ui.get, c357.ui.paint_logger)
        if c371 and c379 then return true end
        return false
    end
    
    return true
end


local function c380()
    if c356 and c357 and c357.ui and c357.ui.paint_logger_animation then
        local c371, c375= pcall(ui.get, c357.ui.paint_logger_animation)
        if c371 and type(c375) == 'number' then return c375 end
    end
    return 0
end


local c381, c382= pcall(require, "require/abc/push_modern")
local c383, c384= pcall(require, "require/abc/push_gamesense")


local function c385(c386)
    local c387= 80
    local c388= c386 - 80
    local c389= 40
    local c390= c386 / 2 - 300
    local c391= c386 - c390 - 10
    c391 = c374(c391, c387 + c389, c388 - c389)
    local c392= c391 - c389
    local c393= c391 + c389
    return c392, c393, c391
end

local function c394()
    if not c347 or not c347.text then return end
    if not c378() then return end

    local c395= c380() or 0
    local c396= c348 and c348.curtime and c348.curtime()
    local c397, c386= c349 and c349.screen_size and c349.screen_size() or 800, 600
    local c398= c386 * 0.5 + (c386 * 0.5 * 1.8)
    local c399= 0
    for i = #c360, 1, -1 do
        local c400= c360[i]
        local c401= (c400.timestamp + c400.duration) - c396
        if c401 <= 0 then
            c352(c360, i)
        else
            local c402, c403= c369(c400.text)
            local c404= (c395 == 1) and 4 or 2
            local c405= 2
            local c406= c397 / 2 - c402 / 2
            local c407= c398 + c399
            local c408= 5
            local c409= c353((c400.color[4] or 255) * math.min(1, (c401 / c400.duration) * c408))
            local c410= (c400.duration - c401)
            local c411= (c400.duration > 0 and c400.duration or 1)
            local c412= c410 / c411
            local c413= 6
            local c414= c374(c412 * c413, 0, 1)
            local c415= c414
            
            
            local c416= math.min(0.5, c411 * 0.25)
            if c401 <= c416 then
                local c417= c401 / c416 
                c415 = c374(c417, 0, 1)
            end
            if c395 == 1 then
                c382(c406, c407, c402, 13, c409, c400.text, c415)
                c399 = c399 + (c403 + c404 * 2 + c354(c405 / 10) * 4)
            else
                c384(c406, c407, c402, 13, c409, c400.text)
                c399 = c399 + (c403 + c404 * 2 + c354(c405 / 10) * 35)
            end
        end
    end
end

if c349 and c349.set_event_callback then
    c349.set_event_callback('paint', c394)
else
    
    c349.set_event_callback('paint', c394)
end

return c362
]]
c927["require/abc/push_modern"] = [[local c350= renderer
local c351= ui
local c352= math.floor

local c353, c354= pcall(require, "require/abc/menu_setup")
local c355, c356= pcall(c351.reference, 'misc', 'settings', 'menu color')

local function c357(c358,c359,c360,c361,c362,c363,c364,c365,c366)
    if not c362 or c362 <= 0 then
        c350.rectangle(c358, c359, c360, c361, c363,c364,c365,c366)
        return
    end
    c350.rectangle(c358 + c362, c359, c360 - (c362 * 2), c361, c363,c364,c365,c366)
    c350.rectangle(c358, c359 + c362, c360, c361 - (c362 * 2), c363,c364,c365,c366)
    c350.circle(c358 + c362, c359 + c362, c363,c364,c365,c366, c362, 0, 1)
    c350.circle(c358 + c360 - c362, c359 + c362, c363,c364,c365,c366, c362, 0, 1)
    c350.circle(c358 + c362, c359 + c361 - c362, c363,c364,c365,c366, c362, 0, 1)
    c350.circle(c358 + c360 - c362, c359 + c361 - c362, c363,c364,c365,c366, c362, 0, 1)
end

local function c367(c368,c369,c370,c371)
    local c372, c373, c374, c375= c368 or 255, c369 or 140, c370 or 0, c371 or 255
    
    if c353 and c354 and c354.ui and c354.ui.paint_logger_color then
        local c376, c377, c378, c379, c380= pcall(c351.get, c354.ui.paint_logger_color)
        if c376 then
            if type(c377) == 'number' then
                c372 = c352(c377 or c372)
                c373 = c352(c378 or c373)
                c374 = c352(c379 or c374)
                c375 = c352(c380 or c375)
            elseif type(c377) == 'string' and #c377 == 12 then
                local c381
                c381, mr = pcall(function() return tonumber(c377:sub(1,3)) end)
                c381, mg = pcall(function() return tonumber(c377:sub(4,6)) end)
                c381, mb = pcall(function() return tonumber(c377:sub(7,9)) end)
                c381, ma = pcall(function() return tonumber(c377:sub(10,12)) end)
                c372 = c372 or c368; c373 = c373 or c369; c374 = c374 or c370; c375 = c375 or c371
            end
            return c372, c373, c374, c375
        end
    end

    
    if c355 and c356 then
        local c376, c377, c378, c379, c380= pcall(c351.get, c356)
        if c376 then
            if type(c377) == 'number' then
                c372 = c352(c377 or c372)
                c373 = c352(c378 or c373)
                c374 = c352(c379 or c374)
                c375 = c352(c380 or c375)
            elseif type(c377) == 'string' and #c377 == 12 then
                local c381
                c381, mr = pcall(function() return tonumber(c377:sub(1,3)) end)
                c381, mg = pcall(function() return tonumber(c377:sub(4,6)) end)
                c381, mb = pcall(function() return tonumber(c377:sub(7,9)) end)
                c381, ma = pcall(function() return tonumber(c377:sub(10,12)) end)
                c372 = c372 or c368; c373 = c373 or c369; c374 = c374 or c370; c375 = c375 or c371
            end
        end
    end
    return c372, c373, c374, c375
end

local function c382(c358,c359,c360,c361,c383,c384,c385)
    local c386= c358 - 4
    local c387= c359 - 40
    local c388= c360 + 8
    local c389= c361 + 1

    local c390= 6
    if c389 < 12 then c390 = math.max(1, math.floor(c389 / 2)) end
    local c391= math.max(1, c390 - 1)

    local c372, c373, c374, c375= c367(255, 140, 0, 255)
    local c392= c352((c375 or 255) * 0.95)

    c385 = math.max(0, math.min(1, c385 or 1))
    local c393= c386 - 1
    local c394= c387 - 1
    local c395= c388 + 2
    local c396= c389 + 2
    local c397= c395 / 2 + (c395 * 0.1)
    local c398= c352(c397 * c385)

    if c398 > 0 then
        local c399= math.min(c390 + 1, c352(c396 / 2), c352(c398 / 2))
        c357(c393, c394, c398, c396, c399, c372, c373, c374, c392)
        c357(c393 + c395 - c398, c394, c398, c396, c399, c372, c373, c374, c392)
    end
    c357(c386, c387, c388, c389, c390, 10, 10, 10, 230)
    c357(c386 + 1, c387 + 1, c388 - 2, c389 - 2, c391, 6, 6, 6, 220)
    if c350.gradient then
        c350.gradient(c386 + 2, c387 + 1, math.max(0, c388 - 4), 2, c372, c373, c374, c352(c392 * 0.14), c372, c373, c374, 0, true)
    end
    c350.text(c358, c359 - 40, 255, 255, 255, 255, '', nil, c384)
end

return c382]]
c927["require/abc/register"] = [[local c353= require("require.abc.login_system")
local c354= "acc_" .. "OIDFGNSOIGNSFGIOSNGOISNGIOS"

local function c355(c356)
    local c357= {}
    for part in c356:gmatch("%S+") do
        table.insert(c357, part)
    end
    return c357
end

client.set_event_callback("console_input", function(c358)
    local c357= c355(c358 or "")
    if #c357 == 0 then return end

    local c359= c357[1]:lower()
    if c359 ~= "register" then
        
        return
    end

    if #c357 < 4 then
        client.log("Usage: register <username> <password> <invite>")
        return
    end

    local c360= c357[2]
    local c361= c357[3]
    local c362= c357[4]

    local c363, c364= c353.is_valid_invite(c362)
    if not c363 then
        client.log("Register failed: invalid or used invite")
        return
    end

    local c365= database.read(c354) or {}
    if c365[c360] then
        client.log("Register failed: username already exists - ", c360)
        return
    end

    local c366, c367= c353.register_with_invite(c362, c360, c361)
    if c366 then
        client.log("Registered user:", c360)
    else
        client.log("Register failed:", c367 or "unknown error")
    end
end)]]
c927["require/abc/screen_logger"] = [[local c356= renderer
local c357= globals
local c358= client
local c359= table.insert
local c360= table.remove
local c361= math.floor




local c362= {}
local c363= 12

local function c364(c365)
    local c366, c367, c368= pcall(c356.measure_text, '', c365)
    if c366 and type(c367) == 'number' then return c367, c368 or 0 end
    c366, c367, h = pcall(c356.measure_text, c365)
    if c366 and type(c367) == 'number' then return c367, c368 or 0 end
    return 0, 0
end

local function c369(c370,c371,c372,c373,c374,c375)
    if not c370 then return end
    c371 = c371 or 4
    if #c362 >= c363 then
        c360(c362, 1)
    end
    c359(c362, {
        text = tostring(c370),
        duration = c371,
        color = { c372 or 255, c373 or 255, c374 or 255, c375 or 255 },
        ts = c357 and c357.curtime and c357.curtime() or os.clock(),
    })
    return true
end

local function c376()
    if not c356 or not c356.text then return end
    local c377= c357 and c357.curtime and c357.curtime() or os.clock()
    local c378, c379= c358 and c358.screen_size and c358.screen_size() or 800, 600

    local c380= 8
    local c381= 6
    local c382= 14
    local c383= 2

    local c384= c381

    for i = #c362, 1, -1 do
        local c385= c362[i]
        if not c385 then goto continue end
        local c386= c377 - (c385.ts or 0)
        local c387= (c385.duration or 4) - c386
        if c387 <= 0 then
            c360(c362, i)
        else
            local c388, c389= c364(c385.text)
            
            local c390= c361(c385.color[4] or 255)
            
            pcall(c356.text, c380, c384, c385.color[1] or 255, c385.color[2] or 255, c385.color[3] or 255, c390, 'b', 0, c385.text)
            c384 = c384 + (c389 > 0 and c389 or c382) + c383
        end
        ::continue::
    end
end

if c358 and c358.set_event_callback then
    c358.set_event_callback('paint', c376)
end

return c369]]
c927["require/brain/dll"] = [=[local ffi = require("ffi")

ffi.cdef([[
struct Vec3 { double x; double y; double z; };
struct AspectState { double original; double last; double last_update; int initialized; };
const char* clipboard_get();
int clipboard_set(const char* text);
int clipboard_empty();
int clantag_anim(double start_time, double now, char* out_buf, int out_buf_len);
void tracer_reset();
void tracer_push_shot(double sx, double sy, double sz, double t);
void tracer_set_impact(double ix, double iy, double iz, double t);
int tracer_collect(double now, double tracer_life, double fade_fraction, double pitch, double yaw, double fallback_dist, double base_alpha, double* out_buf, int max_lines);
 ]])


local function hex(val)
    local ok, num = pcall(ffi.cast, "uintptr_t", val)
    if not ok then return "<na>" end
    return string.format("0x%X", tonumber(num))
end

local function resolve_call_trampoline()
    local tramp = client.find_signature("engine.dll", "\xFF\xE1")
    if tramp == nil then
        return nil
    end
    return ffi.cast("void*", tramp)
end

local function make_import_thunk(sig_pattern, cast_type)
    local addr = client.find_signature("engine.dll", sig_pattern)
    if addr == nil then
        return nil
    end
    local ptr = ffi.cast("void***", ffi.cast("uintptr_t", addr) + 2)[0][0]
    return ptr
end

local call_trampoline = resolve_call_trampoline()
local gm_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B", "void *")
local gpa_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05", "void *")

if gm_thunk and gpa_thunk then
else
    return
end

local function via_trampoline(target, signature, label)
    local fn = ffi.cast(signature, call_trampoline)
    return function(...)
        return fn(target, ...)
    end
end

local function to_wide(str)
    local buf = ffi.new("wchar_t[?]", #str + 1)
    for i = 1, #str do buf[i - 1] = string.byte(str, i) end
    buf[#str] = 0
    return buf
end

local GetModuleHandleA_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const char *)", "GMH A")
local GetModuleHandleW_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const wchar_t *)", "GMH W")
local GetProcAddress_tr   = via_trampoline(gpa_thunk, "void *(__thiscall *)(void *, void *, const char *)", "GPA")

local function call_GetModuleHandle(name)
    local ok1, res1 = pcall(GetModuleHandleA_tr, name)
    if not ok1 then dbg("GetModuleHandleA tramp err", res1) end
    if ok1 and res1 ~= nil and res1 ~= ffi.NULL then
        return res1, "tramp ansi"
    end

    local ok2, res2 = pcall(GetModuleHandleW_tr, to_wide(name))
    if not ok2 then dbg("GetModuleHandleW tramp err", res2) end
    if ok2 and res2 ~= nil and res2 ~= ffi.NULL then
        return res2, "tramp wide"
    end

    return nil, "failed"
end

local function call_GetProcAddress(mod, name)
    local ok, res = pcall(GetProcAddress_tr, mod, name)
    if not ok then dbg("GetProcAddress tramp err", res) end
    if ok and res ~= nil and res ~= ffi.NULL then return res end
    return nil
end

local mod, gm_variant = call_GetModuleHandle("sodiumdll.dll")
if mod == nil then
    return
end

local function bind_export(name, cdecl_sig)
    local addr = call_GetProcAddress(mod, name)
    if addr == nil then
        return nil
    end
    return addr, ffi.cast(cdecl_sig, addr)
end

local add_addr, add_fn = bind_export("add", "int(__cdecl*)(int, int)")
local get_value_addr, get_value_fn = bind_export("get_value", "int(__cdecl*)(void)")
local pin_module_addr, pin_module_fn = bind_export("pin_module", "void(__cdecl*)(void)")
local release_module_addr, release_module_fn = bind_export("release_module", "void(__cdecl*)(void)")
local get_hwid_addr, get_hwid_fn = bind_export("get_hwid", "const char*(__cdecl*)(void)")
local clipboard_get_addr, clipboard_get_fn = bind_export("clipboard_get", "const char*(__cdecl*)(void)")
local clipboard_set_addr, clipboard_set_fn = bind_export("clipboard_set", "int(__cdecl*)(const char*)")
local clipboard_empty_addr, clipboard_empty_fn = bind_export("clipboard_empty", "int(__cdecl*)(void)")
local clantag_anim_addr, clantag_anim_fn = bind_export("clantag_anim", "int(__cdecl*)(double, double, char*, int)")
local tracer_reset_addr, tracer_reset_fn = bind_export("tracer_reset", "void(__cdecl*)(void)")
local tracer_push_shot_addr, tracer_push_shot_fn = bind_export("tracer_push_shot", "void(__cdecl*)(double, double, double, double)")
local tracer_set_impact_addr, tracer_set_impact_fn = bind_export("tracer_set_impact", "void(__cdecl*)(double, double, double, double)")
local tracer_collect_addr, tracer_collect_fn = bind_export("tracer_collect", "int(__cdecl*)(double, double, double, double, double, double, double, double*, int)")

local vec_make_addr, vec_make_fn = bind_export("vec_make", "struct Vec3(__cdecl*)(double, double, double)")
local vec_add_addr, vec_add_fn = bind_export("vec_add", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_sub_addr, vec_sub_fn = bind_export("vec_sub", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_mul_scalar_addr, vec_mul_scalar_fn = bind_export("vec_mul_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_div_scalar_addr, vec_div_scalar_fn = bind_export("vec_div_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_unm_addr, vec_unm_fn = bind_export("vec_unm", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_length_addr, vec_length_fn = bind_export("vec_length", "double(__cdecl*)(struct Vec3)")
local vec_dot_addr, vec_dot_fn = bind_export("vec_dot", "double(__cdecl*)(struct Vec3, struct Vec3)")
local vec_cross_addr, vec_cross_fn = bind_export("vec_cross", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_normalized_addr, vec_normalized_fn = bind_export("vec_normalized", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_distance_addr, vec_distance_fn = bind_export("vec_distance", "double(__cdecl*)(struct Vec3, struct Vec3)")

local m_clamp_addr, m_clamp_fn = bind_export("m_clamp", "double(__cdecl*)(double, double, double)")
local m_clamp01_addr, m_clamp01_fn = bind_export("m_clamp01", "double(__cdecl*)(double)")
local m_abs_addr, m_abs_fn = bind_export("m_abs", "double(__cdecl*)(double)")
local m_lerp_addr, m_lerp_fn = bind_export("m_lerp", "double(__cdecl*)(double, double, double)")
local m_distance2d_addr, m_distance2d_fn = bind_export("m_distance2d", "double(__cdecl*)(double, double, double, double)")
local m_distance3d_addr, m_distance3d_fn = bind_export("m_distance3d", "double(__cdecl*)(double, double, double, double, double, double)")
local m_rad_to_deg_addr, m_rad_to_deg_fn = bind_export("m_rad_to_deg", "double(__cdecl*)(double)")
local m_deg_to_rad_addr, m_deg_to_rad_fn = bind_export("m_deg_to_rad", "double(__cdecl*)(double)")
local m_wrap_degrees_addr, m_wrap_degrees_fn = bind_export("m_wrap_degrees", "double(__cdecl*)(double)")
local m_normalize_angle_addr, m_normalize_angle_fn = bind_export("m_normalize_angle", "double(__cdecl*)(double)")
local m_angle_diff_addr, m_angle_diff_fn = bind_export("m_angle_diff", "double(__cdecl*)(double, double)")
local m_lerp_angle_addr, m_lerp_angle_fn = bind_export("m_lerp_angle", "double(__cdecl*)(double, double, double)")
local m_map_addr, m_map_fn = bind_export("m_map", "double(__cdecl*)(double, double, double, double, double)")
local m_smoothstep_addr, m_smoothstep_fn = bind_export("m_smoothstep", "double(__cdecl*)(double, double, double)")
local aspect_update_addr, aspect_update_fn = bind_export("aspect_update", "void(__cdecl*)(void*, double, double, double, double*, int*)")

if not (add_fn and get_value_fn and pin_module_fn and release_module_fn and get_hwid_fn and
    vec_make_fn and vec_add_fn and vec_sub_fn and vec_mul_scalar_fn and vec_div_scalar_fn and
    vec_unm_fn and vec_length_fn and vec_dot_fn and vec_cross_fn and vec_normalized_fn and vec_distance_fn and
    m_clamp_fn and m_clamp01_fn and m_abs_fn and m_lerp_fn and m_distance2d_fn and m_distance3d_fn and
    m_rad_to_deg_fn and m_deg_to_rad_fn and m_wrap_degrees_fn and m_normalize_angle_fn and m_angle_diff_fn and
    m_lerp_angle_fn and m_map_fn and m_smoothstep_fn and aspect_update_fn and
    clipboard_get_fn and clipboard_set_fn and clipboard_empty_fn and clantag_anim_fn and
    tracer_reset_fn and tracer_push_shot_fn and tracer_set_impact_fn and tracer_collect_fn) then
    return
end

local Call_add = via_trampoline(add_addr, "int(__thiscall *)(void*, int, int)", "add")
local Call_get_value = via_trampoline(get_value_addr, "int(__thiscall *)(void*)", "get_value")
local Call_pin_module = via_trampoline(pin_module_addr, "void(__thiscall *)(void*)", "pin_module")
local Call_release_module = via_trampoline(release_module_addr, "void(__thiscall *)(void*)", "release_module")
local Call_get_hwid = via_trampoline(get_hwid_addr, "const char*(__thiscall *)(void*)", "get_hwid")
local Call_clipboard_get = via_trampoline(clipboard_get_addr, "const char*(__thiscall *)(void*)", "clipboard_get")
local Call_clipboard_set = via_trampoline(clipboard_set_addr, "int(__thiscall *)(void*, const char*)", "clipboard_set")
local Call_clipboard_empty = via_trampoline(clipboard_empty_addr, "int(__thiscall *)(void*)", "clipboard_empty")
local Call_clantag_anim = via_trampoline(clantag_anim_addr, "int(__thiscall *)(void*, double, double, char*, int)", "clantag_anim")
local Call_tracer_reset = via_trampoline(tracer_reset_addr, "void(__thiscall *)(void*)", "tracer_reset")
local Call_tracer_push_shot = via_trampoline(tracer_push_shot_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_push_shot")
local Call_tracer_set_impact = via_trampoline(tracer_set_impact_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_set_impact")
local Call_tracer_collect = via_trampoline(tracer_collect_addr, "int(__thiscall *)(void*, double, double, double, double, double, double, double, double*, int)", "tracer_collect")
local Call_vec_make = via_trampoline(vec_make_addr, "struct Vec3(__thiscall *)(void*, double, double, double)", "vec_make")
local Call_vec_add = via_trampoline(vec_add_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_add")
local Call_vec_sub = via_trampoline(vec_sub_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_sub")
local Call_vec_mul_scalar = via_trampoline(vec_mul_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_mul_scalar")
local Call_vec_div_scalar = via_trampoline(vec_div_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_div_scalar")
local Call_vec_unm = via_trampoline(vec_unm_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_unm")
local Call_vec_length = via_trampoline(vec_length_addr, "double(__thiscall *)(void*, struct Vec3)", "vec_length")
local Call_vec_dot = via_trampoline(vec_dot_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_dot")
local Call_vec_cross = via_trampoline(vec_cross_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_cross")
local Call_vec_normalized = via_trampoline(vec_normalized_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_normalized")
local Call_vec_distance = via_trampoline(vec_distance_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_distance")

local Call_m_clamp = via_trampoline(m_clamp_addr, "double(__thiscall *)(void*, double, double, double)", "m_clamp")
local Call_m_clamp01 = via_trampoline(m_clamp01_addr, "double(__thiscall *)(void*, double)", "m_clamp01")
local Call_m_abs = via_trampoline(m_abs_addr, "double(__thiscall *)(void*, double)", "m_abs")
local Call_m_lerp = via_trampoline(m_lerp_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp")
local Call_m_distance2d = via_trampoline(m_distance2d_addr, "double(__thiscall *)(void*, double, double, double, double)", "m_distance2d")
local Call_m_distance3d = via_trampoline(m_distance3d_addr, "double(__thiscall *)(void*, double, double, double, double, double, double)", "m_distance3d")
local Call_m_rad_to_deg = via_trampoline(m_rad_to_deg_addr, "double(__thiscall *)(void*, double)", "m_rad_to_deg")
local Call_m_deg_to_rad = via_trampoline(m_deg_to_rad_addr, "double(__thiscall *)(void*, double)", "m_deg_to_rad")
local Call_m_wrap_degrees = via_trampoline(m_wrap_degrees_addr, "double(__thiscall *)(void*, double)", "m_wrap_degrees")
local Call_m_normalize_angle = via_trampoline(m_normalize_angle_addr, "double(__thiscall *)(void*, double)", "m_normalize_angle")
local Call_m_angle_diff = via_trampoline(m_angle_diff_addr, "double(__thiscall *)(void*, double, double)", "m_angle_diff")
local Call_m_lerp_angle = via_trampoline(m_lerp_angle_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp_angle")
local Call_m_map = via_trampoline(m_map_addr, "double(__thiscall *)(void*, double, double, double, double, double)", "m_map")
local Call_m_smoothstep = via_trampoline(m_smoothstep_addr, "double(__thiscall *)(void*, double, double, double)", "m_smoothstep")
local Call_aspect_update = via_trampoline(aspect_update_addr, "void(__thiscall *)(void*, void*, double, double, double, double*, int*)", "aspect_update")


return {
    add = function(a, b)
        return Call_add(a, b)
    end,
    get_value = function()
        return Call_get_value()
    end,
    pin_module = function()
        return Call_pin_module()
    end,
    release_module = function()
        return Call_release_module()
    end,
    get_hwid = function()
        return Call_get_hwid()
    end,
    clipboard_get = function()
        return Call_clipboard_get()
    end,
    clipboard_set = function(text)
        return Call_clipboard_set(text)
    end,
    clipboard_empty = function()
        return Call_clipboard_empty()
    end,
    clantag_anim = function(start_time, now, out_buf, out_buf_len)
        return Call_clantag_anim(start_time, now, out_buf, out_buf_len)
    end,
    tracer_reset = function()
        return Call_tracer_reset()
    end,
    tracer_push_shot = function(sx, sy, sz, t)
        return Call_tracer_push_shot(sx, sy, sz, t)
    end,
    tracer_set_impact = function(ix, iy, iz, t)
        return Call_tracer_set_impact(ix, iy, iz, t)
    end,
    tracer_collect = function(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
        return Call_tracer_collect(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
    end,
    vec_make = function(x, y, z)
        return Call_vec_make(x, y, z)
    end,
    vec_add = function(a, b)
        return Call_vec_add(a, b)
    end,
    vec_sub = function(a, b)
        return Call_vec_sub(a, b)
    end,
    vec_mul_scalar = function(v, s)
        return Call_vec_mul_scalar(v, s)
    end,
    vec_div_scalar = function(v, s)
        return Call_vec_div_scalar(v, s)
    end,
    vec_unm = function(v)
        return Call_vec_unm(v)
    end,
    vec_length = function(v)
        return Call_vec_length(v)
    end,
    vec_dot = function(a, b)
        return Call_vec_dot(a, b)
    end,
    vec_cross = function(a, b)
        return Call_vec_cross(a, b)
    end,
    vec_normalized = function(v)
        return Call_vec_normalized(v)
    end,
    vec_distance = function(a, b)
        return Call_vec_distance(a, b)
    end,
    m_clamp = function(val, minVal, maxVal)
        return Call_m_clamp(val, minVal, maxVal)
    end,
    m_clamp01 = function(val)
        return Call_m_clamp01(val)
    end,
    m_abs = function(val)
        return Call_m_abs(val)
    end,
    m_lerp = function(a, b, t)
        return Call_m_lerp(a, b, t)
    end,
    m_distance2d = function(x1, y1, x2, y2)
        return Call_m_distance2d(x1, y1, x2, y2)
    end,
    m_distance3d = function(x1, y1, z1, x2, y2, z2)
        return Call_m_distance3d(x1, y1, z1, x2, y2, z2)
    end,
    m_rad_to_deg = function(rad)
        return Call_m_rad_to_deg(rad)
    end,
    m_deg_to_rad = function(deg)
        return Call_m_deg_to_rad(deg)
    end,
    m_wrap_degrees = function(angle)
        return Call_m_wrap_degrees(angle)
    end,
    m_normalize_angle = function(angle)
        return Call_m_normalize_angle(angle)
    end,
    m_angle_diff = function(a, b)
        return Call_m_angle_diff(a, b)
    end,
    m_lerp_angle = function(a, b, t)
        return Call_m_lerp_angle(a, b, t)
    end,
    m_map = function(val, in_min, in_max, out_min, out_max)
        return Call_m_map(val, in_min, in_max, out_min, out_max)
    end,
    m_smoothstep = function(edge0, edge1, x)
        return Call_m_smoothstep(edge0, edge1, x)
    end,
    aspect_update = function(state, raw_slider, current_aspect, now, out_target, out_dirty)
        return Call_aspect_update(state, raw_slider, current_aspect, now, out_target, out_dirty)
    end,
    module_base = mod,
}]=]
c927["require/brain/test"] = [[local c362= require("require/brain/api/math/math")
local c363= require("require/brain/api/health/health")
local c364= require("require/brain/api/hwid/hwid")
local c365= require("require/brain/dll")


client.set_event_callback("paint_ui", function()
    local c366, c367= pcall(c362.add, 2, math.random(1, 100))
    if c366 then
        
    end

end)

local c368, c369= pcall(c364.get_hwid)
if c368 and c369 and c369 ~= "" then
    
else
    
end]]
c927["require/brain/api/clipboard/clipboard"] = [[]]
c927["require/brain/api/health/health"] = [[local c368= require("require/brain/dll")

if not c368 then
	error("sodiumdll exports unavailable")
end

return {
	pin_module = function()
		return c368.pin_module()
	end,
	release_module = function()
		return c368.release_module()
	end,
	module_base = c368.module_base,
}]]
c927["require/brain/api/hwid/hwid"] = [[local c371= require("ffi")
local c372= require("require/brain/dll")

if not c372 or not c372.get_hwid then
    error("sodiumdll hwid export missing")
end

return {
	get_hwid = function()
		local c373= c372.get_hwid()
		if not c373 or c373 == c371.NULL then
			return ""
		end
		return c371.string(c373)
	end,
}]]
c927["require/brain/api/ip/ip"] = [[
local c374= require("require/brain/dll")

if not c374 or not c374.get_public_ip then
	return error("sodiumdll ip export missing")
end

return {
	get_public_ip = function(c375,c376)
		return c374.get_public_ip(c375, c376)
	end,
}]]
c927["require/brain/api/math/math"] = [[local c377= require("require/brain/dll")

if not c377 or not c377.m_clamp then
	error("sodiumdll math exports missing")
end

return {
	add = function(c378,c379)
		return c377.add(c378, c379)
	end,
	get_value = function()
		return c377.get_value()
	end,
	m_clamp = function(c380,c381,c382)
		return c377.m_clamp(c380, c381, c382)
	end,
	m_clamp01 = function(c380)
		return c377.m_clamp01(c380)
	end,
	m_abs = function(c380)
		return c377.m_abs(c380)
	end,
	m_lerp = function(c378,c379,c383)
		return c377.m_lerp(c378, c379, c383)
	end,
	m_distance2d = function(c384,c385,c386,c387)
		return c377.m_distance2d(c384, c385, c386, c387)
	end,
	m_distance3d = function(c384,c385,c388,c386,c387,c389)
		return c377.m_distance3d(c384, c385, c388, c386, c387, c389)
	end,
	m_rad_to_deg = function(c390)
		return c377.m_rad_to_deg(c390)
	end,
	m_deg_to_rad = function(c391)
		return c377.m_deg_to_rad(c391)
	end,
	m_wrap_degrees = function(c392)
		return c377.m_wrap_degrees(c392)
	end,
	m_normalize_angle = function(c392)
		return c377.m_normalize_angle(c392)
	end,
	m_angle_diff = function(c378,c379)
		return c377.m_angle_diff(c378, c379)
	end,
	m_lerp_angle = function(c378,c379,c383)
		return c377.m_lerp_angle(c378, c379, c383)
	end,
	m_map = function(c380,c393,c394,c395,c396)
		return c377.m_map(c380, c393, c394, c395, c396)
	end,
	m_smoothstep = function(c397,c398,c399)
		return c377.m_smoothstep(c397, c398, c399)
	end,
}]]
c927["require/brain/api/vector/vector"] = [[local c380= require("ffi")
local c381= require("require/brain/dll")

if not c381 or not c381.vec_make or not c381.vec_add or not c381.vec_sub or not c381.vec_mul_scalar or
   not c381.vec_div_scalar or not c381.vec_unm or not c381.vec_length or not c381.vec_dot or
   not c381.vec_cross or not c381.vec_normalized or not c381.vec_distance or not c381.aspect_update then
    error("sodiumdll vector exports missing")
end

local c382= c380.typeof("struct Vec3")

local function c383(c384)
    if c380.istype(c382, c384) then
        return c384
    end
    local c385= (c384 and c384.x) or 0
    local c386= (c384 and c384.y) or 0
    local c387= (c384 and c384.z) or 0
    return c381.vec_make(c385, c386, c387)
end

return {
    Vec3 = c382,
    make = function(c385,c386,c387)
        return c381.vec_make(c385 or 0, c386 or 0, c387 or 0)
    end,
    add = function(c388,c389)
        return c381.vec_add(c383(c388), c383(c389))
    end,
    sub = function(c388,c389)
        return c381.vec_sub(c383(c388), c383(c389))
    end,
    mul_scalar = function(c384,c390)
        return c381.vec_mul_scalar(c383(c384), c390)
    end,
    div_scalar = function(c384,c390)
        return c381.vec_div_scalar(c383(c384), c390)
    end,
    unm = function(c384)
        return c381.vec_unm(c383(c384))
    end,
    length = function(c384)
        return c381.vec_length(c383(c384))
    end,
    dot = function(c388,c389)
        return c381.vec_dot(c383(c388), c383(c389))
    end,
    cross = function(c388,c389)
        return c381.vec_cross(c383(c388), c383(c389))
    end,
    normalized = function(c384)
        return c381.vec_normalized(c383(c384))
    end,
    distance = function(c388,c389)
        return c381.vec_distance(c383(c388), c383(c389))
    end,
    aspect_update = c381.aspect_update,
}]]
c927["require/brain/examples/boxes"] = [[local c383= require("ffi")
local c384= {


}


c384.GetModuleHandlePtr = 
    c383.cast(
        "void***", 
        c383.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B")) + 2
    )[0][0]

c384.GetProcAddressPtr = 
    c383.cast(
        "void***", 
        c383.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05")) + 2
    )[0][0]


c384.reinterpret_cast = function(c385,c386) 
    return function(...) 
        return c383.cast(c386, client.find_signature("engine.dll", "\xFF\xE1"))(c385, ...) 
    end
end


c384.fnGetModuleHandle = c384.reinterpret_cast(
    c384.GetModuleHandlePtr, 
    "void*(__thiscall*)(void*, const char*)"
)

c384.GetModuleHandle = function(c387)
    return c384.fnGetModuleHandle(c387)
end 


c384.fnGetProcAddress = c384.reinterpret_cast(
    c384.GetProcAddressPtr, 
    "void*(__thiscall*)(void*, void*, const char*)"
)

c384.GetProcAddress = function(c387,c388)
    local c385= c384.fnGetProcAddress(c387, c388)
    return c385
end 


c384.lib = {}
c384.lib.user32 = c384.GetModuleHandle("user32.dll")


c384.export = {}
c384.export.user32 = {}

c384.export.user32.MessageBoxPtr = c384.GetProcAddress(c384.lib.user32, "MessageBoxA")
c384.export.user32.MessageBox = c384.reinterpret_cast(
    c384.export.user32.MessageBoxPtr,
    "int(__thiscall*)(void*, void*, const char*, const char*, unsigned int)"
)


local c389= 0x00000000
local c390= 0x00000001
local c391= 0x00000004
local c392= 0x00000010
local c393= 0x00000020
local c394= 0x00000030
local c395= 0x00000040


local c396= 1
local c397= 2
local c398= 6
local c399= 7


local function c400(c401,c402,c403)
    c402 = c402 or "Gamesense"
    c403 = c403 or c389
    
    local c404= c384.export.user32.MessageBox(nil, c401, c402, c403)
    return c404
end


local function c405(c401,c402)
    return c400(c401, c402, c389 + c395)
end

local function c406(c401,c402)
    return c400(c401, c402, c389 + c394)
end

local function c407(c401,c402)
    return c400(c401, c402, c389 + c392)
end

local function c408(c401,c402)
    local c404= c400(c401, c402, c391 + c393)
    return c404 == c398
end
c405("test", "test")]]
c927["require/brain/features/aspectratio"] = [[local c386= require("ffi")
local c387= require("require/brain/dll")

if not c387 or not c387.aspect_update then
    error("sodiumdll aspect_update export missing")
end

return {
    aspect_update = function(c388,c389,c390,c391)
        local c392= c386.new("double[1]")
        local c393= c386.new("int[1]")

        c387.aspect_update(c388 or c386.NULL, c389, c390, c391, c392, c393)

        return c392[0], c393[0]
    end,
}]]
c927["require/features/aa/aa_collect"] = [[
local c389= entity
local c390= require('require/abc/menu_setup')
local c391= require('require/aa/player_condition')

local c392= {}
c392.last_side = 'left'

local function c393()
    local c394, c395= pcall(c391.get)
    if not c394 or not c395 then return nil end
    local c396= 'delay_' .. c395
    if not (c390 and c390.ui) then return nil end
    local c397= c390.ui[c396]
    if not c397 then return nil end
    local c398, c399= pcall(ui.get, c397)
    if not c398 then return nil end
    local c400= tonumber(c399)
    if c400 then return c400 end
    return c399
end

local function c401()
    local c394, c395= pcall(c391.get)
    if not c394 or not c395 then return nil end
    local c396= 'fifty_fifty_' .. c395
    if not (c390 and c390.ui) then return nil end
    local c397= c390.ui[c396]
    if not c397 then return nil end
    local c398, c399= pcall(ui.get, c397)
    if not c398 then return nil end
    local c400= tonumber(c399)
    if c400 then return c400 end
    return c399
end

local function c402()
    local c394, c395= pcall(c391.get)
    if not c394 or not c395 then return nil end
    local c396= 'body_yaw_mode_' .. c395
    if not (c390 and c390.ui) then return nil end
    local c397= c390.ui[c396]
    if not c397 then return nil end
    local c398, c399= pcall(ui.get, c397)
    if not c398 then return nil end
    local c400= tonumber(c399)
    if c400 then return c400 end
    return c399
end

local function c403(c404)
    if not (c389 and c389.get_prop and c404) then return c392.last_side end
    local c405= c389.get_prop(c404, 'm_flPoseParameter', 11)
    if c405 == nil then
        return c392.last_side
    end
    local c406= (c405 > 0.5) and 'right' or 'left'
    c392.last_side = c406
    return c406
end

local function c407()
    local c408= c393() + 1
    local c400= tonumber(c408) or 1
    if c400 < 1 then c400 = 1 end
    if c400 > 17 then c400 = 17 end

    local c409= globals.tickcount()
    if not c409 then return c392.last_side end

    local c410= math.floor(c409 / c400) % 2
    local c406= (c410 == 0) and 'left' or 'right'
    c392.last_side = c406
    return c406
end




local function c411()

    local c412= c401()

    if c412 then
        local c413= math.random(0, 1)
        local c406= (c413 == 0) and 'left' or 'right'
        c392.last_side = c406
        return c406
    end

    local c408= c393()
    local c400= tonumber(c408)

    if c402() ~= 'jitter' then
        return c403(c389.get_local_player())
    end

    if not c400 or c400 == 0 then
        local c404= c389.get_local_player()
        if not c404 or c404 == 0 then return c392.last_side end
        return c403(c404)
    else
        return c407()
    end
end





c392.resolve_side = c403
c392.resolve_local_side = c411
c392.get_delay_for_current_condition = c393

return c392]]
c927["require/features/aa/antiaim"] = [[local c392= require('require/features/aa/builder')
local c393= require('require/features/aa/defensive')

local c394= require('require/abc/callbacks')

local function c395()
    local c396= (globals.maxplayers and globals.maxplayers() or 64)
    local c397, c398, c399= entity.get_classname, entity.is_enemy, entity.is_alive
    if not (c397 and c398 and c399) then return 0 end
    local c400= 0
    for i=1,c396 do
        if c397(i) == 'CCSPlayer' and c398(i) and c399(i) then c400 = c400 + 1 end
    end
    return c400
end

c394.register('setup_command', function(c401)
    if c392 and c392.activate then
        c392.activate(c401)
    end

end, { alive_only = true, require_login = true })]]
c927["require/features/aa/antibrute"] = [[]]
c927["require/features/aa/builder"] = [[local c398= require('require/abc/menu_setup')
local c399= require('require/aa/player_condition')
local c400= require('require/features/aa/aa_collect')
local c401= require('require/help/math')
local c402= require('require/help/vector')
local c403= require('require/help/time')
local c404= require('require/help/string')

local c405= {}
client.set_event_callback('weapon_fire', function(c406)
  if not c406 or not c406.userid then return end
  local c407, c408= pcall(client.userid_to_entindex, c406.userid)
  if not c407 or not c408 or c408 == 0 then return end
  c405[c408] = c403.tickcount()
end)

local function c409(c410)
	if not c410 then return nil end

	local c411= {
		pitch = 'pitch_',
		yaw_base = 'yaw_base_',
		yaw = 'yaw_',
		body_yaw_base = 'body_yaw_base_',
		body_yaw_left = 'body_yaw_left_',
		body_yaw_right = 'body_yaw_right_',
		randomize_yaw = 'randomize_yaw_',
		yaw_jitter = 'yaw_jitter_',
		yaw_jitter_base = 'yaw_jitter_base_',
		body_yaw_mode = 'body_yaw_mode_',
		static_body_yaw = 'static_body_yaw_',
		body_yaw_value = 'body_yaw_value_',
		delay = 'delay_',
		fifty_fifty = 'fifty_fifty_',
		only_flip_on_0_choke = 'only_flip_on_0_choke_',
	}

	local c412= { condition = c410 }
	for name, prefix in pairs(c411) do
		local c413= prefix .. c410
		local c414= c398.ui and c398.ui[c413]
		if c414 then
			local c415, c416= pcall(ui.get, c414)
			if c415 then c412[name] = c416 else c412[name] = nil end
		else
			c412[name] = nil
		end
	end

	return c412
end




local function c417()
  local c415, c410= pcall(c399.get)
  if not c415 or not c410 then
    return nil
  end
  local c418= c409(c410)
  return c418 and c418.pitch or nil
end




local function c419()
  local c415, c410= pcall(c399.get)
  if not c415 or not c410 then
    return nil
  end
  local c418= c409(c410)
  local c420= c418 and c418.yaw_base or nil
  if c420 == nil then return nil end
  local c421= c404.lower(tostring(c420))
  if c421 == 'threat' then
    return 'local view'
  elseif c421 == 'distance' then
    return 'local view'
  elseif c421 == 'target' then
    return 'at targets'
  elseif c421 == 'view' then
    return 'local view'
  elseif c421 == 'smart' then
    return 'local view'
  else
    return tostring(c420)
  end
end




local function c422()
	local c415, c410= pcall(c399.get)
	if not c415 or not c410 then
		return nil
	end
	local c418= c409(c410)
	return c418 and c418.yaw or nil
end




local function c423()
    local c415, c410= pcall(c399.get)
    if not c415 or not c410 then
        return nil
    end
    local c418= c409(c410)
    return c418 and c418.yaw_jitter or nil
end




local function c424()
  local c415, c410= pcall(c399.get)
  if not c415 or not c410 then
    return nil
  end
  local c418= c409(c410)
  return c418 and c418.yaw_jitter_base or nil
end




local function c425()
  local c415, c410= pcall(c399.get)
  if not c415 or not c410 then return nil end
  local c418= c409(c410)
  if not c418 then return nil end
  local c426= c418.randomize_yaw
  if c426 == nil then return nil end
  local c427= tonumber(c426)
  if not c427 then return nil end
  if c427 < 0 then c427 = 0 end
  if c427 > 30 then c427 = 30 end
  return math.floor(c427)
end




local function c428()
    local c415, c410= pcall(c399.get)
    if not c415 or not c410 then
        return nil
    end
  local c418= c409(c410)
  local c429= c418 and c418.body_yaw_mode or nil
  if not c429 then return nil end
  local c430= c404.lower(tostring(c429))
  if c430 == 'jitter' then
    local c431= c400.get_delay_for_current_condition and c400.get_delay_for_current_condition() or nil
    local c427= tonumber(c431) or 0
    if c427 > 0 then
      return 'static'
    else
      return 'jitter'
    end
  end
  return c429
end




local function c432()
  local c415, c410= pcall(c399.get)
  if not c415 or not c410 then
    return nil
  end
  local c418= c409(c410)
  if not c418 then return nil end


  local c429= c418.body_yaw_mode
  if c429 ~= nil then c429 = c404.lower(tostring(c429)) end

  if c429 == 'jitter' then
    local c431= c400.get_delay_for_current_condition and c400.get_delay_for_current_condition() or nil
    local c433= tonumber(c431) or 0
    if c433 > 0 then
      local c434= c400.resolve_local_side and c400.resolve_local_side() or nil
      if c434 == 'right' then
        return -58
      else
        return 58
      end
    end

    local c420= c418.body_yaw_value
    local c427= tonumber(c420) or nil
    if c427 == 1 then
      return -180
    elseif c427 == 2 then
      return 0
    elseif c427 == 3 then
      return 180
    end
    return nil
  elseif c429 == 'static' then
    if c418.static_body_yaw ~= nil then
      local c435= tonumber(c418.static_body_yaw)
      if c435 then return c435 end
    end
    local c420= c418.body_yaw_value
    local c427= tonumber(c420) or nil
    if c427 == 1 then
      return -180
    elseif c427 == 2 then
      return 0
    elseif c427 == 3 then
      return 180
    end
    return nil
  else
    return 0
  end
end




local function c436()
  local c415, c410= pcall(c399.get)
  if not c415 or not c410 then
    return nil
  end
  local c418= c409(c410)
  return c418 and c418.body_yaw_base or nil
end




local function c437()
    local c415, c410= pcall(c399.get)
    if not c415 or not c410 then
        return nil
    end
    local c418= c409(c410)
    return c418 and c418.body_yaw_left or nil
end




local function c438()
    local c415, c410= pcall(c399.get)
    if not c415 or not c410 then
        return nil
    end
    local c418= c409(c410)
    return c418 and c418.body_yaw_right or nil
end




local function c439()
    local c415, c410= pcall(c399.get)
    if not c415 or not c410 then
        return nil
    end
    local c418= c409(c410)
    if not c418 then return nil end
    local c426= c418.only_flip_on_0_choke
    if c426 == nil then return nil end
    return not not c426
end




local function c440()
  local c415, c410= pcall(c399.get)
  if not c415 or not c410 then
    return nil
  end
  local c413= 'delay_' .. c410
  if not (c398 and c398.ui) then return nil end
  local c414= c398.ui[c413]
  if not c414 then return nil end
  local c441, c416= pcall(ui.get, c414)
  if c441 then return c416 end
  return nil
end




local function c442()
  local c415, c410= pcall(c399.get)
  if not c415 or not c410 then return nil end
  local c418= c409(c410)
  if not c418 then return nil end
  local c426= c418.fifty_fifty
  if c426 == nil then return nil end
  return not not c426
end





local function c443(c429)
  local c430= c404.lower(tostring(c429 or 'threat'))

  local c444= nil
  if c430 == 'distance' then
    local c445, c446= pcall(entity.get_players, true)
    if not c445 or not c446 or #c446 == 0 then return nil end
    local c447= entity.get_local_player()
    if not c447 then return nil end
    local c448, c449, c450, c451= pcall(entity.get_origin, c447)
    if not c448 or not c449 then return nil end
    local c452= nil
    local c453= nil
    for _, c408 in ipairs(c446) do
      if c408 and entity.is_alive and entity.is_alive(c408) and entity.is_enemy and entity.is_enemy(c408) then
        local c454, c455, c456, c457= pcall(entity.get_origin, c408)
        if c454 and c455 then
          local c458= c401.distance2d(c449, c450, c455, c456)
          if not c453 or c458 < c453 then
            c453 = c458
            c452 = c408
          end
        end
      end
    end
    c444 = c452
    elseif c430 == 'smart' then
      local c445, c446= pcall(entity.get_players, true)
      if c445 and c446 and #c446 > 0 then
        local c447= entity.get_local_player()
        if c447 then
          local c448, c449, c450, c451= pcall(entity.get_origin, c447)
          if c448 and c449 then
            local c452= nil
            local c453= nil
            for _, c408 in ipairs(c446) do
              if c408 and entity.is_alive and entity.is_alive(c408) and entity.is_enemy and entity.is_enemy(c408) then
                local c454, c455, c456, c457= pcall(entity.get_origin, c408)
                if c454 and c455 then
                  local c459= c405[c408]
                  if c459 and c403.within_ticks_window(c459, 10) then goto continue_smart end
                  local c460, c461= pcall(entity.get_player_weapon, c408)
                  if c460 and c461 and c461 ~= 0 then
                    local c462, c463= pcall(entity.get_classname, c461)
                    local c464= c404.lower(c462 and c463 and tostring(c463) or '')
                    if c464:find('knife') or c464:find('grenade') or c464:find('taser') or c464:find('zeus') then goto continue_smart end
                  end
                  do
                    local c458= c401.distance2d(c449, c450, c455, c456)
                    if not c453 or c458 < c453 then
                      c453 = c458
                      c452 = c408
                    end
                  end
                  ::continue_smart::
                end
              end
            end
            c444 = c452
          end
        end
      end
      if not c444 then
        local c465, c466= pcall(client.current_threat)
        if c465 and c466 then c444 = c466 end
      end
    else
      local c465, c466= pcall(client.current_threat)
      if c465 and c466 then c444 = c466 end
    end

  if not c444 then return nil end
  if not (entity.is_alive and entity.is_enemy and entity.is_alive(c444) and entity.is_enemy(c444)) then
    return nil
  end

  local c447= entity.get_local_player()
  if not c447 then return nil end

  local c467, c449, c450, c451= pcall(entity.get_origin, c447)
  local c468, c455, c456, c457= pcall(entity.get_origin, c444)
  if not c467 or not c468 or not c449 or not c455 then return nil end

  local c469= c455 - c449
  local c470= c456 - c450
  local c471= math.atan2(c470, c469)
  local c472= c401.rad_to_deg(c471)

  local c473, c474, c475= pcall(client.camera_angles)
  local c476= c473 and c475 or 0

  local c477= c401.normalize_angle(c472 - c476)
  return c401 and c401.round and c401.round(c477) or math.floor(c477 + 0.5)

end




local c478= {}
local c479= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local c480= {ui.reference(item[1], item[2], item[3])}
    c478[i] = c480
    for _, ref in ipairs(c480) do
        c479[ref] = true
    end
end





local function c481(c482)
  if weaponn ~= nil and entity.get_classname(weaponn) == "CC4" then
    if c482.in_attack == 1 then
        c482.in_attack = 0 
        c482.in_use = 1
    end
  else
    if c482.chokedcommands == 0 then
        c482.in_use = 0
    end
  end

end





local function c483(c482)

    local c484= c482.chokedcommands
    
    if c439() then
        if c484 > 0 then
            return
        end
    end

    local c434= c400.resolve_local_side()

    
    
    
    ui.set(c478[2][1], tostring(c417()))

    
    
    
    ui.set(c478[3][1], tostring(c419()))

    
    
    
    local c485= c422()
    if c485 == "3way" then
      c485 = '180'
    elseif c485 == "ideal" then
      c485 = '180'
    end
    ui.set(c478[4][1], c485)

    
    
    
    ui.set(c478[5][1], tostring(c423()))

    
    
    
    ui.set(c478[5][2], tostring(c424()))

    
    
    
    ui.set(c478[6][1], tostring(c428()))

    
    
    
    ui.set(c478[6][2], tostring(c432()))

    
    
    
    local c486= tonumber(c436()) or 0
    local c487= 0
    if ui.get(c478[4][1]) == '180' then
      if c434 == 'right' then
        c487 = tonumber(c437()) or 0
      elseif c434 == 'left' then
        c487 = tonumber(c438()) or 0
      end
    end
    local c488= c486 + c487
    local c489= tonumber(c425()) or 0
    if c489 > 0 then
      local c490= math.abs(c488) * (c489 / 100)
      local c491= (c401.random_int(-1000, 1000) / 1000)
      local c492= c491 * c490
      c488 = c488 + c492
    end

    do
      local c493, c410= pcall(c399.get)
      if c493 and c410 then
        local c418= c409(c410)
        if c418 then
          local c494= c404.lower(tostring(c418.yaw_base or ''))
          if c494 == 'threat' or c494 == 'distance' then
            local c495= c443(c494)
            if c495 then
              c488 = c488 + tonumber(c495) or c488
            end
          end
        end
      end
    end

    local c496= c401.normalize_angle(c488)
    ui.set(c478[4][2], c401.round(c496))

    
    
    
    c481(c482)

end


return {
  gather = c409,
  activate = c483,
  print_current = c483,
}]]
c927["require/features/aa/defensive"] = [[local c401= {}
c401.active = nil
c401.activate = nil
local c402= require('require/help/time')
local c403= require('require/abc/menu_setup')
local c404= require('require/features/aa/defensive_presets')
local c405= require('require/aa/player_condition')
local c406= require('require/abc/screen_logger')
local c407, c408= pcall(require, 'require/abc/callbacks')




local c409= {}
local c410= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'RAGE', 'Aimbot', 'Double tap' },
    { 'RAGE', 'Other', 'Duck peek assist' },

}) do
    local c411= {ui.reference(item[1], item[2], item[3])}
    c409[i] = c411
    for _, ref in ipairs(c411) do
        c410[ref] = true
    end
end


local c412= {
    cond = nil,
    idx = nil,
    preset = nil,
    selected_tick = 0,
}
local c413= false
local c414= 0





local c415= {
    last = false,
    pending_until = nil,
}
local function c416()
    local c417, c418= pcall(ui.get, c409[10][2])
    local c419= c417 and not not c418 or false
    local c420= c402.tickcount() or (globals and globals.tickcount and globals.tickcount()) or 0
    if c419 and not c415.last then
        c415.pending_until = c420 + 32
    end
    if not c419 then
        c415.pending_until = nil
    end
    c415.last = c419
    if c415.pending_until then
        return c420 >= c415.pending_until
    end
    return c419
end

local function c421()
    local c411= c409[11]
    if not c411 or not c411[1] then
        return false
    end
    local c417, c418= pcall(ui.get, c411[1])
    return c417 and not not c418 or false
end

local function c422()
  local c423= entity.get_local_player()
  if not c423 or not entity.is_alive(c423) then
    return false
  end
  local c424= entity.get_player_weapon(c423)
  if not c424 then
    return false
  end
  local c425= entity.get_classname(c424)
  return c425 == "CKnife"
end




local function c426()
    if not c403 or type(c403) ~= 'table' or not c403.ui then
        return false
    end
    local c427= c403.ui.fakelag_defensive
    if not c427 then
        return false
    end
    local c417, c418= pcall(ui.get, c427)
    return c417 and not not c418 or false
end

local function c428()
    if not c403 or type(c403) ~= 'table' or not c403.ui then
        return false
    end
    local c427= c403.ui.fakelag_force
    if not c427 then
        return false
    end
    local c417, c418= pcall(ui.get, c427)
    return c417 and not not c418 or false
end

local function c429(c430)

    


    local c420= (globals and globals.tickcount and globals.tickcount()) or c402.tickcount() or 0
    c414 = c420
end




local function c431(c432)

    c432 = c432 or 20
    local c433= entity.get_local_player()
    if not c433 then return false end
    local c434= entity.get_prop(c433, "m_flSimulationTime")
    local c435= 1 / globals.tickinterval()
    if not c434 or c435 == 0 then return false end
    local c436= math.floor(c434 * c435 + 0.5)
    local c437= globals.tickcount()
    nigga = c437 >= c436 and c437 <= c436 + c432

    return c437 >= c436 and c437 <= c436 + c432

end







local function c438(c430)
    
    
    
    local c439= false
    local c440= c426()
    local c441= c416()
    local c442= c421()
    local c443= c422()
    local c444= c431()
    

    c439 = c440 and c441 and not c442 and not c443 
    c401.active = c439


    local c420= (globals and globals.tickcount and globals.tickcount()) or c402.tickcount() or 0
    local c445= false
    if c420 and (c414 == nil or c420 - c414 >= 64) then
        c445 = true
        c429(c430)
    end



    
    
    

    
    
    
    if c439 then
        local c446= c405.get() or 'global'
        if (not c413) or (c412.cond ~= c446) or (not c412.preset) then
            local c447, c448= c404.get_random_for_condition(c446)
            if c447 and c448 then
                c412.cond = c446
                c412.idx = c447
                c412.preset = c448
                c412.selected_tick = globals.tickcount()
            else
                c412.cond = c446
                c412.idx = nil
                c412.preset = nil
                c412.selected_tick = 0
            end
        end

        if not c445 then
            if c412.preset and type(c412.preset.apply) == 'function' then
                c412.preset.apply(c412, c430)
            end
        end
    else
        if c413 then
            c412.cond = nil
            c412.idx = nil
            c412.preset = nil
            c412.selected_tick = 0
        end
    end

    c413 = c439

end


c401.activate = c438
c401.reset = c429


c408.register('setup_command', function(c430)
    c438(c430)
end, { alive_only = true, require_login = true })


return c401]]
c927["require/features/aa/defensive_presets"] = [[local c404= require('require/aa/player_condition')
local c405= require('require/help/time')
local c406= require('require/abc/screen_logger')



local c407= {}
local c408= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },

}) do
    local c409= {ui.reference(item[1], item[2], item[3])}
    c407[i] = c409
    for _, ref in ipairs(c409) do
        c408[ref] = true
    end
end


local c410= {}

local function c411(c412,c413,c414) if c412 < c413 then return c413 end if c412 > c414 then return c414 end return c412 end

local function c415(c416,c417,c418)
    local c409= c407[c416]
    if not c409 or not c409[c417] then return false end
    pcall(ui.set, c409[c417], c418)
    return true
end



local c419, c420= pcall(require, "require/abc/menu_setup")



local function c421(c422)

    local c423, c420= pcall(require, "require/abc/menu_setup")
    if not c423 or not c420 or not c420.ui then return end
    local c424, c425= pcall(ui.get, c420.ui.fakelag_fakedef)

    
    if c425 then 
        c422.force_defensive = false
    else
        c422.force_defensive = true
    end

end

do
    local c426, c427= pcall(require, "require/abc/callbacks")

    ticks = ticks or {}
    ticks.tickbase_max = ticks.tickbase_max or nil
    ticks.tickbase_diff = ticks.tickbase_diff or nil
    ticks.current_cmd = ticks.current_cmd or nil

    ticks.runc = function(c422)
        if not c422 then return end
        ticks.current_cmd = c422.command_number
    end

    ticks.tickcalc = function(c422)
        if not c422 then return end
        if c422.command_number == ticks.current_cmd then
            ticks.current_cmd = nil
            local c428= entity.get_local_player()
            if not c428 then return end
            local c429= entity.get_prop(c428, "m_nTickBase")
            if c429 then
                if ticks.tickbase_max ~= nil then
                    ticks.tickbase_diff = c429 - ticks.tickbase_max
                end
                ticks.tickbase_max = math.max(c429, ticks.tickbase_max or 0)
            end
        end
    end

    if c426 and c427 and c427.callback then
        c427.callback('run_command', ticks.runc, { alive_only = true, require_login = true })
        c427.callback('predict_command', ticks.tickcalc, { alive_only = true, require_login = true })
    end
end

client.set_event_callback("level_init", function()
    ticks.tickbase_max = nil
    ticks.tickbase_diff = nil
end)


local function c430(c431)
    local c428= entity.get_local_player()
    if not c428 then return false end

    local c432= entity.get_prop(c428, 'm_nTickBase')
    if not c432 then return false end

    local c433= ticks and ticks.tickbase_max or 0

    if math.abs(c432 - c433) > 64 then
        c433 = 0
    end

    local c434= 0

    if c432 > c433 then
        c433 = c432
    elseif c433 > c432 then
        c434 = math.min(14, math.max(0, c433 - c432 - 1))
    end

    c431 = c431 or 7

    return c434 > c431
end




local c435= {



    stand = {

        [1] = {
            name = "jitter -90/90",
            apply = function(c436,c422)

                local c437= globals.tickcount()
                local c438= math.floor(c437 / 2) % 2

                local function c439()
                    local c437= globals.tickcount()

                    if not c436._next_change_at then
                        c436._next_change_at = c437 + math.random(24, 64)
                        c436._mode = math.random(1, 3)
                        c436._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        c436._spin_speed = math.random(45, 55)
                        c436._spin_angle = (c438 == 0) and -90 or 90
                    end

                    if c437 >= (c436._next_change_at or 0) then
                        c436._next_change_at = c437 + math.random(24, 64)
                        c436._mode = math.random(1, 3)
                        c436._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        c436._spin_speed = math.random(45, 55)
                        c436._spin_angle = (c438 == 0) and -90 or 90

                        if c436._mode == 2 then
                            c436._spin_until = c437 + math.random(12, 24)
                        elseif c436._mode == 3 then
                            local c440= math.ceil(360 / c436._spin_speed)
                            c436._spin_until = c437 + c440
                            c436._rest_until = c437 + c440 + math.random(24, 64)
                            c436._spin_done = false
                        else
                            c436._spin_until = nil
                            c436._rest_until = nil
                        end
                    end

                    if c436._mode == 1 then
                        local c441= (c438 == 0) and -120 or 120
                        local c442= 0
                        return c441, c442

                    elseif c436._mode == 2 then
                        if c436._spin_until and c437 <= c436._spin_until then
                            c436._spin_angle = (c436._spin_angle or ((c438 == 0) and -90 or 90)) + (c436._spin_dir * (c436._spin_speed or 50))
                            if c436._spin_angle > 180 then c436._spin_angle = c436._spin_angle - 360 end
                            if c436._spin_angle < -180 then c436._spin_angle = c436._spin_angle + 360 end
                            return c436._spin_angle, 0
                        end
                        local c441= (c438 == 0) and -90 or 90
                        return c441, 0
                    else
                        if c436._spin_until and c437 <= c436._spin_until then
                            c436._spin_angle = (c436._spin_angle or ((c438 == 0) and -90 or 90)) + (c436._spin_dir * (c436._spin_speed or 50))
                            if c436._spin_angle > 180 then c436._spin_angle = c436._spin_angle - 360 end
                            if c436._spin_angle < -180 then c436._spin_angle = c436._spin_angle + 360 end
                            return c436._spin_angle, -89
                        end

                        if c436._rest_until and c437 <= c436._rest_until then
                            return nil, nil
                        end

                        local c441= (c438 == 0) and -90 or 90
                        return c441, 0
                    end
                end

                local c441, c442= c439()

                if c441 ~= nil and c422.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (c430(6))) then
                    c421(c422)
                    c415(4, 2, c441)
                    c415(2, 1, 'Custom')
                    c415(2, 2, c442)
                    c415(5, 1, 'off')
                    c415(6, 1, 'off')
                end

            end
        }
    },

    move = {

        [1] = {
            name = "jitter -90/90",
            apply = function(c436,c422)


                local c437= globals.tickcount()
                local c438= math.floor(c437 / 2) % 2
                local c441= (c438 == 0) and -135 or 135
                c436._side = c441
                c436._pitch = -55


                if c422.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (c430(3))) then
                    c421(c422)
                    c415(4, 2, c436._side)
                    c415(2, 1, 'Custom')
                    c415(2, 2, c436._pitch)
                    c415(5, 1, 'off')
                    c415(6, 1, 'off')
                    c415(3, 1, 'at targets')
                end
            end
        }
    },

    walk = {

        [1] = {
            name = "jitter -90/90",
            apply = function(c436,c422)

                local c437= globals.tickcount()
                local c438= math.floor(c437 / 2) % 2
                local c443= (c438 == 0) and -130 or 130

                
                local c441, c442
                if (c437 % 8) == 0 then
                    c441 = 0
                    c442 = 89
                else
                    c441 = c443
                    c442 = -65
                end

                c436._side = c441
                c436._pitch = c442





                if c422.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (c430(3))) then
                    c421(c422)
                    c415(4, 2, c436._side)
                    c415(2, 1, 'Custom')
                    c415(2, 2, c436._pitch)
                    c415(5, 1, 'off')
                    c415(6, 1, 'off')
                    c415(3, 1, 'at targets')
                end
            end
        },
    },

    duck = {
        
        [1] = {
            name = "jitter -90/90",
            apply = function(c436,c422)

                local c437= globals.tickcount()
                local c438= math.floor(c437 / 2) % 2

                local function c439()
                    local c437= globals.tickcount()

                    
                    if not c436._next_change_at then
                        c436._next_change_at = c437 + math.random(24, 64)
                        c436._mode = 1 
                    end

                    if c437 >= (c436._next_change_at or 0) then
                        c436._next_change_at = c437 + math.random(24, 64)
                        c436._mode = math.random(1, 5)
                        
                        c436._spin_dir = nil
                        c436._spin_speed = nil
                        c436._spin_angle = nil
                        c436._jitter_yaw = nil
                        c436._jitter_pitch = nil
                        c436._rand_yaw = nil
                        c436._rand_pitch = nil
                        c436._rand_until = nil
                        c436._phase_tick = c437
                    end

                    
                    
                    
                    
                    
                    

                    if c436._mode == 1 then
                        if not c436._spin_dir then
                            c436._spin_dir = (math.random(0,1) == 0) and -1 or 1
                            c436._spin_speed = 35
                            c436._spin_angle = (c438 == 0) and -90 or 90
                        end

                        if c437 % 10 == 0 then
                            return nil, nil
                        end

                        c436._spin_angle = (c436._spin_angle or ((c438 == 0) and -90 or 90)) + (c436._spin_dir * (c436._spin_speed or 45))
                        if c436._spin_angle > 180 then c436._spin_angle = c436._spin_angle - 360 end
                        if c436._spin_angle < -180 then c436._spin_angle = c436._spin_angle + 360 end
                        return c436._spin_angle, 0

                    elseif c436._mode == 2 then
                        local c444= math.random(-100, 100)
                        return c444, -50

                    elseif c436._mode == 3 then
                        local c444= math.random(-180, 180)
                        local c442= math.random(-89, 89)
                        return c444, c442

                    elseif c436._mode == 4 then
                        if not c436._rand_until then
                            c436._rand_yaw = math.random(-180, 180)
                            c436._rand_pitch = math.random(-89, 89)
                            c436._rand_until = c437 + 2
                            c436._rand_rest = c437 + 3
                        end
                        if c437 <= c436._rand_until then
                            return c436._rand_yaw, c436._rand_pitch
                        elseif c437 <= c436._rand_rest then
                            return nil, nil
                        else
                            c436._rand_until = nil
                            c436._rand_rest = nil
                            return nil, nil
                        end

                    else
                        
                        if not c436._ramp then
                            c436._ramp = {}
                            c436._ramp.yaw = math.random(-180, 180)
                            c436._ramp.pitch = 89
                            c436._ramp.dir = -1 
                        end

                        
                        if not c436._ramp.step then c436._ramp.step = 30 end
                        if c436._ramp.pitch == 89 then
                            
                            c436._ramp.pitch = c436._ramp.pitch + (c436._ramp.dir * c436._ramp.step)
                            if c436._ramp.pitch < -89 then c436._ramp.pitch = -89 end
                            return c436._ramp.yaw, 89
                        else
                            
                            local c445= c436._ramp.pitch
                            c436._ramp.pitch = c436._ramp.pitch + (c436._ramp.dir * c436._ramp.step)
                            if c436._ramp.pitch <= -89 then
                                
                                c436._ramp = nil
                            end
                            return c436._ramp and c436._ramp.yaw or math.random(-180,180), c445
                        end
                    end
                end

                local c441, c442= c439()

                if c441 ~= nil and c422.chokedcommands == 1 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (c430(8))) then
                    c421(c422)
                    c415(4, 2, c441)
                    c415(2, 1, 'Custom')
                    c415(2, 2, c442)
                    c415(5, 1, 'off')
                    c415(6, 1, 'off')
                    c415(3, 1, 'at targets')
                end
            end
        }
    },

    ["duck+"] = {
        
        [1] = {

            name = "jitter -90/90",
            apply = function(c436,c422)


                local c437= globals.tickcount()
                local c438= math.floor(c437 / 2) % 2
                local c441= (c438 == 0) and -90 or 90
                c436._side = 180
                c436._pitch = -76


                if c422.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (c430(1))) then
                    c421(c422)
                    c415(4, 2, c436._side)
                    c415(2, 1, 'Custom')
                    c415(2, 2, c436._pitch)
                    c415(5, 1, 'off')
                    c415(6, 1, 'off')
                    c415(3, 1, 'at targets')
                end

            end
        }
    },

    ['jump'] = {
        [1] = {
            name = "jitter -90/90",
            apply = function(c436,c422)

                local c437= globals.tickcount()
                
                if not c436._spin_choice_at then
                    c436._spin_choice_at = c437 + 64
                    c436._spin_dir = (math.random(0,1) == 0) and -1 or 1
                    c436._spin_angle = 0
                end

                if c437 >= (c436._spin_choice_at or 0) then
                    c436._spin_choice_at = c437 + 64
                    c436._spin_dir = (math.random(0,1) == 0) and -1 or 1
                end

                
                if (c437 % 10) == 0 then
                    return
                end

                
                c436._spin_angle = (c436._spin_angle or 0) + (c436._spin_dir * 35)
                if c436._spin_angle > 180 then c436._spin_angle = c436._spin_angle - 360 end
                if c436._spin_angle < -180 then c436._spin_angle = c436._spin_angle + 360 end

                local c441= c436._spin_angle
                c436._side = c441
                c436._pitch = 0

                if c422.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (c430(8))) then
                    c421(c422)
                    c415(4, 2, c436._side)
                    c415(2, 1, 'Custom')
                    c415(2, 2, c436._pitch)
                    c415(5, 1, 'off')
                    c415(6, 1, 'off')
                    c415(3, 1, 'at targets')
                end
            end
        },

    },

    ['jump+'] = {
        [0] = {
            name = "jitter -90/90",
            apply = function(c436,c422)

                local c437= globals.tickcount()
                local c438= math.floor(c437 / 2) % 2
                local c441= (c438 == 0) and -90 or 90
                c436._side = c441
                c436._pitch = 0

                if c422.chokedcommands > 0 and (not (c430(6))) then
                    c421(c422)
                    c415(4, 2, c436._side)
                    c415(2, 1, 'Custom')
                    c415(2, 2, c436._pitch)
                    c415(5, 1, 'off')
                    c415(6, 1, 'off')
                    c415(3, 1, 'at targets')
                end
            end
        },
    },

    
    global = {
        [0] = {
            name = "back",
            apply = function(c436,c422)

            end
        }
    }


}





local function c446(c447)
    local c448= {}
    for k, _ in pairs(c447) do
        if type(k) == 'number' then table.insert(c448, k) end
    end
    table.sort(c448)
    return c448
end

function c410.get_presets_for_condition(c449)
    c449 = c449 or c404.get() or 'global'
    return c435[c449] or c435['global'] or {}
end

function c410.get_preset_by_index(c449,c450)
    local c451= c410.get_presets_for_condition(c449)
    return c451[c450]
end

function c410.get_random_for_condition(c449)
    local c451= c410.get_presets_for_condition(c449)
    local c448= c446(c451)
    if #c448 == 0 then return nil, nil end
    local c452= c448[math.random(1, #c448)]
    return c452, c451[c452]
end

function c410.get_random_for_current_condition()
    return c410.get_random_for_condition(c404.get())
end


function c410.get_next_for_condition(c449,c453)
    local c451= c410.get_presets_for_condition(c449)
    local c448= c446(c451)
    if #c448 == 0 then return nil, nil end
    
    local c454= 1
    for i, k in ipairs(c448) do
        if k == c453 then c454 = i; break end
    end
    local c455= (c454 % #c448) + 1
    local c456= c448[c455]
    return c456, c451[c456]
end


function c410.available_conditions()
    local c457= {}
    for k, _ in pairs(c435) do table.insert(c457, k) end
    table.sort(c457)
    return c457
end

c410._presets = c435

return c410]]
c927["require/features/misc/analyze"] = [[local function c407(c408)
	while c408 > 180 do c408 = c408 - 360 end
	while c408 < -180 do c408 = c408 + 360 end
	return c408
end

local c409= _G.player_labels or {}
_G.player_labels = c409

local c410= function(ent)
	return (_G.player_history and _G.player_history[ent]) or nil
end

local c411, c412= pcall(require, "require/features/misc/resolver_dispatcher")
local c413= require('require/abc/callbacks')

local function c414(c415)
	
	local c416= c410(c415)
	if not c416 or #c416 < 2 then
		c409[c415] = nil
		return
	end

	
	
	local c417, c418= pcall(function() return (globals and globals.curtime and globals.curtime()) or nil end)
	if c416[1] and c416[1].last_shot_time and c417 and c418 then
		local c419= c418 - c416[1].last_shot_time
		if c419 >= 0 and c419 <= 0.25 then
			c409[c415] = "ON SHOT"
			return
		end
	end

	
	local c420= {}
	for i = 1, #c416 - 1 do
		local c421= c416[i] and c416[i].yaw
		local c422= c416[i+1] and c416[i+1].yaw
		if c421 ~= nil and c422 ~= nil then
			c420[#c420 + 1] = c407(c421 - c422)
		end
	end

	if #c420 == 0 then
		c409[c415] = nil
		return
	end

	
	local c423, c424= 0, 0
	local c425, c426= -1e9, 1e9
	for _, v in ipairs(c420) do
		c423 = c423 + v
		c424 = c424 + math.abs(v)
		if v > c425 then c425 = v end
		if v < c426 then c426 = v end
	end
	local c427= c423 / #c420
	local c428= c424 / #c420

	local c429= 0
	for _, v in ipairs(c420) do
		c429 = c429 + (v - c427) ^ 2
	end
	local c430= math.sqrt(c429 / #c420)

	local c431= 0
	for i = 2, #c420 do
		if (c420[i] > 0 and c420[i-1] < 0) or (c420[i] < 0 and c420[i-1] > 0) then
			c431 = c431 + 1
		end
	end

	
	local c432= c420[1]
	local c433= c425 - c426

	
	local c434= {}
	for i, v in ipairs(c420) do c434[i] = v end
	table.sort(c434)
	local c435= c434[math.ceil(#c434 / 2)]

	
	local c436= {
		deltas = c420,
		mean = c427,
		meanabs = c428,
		std = c430,
		sign_changes = c431,
		max_delta = c425,
		min_delta = c426,
		total_range = c433,
		median = c435,
		last_delta = c432,
		samples = #c420,
		last_yaw = c416[1] and c416[1].yaw,
		oldest_yaw = c416[#c416] and c416[#c416].yaw,
		hist = c416
	}

	
	do
		local c437, c438= 0, 0
		local c439, c440, c441
		for i=1,math.min(#c416, 20) do
			local c442= c416[i]
			if c442 then
				if c442.moveSpeedAnim then c437 = c437 + (c442.moveSpeedAnim or 0); c438 = c438 + 1 end
				if c442.speed2d then c437 = c437 + (c442.speed2d or 0); c438 = c438 + 1 end
				if not c439 and c442.feetYaw then c439 = c442.feetYaw end
				if not c440 and c442.goalFeetYaw then c440 = c442.goalFeetYaw end
				if not c441 and c442.moveSpeedAnim then c441 = c442.moveSpeedAnim end
			end
		end
		local c443= (c438 > 0) and (c437 / c438) or 0
		c436.movement = c443 >= 1.2
		c436.avg_speed = c443
		c436.feet_yaw = c439
		c436.goal_feet_yaw = c440
		c436.move_anim = c441
	end

	local c444= nil
	if detect_static and detect_static(c436, c415) then c444 = "STATIC" end
	if detect_spin and detect_spin(c436, c415) then c444 = "SPIN" end
	if detect_jitter_minus and detect_jitter_minus(c436, c415) then c444 = "JITTER-" end
	if detect_jitter and detect_jitter(c436, c415) then c444 = "JITTER" end
	if detect_jitter_plus and detect_jitter_plus(c436, c415) then c444 = "JITTER+" end
	if detect_sway and detect_sway(c436, c415) then c444 = "SWAY" end
	if detect_skitter and detect_skitter(c436, c415) then c444 = "SKITTER" end
	if detect_defensive and detect_defensive(c436, c415) then c444 = "DEFENSIVE" end
	if detect_random and detect_random(c436, c415) then c444 = "RANDOM" end
	if detect_delayed and detect_delayed(c436, c415) then c444 = "DELAYED" end

	if not c444 then c444 = "?" end
	pcall(function()
		local c445= nil
		pcall(function() c445 = entity.get_player_name(c415) end)
		local c446= "nil"
		if c416 and c416[1] and c416[1].last_shot_time then
			c446 = string.format("%.3f", c416[1].last_shot_time)
		end
		local c447= c436.feet_yaw and string.format("%.2f", c436.feet_yaw) or "nil"
		local c448= c436.goal_feet_yaw and string.format("%.2f", c436.goal_feet_yaw) or "nil"

	end)

	c409[c415] = c444

	
	if c411 and c412 and type(c412.process_entity) == "function" then
		pcall(function() c412.process_entity(c415, c444, c436) end)
	end
end



function c449(c436,c415)
	local c428= c436.meanabs or 0
	local c430= c436.std or 0
	local c450= c436.samples or 0
	local c420= c436.deltas or {}
	local c451= 1.0
	local c452= 1.5
	local c453= 2.5

	if c428 <= c451 and c430 <= c452 then
		return true
	end

	local c454= 0
	local c455= nil
	for i, d in ipairs(c420) do
		if math.abs(d) >= c453 then
			c454 = c454 + 1
			if not c455 then
				c455 = i
			end
		end
	end

	if c454 == 0 then
		return true
	end

	if c454 == 1 and c455 and c455 > 20 then
		return true
	end

	return false
end

function c456(c436,c415)
	local c428= c436.meanabs or 0
	local c430= c436.std or 0
	local c450= c436.samples or 0
	local c431= c436.sign_changes or 0
	local c457= math.max(math.abs(c436.max_delta or 0), math.abs(c436.min_delta or 0))

	local c458= false

	if c450 >= 4 then
		local c459= 5.0
		local c460= 12.0
		local c461= 22.0
		local c462= 40.0

		if c428 >= c459 and c428 < c460 and c430 <= c461 and c457 <= c462 then
			c458 = true
		end
	end

	return c458
end

function c463(c436,c415)
	local c428= c436.meanabs or 0
	local c430= c436.std or 0
	local c450= c436.samples or 0
	local c431= c436.sign_changes or 0
	local c457= math.max(math.abs(c436.max_delta or 0), math.abs(c436.min_delta or 0))

	local c458= false

	if c450 >= 4 then
		local c459= (c436.movement and 8.0) or 6.0
		local c460= 24.0
		local c464= 34.0
		local c465= 28.0
		local c466= 100.0

		if c428 >= c459 and c428 < c460 and c430 <= c464 then
			if c431 >= 2 or c457 <= c466 or (c428 < 12.0 and c430 <= c465) then
				c458 = true
			end
		end
	end

	return c458
end

function c467(c436,c415)
	local c428= c436.meanabs or 0
	local c430= c436.std or 0
	local c450= c436.samples or 0
	local c431= c436.sign_changes or 0
	local c457= math.max(math.abs(c436.max_delta or 0), math.abs(c436.min_delta or 0))

	local c458= false

	if c450 >= 4 then
		local c459= 18.0
		local c468= 22.0
		local c469= 26.0
		local c470= 70.0

		if c428 >= c459 and (c430 >= c469 or c457 >= c470) then
			if c428 >= c468 or c457 >= c470 or c430 >= (c469 + 8) then
				c458 = true
			end
		end
	end
	
	return c458
end

function c471(c436,c415)
	local c428= c436.meanabs or 0
	local c430= c436.std or 0
	local c450= c436.samples or 0
	local c431= c436.sign_changes or 0
	local c433= c436.total_range or 0
	local c457= math.max(math.abs(c436.max_delta or 0), math.abs(c436.min_delta or 0))

	local c458= false

	if c450 >= 6 then
		local c459= 2.5
		local c460= 15.0
		local c472= 0.08
		local c473= 30.0
		local c474= 180.0

		if c428 >= c459 and c428 < c460 and c430 <= 40.0 and c433 >= c473 and c433 <= c474 then
			if (c431 / math.max(1, c450)) >= c472 then
				c458 = true
			end
		end
	end

	return c458
end

function c475(c436,c415)
	local c428= c436.meanabs or 0
	local c430= c436.std or 0
	local c450= c436.samples or 0
	local c431= c436.sign_changes or 0
	local c433= c436.total_range or 0
	local c432= c436.last_delta or 0
	local c457= math.max(math.abs(c436.max_delta or 0), math.abs(c436.min_delta or 0))

	local c420= c436.deltas or {}

	local c476, c477, c478= 0, 0, 0
	for _, v in ipairs(c420) do
		if v > 0.5 then c476 = c476 + 1
		elseif v < -0.5 then c477 = c477 + 1
		else c478 = c478 + 1 end
	end

	local c479= math.max(c476, c477) / math.max(1, c450)
	local c480= math.abs(c476 - c477) / math.max(1, (c476 + c477))

	local c481, c482, c483= 0, 0, 0
	for _, v in ipairs(c420) do
		local c442= 0
		if v > 0.5 then c442 = 1 elseif v < -0.5 then c442 = -1 end
		if c442 ~= 0 and c442 == c483 then
			c482 = c482 + 1
		else
			c482 = (c442 ~= 0) and 1 or 0
			c483 = c442
		end
		if c482 > c481 then c481 = c482 end
	end

	local c484= c481 / math.max(1, c450)

	local c458= false

	if c450 >= 6 then
		if c433 >= 300 and (c479 >= 0.60 or c480 >= 0.60) then
			c458 = true
		end

		if not c458 and c433 >= 140 and c428 >= 9 and (c479 >= 0.75 or c480 >= 0.70 or c431 <= 1) then
			c458 = true
		end

		if not c458 and c484 >= 0.50 and c428 >= 8 and c433 >= 120 then
			c458 = true
		end

		if not c458 and c457 >= 120 and (c479 >= 0.60 or c480 >= 0.60) then
			c458 = true
		end
	end
	local c485= nil
	if not c458 and c450 > 0 then
		local c486= math.min(c433, 360) / 360.0
		local c487= math.min(c428, 60) / 60.0
		local c488= (c431 or 0) / math.max(1, c450)
		c485 = c486 * 0.45 + c487 * 0.35 + c480 * 0.15 + c479 * 0.05 - c488 * 0.20
		if c485 >= 0.42 and c433 >= 200 and c428 >= 6 then
			c458 = true
		end
		c436.spin_score = c485
	end

	return c458
end

function c489(c436,c415)
	
	return false
end

function c490(c436,c415)
	
	return false
end

function c491(c436,c415)
	local c428= c436.meanabs or 0
	local c430= c436.std or 0
	local c450= c436.samples or 0
	local c431= c436.sign_changes or 0
	local c433= c436.total_range or 0
	local c457= math.max(math.abs(c436.max_delta or 0), math.abs(c436.min_delta or 0))
	local c420= c436.deltas or {}

	if c450 < 6 then return false end

	local c492= c431 / math.max(1, c450)
	local c493= c436.movement
	if c492 >= 0.45 and c430 >= (c493 and 12.0 or 18.0) and c428 >= (c493 and 4.0 or 6.0) then
		return true
	end

	if c457 >= 120 and c492 >= 0.30 and c430 >= 12.0 then
		return true
	end

	if c433 >= 60 and c433 <= 300 and c492 >= 0.40 and c430 >= 14.0 and c428 >= 4.0 then
		return true
	end

	if c430 >= 30.0 and c492 >= 0.25 and c428 >= 5.0 then
		return true
	end

	return false
end

function c494(c436,c415)
	local c428= c436.meanabs or 0
	local c430= c436.std or 0
	local c450= c436.samples or 0
	local c431= c436.sign_changes or 0
	local c433= c436.total_range or 0
	local c457= math.max(math.abs(c436.max_delta or 0), math.abs(c436.min_delta or 0))

	if c450 >= 6 then
		local c459= 2.5
		local c460= 24.0
		local c495= 9.0
		local c496= 40.0
		local c473= 10.0

		if c428 >= c459 and c428 < c460 and c430 >= c495 and c430 <= c496 and c433 >= c473 then
			local c497= (c431 or 0) / math.max(1, c450)
			if c431 <= 3 or c497 <= 0.12 or c457 >= 40 then
				return true
			end
		end
	end

	return false
end

local function c498()
	local c499, c500= pcall(entity.get_players, true)
	if not c499 or type(c500) ~= "table" then return end
	for _, c415 in ipairs(c500) do
		if entity.is_alive(c415) and not entity.is_dormant(c415) then
			pcall(c414, c415)
		else
			c409[c415] = nil
		end
	end
end

local function c501(c415)
	if not entity.is_alive(entity.get_local_player()) then return end
	if not c415 or c415 == 0 then return end

	local c502= c409[c415]


	if c502 then
		return true, c502
	end

	local c416= c410(c415)
	if c416 and c416[1] and c416[1].yaw ~= nil then
		return true, tostring(c416[1].yaw)
	end
end

client.register_esp_flag("Resolver", 255, 255, 255, c501)

c413.register('net_update_end', function()
	local c503, c504= pcall(require, "require/abc/menu_setup")
	if c503 and c504 and c504.ui and c504.ui.misc_resolver then
		local c505, c506= pcall(ui.get, c504.ui.misc_resolver)
		if c505 and c506 then
			pcall(c498)
		end
	end
end, { alive_only = true, require_login = true })
]]
c927["require/features/misc/backstab_assist"] = [[local c410= require("require/abc/menu_setup")
local c411= require('require/abc/callbacks')
local c412= require('require/help/enemies')

local c413= ui.reference("AA", "Anti-aimbot angles", "Pitch")
local c414= ui.reference("AA", "Anti-aimbot angles", "Yaw base")
local c415, c416= ui.reference("AA", "Anti-aimbot angles", "Yaw")
local c417= nil

local function c418()
	if c417 then return end
	c417 = {}
	if c413 then c417.pitch = ui.get(c413) end
	if c414 then c417.yaw_base = ui.get(c414) end
	if c415 then c417.yaw = ui.get(c415) end
	if c416 then c417.yaw_slider = ui.get(c416) end
end

local function c419()
	if not c417 then return end
	if c413 and c417.pitch ~= nil then pcall(ui.set, c413, c417.pitch) end
	if c414 and c417.yaw_base ~= nil then pcall(ui.set, c414, c417.yaw_base) end
	if c415 and c417.yaw ~= nil then pcall(ui.set, c415, c417.yaw) end
	if c416 and c417.yaw_slider ~= nil then pcall(ui.set, c416, c417.yaw_slider) end
	c417 = nil
end

local function c420()
	c418()
	if c413 then pcall(ui.set, c413, "Off") end
	if c414 then pcall(ui.set, c414, "At targets") end
	if c415 then pcall(ui.set, c415, "180") end
	if c416 then pcall(ui.set, c416, 180) end
end

local function c421(c422)
	local c423= entity.get_local_player()
	if not c423 or not entity.is_alive(c423) then return false end
	local c424= c412.list() or {}
	for _, enemy in ipairs(c424) do
		if c412.is_alive(enemy) and not c412.is_dormant(enemy) and c412.has_knife(enemy) then
			local c425= c412.distance(enemy)
			if c425 and c425 <= c422 then
				return true
			end
		end
	end
	return false
end

local function c426(c427)
	if not (c410 and c410.ui and c410.ui.misc_backstab) then c419() return end
	local c428, c429= pcall(ui.get, c410.ui.misc_backstab)
	if not c428 or not c429 then c419() return end
	local c422= 200
	if c421(c422) then
		c420()
	else
		c419()
	end
end

if c410 and c410.ui and c410.ui.misc_backstab then
	ui.set_callback(c410.ui.misc_backstab, function()
		local c428, c430= pcall(ui.get, c410.ui.misc_backstab)
		if not c428 or not c430 then c419() end
	end)
end

c411.register("setup_command", c426, { alive_only = true, require_login = true })
c411.register("shutdown", c419, { alive_only = true, require_login = true })]]
c927["require/features/misc/collect"] = [=[
local M = {}


do
    local ok, ffi = pcall(require, "ffi")
    if ok and ffi and client and client.create_interface then
        local status, entity_list_ptr = pcall(function()
            return client.create_interface("client.dll", "VClientEntityList003")
        end)

        if status and entity_list_ptr then
            local pointer_type = ffi.typeof("void***")
            local entity_list = ffi.cast(pointer_type, entity_list_ptr)
            local ok_cast, get_client_entity = pcall(function()
                return ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
            end)

            if ok_cast and get_client_entity then
                
                local animstate_offset = 0x9960

                
                
                
                ffi.cdef[[
                struct animation_layer_t {
                    char  pad_0000[20];
                    uint32_t m_nOrder;
                    uint32_t m_nSequence;
                    float m_flPrevCycle;
                    float m_flWeight;
                    float m_flWeightDeltaRate;
                    float m_flPlaybackRate;
                    float m_flCycle;
                    void *m_pOwner;
                    char  pad_0038[4];
                };
                ]]

                
                
                

                ffi.cdef[[
                struct c_animstate_min {
                    char pad0[3];
                    char m_bForceWeaponUpdate;
                    char pad1[91];
                    void* m_pBaseEntity;
                    void* m_pActiveWeapon;
                    void* m_pLastActiveWeapon;
                    float m_flLastClientSideAnimationUpdateTime;
                    int m_iLastClientSideAnimationUpdateFramecount;
                    float m_flAnimUpdateDelta;
                    float m_flEyeYaw;
                    float m_flPitch;
                    float m_flGoalFeetYaw;
                    float m_flCurrentFeetYaw;
                    float m_flCurrentTorsoYaw;
                    float m_flUnknownVelocityLean;
                    float m_flLeanAmount;
                    char pad2[4];
                    float m_flFeetCycle;
                    float m_flFeetYawRate;
                    char pad3[4];
                    float m_fDuckAmount;
                    float m_fLandingDuckAdditiveSomething;
                    char pad4[4];
                    float m_vOriginX;
                    float m_vOriginY;
                    float m_vOriginZ;
                    float m_vLastOriginX;
                    float m_vLastOriginY;
                    float m_vLastOriginZ;
                    float m_vVelocityX;
                    float m_vVelocityY;
                    char pad5[4];
                    float m_flUnknownFloat1;
                    char pad6[8];
                    float m_flUnknownFloat2;
                    float m_flUnknownFloat3;
                    float m_flUnknown;
                    float m_flSpeed2D;
                    float m_flUpVelocity;
                    float m_flSpeedNormalized;
                    float m_flFeetSpeedForwardsOrSideWays;
                    float m_flFeetSpeedUnknownForwardOrSideways;
                    float m_flTimeSinceStartedMoving;
                    float m_flTimeSinceStoppedMoving;
                    bool m_bOnGround;
                    bool m_bInHitGroundAnimation;
                    char pad7[2];
                    float m_flTimeSinceInAir;
                    float m_flLastOriginZ;
                    float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
                    float m_flStopToFullRunningFraction;
                    float m_flMagicFraction;
                    char pad8[60];
                    float m_flWorldForce;
                    char pad9[462];
                    float m_flMaxYaw;
                };
                ]]

                
                M._get_animstate = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    
                    
                    local base = ffi.cast("char*", ent_ptr)
                    local anim_ptr_ptr = ffi.cast("struct c_animstate_min**", base + animstate_offset)
                    if anim_ptr_ptr == nil or anim_ptr_ptr == ffi.NULL then return nil end
                    local anim_ptr = anim_ptr_ptr[0]
                    if anim_ptr == nil or anim_ptr == ffi.NULL then return nil end
                    return anim_ptr
                end
                
                M._get_entity_ptr = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    return ent_ptr
                end
            end
        end
    end
end



function M.get_sim_time(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flSimulationTime") end)
    if ok then return val end
    return nil
end


function M.get_enemies_simtimes()
    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        out[ent] = M.get_sim_time(ent)
    end
    return out
end


function M.get_velocity_3d(ent)
    local ok, vals = pcall(function() return { entity.get_prop(ent, "m_vecVelocity") } end)
    if not ok or type(vals) ~= "table" then return nil end
    if #vals >= 3 then
        return { vals[1], vals[2], vals[3] }
    end
    return nil
end


function M.get_speed_2d(ent)
    local v = M.get_velocity_3d(ent)
    if not v then return nil end
    local x, y = v[1] or 0, v[2] or 0
    return math.sqrt(x * x + y * y)
end




function M.get_origin(ent)
    local ok, x, y, z = pcall(function() return entity.get_prop(ent, "m_vecOrigin") end)
    if ok and x then
        
        if type(x) == "table" then
            return x[1], x[2], x[3]
        elseif y and z then
            return x, y, z
        end
    end
    return nil
end


function M.get_view_offset(ent)
    local tries = { "m_vecViewOffset[0]", "m_vecViewOffset" }
    for _, prop in ipairs(tries) do
        local ok, v1, v2, v3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and v1 then
            if type(v1) == "table" then
                return v1[1], v1[2], v1[3]
            elseif v2 and v3 then
                return v1, v2, v3
            end
        end
    end
    return nil
end


function M.get_eye_pos(ent)
    local ox, oy, oz = M.get_origin(ent)
    local vx, vy, vz = M.get_view_offset(ent)
    if ox and vx then
        return ox + vx, oy + vy, oz + vz
    end
    return nil
end


function M.get_eye_angles(ent)
    local tries = { "m_angEyeAngles[0]", "m_angEyeAngles", "m_angRotation", "m_angNetworkAngles" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return nil
end


function M.get_abs_angles(ent)
    local tries = { "m_angAbsRotation", "m_angAbsAngles", "m_angAbsOrigin" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return M.get_eye_angles(ent)
end


function M.get_lower_body_yaw(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flLowerBodyYawTarget") end)
    if ok and val then return val end
    return nil
end


function M.get_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flCurrentFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    
    return M.get_lower_body_yaw(ent)
end

function M.get_goal_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flGoalFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    return M.get_feet_yaw(ent)
end


function M.get_speed(ent)
    
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flVelocityModifier") end)
    if ok and val then return val end
    
    local v = M.get_velocity_3d(ent)
    if v then
        return math.sqrt((v[1] or 0) * (v[1] or 0) + (v[2] or 0) * (v[2] or 0) + (v[3] or 0) * (v[3] or 0))
    end
    return nil
end

function M.get_move_speed_anim(ent)
    
    
    
    
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local try_fields = { "m_flFeetSpeedForwardsOrSideWays", "m_flSpeed2D", "m_flSpeedNormalized", "m_flFeetSpeedUnknownForwardOrSideways" }
            for _, f in ipairs(try_fields) do
                local okf, val = pcall(function() return tonumber(anim[f]) end)
                if okf and val and val ~= 0 then
                    return val
                end
            end
        end
    end

    
    local ok_nv, nv = pcall(function() return entity.get_prop(ent, "m_flMaxspeed") end)
    if ok_nv and nv then return nv end

    
    return M.get_speed_2d(ent)
end


function M.get_flags(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_fFlags") end)
    if ok and val then return val end
    ok, val = pcall(function() return entity.get_prop(ent, "m_iFlags") end)
    if ok and val then return val end
    return nil
end



function M.read_animstate(ent)
    if not M._get_animstate then return nil end
    local ok, anim = pcall(function() return M._get_animstate(ent) end)
    if not ok or not anim then return nil end
    local out = {}
    pcall(function()
        out.m_flEyeYaw = tonumber(anim.m_flEyeYaw)
        out.m_flPitch = tonumber(anim.m_flPitch)
        out.m_flGoalFeetYaw = tonumber(anim.m_flGoalFeetYaw)
        out.m_flCurrentFeetYaw = tonumber(anim.m_flCurrentFeetYaw)
        out.m_flCurrentTorsoYaw = tonumber(anim.m_flCurrentTorsoYaw)
        out.m_flUnknownVelocityLean = tonumber(anim.m_flUnknownVelocityLean)
        out.m_flLeanAmount = tonumber(anim.m_flLeanAmount)
        out.m_flFeetCycle = tonumber(anim.m_flFeetCycle)
        out.m_flFeetYawRate = tonumber(anim.m_flFeetYawRate)
        out.m_fDuckAmount = tonumber(anim.m_fDuckAmount)
        out.m_fLandingDuckAdditiveSomething = tonumber(anim.m_fLandingDuckAdditiveSomething)
        out.m_vOrigin = { tonumber(anim.m_vOriginX), tonumber(anim.m_vOriginY), tonumber(anim.m_vOriginZ) }
        out.m_vLastOrigin = { tonumber(anim.m_vLastOriginX), tonumber(anim.m_vLastOriginY), tonumber(anim.m_vLastOriginZ) }
        out.m_vVelocity = { tonumber(anim.m_vVelocityX), tonumber(anim.m_vVelocityY) }
        out.m_flUnknownFloat1 = tonumber(anim.m_flUnknownFloat1)
        out.m_flUnknownFloat2 = tonumber(anim.m_flUnknownFloat2)
        out.m_flUnknownFloat3 = tonumber(anim.m_flUnknownFloat3)
        out.m_flUnknown = tonumber(anim.m_flUnknown)
        out.m_flSpeed2D = tonumber(anim.m_flSpeed2D)
        out.m_flUpVelocity = tonumber(anim.m_flUpVelocity)
        out.m_flSpeedNormalized = tonumber(anim.m_flSpeedNormalized)
        out.m_flFeetSpeedForwardsOrSideWays = tonumber(anim.m_flFeetSpeedForwardsOrSideWays)
        out.m_flFeetSpeedUnknownForwardOrSideways = tonumber(anim.m_flFeetSpeedUnknownForwardOrSideways)
        out.m_flTimeSinceStartedMoving = tonumber(anim.m_flTimeSinceStartedMoving)
        out.m_flTimeSinceStoppedMoving = tonumber(anim.m_flTimeSinceStoppedMoving)
        out.m_bOnGround = (anim.m_bOnGround ~= 0)
        out.m_bInHitGroundAnimation = (anim.m_bInHitGroundAnimation ~= 0)
        out.m_flTimeSinceInAir = tonumber(anim.m_flTimeSinceInAir)
        out.m_flLastOriginZ = tonumber(anim.m_flLastOriginZ)
        out.m_flHeadHeightOrOffsetFromHittingGroundAnimation = tonumber(anim.m_flHeadHeightOrOffsetFromHittingGroundAnimation)
        out.m_flStopToFullRunningFraction = tonumber(anim.m_flStopToFullRunningFraction)
        out.m_flMagicFraction = tonumber(anim.m_flMagicFraction)
        out.m_flWorldForce = tonumber(anim.m_flWorldForce)
        out.m_flMaxYaw = tonumber(anim.m_flMaxYaw)
    end)
    return out
end



function M.read_anim_layers(ent)
    if not M._get_entity_ptr then return nil end
    local ok_ent, ent_ptr = pcall(function() return M._get_entity_ptr(ent) end)
    if not ok_ent or not ent_ptr then return nil end
    local ok, res = pcall(function()
        local ffi = require("ffi")
        local base = ffi.cast("char*", ent_ptr)
        local layers_ptr = ffi.cast("struct animation_layer_t**", base + 0x2990)
        if layers_ptr == nil or layers_ptr == ffi.NULL then return nil end
        local owner = layers_ptr[0]
        if owner == nil or owner == ffi.NULL then return nil end
        local out = {}
        for i = 0, 15 do
            local layer = owner[i]
            if layer == nil or layer == ffi.NULL then break end
            local t = {}
            t.m_nOrder = tonumber(layer.m_nOrder)
            t.m_nSequence = tonumber(layer.m_nSequence)
            t.m_flPrevCycle = tonumber(layer.m_flPrevCycle)
            t.m_flWeight = tonumber(layer.m_flWeight)
            t.m_flWeightDeltaRate = tonumber(layer.m_flWeightDeltaRate)
            t.m_flPlaybackRate = tonumber(layer.m_flPlaybackRate)
            t.m_flCycle = tonumber(layer.m_flCycle)
            t.m_pOwner = tostring(layer.m_pOwner)
            table.insert(out, t)
        end
        return out
    end)
    if not ok then return nil end
    return res
end


function M.get_tick_from_simtime(simtime)
    if not simtime or not globals or not globals.tickinterval then return nil end
    local ti = globals.tickinterval()
    if not ti or ti == 0 then return nil end
    return math.floor(simtime / ti + 0.5)
end

function M.get_tick(ent)
    local sim = M.get_sim_time(ent)
    if sim then return M.get_tick_from_simtime(sim) end
    return nil
end








function M.get_enemies_snapshot(opts)
    opts = opts or {}
    local heavy = true 

    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        local snap = {}

        
        snap.is_alive = (pcall(function() return entity.is_alive(ent) end) and entity.is_alive(ent)) or false
        snap.is_dormant = (pcall(function() return entity.is_dormant(ent) end) and entity.is_dormant(ent)) or false

        
        local ok_name, name = pcall(function() return entity.get_player_name(ent) end)
        snap.name = ok_name and name or nil

        
        snap.simtime = M.get_sim_time(ent)
        do
            local base_tick = snap.simtime and M.get_tick_from_simtime(snap.simtime) or nil
            
            local ok_flags, esp_flags = pcall(function()
                local d = entity.get_esp_data and entity.get_esp_data(ent)
                return (d and d.flags) or 0
            end)

            local adjusted_tick = base_tick
            if ok_flags and esp_flags and base_tick then
                
                local ok_bit, is_backtrack = pcall(function()
                    return bit and bit.band(esp_flags, bit.lshift(1, 17)) ~= 0
                end)
                if ok_bit and is_backtrack then
                    adjusted_tick = base_tick - 14
                end
            end
            snap.simTicks = adjusted_tick
        end

        
        do
            local ok, ox, oy, oz = pcall(function() return M.get_origin(ent) end)
            if ok and ox then snap.origin = { ox, oy, oz } end
        end
        do
            local ok, vx, vy, vz = pcall(function() return M.get_view_offset(ent) end)
            if ok and vx then snap.viewOffset = { vx, vy, vz } end
        end
        do
            local ok, ex, ey, ez = pcall(function() return M.get_eye_pos(ent) end)
            if ok and ex then snap.eyePos = { ex, ey, ez } end
        end

        
        do
            local ok, a1, a2, a3 = pcall(function() return M.get_eye_angles(ent) end)
            if ok and a1 then snap.eyeAngles = { a1, a2, a3 } end
        end
        do
            local ok, aa1, aa2, aa3 = pcall(function() return M.get_abs_angles(ent) end)
            if ok and aa1 then snap.absAngles = { aa1, aa2, aa3 } end
        end

        
        snap.lowerBodyYaw = (pcall(function() return M.get_lower_body_yaw(ent) end) and M.get_lower_body_yaw(ent)) or nil
        snap.feetYaw = (pcall(function() return M.get_feet_yaw(ent) end) and M.get_feet_yaw(ent)) or snap.lowerBodyYaw
        snap.goalFeetYaw = (pcall(function() return M.get_goal_feet_yaw(ent) end) and M.get_goal_feet_yaw(ent)) or snap.feetYaw

        
        snap.velocity3d = (pcall(function() return M.get_velocity_3d(ent) end) and M.get_velocity_3d(ent)) or nil
        if snap.velocity3d then
            snap.speed2d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0))
            snap.speed3d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0) + (snap.velocity3d[3] or 0) * (snap.velocity3d[3] or 0))
        else
            snap.speed2d = M.get_speed_2d(ent)
            snap.speed3d = M.get_speed(ent)
        end

        
        do
            local ok_ms, ms = pcall(function() return M.get_move_speed_anim(ent) end)
            if ok_ms and ms then
                snap.moveSpeedAnim = ms
            else
                snap.moveSpeedAnim = nil
            end
        end

        
        snap.flags = (pcall(function() return M.get_flags(ent) end) and M.get_flags(ent)) or nil

        
        local ok_head, hx, hy, hz = pcall(function() return entity.hitbox_position(ent, "head") end)
        if ok_head and hx then snap.headPos = { hx, hy, hz } end

        
        local ok_w, w = pcall(function() return entity.get_player_weapon(ent) end)
        snap.weapon = ok_w and w or nil

        

        
        local ok_b, bones = pcall(function() return entity.get_bone_matrices and entity.get_bone_matrices(ent) end)
        if ok_b and bones then snap.bones = bones end

        local ok_as, as = pcall(function() return M.read_animstate(ent) end)
        if ok_as and as then snap.animstate_full = as end
        local ok_layers, layers = pcall(function() return M.read_anim_layers(ent) end)
        if ok_layers and layers then snap.animLayers = layers end

        out[ent] = snap
    end
    return out
end

return M
]=]
c927["require/features/misc/dormant_aimbot"] = [[local c416, c417, c418, c419= client.visible, client.eye_position, client.log, client.trace_bullet
local c420, c421, c422, c423, c424, c425, c426, c427, c428, c429= entity.get_bounding_box, entity.get_local_player, entity.get_origin, entity.get_player_name, entity.get_player_resource, entity.get_player_weapon, entity.get_prop, entity.is_dormant, entity.is_enemy, entity.is_alive
local c430, c431, c432= globals.curtime, globals.maxplayers, globals.tickcount
local c433, c434, c435= math.max, math.min, math.sqrt
local c436, c437, c438= renderer.indicator, string.format, table.unpack or unpack
local c439, c440, c441, c442, c443, c444, c445, c446, c447, c448= ui.get, ui.new_checkbox, ui.new_color_picker, ui.new_hotkey, ui.new_multiselect, ui.new_slider, ui.reference, ui.set, ui.set_callback, ui.set_visible
local c449, c450= plist.get, entity.hitbox_position
local c451= require("ffi")
local c452= require("vector")
local c453= require("gamesense/csgo_weapons")
local c454= vtable_bind("client_panorama.dll", "VClientEntityList003", 3, "void*(__thiscall*)(void*, int)")
local c455= vtable_thunk(166, "bool(__thiscall*)(void*)")
local c456= vtable_thunk(483, "float(__thiscall*)(void*)")
local c457= {
	mindamage = c445("RAGE", "Aimbot", "Minimum damage"),
	dormant_esp = c445("VISUALS", "Player ESP", "Dormant"),
	override_mindamage = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}
local c458= require("require/abc/menu_setup")
local c459= require('require/abc/callbacks')

local c460= {}
local function c461(c462)
	if type(c458) ~= 'table' then return false end
	if c460[c462] == nil then c460[c462] = c458.ui and c458.ui[c462] end
	local c463= c460[c462]
	if not c463 then return false end
	local c464, c465= pcall(c439, c463)
	if not c464 then
		c460[c462] = c458.ui and c458.ui[c462]
		c463 = c460[c462]
		if not c463 then return false end
		c464, val = pcall(c439, c463)
		if not c464 then return false end
	end
	return c465
end

local c466= { "Head", "Chest", "Stomach" }
local c467= {
	"generic",
	"head",
	"chest",
	"stomach",
	"left arm",
	"right arm",
	"left leg",
	"right leg",
	"neck",
	"?",
	"gear"
}

local c468= {
	"",
	"Head",
	"Chest",
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs",
	"Head",
	"",
	""
}

local c469= {
	{ scale = 5, hitbox = "Stomach", vec = c452(0, 0, 40) },
	{ scale = 6, hitbox = "Chest", vec = c452(0, 0, 50) },
	{ scale = 3, hitbox = "Head", vec = c452(0, 0, 58) },
	{ scale = 4, hitbox = "Legs", vec = c452(0, 0, 20) }
}

local c470= {
	[0] = "Head",
	nil,
	"Stomach",
	nil,
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs"
}

local c471= 0
local c472= {}
local c473= {}
local c474= 1
local c475= false
local c476
local c477
local c478
local c479
local c480= false
local c481= {}

local c482= {
	0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18
}

local function c483(c484,c485,c486)
	local c487, c488= c484:to(c485):angles()
	local c489= math.rad(c488 + 90)
	local c490= c452(math.cos(c489), math.sin(c489), 0) * c486

	return {
		{ text = "Middle", vec = c485 },
		{ text = "Left", vec = c485 + c490 },
		{ text = "Right", vec = c485 - c490 }
	}
end

local function c491(c492,c493)
	for i = 1, #c492 do if c492[i] == c493 then return true end end
	return false
end
local function c494(c492,c493)
	for i = 1, #c492 do local c495= c492[i] if type(c495) == 'table' and c495[1] == c493 then return i end end
end
local function c496(c492,c497) return c494(c492, c497) ~= nil end
local function c498(c492,c497) local c499= c494(c492, c497) if c499 then table.remove(c492, c499) end end

local function c500(c501,c502)
	local c503= c435(c501.forwardmove*c501.forwardmove + c501.sidemove*c501.sidemove)
	if c502<=0 or c503<=0 then return end
	if c501.in_duck==1 then c502 = c502*2.94117647 end
	if c503<=c502 then return end
	local c504= c502/c503; c501.forwardmove = c501.forwardmove*c504; c501.sidemove = c501.sidemove*c504
end

local function c505()
	local c506, c507= {}, c424()
	for i=1,c431() do if c426(c507, "m_bConnected", i)==1 and i~=c421() and c428(i) then c506[#c506+1]=i end end
	return c506
end
local function c508()
	local c506, c507= {}, c424()
	for i=1,c431() do if c426(c507, "m_bConnected", i)==1 and not c449(i, "Add to whitelist") and c427(i) and c428(i) then c506[#c506+1]=i end end
	return c506
end

local function c509()
	for c487,enemy in ipairs(c505()) do
		local c487,c487,c487,c487,c510= c420(enemy)
		if c510<1 then if not c496(c473,enemy) then c473[#c473+1]={enemy,c432()} end else c498(c473,enemy) end
	end
end

local function c511(c512)
	local c513= c439(c457.override_mindamage[1]) and c439(c457.override_mindamage[2])
	local c514= c513 and c439(c457.override_mindamage[3]) or c439(c457.mindamage)
	local c515= entity.get_esp_data(c512).health
	if c514>100 then c514 = c514 - 100 + c515 end
	return c514
end

local function c516(c517,c504) return (c517.type=="sniperrifle" and c504) and c517.max_player_speed_alt or c517.max_player_speed end

local function c518(c512,c519,c520)
	local c521= {}
	local c522= c426(c512, "m_flDuckAmount") or 0
	for c487,p in ipairs(c469) do
		if #c520==0 or c491(c520,p.hitbox) then
			local c523= p.vec
			if p.hitbox=="Head" then c523 = c523 - c452(0,0,c522*10) elseif p.hitbox=="Chest" then c523 = c523 - c452(0,0,c522*4) end
			c521[#c521+1]={vec=c519+c523,scale=p.scale,hitbox=p.hitbox}
		end
	end
	for i=1,7 do
		local c524= c470[i-1]
		if c524 and (#c520==0 or c491(c520,c524)) then
			local c525= c450(c512,i-1)
			if c525 then c521[#c521+1]={vec=c452(c525),scale=3,hitbox=c524} end
		end
	end
	return c521
end

local function c526(c527,c528,c529,c530,c531)
	for c487,p in ipairs(c530) do
		for c487,c523 in ipairs(c483(c529,p.vec,3)) do
			local c487,c532= c419(c527, c529.x,c529.y,c529.z, c523.vec.x,c523.vec.y,c523.vec.z, true)
			if p.hitbox=="Head" then c532=c532*4 end
			if c532>c531 then return c523.vec,c532,p.hitbox,c523.text end
		end
	end
end

local function c533(c501)
	c509()

	if not c461('misc_dormantaimbot') and c461('misc_dormantaimbot_key') then
		return
	end

	local c534= c421()
	if not c534 or not c429(c534) then
		return
	end

	local c535= c425(c534)
	if not c535 then
		return
	end

	local c536= c454(c535)
	if not c536 or not c455(c536) then
		return
	end

	local c537= c456(c536)
	if not c537 then
		return
	end

	local c538= c452(c417())
	local c539= c426(c534, "m_flSimulationTime")
	local c540= c432()
	local c541= c453(c535)
	local c542= c426(c534, "m_bIsScoped") == 1
	local c543= bit.band(c426(c534, "m_fFlags"), bit.lshift(1, 0))

	local c544= c508()
	if #c544 == 0 then
		c472 = {}
		return
	end

	if c540 % #c544 ~= 0 then
		c474 = c474 + 1
	else
		c474 = 1
	end

	local c512= c544[c474]
	if not c512 then
		c472 = {}
		return
	end

	if c540 < c471 then
		c472 = {}
		return
	end

	if c541.type == "grenade" or c541.type == "knife" then
		c472 = {}
		return
	end

	if c501.in_jump == 1 and c543 == 0 then
		c472 = {}
		return
	end

	local c545= c466
	local c546= c452(c422(c512))
	local c487, c487, c487, c487, c547= c420(c512)

	c472[c512] = nil

	if c547 < 1 then
		if not c496(c481, c512) then
			c481[#c481 + 1] = { c512, c540 }
		end
	else
		c498(c481, c512)
	end

	local c548= c518(c512, c546, c545)
	local c549= c511(c512)

	local c550
	if c541.is_revolver then
		c550 = c539 > c426(c535, "m_flNextPrimaryAttack")
	else
		c550 = c539 > c433(
			c426(c534, "m_flNextAttack"),
			c426(c535, "m_flNextPrimaryAttack"),
			c426(c535, "m_flNextSecondaryAttack")
		)
	end

	if not c550 then
		return
	end

	local c551, c552, c553, c554= c526(
		c534,
		c541,
		c538,
		c548,
		c549
	)

	if not c551 then
		return
	end

	if c416(c551.x, c551.y, c551.z) then
		return
	end

	c500(c501, c516(c541, c542) * 0.33)

	local c555, c488= c538:to(c551):angles()

	if not c542 and c541.type == "sniperrifle" and c501.in_jump == 0 and c543 == 1 then
		c501.in_attack2 = 1
	end

	c472[c512] = true

	if c537 < 0.01 then
		c501.pitch = c555
		c501.yaw = c488
		c501.in_attack = 1
		c475 = true
		c476 = c553
		c477 = c554
		c478 = c512
		c479 = (c439(c458.ui.misc_dormantaimbot_value) or 0)
	end
end

local function c556(c557)
	client.delay_call(0.03, function()
		local c534= c421()
		if client.userid_to_entindex(c557.userid) ~= c534 then
			return
		end

		if c475 and not c480 then
			client.fire_event("dormant_miss", {
				userid = c478,
				aim_hitbox = c476,
				aim_point = c477,
				accuracy = c479
			})
		end

		c480 = false
		c475 = false
		c476 = nil
		c477 = nil
		c478 = nil
		c479 = nil
	end)
end

local function c558(c557)
	local c559= client.userid_to_entindex(c557.userid)
	local c560= client.userid_to_entindex(c557.attacker)

	if c560 == c421() and c559 ~= nil and c475 then
		c480 = true

		client.fire_event("dormant_hit", {
			userid = c559,
			attacker = c560,
			health = c557.health,
			armor = c557.armor,
			weapon = c557.weapon,
			dmg_health = c557.dmg_health,
			dmg_armor = c557.dmg_armor,
			hitgroup = c557.hitgroup,
			accuracy = c479 or 0,
			aim_hitbox = c476
		})
	end
end

local function c561()
	local c562= (cvar.mp_freezetime:get_float() + 1) / globals.tickinterval()
	c471 = c432() + c562
end

c459.register("setup_command", c533, { alive_only = true, require_login = true })
c459.register("round_prestart", c561, { alive_only = true, require_login = true })
c459.register("player_hurt", c558, { alive_only = true, require_login = true })
c459.register("weapon_fire", c556, { alive_only = true, require_login = true })

client.register_esp_flag("DA", 255, 255, 255, function(c497)
	if c461('misc_dormantaimbot') and c461('misc_dormantaimbot_key') and c429(c421()) then
		return c472[c497]
	end
end)


c459.register("paint", function()
	if not c429(c421()) then return end
	if c461('misc_dormantaimbot') and c461('misc_dormantaimbot_key') then
		local c563= {255,255,255,200}
		for c487,c495 in pairs(c472) do if c495 then c563={143,194,21,255}; break end end
		if #c508()==0 then c563={255,0,50,255} end
		c436(c563[1],c563[2],c563[3],c563[4],"DA")
	end
end, { alive_only = true, require_login = true })]]
c927["require/features/misc/enhance_osaa"] = [[local c419, c420= pcall(require, "require/abc/menu_setup")

local c421= require('require/abc/callbacks')

local c422= {}
local c423= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local c424= {ui.reference(item[1], item[2], item[3])}
    c422[i] = c424
    for _, ref in ipairs(c424) do
        c423[ref] = true
    end
end

local c425= {}
local c426= {}

c421.register("weapon_fire", function(c427)
    local c428= entity.get_local_player()
    if c428 and client.userid_to_entindex(c427.userid) == c428 then
        c425[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

c421.register("player_hurt", function(c427)
    local c428= entity.get_local_player()
    if c428 and client.userid_to_entindex(c427.userid) == c428 then
        c426[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

local function c429()
    local c430= globals.tickcount()
    local c431= nil
    for t = c430-20, c430 do
        if c425[t] then
            c431 = t
            break
        end
    end
    if c431 then
        if c430 - c431 <= 4 then
            return true
        end
        return true
    end
    return false
end



local function c432(c433)

    local c429= has_fired()

    local function c434(c435,c436)
        if type(c435) ~= 'table' then return false end
        for _, v in ipairs(c435) do if tostring(v) == tostring(c436) then return true end end
        return false
    end

    local c437= ui.get(c420.ui.fakelag_settings_enhance_onshot) or {}

    if c420 and c420.ui and c429 then
            if c434(c437, 'defensive') then
                c433.force_defensive = true
            end

            if c434(c437, 'roll') then
                ui.set(c422[3][1], math.random(-45, 45))
            end

            local c438= globals.tickcount() % 4 < 2
            if c434(c437, 'jitter') then
                ui.set(c422[2][1], '180')
                ui.set(c422[2][2], c438 and 55 or -48)
            end
    end
end

c421.register('setup_command', function(c433)

    c432(c433)

end, { alive_only = true, require_login = true })]]
c927["require/features/misc/events"] = [[local c422= {}
local c423= globals

c422.last_hit = {}
c422.last_miss = {}

c422.shots_queue = {}
c422.shots_by_id = {}

function c422.record_weapon_fire(c424)
  if not c424 or not c424.t then return end
  c422.shots_queue[#c422.shots_queue+1] = c424
end

function c422.record_aim_fire(c425,c424)
  if not c425 or not c424 then return end
  c422.shots_by_id[c425] = c424
end

function c422.record_aim_miss(c425,c426,c427)
  if not c426 then return end
  local c428= c423.curtime()
  local c429= c427 or {}
  c429.time = c428
  c422.last_miss[c426] = c429
  if c425 then c422.shots_by_id[c425] = nil end
end

function c422.record_player_hurt(c425,c426,c427)
  if not c426 then return end
  local c428= c423.curtime()
  local c429= c427 or {}
  c429.time = c428
  c422.last_hit[c426] = c429
  if c425 then c422.shots_by_id[c425] = nil end
end

function c422.link_recent_shot_to_victim(c426,c430)
  c430 = c430 or 0.35
  local c428= c423.curtime()
  for i=#c422.shots_queue,1,-1 do
    local c431= c422.shots_queue[i]
    if c431 and c431.target == c426 and (c428 - (c431.t or c428)) <= c430 and not c431.linked then
      c422.shots_queue[i].linked = true
      return c422.shots_queue[i]
    end
  end
  return nil
end

return c422
]]
c927["require/features/misc/exploit_fakelag"] = [[local c425, c426= pcall(require, "require/abc/menu_setup")

local c427= require('require/abc/callbacks')

local c428= {}
local c429= {}
for i, item in ipairs({
    { 'rage', 'aimbot', 'double tap' },
    { 'aa', 'other', 'on shot anti-aim' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },

}) do
    local c430= {ui.reference(item[1], item[2], item[3])}
    c428[i] = c430
    for _, ref in ipairs(c430) do
        c429[ref] = true
    end
end


local function c431(c432)

    local c433= ui.get(c426.ui.misc_exploit_fakelag)

    local c434= (ui.get(c428[1][1]) and ui.get(c428[1][2]))
    local c435= (ui.get(c428[2][1]) and ui.get(c428[2][2]))

    local c436= c433 and (c434 or c435)

    if c436 then
        ui.set(c428[3][1], false)
    end

end

c427.register('setup_command', function(c432)

    c431(c432)

end, { alive_only = true, require_login = true })]]
c927["require/features/misc/fakelag"] = [[local c428= {}
local c429= {}
for i, item in ipairs({
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
}) do
    local c430= {ui.reference(item[1], item[2], item[3])}
    c428[i] = c430
    for _, ref in ipairs(c430) do
        c429[ref] = true
    end
end

local c431, c432= pcall(require, "require/abc/menu_setup")

local c433= require('require/abc/callbacks')

c433.register("setup_command", function()
    if not (c431 and c432 and c432.ui) then return end

    local c434, c435= pcall(ui.get, c432.ui.fakelag_fakelag)
    if not c434 or not c435 then return end

    local c436, c437= pcall(ui.get, c432.ui.fakelag_fakelag_type)
    if not c436 then return end

    if tostring(c437) == "gamesense" then
        ui.set(c428[1][1], true)
        local c438, c439= pcall(ui.get, c432.ui.fakelag_fakelag_amount)
        local c440, c441= pcall(ui.get, c432.ui.fakelag_fakelag_variance)
        local c442, c443= pcall(ui.get, c432.ui.fakelag_fakelag_limit)

        if c438 and c439 and c428[2] and c428[2][1] then
            pcall(ui.set, c428[2][1], c439)
        end
        if c440 and c441 and c428[3] and c428[3][1] then
            pcall(ui.set, c428[3][1], c441)
        end
        if c442 and c443 and c428[4] and c428[4][1] then
            pcall(ui.set, c428[4][1], c443)
        end

        return
    end

    if tostring(c437) == "sodium" then
        ui.set(c428[1][1], true)
        local c444, c445= pcall(ui.get, c432.ui.fakelag_fakelag_type2)
        if not c444 then return end

        if tostring(c445) == "jitter" then
            if c428[2] and c428[2][1] then
                pcall(ui.set, c428[2][1], "dynamic")
            end
            local c446= globals.tickcount() or 0
            local c447= math.max(c446 % 101, 100)
            local c448= math.min(math.random(7) + (c446 % 15), 11)
            if c428[3] and c428[3][1] then pcall(ui.set, c428[3][1], c447) end
            if c428[4] and c428[4][1] then pcall(ui.set, c428[4][1], 15) end

            return
        end

        if tostring(c445) == "max" then
            if c428[2] and c428[2][1] then
                pcall(ui.set, c428[2][1], "dynamic")
            end
            if c428[3] and c428[3][1] then
                pcall(ui.set, c428[3][1], 0)
            end
            local c443= 14 + ((globals.tickcount() or 0) % 2)
            if c428[4] and c428[4][1] then pcall(ui.set, c428[4][1], c443) end

            return
        end
    end
end, { alive_only = true, require_login = true })]]
c927["require/features/misc/freestand_helper"] = [[local c431= {}
local c432= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
}) do
    local c433= {ui.reference(item[1], item[2], item[3])}
    c431[i] = c433
    for _, ref in ipairs(c433) do
        c432[ref] = true
    end
end

local c434, c435= pcall(require, "require/abc/menu_setup")

local c436= require('require/abc/callbacks')

local function c437(c438)
    if not (c435 and c435.ui and c435.ui.aa_gskey_freestand) then return end
    if not ui.get(c435.ui.aa_gskey_freestand) then return end

    local function c439(c440,c441)
        if type(c440) ~= 'table' then return false end
        for _, v in ipairs(c440) do if tostring(v) == tostring(c441) then return true end end
        return false
    end

    local c442= ui.get(c435.ui.fakelag_settings_freestanding) or {}


    localplayer = entity.get_local_player()
    local c443, c444, c445= entity.get_prop(localplayer, 'm_vecVelocity')
    if c443 and c444 and c445 then
        velvel =  math.sqrt(c443 * c443 + c444 * c444 + c445 * c445)
    end
    


    if c439(c442, 'static') then
        ui.set(c431[1][1], true)
        ui.set(c431[5][1], '180')
        ui.set(c431[5][2], 6)
        ui.set(c431[6][1], 'off')
        ui.set(c431[7][1], 'off')
    end

    if c439(c442, 'zero pitch') and velvel > 5 then
        ui.set(c431[3][1], 'Off')
    end

    if c439(c442, 'defensive') then
        c438.force_defensive = true
    end

    local c446= globals.tickcount() % 4 < 2
    if c439(c442, 'side flip') and velvel > 5 then
        ui.set(c431[5][1], '180')
        ui.set(c431[5][2], c446 and -90 or 90)
    end

    local c446= globals.tickcount() % 6 < 2
    if c439(c442, 'pitch flip') and velvel > 5 then
        ui.set(c431[3][1], 'custom')
        ui.set(c431[3][2], c446 and -89 or 89)
    end

end

c436.register('setup_command', function(c438)
    c437(c438)
end, { alive_only = true, require_login = true })]]
c927["require/features/misc/history"] = [[
local c434= {}

local c435= 20
local c436= {}

local function c437(c438)
  if not c436[c438] then c436[c438] = { buf = {} } end
  return c436[c438]
end

function c434.push(c438,c439)
  if not c438 or not c439 then return end
  local c440= c437(c438)
  c440.buf[#c440.buf+1] = c439
  if #c440.buf > c435 then table.remove(c440.buf, 1) end
end

function c434.get_last_n(c438,c441)
  c441 = c441 or c435
  local c440= c436[c438]
  if not c440 or #c440.buf == 0 then return {} end
  local c442= {}
  local c443= #c440.buf
  local c444= math.max(1, c443 - c441 + 1)
  for i = c444, c443 do c442[#c442+1] = c440.buf[i] end
  return c442
end

function c434.clear(c438)
  if not c438 then c436 = {} return end
  c436[c438] = nil
end

return c434
]]
c927["require/features/misc/hotkeys"] = [[local c437= {}
local c438= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local c439= {ui.reference(item[1], item[2], item[3])}
    c437[i] = c439
    for _, ref in ipairs(c439) do
        c438[ref] = true
    end
end

local c440, c441= pcall(require, "require/abc/menu_setup")

local c442= require('require/abc/callbacks')

local function c443()

    if ui.get(c441.ui.aa_gskey_freestand) then
        ui.set(c437[3][1], true)
        ui.set(c437[3][2], 'Always on')
    else
        ui.set(c437[3][1], false)
        ui.set(c437[3][2], 'On hotkey')
    end

    if ui.get(c441.ui.aa_gskey_slowmotion) then
        ui.set(c437[4][1], true)
    else
        ui.set(c437[4][1], false)
    end

    if c441 and c441.ui and ui.get(c441.ui.aa_gskey_edgeyaw) then
        ui.set(c437[2][1], true)
    else
        ui.set(c437[2][1], false)
    end

    if c441 and c441.ui and ui.get(c441.ui.aa_gskey_onshot) then
        ui.set(c437[6][2], 'Always on')
    else
        ui.set(c437[6][2], 'On hotkey')
    end

end

c442.register('setup_command', function()

    c443()

end, { alive_only = true, require_login = true })]]
c927["require/features/misc/localdebug"] = [=[local callbacks_ok, callbacks = pcall(require, "require/abc/callbacks")
local M = {}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")

local state = {
    last_yaw = nil,
    last_pitch = nil,
    last_defensive = false,
    skel_list = {},
    last_choked = 0,
    shot_ticks = {},
    shot_ticks_aim = {},
    skel_history = {},
}

local function normalize_angle(a)
    if not a then return a end
    local ang = tonumber(a) or 0
    while ang > 180 do ang = ang - 360 end
    while ang <= -180 do ang = ang + 360 end
    return ang
end

local function on_weapon_fire(ev)
    if not ev then return end
    local attacker_ent = client.userid_to_entindex(ev.userid)
    local lp = entity.get_local_player()
    if attacker_ent ~= lp then return end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks, t)
    while #state.shot_ticks > 200 do table.remove(state.shot_ticks, 1) end
end

local function on_aim_fire(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    if ev.attacker then
        local attacker_ent = client.userid_to_entindex(ev.attacker)
        if attacker_ent ~= lp then return end
    end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks_aim, t)
    while #state.shot_ticks_aim > 200 do table.remove(state.shot_ticks_aim, 1) end
end

local function had_recent_shot(ticks_back)
    ticks_back = ticks_back or 30
    local now = globals.tickcount and globals.tickcount() or 0
    for i = #state.shot_ticks_aim, 1, -1 do
        local s = state.shot_ticks_aim[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    for i = #state.shot_ticks, 1, -1 do
        local s = state.shot_ticks[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    return false
end

local function safe_tonumber(v)
    local n = tonumber(v)
    if n then return n end
    return 0
end


local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {
    head={names={'head','Head','HEAD'},idx={0}},
    neck={names={'neck','Neck'},idx={1}},
    chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},
    stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},
    pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},
    l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},
    l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},
    l_hand={names={'left hand','Left Hand'},idx={14}},
    r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},
    r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},
    r_hand={names={'right hand','Right Hand'},idx={13}},
    l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},
    l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},
    l_foot={names={'left foot','Left Foot'},idx={12}},
    r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},
    r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},
    r_foot={names={'right foot','Right Foot'},idx={11}},
}

local function find_bone(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x,y,z = entity.hitbox_position(ent, def.names[i])
        if x then return x,y,z end
    end
    for i = 1, #(def.idx or {}) do
        local x,y,z = entity.hitbox_position(ent, def.idx[i])
        if x then return x,y,z end
    end
end

local function snap_ent(ent)
    if not ent then return end
    local pts = {}
    for key, def in pairs(boxes) do
        local x,y,z = find_bone(ent, def)
        if x then pts[key] = {x=x,y=y,z=z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local function paint_handler()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lag_record then
        local ok_enabled, enabled = pcall(ui.get, menu_setup.ui.paint_lag_record)
        if not ok_enabled or not enabled then return end
    end
    if not renderer or not renderer.world_to_screen or not renderer.line then return end
    local now = globals.realtime and globals.realtime() or os.time()
    local i = 1
    while i <= #state.skel_list do
        local it = state.skel_list[i]
        if not it or not it.t or (now - it.t) > 10 then
            table.remove(state.skel_list, i)
        else
            local SKEL_SCALE = 1.15
            
            local trail = it.trail or {}
            if trail and #trail > 0 then
                for ti = 1, #trail do
                    local entry = trail[ti]
                    local trail_pts = entry.pts or {}
                    
                    local ratio = ti / #trail
                    local r, g, b, alpha
                    if ti == #trail then
                        
                        r = 0
                        g = 140
                        b = 255
                        alpha = 200
                    else
                        
                        r = 255
                        g = math.floor(255 * (1 - ratio))
                        b = math.floor(255 * (1 - ratio))
                        alpha = math.floor(40 + ratio * (160 - 40))
                    end
                    
                    local center = trail_pts.pelvis or trail_pts.chest
                    if not center then
                        local sx, sy, sz, ccount = 0,0,0,0
                        for k, v in pairs(trail_pts) do
                            if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                        end
                        if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
                    end
                    for c = 1, #chains do
                        local chain = chains[c]
                        local from, to = trail_pts[chain[1]], trail_pts[chain[2]]
                        if from and to then
                            local fxw, fyw, fzw = from.x, from.y, from.z
                            local txw, tyw, tzw = to.x, to.y, to.z
                            if center and center.x then
                                fxw = center.x + (from.x - center.x) * SKEL_SCALE
                                fyw = center.y + (from.y - center.y) * SKEL_SCALE
                                fzw = center.z + (from.z - center.z) * SKEL_SCALE
                                txw = center.x + (to.x - center.x) * SKEL_SCALE
                                tyw = center.y + (to.y - center.y) * SKEL_SCALE
                                tzw = center.z + (to.z - center.z) * SKEL_SCALE
                            end
                            local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                            local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                            if fx and tx then renderer.line(fx,fy,tx,ty,r,g,b,alpha) end
                        end
                    end
                end
            end
            
            local pts = it.pts or {}
            local center = pts.pelvis or pts.chest
            if not center then
                local sx, sy, sz, ccount = 0,0,0,0
                for k, v in pairs(pts) do
                    if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                end
                if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
            end
            for c = 1, #chains do
                local chain = chains[c]
                local from, to = pts[chain[1]], pts[chain[2]]
                if from and to then
                    local fxw, fyw, fzw = from.x, from.y, from.z
                    local txw, tyw, tzw = to.x, to.y, to.z
                    if center and center.x then
                        fxw = center.x + (from.x - center.x) * SKEL_SCALE
                        fyw = center.y + (from.y - center.y) * SKEL_SCALE
                        fzw = center.z + (from.z - center.z) * SKEL_SCALE
                        txw = center.x + (to.x - center.x) * SKEL_SCALE
                        tyw = center.y + (to.y - center.y) * SKEL_SCALE
                        tzw = center.z + (to.z - center.z) * SKEL_SCALE
                    end
                    local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                    local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                    if fx and tx then renderer.line(fx,fy,tx,ty,255,0,0,220) end
                end
            end
            i = i + 1
        end
    end
end


local function on_setup_command(cmd)
    if not cmd then return end
    local aa_funcs = nil
    local ok_req, req_lib = pcall(require, 'gamesense/antiaim_funcs')
    if ok_req and req_lib then aa_funcs = req_lib end
    if not aa_funcs then
        local ok_libs, libs = pcall(require, 'require/help/libs')
        if ok_libs and libs and libs.get then
            aa_funcs = libs.get('antiaim_funcs')
        end
    end

    local pitch, yaw = nil, nil
    if aa_funcs then
        local okp, pval = pcall(function() return aa_funcs.get_pitch and aa_funcs.get_pitch() end)
        if okp and pval ~= nil then pitch = pval end
        local oky, yval = pcall(function() return aa_funcs.get_yaw_base and aa_funcs.get_yaw_base() end)
        if oky and yval ~= nil then yaw = yval end
        if yaw == nil then
            local okb, bval = pcall(function() return aa_funcs.get_body_yaw and aa_funcs.get_body_yaw() end)
            if okb and bval ~= nil then yaw = bval end
        end
    end

    if (pitch == nil or yaw == nil) then
        local lp = entity.get_local_player()
        if lp then
            local ax, ay = entity.get_prop(lp, "m_angEyeAngles")
            if ax and ay then
                if pitch == nil then pitch = ax end
                if yaw == nil then yaw = ay end
            end
        end
    end

    if pitch ~= nil then state.last_pitch = pitch end
    if yaw ~= nil then state.last_yaw = normalize_angle(yaw) end

    do
        local ok_def, def_mod = pcall(require, 'require/features/aa/defensive')
        if ok_def and def_mod and def_mod.active ~= nil then
            state.last_defensive = not not def_mod.active
        else
            if cmd and cmd.force_defensive ~= nil then
                state.last_defensive = not not cmd.force_defensive
            end
        end
    end
    if cmd and cmd.chokedcommands ~= nil then
        state.last_choked = tonumber(cmd.chokedcommands) or 0
    end
    local lp = entity.get_local_player()
    if lp then
        local tick = globals.tickcount and globals.tickcount() or 0
        local hist_pts = snap_ent(lp)
        if hist_pts then
            state.skel_history[#state.skel_history + 1] = { tick = tick, pts = hist_pts }
            if #state.skel_history > 128 then table.remove(state.skel_history, 1) end
        end
    end
end

local function on_player_death(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    local victim_ent = client.userid_to_entindex(ev.userid)
    local attacker_ent = nil
    if ev.attacker then attacker_ent = client.userid_to_entindex(ev.attacker) end

    if victim_ent == lp then
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then
                attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker)
            else
                attacker_name = tostring(ev.attacker)
            end
        end
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] DIED — last_yaw=%.2f last_pitch=%.2f attacker=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
        return
    end
    if attacker_ent == lp and victim_ent and victim_ent ~= 0 and victim_ent ~= lp then
        local victim_name = entity.get_player_name(victim_ent) or tostring(ev.userid)
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] KILLED — last_yaw=%.2f last_pitch=%.2f victim=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, victim_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end
end

if callbacks_ok and callbacks and callbacks.callback then
    callbacks.callback('setup_command', on_setup_command, { alive_only = false, require_login = false })
    callbacks.callback('player_death', on_player_death, { alive_only = false, require_login = false })
    callbacks.callback('paint', paint_handler, { alive_only = false, require_login = false })
    callbacks.callback('weapon_fire', on_weapon_fire, { alive_only = false, require_login = false })
    callbacks.callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end, { alive_only = false, require_login = false })
else
    client.set_event_callback('setup_command', on_setup_command)
    client.set_event_callback('player_death', on_player_death)
    client.set_event_callback('paint', paint_handler)
    client.set_event_callback('weapon_fire', on_weapon_fire)
    client.set_event_callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end)
end
]=]
c927["require/features/misc/resolver"] = [[














local c443, c444= pcall(require, "require/features/misc/collect")
local c445, c446= pcall(require, "require/features/misc/history")
local c447, c448= pcall(require, "require/features/misc/state")
local c449, c450= pcall(require, "require/features/misc/events")
local c451, c452= pcall(require, "require/help/vector")
local c453= c451 and c452 or nil
local c454= require('require/abc/callbacks')







if not M then M = {} end
M.players = M.players or {}


local function c455()
	pcall(function()
		if not c443 or type(c444) ~= "table" or not c444.get_enemies_snapshot then return end

		local c456, c457= pcall(function() return c444.get_enemies_snapshot() end)
		if not c456 or type(c457) ~= "table" then return end

		M.players = M.players or {}

		for ent, snap in pairs(c457) do
			M.players[ent] = M.players[ent] or {}
			M.players[ent].snapshot = snap

            
            
            
			M.players[ent].simtime = snap.simtime
			M.players[ent].simTicks = snap.simTicks
			M.players[ent].lowerBodyYaw = snap.lowerBodyYaw
			M.players[ent].speed2d = snap.speed2d
			M.players[ent].velocity3d = snap.velocity3d
			M.players[ent].is_alive = snap.is_alive
			M.players[ent].is_dormant = snap.is_dormant
			M.players[ent].feetYaw = snap.feetYaw
			M.players[ent].goalFeetYaw = snap.goalFeetYaw
			M.players[ent].moveSpeedAnim = snap.moveSpeedAnim
		end

		for ent, snap in pairs(c457) do
			local c458= snap.name or "?"
			local c459= snap.simtime or 0
			local c460= snap.speed2d or 0
			local c461= snap.lowerBodyYaw or "nil"
			local c462= snap.moveSpeedAnim or 0
			local c463= snap.feetYaw or "nil"
			local c464= snap.goalFeetYaw or "nil"
			local c465= snap.animstate_full.m_fDuckAmount

		end
	end)
end



local function c466(c467)
    while c467 > 180 do
        c467 = c467 - 360
    end
    while c467 < -180 do
        c467 = c467 + 360
    end
    return c467
end


local function c468(c469,c470)
    local c471= c470 - c469
    local c467= math.atan(c471.y / c471.x)
    c467 = c466(c467 * 180 / math.pi)

    if c471.x >= 0 then
        c467 = c466(c467 + 180)
    end

    return c467
end



local c472= 100
local c473= {}
_G.player_history = c473

local function c474(c475)
    return math.floor(0.5 + c475 / globals.tickinterval())
end

local function c476(c477)
    local c478= entity.get_players(true)

	if #c478 == 0 then
		
		c473 = {}
		_G.player_history = c473
		return nil
	end


	for i, player in ipairs(c478) do
		if entity.is_alive(player) and not entity.is_dormant(player) then

			local c479= 0
			local c480= entity.get_esp_data(player).flags or 0

			if bit.band(c480, bit.lshift(1, 17)) ~= 0 then
				c479 = c474(entity.get_prop(player, "m_flSimulationTime")) - 14
			else
				c479 = c474(entity.get_prop(player, "m_flSimulationTime"))
			end

			
			local c481= c473[player] or {}
			local c482= c481[1]

			if c482 == nil or (c479 - (c482.simtime or -999)) >= 1 then

				local c483= c453(entity.get_prop(c477, "m_vecOrigin"))
				local c484= c453(entity.get_prop(player, "m_angEyeAngles"))
				local c485= c453(entity.get_prop(player, "m_vecOrigin"))
				local c486= math.floor(c466(c484.y - c468(c483, c485)))
				

				local c487= {
					id = player or nil,
					origin = c453(entity.get_origin(player)) or c453(nil,nil,nil),
					pitch = c484.x or nil,
					yaw = c486 or nil,
					yaw_backwards = backwards_angle or nil,
					simtime = c479 or nil,
					stance = stance or nil,
					esp_flags = entity.get_esp_data(player).flags or 0,
					last_shot_time = last_shot_time or nil
				}

				table.insert(c481, 1, c487)
				while #c481 > c472 do
					table.remove(c481)
				end

				c473[player] = c481
			end
		end
	end
end















client.set_event_callback('net_update_end', function()
    pcall(function()

        
        

        local c477= entity.get_local_player()
        if not entity.is_alive(c477) then
            return
        end
        c476(c477)


        local c488= (globals and globals.tickcount and globals.tickcount()) or (globals and globals.realtime and globals.realtime()) or os.time()
        

    end)
end, { alive_only = true, require_login = true })

c454.register('weapon_fire', function(c489)
    pcall(function()







        local c490= (c489 and c489.userid) and (client.userid_to_entindex and client.userid_to_entindex(c489.userid)) or (c489 and (c489.attacker or c489.userid)) or "?"
        local c491= (c489 and (c489.weapon or c489.weapon_name or c489.weaponid)) or "?"
        
    end)
    if EVENTS and EVENTS.record_weapon_fire then pcall(EVENTS.record_weapon_fire, c489) end
end, { alive_only = true, require_login = true })

c454.register('aim_fire', function(c489)
    pcall(function()








        local c492= c489 and c489.id or "?"
        local c493= c489 and c489.target or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_fire then pcall(EVENTS.record_aim_fire, c489) end
end, { alive_only = true, require_login = true })

c454.register('aim_hit', function(c489)
    pcall(function()








        local c492= c489 and c489.id or "?"
        local c493= c489 and c489.target or "?"
        local c494= c489 and c489.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_hit then pcall(EVENTS.record_aim_hit, c489) end
end, { alive_only = true, require_login = true })

c454.register('aim_miss', function(c489)
    pcall(function()






        local c492= c489 and c489.id or "?"
        local c495= c489 and c489.reason or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_miss then pcall(EVENTS.record_aim_miss, c489) end
end, { alive_only = true, require_login = true })

c454.register('player_hurt', function(c489)
    pcall(function()






        local c496= (c489 and c489.attacker) or (c489 and c489.userid) or "?"
        local c497= (c489 and c489.userid) or (c489 and c489.userid) or "?"
        local c494= c489 and c489.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_player_hurt then pcall(EVENTS.record_player_hurt, c489) end
end, { alive_only = true, require_login = true })

c454.register('bullet_impact', function(c489)
    pcall(function()




        local c490= (c489 and c489.userid) and (client.userid_to_entindex and client.userid_to_entindex(c489.userid)) or "?"
        local c498,c499,c500= c489 and c489.x or "?", c489 and c489.y or "?", c489 and c489.z or "?"
        
    end)
    if EVENTS and EVENTS.on_bullet_impact then pcall(EVENTS.on_bullet_impact, c489) end
    if EVENTS and EVENTS.record_bullet_impact then pcall(EVENTS.record_bullet_impact, c489) end
end, { alive_only = true, require_login = true })

c454.register('paint', function()
    pcall(function()

        

    end)
    if EVENTS and EVENTS.on_paint then pcall(EVENTS.on_paint) end
end, { alive_only = true, require_login = true })

c454.register("round_start", function(c489)
    pcall(function() print("[resolver] round_start") end)



    M.players = {}
    if EVENTS and EVENTS.on_round_start then pcall(EVENTS.on_round_start, c489) end
end, { alive_only = true, require_login = true })

c454.register("shutdown", function()
    if client and client.unset_event_callback then



    end
end, { alive_only = true, require_login = true })
]]
c927["require/features/misc/resolver_dispatcher"] = [[local c446= {}


local c447= {}


_G.player_resolver_state = _G.player_resolver_state or {}

local function c448(c449)
    if not c449 or type(c449) ~= "string" then return nil end
    
    local c450= c449:lower()
    c450 = c450:gsub("%+", "plus")
    c450 = c450:gsub("%-% ", "minus_") 
    c450 = c450:gsub("%-%", "minus")
    c450 = c450:gsub("%s+", "_")
    c450 = c450:gsub("[^%w_]", "")
    return c450
end

local function c451(c449)
    local c452
    
    if c449 == "?" then
        c452 = "default"
    else
        c452 = c448(c449)
    end
    if not c452 or c452 == "" then return nil end
    if c447[c452] ~= nil then return c447[c452] end
    local c453= "require/features/misc/res_" .. c452
    local c454, c455= pcall(require, c453)
    if c454 and type(c455) == "table" then
        c447[c452] = c455
        return c455
    end
    c447[c452] = false
    return nil
end



function c446.process_entity(c456,c449,c457)
    local c454, c458= pcall(function()
        if not c456 or c456 == 0 then return end
        if not c449 or c449 == "?" then return end

        local c455= c451(c449)
        if not c455 then return end

        
        local c459= _G.player_resolver_state[c456]
        if not c459 then
            c459 = {}
            _G.player_resolver_state[c456] = c459
        end

        if type(c455.run) == "function" then
            
            pcall(function() c455.run(c456, c457 or {}, c459, c449) end)
        elseif type(c455.process) == "function" then
            pcall(function() c455.process(c456, c457 or {}, c459, c449) end)
        end
    end)
    return c454
end


c446._modules = c447
c446._sanitize_label = c448

return c446
]]
c927["require/features/misc/res_default"] = [[local c449= {}

local function c450(c451)
    pcall(function()
        if plist and type(plist.set) == "function" then
            
            plist.set(c451, "Force body yaw", false)
            plist.set(c451, "Force body yaw value", 0)
            plist.set(c451, "Force pitch", false)
            plist.set(c451, "Force pitch value", 0)
        end
    end)
end

function c449.run(c451,c452,c453,c454)
    
    if c454 ~= "?" and c454 ~= "DEFAULT" and c454 ~= "default" then return end

    c453.clears = (c453.clears or 0) + 1
    c453.last_seen = (globals and globals.curtime and globals.curtime()) or os.time()

    
    c450(c451)

    pcall(function()
        print(string.format("[res_default] ent=%d cleared_forces label=%s count=%d", c451, tostring(c454), c453.clears))
    end)
end

return c449
]]
c927["require/features/misc/res_static"] = [=[local M = {}
local ok_ffi, ffi = pcall(require, "ffi")
local ok_bit, bit = pcall(require, "bit")


local get_entity_ptr
local function init_ffi_helpers()
    if not ok_ffi or not client or not client.create_interface then return end
    local status, res = pcall(function()
        local pointer_type = ffi.typeof("void***")
        local entity_list_ptr = client.create_interface("client.dll", "VClientEntityList003")
        if not entity_list_ptr then return nil end
        local entity_list = ffi.cast(pointer_type, entity_list_ptr)
        local get_client_entity = ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
        return function(entindex)
            if not entindex or entindex == 0 then return nil end
            local ptr = get_client_entity(entity_list, entindex)
            if ptr == nil then return nil end
            return ptr
        end
    end)
    if status and type(res) == "function" then
        get_entity_ptr = res
    else
        get_entity_ptr = nil
    end
end
init_ffi_helpers()

local function get_speed2d(ent)
    
    local ok, vx, vy = pcall(function()
        local x,y,z = entity.get_prop(ent, "m_vecVelocity")
        return x or 0, y or 0
    end)
    if ok and vx and vy then
        return math.sqrt((vx or 0)*(vx or 0) + (vy or 0)*(vy or 0))
    end
    return 0
end

local function estimate_max_desync_ent(ent)
    
    if not ok_ffi or not get_entity_ptr then return nil end
    local ok_read, result = pcall(function()
        ffi.cdef[[
        struct c_animstate {
            char pad0[3];
            char m_bForceWeaponUpdate;
            char pad1[91];
            void* m_pBaseEntity;
            void* m_pActiveWeapon;
            void* m_pLastActiveWeapon;
            float m_flLastClientSideAnimationUpdateTime;
            int m_iLastClientSideAnimationUpdateFramecount;
            float m_flAnimUpdateDelta;
            float m_flEyeYaw;
            float m_flPitch;
            float m_flGoalFeetYaw;
            float m_flCurrentFeetYaw;
            float m_flCurrentTorsoYaw;
            float m_flUnknownVelocityLean;
            float m_flLeanAmount;
            char pad2[4];
            float m_flFeetCycle;
            float m_flFeetYawRate;
            char pad3[4];
            float m_fDuckAmount;
            float m_fLandingDuckAdditiveSomething;
            char pad4[4];
            float m_vOriginX;
            float m_vOriginY;
            float m_vOriginZ;
            float m_vLastOriginX;
            float m_vLastOriginY;
            float m_vLastOriginZ;
            float m_vVelocityX;
            float m_vVelocityY;
            char pad5[4];
            float m_flUnknownFloat1;
            char pad6[8];
            float m_flUnknownFloat2;
            float m_flUnknownFloat3;
            float m_flUnknown;
            float m_flSpeed2D;
            float m_flUpVelocity;
            float m_flSpeedNormalized;
            float m_flFeetSpeedForwardsOrSideWays;
            float m_flFeetSpeedUnknownForwardOrSideways;
            float m_flTimeSinceStartedMoving;
            float m_flTimeSinceStoppedMoving;
            bool m_bOnGround;
            bool m_bInHitGroundAnimation;
            char pad7[2];
            float m_flTimeSinceInAir;
            float m_flLastOriginZ;
            float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
            float m_flStopToFullRunningFraction;
            float m_flMagicFraction;
            char pad8[60];
            float m_flWorldForce;
            char pad9[462];
            float m_flMaxYaw;
        };
        ]]
        local ent_ptr = get_entity_ptr(ent)
        if not ent_ptr then return nil end
        local animstate_ptr = ffi.cast("struct c_animstate**", ffi.cast("uintptr_t", ent_ptr) + 0x9960)
        if animstate_ptr == nil or animstate_ptr == ffi.NULL then return nil end
        local anim = animstate_ptr[0]
        if anim == nil or anim == ffi.NULL then return nil end

        local duck_amount = tonumber(anim.m_fDuckAmount) or 0
        local speed2d_norm = tonumber(anim.m_flFeetSpeedForwardsOrSideWays) or 0
        local stop_to_full = tonumber(anim.m_flStopToFullRunningFraction) or 0
        local max_yaw = tonumber(anim.m_flMaxYaw) or 0

        local yaw_modifier = ((-0.3 * stop_to_full) - 0.2) * math.max(0, math.min(speed2d_norm, 1)) + 1.0
        if duck_amount > 0 then
            yaw_modifier = yaw_modifier + (duck_amount * 0.5) * (0.5 - yaw_modifier)
        end

        local raw_delta = max_yaw * yaw_modifier
        local velocity = get_speed2d(ent) or 0
        local velocity_clamped = math.min(math.max(velocity, 0), 260)
        local move_scale = 1.0 - (velocity_clamped / 260)
        move_scale = 0.35 + (move_scale * 0.65)
        local delta = raw_delta * move_scale
        if velocity >= 250 then
            delta = math.min(delta, 28)
        end
        local flags = nil
        if ok_bit and entity and entity.get_prop then
            flags = entity.get_prop(ent, "m_fFlags") or 0
        end
        local on_ground = true
        if flags then on_ground = bit.band(flags, 1) == 1 end
        if not on_ground then delta = delta * 0.55 end
        if duck_amount > 0.9 then delta = delta * 0.9 end
        delta = math.max(0, math.min(delta, 60))
        return delta
    end)
    if ok_read then return result end
    return nil
end

local function safe_unset(ent)
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", false)
            plist.set(ent, "Force body yaw value", 0)
        end
    end)
end

local function now_time()
    local ok, t = pcall(function() return (globals and globals.curtime and globals.curtime()) or os.time() end)
    return ok and t or os.time()
end

local function normalize_angle(angle)
    if not angle or type(angle) ~= "number" then return 0 end
    while angle > 180 do angle = angle - 360 end
    while angle < -180 do angle = angle + 360 end
    return angle
end

local function round(n)
    return math.floor((n or 0) + 0.5)
end

function M.run(ent, features, state, label)
    
    state.count = (state.count or 0) + 1
    state.last_seen = now_time()
    if state.last_label and state.last_label ~= label then state.count = 1 end
    state.last_label = label

    
    if not label or label ~= "STATIC" then return end

    
    local required_count = 3
    if state.count < required_count then return end

    
    if features and features.shot_age and tonumber(features.shot_age) and features.shot_age <= 0.25 then
        return
    end

    
    local avg_speed = tonumber((features and features.avg_speed) or 0) or 0
    if features and features.movement and features.movement == true then return end
    if avg_speed >= 1.2 then return end

    
    local max_mag_low = 58
    local max_mag_high = 28
    local speed_cap = 250
    local t = math.min(math.max(avg_speed / speed_cap, 0), 1)
    local max_mag = max_mag_low + (max_mag_high - max_mag_low) * t

    
    local ok_est, est = pcall(function() return estimate_max_desync_ent(ent) end)
    if ok_est and est and type(est) == "number" then
        max_mag = math.min(max_mag, est)
    end

    
    local on_ground = true
    pcall(function()
        if ok_bit and entity and entity.get_prop then
            local flags = entity.get_prop(ent, "m_fFlags") or 0
            on_ground = bit.band(flags, 1) == 1
        end
    end)
    if not on_ground then max_mag = max_mag * 0.55 end

    
    local forced_val = 0

    
    local last_yaw = (features and features.last_yaw)
    local ref_yaw = features and (features.goal_feet_yaw or features.feet_yaw)
    local desync = nil
    if last_yaw and ref_yaw then
        desync = normalize_angle(last_yaw - ref_yaw)
    end

    
    if not desync then
        forced_val = 0
    else
        local absd = math.abs(desync)
        
        if absd <= 10 then
            forced_val = 0
        else
            
            if ok_est and est and type(est) == "number" and est >= 8 then
                local mag = math.min(math.floor(max_mag + 0.5), math.floor(est + 0.5))
                local desired = math.min(absd, mag)
                
                if desired >= 8 then
                    forced_val = (desync >= 0) and desired or -desired
                else
                    forced_val = 0
                end
            else
                
                forced_val = 0
            end
        end
    end

    
    forced_val = round(forced_val)
    if forced_val > 60 then forced_val = 60 end
    if forced_val < -60 then forced_val = -60 end

    
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", true)
            plist.set(ent, "Force body yaw value", forced_val)
            state.forced = true
            state.forced_value = forced_val
            state.cooldown = now_time() + 0.5

            if client and type(client.delay_call) == "function" then
                client.delay_call(0.6, function()
                    pcall(function()
                        local t = now_time()
                        if not state.cooldown or t > state.cooldown then
                            safe_unset(ent)
                            state.forced = nil
                            state.forced_value = nil
                        end
                    end)
                end)
            end
        end
    end)
end

return M
]=]
c927["require/features/misc/roll"] = [[local c455, c456= pcall(require, "require/abc/menu_setup")

local c457= {}
local c458= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local c459= {ui.reference(item[1], item[2], item[3])}
    c457[i] = c459
    for _, ref in ipairs(c459) do
        c458[ref] = true
    end
end

local function c460(c461)
end

    local c462= 0
    local c463= 1

    if c455 and c456 and c456.ui then
        if c456.ui.fakelag_settings_roll ~= nil then
            local c464, c465= pcall(ui.get, c456.ui.fakelag_settings_roll)
            if c464 and c465 ~= nil then c462 = c465 end
        end
        if c456.ui.fakelag_settings_side ~= nil then
            local c464, c465= pcall(ui.get, c456.ui.fakelag_settings_side)
            if c464 and c465 ~= nil then c463 = c465 end
        end
    end

    local c466= entity.get_local_player()
    local c467= 0
    if c466 then
        local c468= entity.get_prop(c466, 'm_vecVelocity')
        if c468 then
            local c469= c468.x or c468[1] or 0
            local c470= c468.y or c468[2] or 0
            local c471= c468.z or c468[3] or 0
            c467 = math.sqrt(c469*c469 + c470*c470 + c471*c471)
        end
    end

    if c467 > 3 then
        pcall(ui.set, c457[1] and c457[1][1], 0)
        return
    end

    if c463 == 3 then
        pcall(ui.set, c457[1] and c457[1][1], -c462)
    elseif c463 == 2 then
        local c472= (globals.tickcount() % 20) < 10
        pcall(ui.set, c457[1] and c457[1][1], (c472 and c462 or -c462))
    elseif c463 == 1 then
        pcall(ui.set, c457[1] and c457[1][1], c462)
    end

end

client.set_event_callback('setup_command', function(c461)

    c460(c461)

end)]]
c927["require/features/misc/spin_on_dead_enemies"] = [[local c458= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local c459= {ui.reference(item[1], item[2], item[3])}
    c458[i] = c459
end

local c460, c461, c462, c463= entity, globals, ui, client
local c464= require("require/abc/menu_setup")
local c465= (c463.random_int(1, 2) == 1) and 1 or -1

local function c466()
    local c467= {
        {2, 'Off'}, {3, 'Local view'}, {4, {'Spin', 45}}, {5, {'Off', 0}}, {6, {'Off', 0}},
    }
    local c465= (c463.random_int(1, 2) == 1) and 1 or -1
    for _, v in ipairs(c467) do
        local c468, c469= v[1], v[2]
        local c459= c458[c468]
        if not c459 then goto continue end
        if type(c469) ~= 'table' then
            pcall(c462.set, c459[1], c469)
        else
            if c459[1] then pcall(c462.set, c459[1], c469[1]) end
            if c459[2] then
                if type(c469[2]) == 'number' and c469[1] == 'Spin' then
                    pcall(c462.set, c459[2], c469[2] * c465)
                else
                    pcall(c462.set, c459[2], c469[2])
                end
            end
        end
        ::continue::
    end
end

local function c470()
    local c471= (c461.maxplayers and c461.maxplayers() or 64)
    local c472, c473, c474= c460.get_classname, c460.is_enemy, c460.is_alive
    if not (c472 and c473 and c474) then return 0 end
    local c475= 0
    for i=1,c471 do
        if c472(i) == 'CCSPlayer' and c473(i) and c474(i) then c475 = c475 + 1 end
    end
    return c475
end

local function c476()
    if not c462.get(c464.ui.misc_spindead) then return end
    if c470() == 0 then c466() end
end

local c477, c478= pcall(require, "require/abc/callbacks")
if c477 and c478 then
    c478.callback('run_command', c476, { alive_only = true, require_login = true })
end
]]
c927["require/features/misc/walkbot"] = [[local c461= require("require/abc/callbacks")
local c462= require("require/abc/menu_setup")

local c463= nil
local c464= 1
local c465= 0
local c466= 40
local c467= 30
local c468= 450
local c469= 200
local c470= 8
local c471= {150, 300}
local c472= nil
local c473= nil
local c474= nil
local c475= 0
local c476= 700
local c477= 3

local c478= {}
local c479= 3
local c480= 4
local c481= 0
local c482= nil
local c483= 0
local c484= 500
local c485= 1500
local c486= 30
local c487= {}
local c488= false

local c489= 500 
local c490= 0

local c491= {
    { name = "A", x = -445.0, y = -1997.7, z = -180.0 },
    { name = "B", x = -2032.4, y = 259.8, z = -160.0 },
    { name = "Mid", x = -350.3, y = -617.1, z = -269.2 },
}

local function c492(c493)
    if not c493 then return false end
    local c494, c495= pcall(ui.get, c493)
    if not c494 then return false end
    return c495
end

local function c496(c497)
    while c497 > 180 do c497 = c497 - 360 end
    while c497 < -180 do c497 = c497 + 360 end
    return c497
end

local function c498(c499,c500,c501,c502,c503,c504)
    local c505, c506, c507= c499-c502, c500-c503, c501-c504
    return math.sqrt(c505*c505 + c506*c506 + c507*c507)
end

local function c508(c509,c510,c511,c512,c513,c514,c515)
    local c494, c516, c517= pcall(function()
        return client.trace_line(c509, c510, c511, c512, c513, c514, c515)
    end)
    if not c494 then return nil end
    return c516, c517
end

local function c518(c509,c519,c520,c521)
    local c522= c521 + 1000
    local c523= c521 - 1000
    local c516= c508(c509, c519, c520, c522, c519, c520, c523)
    if not c516 then return c521 end
    if type(c516) ~= 'number' then return c521 end
    local c524= c522 + (c523 - c522) * c516
    return c524
end

local function c525(c509,c510,c511,c512,c513,c514,c515)
    local c516= c508(c509, c510, c511, c512, c513, c514, c515)
    if not c516 then return false end
    if c516 >= 1 then return true end
    return false
end

local function c526(c519,c520)
    return tostring(math.floor(c519/50))..":"..tostring(math.floor(c520/50))
end

local function c527(c519,c520)
    local c528= c526(c519, c520)
    c478[c528] = (c478[c528] or 0) + 1
    if c478[c528] >= c479 then
        c487[c528] = true
    end
    return c478[c528]
end

local function c529(c519,c520)
    local c528= c526(c519, c520)
    c478[c528] = nil
end

local function c530(c509)
    local c531, c532, c533= entity.get_origin(c509)
    if not c531 then return nil end
    for i=1,c467 do
        local c534= math.random()*math.pi*2
        local c535= 200 + math.random()*800
        local c513= c531 + math.cos(c534)*c535
        local c514= c532 + math.sin(c534)*c535
        local c515= c533
            local c516= c508(c509, c531, c532, c533 + 16, c513, c514, c515 + 16)
        if c516 and c516 >= 1 then
            local c536= c518(c509, c513, c514, c515)
            return { x = c513, y = c514, z = c536 }
        end
        if c516 and c516 < 1 then
            local c537= c531 + (c513-c531)*c516
            local c538= c532 + (c514-c532)*c516
            local c539= c533 + (c515-c533)*c516
            for _, r in ipairs(c471) do
                for s=0,c470-1 do
                    local c497= (s/c470) * math.pi * 2
                    local c540= c537 + math.cos(c497)*r
                    local c541= c538 + math.sin(c497)*r
                    local c542= c518(c509, c540, c541, c539)
                    local c543= c508(c509, c531, c532, c533+16, c540, c541, c542+16)
                    local c544= c508(c509, c540, c541, c542+16, c513, c514, c515+16)
                    if c543 and c543>=1 and c544 and c544>=1 then
                        local c536= c518(c509, c513, c514, c515)
                        return { x = c513, y = c514, z = c536 }
                    end
                end
            end
        end
    end
    return nil
end

local function c545(c546)
    local c547= {}
    while c546 do
        c547[#c547+1] = { x = c546.x, y = c546.y, z = c546.z }
        c546 = c546.parent
    end
    local c548= {}
    for i=#c547,1,-1 do c548[#c548+1] = c547[i] end
    return c548
end

local function c549(c509,c550)
    local c531, c532, c533= entity.get_origin(c509)
    if not c531 then return nil end
    local c551= { x = c531, y = c532, z = c533 }
    c551.z = c518(c509, c551.x, c551.y, c551.z)
    local c552= { { x = c551.x, y = c551.y, z = c551.z, parent = nil } }
    local c553= {}
    local function c554(c555)
        local c556= tostring(math.floor(c555.x/50))..":"..tostring(math.floor(c555.y/50))
        c553[c556] = true
    end
    local function c557(c555)
        local c556= tostring(math.floor(c555.x/50))..":"..tostring(math.floor(c555.y/50))
        if c487[c556] then return true end
        return c553[c556]
    end
    c554(c551)
    local c558= 0
    while #c552 > 0 and c558 < c469 do
        local c559= table.remove(c552, 1)
        c558 = c558 + 1
        local c516= c508(c509, c559.x, c559.y, c559.z+16, c550.x, c550.y, c550.z+16)
        if c516 and c516 >= 1 then
            local c560= c545(c559)
            c560[#c560+1] = { x = c550.x, y = c550.y, z = c550.z }
            return c560
        end
        if c516 and c516 < 1 then
            local c537= c559.x + (c550.x-c559.x)*c516
            local c538= c559.y + (c550.y-c559.y)*c516
            local c539= c559.z + (c550.z-c559.z)*c516
            for _, r in ipairs(c471) do
                for s=0,c470-1 do
                    local c497= (s/c470) * math.pi * 2
                    local c540= c537 + math.cos(c497)*r
                    local c541= c538 + math.sin(c497)*r
                    local c542= c518(c509, c540, c541, c539)
                    if not c557({x=c540,y=c541}) then
                        local c543= c508(c509, c559.x, c559.y, c559.z+16, c540, c541, c542+16)
                        if c543 and c543 >= 1 then
                            c554({x=c540,y=c541})
                            table.insert(c552, { x = c540, y = c541, z = c542, parent = c559 })
                        end
                    end
                end
            end
        end
    end
    return nil
end

local function c561(c562,c509,c513,c514,c515)
    local c531, c532, c533= entity.get_origin(c509)
    if not c531 then return end
    
    local c505, c506= c513 - c531, c514 - c532
    local c563= math.sqrt(c505*c505 + c506*c506)
    if c563 <= 0 then return end
    local c564, c565= c505 / c563, c506 / c563
    local c566= 64
    local c510= c531 + c564 * c566
    local c511= c532 + c565 * c566
    local c512= c533

    
    local c567, c568= client.camera_angles()
    local c534= math.deg(math.atan2(c506, c505))
    local c569= c496(c534 - c568)
    local c570= math.rad(c569)
    local c571= math.cos(c570) * c468
    local c572= -math.sin(c570) * c468

    
    local c573, c574, c575= client.eye_position()
    if not c573 then c573, c574, ez = c531, c532, c533 end
    if type(c573) == 'table' then c573, c574, ez = c573[1], c573[2], c573[3] end
    local c576= c531 + c564 * 24
    local c577= c532 + c565 * 24
    local c578= c533 + 16
    local c579= c508(c509, c573, c574, c575, c576, c577, c578)
    if c579 and c579 < 1 then
        
        if c488 then pcall(client.log, "move_towards: short forward blocked, sidestep") end
        pcall(function() c562.forwardmove = 0; c562.sidemove = -c468 end)
        local c580= c531 - c565 * c566
        local c581= c532 + c564 * c566
        local c582= c508(c509, c531, c532, c533 + 16, c580, c581, c512 + 16)
        if c582 and c582 >= 1 then return end
        pcall(function() c562.forwardmove = 0; c562.sidemove = c468 end)
        local c583= c531 + c565 * c566
        local c584= c532 - c564 * c566
        local c585= c508(c509, c531, c532, c533 + 16, c583, c584, c512 + 16)
        if c585 and c585 >= 1 then return end
        
        pcall(function() c527(c513, c514); c465 = client.timestamp() + 250 end)
        c463 = nil
        return
    end

    
    pcall(function()
        c562.forwardmove = c571
        c562.sidemove = c572
    end)

    if c488 then pcall(client.log, string.format("move_towards: fwd=%.1f side=%.1f yaw_diff=%.1f", c571, c572, c569)) end

    local c516= c508(c509, c531, c532, c533 + 16, c510, c511, c512 + 16)
    if c516 and c516 < 1 then
        
        if c488 then pcall(client.log, "move_towards: forward blocked, attempting sidestep") end
        
        pcall(function() c562.forwardmove = 0; c562.sidemove = -c468 end)
        local c580= c531 - c565 * c566
        local c581= c532 + c564 * c566
        local c582= c508(c509, c531, c532, c533 + 16, c580, c581, c512 + 16)
        if c582 and c582 >= 1 then return end
        
        pcall(function() c562.forwardmove = 0; c562.sidemove = c468 end)
        local c583= c531 + c565 * c566
        local c584= c532 - c564 * c566
        local c585= c508(c509, c531, c532, c533 + 16, c583, c584, c512 + 16)
        if c585 and c585 >= 1 then return end
        
        pcall(function()
            c527(c513, c514)
            c465 = client.timestamp() + 250
        end)
        c463 = nil
        return
    end
end

c461.register("setup_command", function(c562)
    local c494, c586= pcall(function()
        if not c492(c462.ui.misc_walkbot) then return end
        local c509= entity.get_local_player()
        if not c509 or not entity.is_alive(c509) then return end
        local c587= client.timestamp()
        if c587 < c465 then return end

        
        do
            local c588= client.timestamp()
            if c588 - c490 >= c489 then
                local c589, c590, c591= entity.get_origin(c509)
                if c589 then
                    pcall(function()
                        client.log(string.format("walkbot_coord: %.1f %.1f %.1f", c589, c590, c591))
                    end)
                    c490 = c588
                end
            end
        end
        if client.key_state(87) or client.key_state(65) or client.key_state(83) or client.key_state(68) or client.key_state(32) or client.key_state(16) or client.key_state(17) then
            c465 = c587 + 500
            return
        end
        
        do
            local c592= entity.get_players(true) or {}
            for i=1,#c592 do
                local c593= c592[i]
                local c589, c590, c591= entity.get_origin(c593)
                if c589 then
                    local c594= pcall(function() return client.visible(c589, c590, c591) end)
                    if c594 and client.visible(c589, c590, c591) then
                        pcall(function()
                            local c595= c562.buttons or 0
                            c562.buttons = bit.bor(c595, 4) 
                        end)
                        break
                    end
                end
            end
        end
        
        local c531, c532, c533= entity.get_origin(c509)
        if c531 then
            local c592= entity.get_players(true) or {}
            if #c592 > 0 then
                if not c472 or not entity.is_alive(c472) or entity.is_dormant(c472) then
                    
                    local c596= {}
                    for i=1,#c592 do
                        local c593= c592[i]
                        local c589, c590, c591= entity.get_origin(c593)
                        if c589 then
                            local c597= c498(c531, c532, c533, c589, c590, c591)
                            c596[#c596+1] = { ent = c593, dist = c597 }
                        end
                    end
                    table.sort(c596, function(c497,c595) return c497.dist < c595.dist end)
                    if #c596 > 0 then
                                c472 = c596[1].ent  
                        c463 = nil
                        c464 = 1
                    end
                end
            else
                c472 = nil
            end
        end

        
        if c472 and entity.is_alive(c472) and not entity.is_dormant(c472) then
            local c513, c514, c515= entity.get_origin(c472)
            if c513 then
                local c536= c518(c509, c513, c514, c515)
                c473 = { x = c513, y = c514, z = c536 }
            else
                c472 = nil
                c473 = nil
            end
        else
            c472 = nil
            c473 = nil
        end

        
        do
            local c587= client.timestamp()
            if c531 then
                if not c482 then
                    c482 = { x = c531, y = c532, z = c533 }
                    c483 = c587
                else
                    if c587 - c483 >= c484 then
                        local c598= c498(c482.x, c482.y, c482.z, c531, c532, c533)
                        if c598 >= c486 then
                            
                            c481 = 0
                            c482 = { x = c531, y = c532, z = c533 }
                            c483 = c587
                        else
                            
                            if c587 - c483 >= c485 then
                                c481 = c481 + 1
                                c463 = nil
                                c465 = c587 + 300
                                c482 = { x = c531, y = c532, z = c533 }
                                c483 = c587
                                if c481 >= c480 then
                                    
                                    c472 = nil
                                    c473 = nil
                                    c481 = 0
                                end
                            end
                        end
                    end
                end
            end
        end

        if c473 then
            local c587= client.timestamp()
            local c599= (not c463) or (c587 > c475)
            if not c474 then c599 = true end
            if c474 and c473 and c498(c474.x, c474.y, c474.z, c473.x, c473.y, c473.z) > 100 then
                c599 = true
            end
            if c599 then
                local c593= c549(c509, c473)
                if c593 then
                    c463 = c593
                    c464 = 1
                    c475 = client.timestamp() + c476
                    c474 = { x = c473.x, y = c473.y, z = c473.z }
                else
                    
                    c472 = nil
                    c473 = nil
                    c463 = nil
                end
            end
        else
            if not c463 then
                local c600= c530(c509)
                
                if not c600 and #c491 > 0 then
                    local c601= c491[ math.random(1, #c491) ]
                    if c601 then c600 = { x = c601.x, y = c601.y, z = c601.z } end
                end
                if c600 then
                    local c593= c549(c509, c600)
                    if c593 then
                        c463 = c593
                        c464 = 1
                    else
                        
                        c463 = nil
                    end
                end
            end
        end
        if not c463 then return end
        local c531, c532, c533= entity.get_origin(c509)
        if not c531 then return end
        local c602= c463[c464+1] or c463[#c463]
        if not c602 then c463 = nil return end
        local c597= c498(c531, c532, c533, c602.x, c602.y, c602.z)
        if c597 <= c466 then
            c464 = c464 + 1
            
            c529(c602.x, c602.y)
            if c464 >= #c463 then c463 = nil return end
            return
        end
        do
            local c603= false
            if c472 and c473 then
                local c513, c514, c515= c473.x, c473.y, c473.z
                local c535= c498(c531, c532, c533, c513, c514, c515)
                if c535 > 1000 then
                    
                end
            end
            if not c603 then
                c561(c562, c509, c602.x, c602.y, c602.z)
            end
        end
    end)
    if not c494 then pcall(client.error_log, "walkbot error: "..tostring(c586)) end
end)

c461.register("paint", function()
    if not c492(c462.ui.misc_walkbot) then return end
    if not c463 or #c463 == 0 then return end
    local c509= entity.get_local_player()
    if not c509 then return end
    local c531, c532, c533= entity.get_origin(c509)
    if not c531 then return end
    local c604, c605, c606= c531, c532, c533
    c606 = c518(c509, c604, c605, c606)
    local c589, c590= renderer.world_to_screen(c604, c605, c606)
    for i=c464, #c463 do
        local c548= c463[i]
        if not c548 then break end
        local c607= c518(c509, c548.x, c548.y, c548.z)
        local c510, c511= renderer.world_to_screen(c548.x, c548.y, c607)
        if c510 and c511 and c589 and c590 then
            renderer.line(c589, c590, c510, c511, 255, 180, 0, 200)
            renderer.rectangle(c510-3, c511-3, 6, 6, 255, 80, 0, 200)
        end
        c589, py = c510, c511
    end
end)

return true
]]
c927["require/features/paint/aimbot_logs"] = [[local c464= require("require/abc/menu_setup")
local c465= require("require/abc/screen_logger")


local c466= nil
pcall(function() c466 = require('require/abc/callbacks') end)
if not c466 then error("callbacks manager required: require/abc/callbacks") end
local c467= {}
local c468= {}

local function c469()
	local c470= c464.ui.paint_aimbot_logs
	if not c470 then return false end
	local c471= ui.get(c470)
	if type(c471) == "string" then
		return c471 ~= "off"
	end
	return false
end

local function c472()
	local c470= c464.ui.paint_aimbot_logs
	if not c470 then return "gamesense" end
	local c471= ui.get(c470)
	if type(c471) == "table" then
		for _, v in ipairs(c471) do
			if v == "gamesense beta" then return "gamesense beta" end
			if v == "sodium" then return "sodium" end
			if v == "gamesense" then return "gamesense" end
		end
	elseif type(c471) == "string" then
		return c471
	end
	return "gamesense"
end

local c473= require("require/help/enemies")
local c474= require("require/abc/push_logger")
local c475= require("require/help/safe")

local c476, c477= pcall(require, "require/features/misc/collect")


local function c478(c479)
	if not c479 or c479 == 0 then return 0 end
	
	if c476 and c477 then
		local c480, c481= pcall(function()
			return c477.get_goal_feet_yaw(c479) or c477.get_feet_yaw(c479) or c477.get_lower_body_yaw(c479)
		end)
		if c480 and c481 and c481 ~= 0 then return c481 end
	end
	
	local c482, c483, c484, c485= pcall(function() return entity.get_prop(c479, "m_angAbsRotation") end)
	if c482 and c483 then
		if type(c483) == "table" then
			return c483[2] or 0
		else
			return c484 or 0
		end
	end
	
	local c486, c487= pcall(function() return entity.get_prop(c479, "m_flLowerBodyYawTarget") end)
	if c486 and c487 then return c487 end
	return 0
end


local function c488(c479)
	local c480, c489= pcall(function() return _G.player_labels end)
	if not c480 or type(c489) ~= "table" then return nil end
	local c490, c491= pcall(function() return c489[c479] end)
	if not c490 then return nil end
	return c491
end


local function c492()
	local c480, c493, c494, c495= pcall(function() return client.camera_angles() end)
	if not c480 then return nil, nil, nil end
	return c493 or 0, c494 or 0, c495 or 0
end


local function c496(c479)
	if not c479 or c479 == 0 then return nil, nil, nil end
	local c480, c497, c498, c499= pcall(function() return entity.get_prop(c479, "m_angAbsRotation") end)
	if not c480 then return nil, nil, nil end
	
	if type(c497) == "table" then
		return c497[1] or 0, c497[2] or 0, c497[3] or 0
	else
		return c497 or 0, c498 or 0, c499 or 0
	end
end

local function c500(c501)
	local c470= c464.ui.paint_logger
	if not c470 then return false end
	local c471= c475.safe_get(c470)
	if type(c471) == 'table' then
		for _, v in ipairs(c471) do
			if v == c501 then return true end
		end
		return false
	elseif type(c471) == 'string' then
		return c471 == c501
	end
	return false
end

local function c502(c503,c504,c494,c493) return string.format("\a%02x%02x%02x%02x", c503 or 255, c504 or 255, c494 or 255, c493 or 255) end
local function c505(c506,c503,c504,c494,c493)
	if not c506 or c506 == "" then return c506 end
	local c507= c502(c503,c504,c494,c493)
	local c508= c502(255,255,255,255)
	local c509= "([-+]?%d+%.?%d*%%?)"
	local c480, c510= pcall(function()
		return (c506:gsub(c509, function(c511)
			return c507 .. c511 .. c508
		end))
	end)
	if c480 and c510 then return c510 end
	return c506
end

local function c512(c506)
	if not c506 then return "" end
	return c506:gsub("([%^%$%(%)%%.%[%]%*%+%-%?])", "%%%1")
end

local function c513(c514,c515,c503,c504,c494,c493)
	if not c514 or c514 == "" then return c514 end
	if not c515 or c515 == "" then
		return c505(c514, c503,c504,c494,c493)
	end
	
	local c516, c517= c514:find(c515, 1, true)
	if not c516 then
		
		return c505(c514, c503,c504,c494,c493)
	end
	local c518= c514:sub(1, c516 - 1)
	local c519= c514:sub(c516, c517)
	local c520= c514:sub(c517 + 1)
	local c521= c505(c518, c503,c504,c494,c493)
	local c522= c505(c520, c503,c504,c494,c493)
	local c507= c502(c503,c504,c494,c493)
	local c508= c502(255,255,255,255)
	local c523= c507 .. c519 .. c508
	return (c521 or "") .. c523 .. (c522 or "")
end
local function c524(c525,c526,c527,c528)
	local c529= c525.target_name or "?"
	local c530= c525.hitgroup_name or "?"
	local c531= (c528 and c528.damage) or c525.damage or 0
	local c532= c525.damage or c531
	local c533= c531 - c532
	local c534
	if c531 == c532 then
		c534 = string.format("%d dmg", c531)
	elseif c533 < 0 then
		c534 = string.format("%d(-%d) dmg", c531, math.abs(c533))
	else
		c534 = string.format("%d(+%d) dmg", c531, c533)
	end
	local c535= (c526 == "gamesense" and c528 and c528.health) or c525.health or 0
	local c515= c528 and c528.reason or ""

	local c536= c525.backtrack_ticks or (c528 and c528.backtrack_ticks) or 0
	if c536 == 0 then
		local c537, c538= pcall(function() return globals.tickcount() end)
		if c537 and c525.tick then
			c536 = math.max(0, c538 - (c525.tick or c538))
		end
	end
	local c539= c525.backtrack or (c528 and c528.backtrack) or 0
	if c539 == 0 and c536 and c536 > 0 then
		local c540, c541= pcall(function() return globals.tickinterval() end)
		local c542= (c540 and c541) or 0
		c539 = math.floor(c536 * c542 * 1000)
	end
	if c539 == 0 and c525.time then
		local c543, c544= pcall(function() return globals.realtime() end)
		if c543 and c544 and c525.time then
			c539 = math.floor((c544 - c525.time) * 1000)
		end
	end
	local c545= c528 and c528.hitchance or c525.hitchance or "hehe"
	local c546= c525.safepoint or false
	local c547= c525.tick or 0
	local c548= c525.time or globals.realtime()
	local c549= c525.move or 0
	local c550= c525.t or 0
	local c551= (c528 and c528.boneyaw) or c478(c525.target) or 0
	local c552= (c528 and c528.resolver) or c488(c525.target) or "?"
	c552 = tostring(c552):lower()
	local c553, c554= c492()
	local c555, c556= c496(c525.target)
	local c557= c525.id or 0
	if c526 == "gamesense beta" then
		if c527 == "hit" then
			return string.format("[+] Hit %s's %s for %s (%d%%) bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				c529, c530, c534, c545, c539, c536,
				c554 or 0, c553 or 0, c556 or 0, c555 or 0, c549, c550, c551)
		else
			return string.format("[-] Missed %s's %s for %s (%d%%) due to %s bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				c529, c530, c534, c545, c515, c539, c536,
				c554 or 0, c553 or 0, c556 or 0, c555 or 0, c549, c550, c551)
		end
	elseif c526 == "gamesense" then
		if c527 == "hit" then
			return string.format("[gamesense] Hit %s's %s for %s (%d%%) (%dhp remaining)",
				c529, c530, c534, c545, c535)
		else
			return string.format("[gamesense] Missed %s's %s for %s (%d%%) reason=%s",
				c529, c530, c534, c545, c515)
		end
	elseif c526 == "sodium" then
		if c527 == "hit" then
			return string.format("hit %s's %s for %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				c529, c530, c534, c545, c539, c552, c551)
		else
			return string.format("missed %s's %s due to %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				c529, c530, c515, c545, c539, c552, c551)
		end
	else
		if c527 == "hit" then
			return string.format("a",
				c529, c530, dmg, c545, c549, c550, c551)
		else
			return string.format("b",
				c529, c530, dmg, c545, c515, c549, c550, c551)
		end
	end
end

c466.register('aim_fire', function(c558)

	if not c469() then return end
	
	c468[c558.id] = {
		id = c558.id,
		target = c558.target,
		target_name = entity.get_player_name(c558.target or 0),
		hitgroup = c558.hitgroup,
		hitgroup_name = c558.hitgroup and ({"head","chest","stomach","left arm","right arm","left leg","right leg"})[c558.hitgroup] or "?",
		damage = c558.damage,
		health = c558.health,
		backtrack = (c558.backtrack or 0) * globals.tickinterval() * 1000,
		backtrack_ticks = c558.backtrack or 0,
		hitchance = c558.hit_chance or 0,
		safepoint = c558.safepoint,
		tick = globals.tickcount(),
		time = globals.realtime(),
		move = c558.move or 0,
		t = c558.t or 0,
		boneyaw = c558.boneyaw or c478(c558.target) or 0,
	}
end, { require_login = true, alive_only = true })

c466.register('aim_hit', function(c558)

	if not c469() then return end
	local c559= c468[c558.id]
	if not c559 then return end
	local c526= c472()
	local c560= entity.get_prop(c558.target, "m_iHealth") or 0
	local c551= c559.boneyaw or c478(c559.target)
	local c561= c488(c559.target)
	local c562= c524(c559, c526, "hit", {
		damage=c558.damage,
		health=c560,
		backtrack=c559.backtrack,
		backtrack_ticks=c559.backtrack_ticks,
		boneyaw=c551,
		resolver=c561
	})
	if c526 == "gamesense beta" then
		
		client.color_log(165, 202, 42, c562)
		c465(c562, 4, 165, 202, 42, 255)
	elseif c526 == "sodium" then
		local c563= c559.damage or 0
		local c564= c558.damage or c563
		local c565= c564 - c563
		if c565 == 0 then
			client.color_log(165, 202, 42, c562)
			local c566= c505(c562, 165, 202, 42, 255)
			c465(c566, 4)
		else
			client.color_log(255, 204, 51, c562)

			local c567= string.format("(%+d)", c565)
			local c568= c512(c567)
			local c518, c519, c520= c562:match("^(.-)(" .. c568 .. ")(.*)$")
			if not c518 then
				local c566= c505(c562, 165, 202, 42, 255)
				c465(c566, 4)
			else
				local c569= c505(c518, 165, 202, 42, 255)
				local c570= c505(c520, 165, 202, 42, 255)
				local c571, c572, c573
				if c565 > 0 then
					c571, c572, db = 255, 204, 51
				else
					c571, c572, db = 217, 100, 100 
				end
				local c507= c502(c571, c572, c573, 255)
				local c508= c502(255, 255, 255, 255)
				local c574= c519:sub(2, -2) or c519
				local c575= "(" .. c507 .. c574 .. c508 .. ")"
				local c566= (c569 or "") .. c575 .. (c570 or "")
				c465(c566, 4)
			end
		end
	else
		client.log(c562)
		c465(c562, 4, 255, 255, 255, 255)
	end

	
	if c500('aimbot') then
		local c529= c559.target_name or "?"
		local c576= c559.hitgroup_name or "?"
		local c577= c558.damage or 0
		local c578= c559.hitchance or 0
		local c579= string.format("Hit %s's %s for %d(%d%%)", c529, c576, c577, c578)
		c474(c579, 4, 255, 255, 255, 255)
	end

	c468[c558.id] = nil
end, { require_login = true, alive_only = true })

c466.register('aim_miss', function(c558)

	if not c469() then return end
	local c559= c468[c558.id]
	if not c559 then return end
	local c526= c472()
	local c551= c559.boneyaw or c478(c559.target)
	local c561= c488(c559.target)
	local c562= c524(c559, c526, "miss", {reason=c558.reason or "?", boneyaw=c551, resolver=c561})
		if c526 == "gamesense beta" then
			client.color_log(217, 100, 100, c562)
			c465(c562, 4, 217, 100, 100, 255)
		elseif c526 == "sodium" then
			
			local c580= c558.reason or "?"
			local c566= c513(c562, c580, 217, 100, 100, 255)
			c465(c566, 4)
			client.color_log(217, 100, 100, c562)
		else
			c465(c562, 4, 255, 255, 255, 255)
			client.log(c562)
		end

	if c500('aimbot') then
		local c529= c559.target_name or "?"
		local c576= c559.hitgroup_name or "?"
		local c577= c559.damage or 0
		local c578= c559.hitchance or 0
		local c515= c558.reason or "?"
		local c579= string.format("Missed %s's %s for %d(%d%%) due to %s", c529, c576, c577, c578, c515)
		c474(c579, 4, 255, 255, 255, 255)
	end

	c468[c558.id] = nil
end, { require_login = true, alive_only = true })]]
c927["require/features/paint/animations"] = [[


local c467= nil
pcall(function() c467 = require('require/help/safe') end)
local c468= nil
pcall(function() c468 = require('require/abc/menu_setup') end)

local c469= nil
pcall(function() c469 = require('require/abc/callbacks') end)
if not c469 then error("callbacks manager required: require/abc/callbacks") end
local c470= require("gamesense/entity") or error("You're missing a required module: gamesense/entity")


local function c471()
    local c472= entity.get_local_player()
    if not c472 then return nil, nil end
    local c473, c474= pcall(function() return c470.new(c472) end)
    if not c473 then return c472, nil end
    return c472, c474
end




local c475= {
    STRAFE_YAW = 0,
    STAND = 1,
    LEAN_YAW = 2,
    SPEED = 3,
    LADDER_YAW = 4,
    LADDER_SPEED = 5,
    JUMP_FALL = 6,
    MOVE_YAW = 7,
    MOVE_BLEND_CROUCH = 8,
    MOVE_BLEND_WALK = 9,
    MOVE_BLEND_RUN = 10,
    BODY_YAW = 11,
    BODY_PITCH = 12,
    AIM_BLEND_STAND_IDLE = 13,
    AIM_BLEND_STAND_WALK = 14,
    AIM_BLEND_STAND_RUN = 14,
    AIM_BLEND_CROUCH_IDLE = 16,
    AIM_BLEND_CROUCH_WALK = 17,
    DEATH_YAW = 18
}

local function c476(c477)
    if not c477 then return 0 end
    local c478, c479, c480= entity.get_prop(c477, 'm_vecVelocity')
    if not c478 or not c479 then
        local c481= c478
        if type(c481) == 'table' then
            c478 = c481.x or c481[1] or 0
            c479 = c481.y or c481[2] or 0
        else
            return 0
        end
    end
    return math.sqrt((c478 or 0) * (c478 or 0) + (c479 or 0) * (c479 or 0))
end

local c482= {}
local c483= {}
for i, item in ipairs({
    { 'AA', 'Other', 'Leg movement' },

}) do
    local c484= {ui.reference(item[1], item[2], item[3])}
    c482[i] = c484
    for _, ref in ipairs(c484) do
        c483[ref] = true
    end
end






local c485= require("gamesense/antiaim_funcs")


local function c486()
    local c472= entity.get_local_player()
    if not c472 then return end
    entity.set_prop(c472, "m_flPoseParameter", 1, c475.JUMP_FALL)
end

local function c487()

    if c485.get_tickbase_shifting() > 0 then
        return
    end
    
    value = 0.5
    local c472= entity.get_local_player()
    if not c472 then return end
    local c488= globals.tickcount()
    local c489= math.floor(c488 / 2) % 2
    local c490= (c489 == 0) and -0.1 or 0.9
    entity.set_prop(c472, "m_flPoseParameter", math.random(0, 10) / value, c475.SPEED)
    entity.set_prop(c472, "m_flPoseParameter", math.random(0, 10) / 10, c475.MOVE_YAW)
    entity.set_prop(c472, "m_flPoseParameter", math.random(0, 10) / 10, c475.JUMP_FALL)
end



local function c491()
    local c472, c492= c471()
    if not c472 or not c492 then return end
    local c493= c492:get_anim_state()
    local c494= c492:get_anim_overlay(12)
    entity.set_prop(c472, "m_flPoseParameter", client.random_float(0, 1), 0)
    c494.weight = client.random_float(0, 1)
    ui.set(c482[1][1], "Always slide")
end

local function c495()
    local c472, c492= c471()
    if not c472 or not c492 then return end
    local c494= c492:get_anim_overlay(12)
    c494.weight = math.random(0,10) / 10
end


local function c496()
    local c472, c492= c471()
    if not c472 or not c492 then return end
    local c493= c492:get_anim_state()
    local c494= c492:get_anim_overlay(12)
    if c494 then c494.weight = 0.999 end
end

local function c497()
    local c472, c492= c471()
    if not c472 or not c492 then return end
    local c493= c492:get_anim_state()
    if c493 and c493.hit_in_ground_animation then
        entity.set_prop(c472, "m_flPoseParameter", 0.5, c475.BODY_PITCH)
    end
end

local function c498()
    local c472, c492= c471()
    if not c472 or not c492 then return end
    local c499= c492:get_anim_overlay(6)
    entity.set_prop(c472, "m_flPoseParameter", 0, c475.MOVE_YAW)
    if c499 then c499.weight = 1 end
end

local function c500()
    local c472, c492= c471()
    if not c472 or not c492 then return end
    local c501= c492:get_anim_overlay(12)
    local c502= c492:get_anim_overlay(6)
    if c501 then c501.weight = 0 end
    if c502 then c502.weight = 1 end
end

local function c503()
    local c472= entity.get_local_player()
    if not c472 then return end
    ui.set(c482[1][1], math.random(1,2) == 1 and "Always slide" or "Never slide")
    entity.set_prop(c472, "m_flPoseParameter", 8, 0)
end


local function c504()
    local c472, c492= c471()
    if not c472 or not c492 then return end
    local c505= c492:get_anim_overlay(9)
    if c505 then
        c505.weight = 1
        c505.sequence = 224
    end
end

local function c506()
    local c472, c492= c471()
    if not c472 or not c492 then return end
    local c507= c492:get_anim_overlay(0)
    if c507 then c507.sequence = 11 end
end

local function c508()

    local c472= c471()
    if not c472 then return end
    entity.set_prop(c472, 'm_flPoseParameter', 0, c475.BODY_PITCH)
    entity.set_prop(c472, 'm_flPoseParameter', math.random(-1, 1), c475.BODY_YAW)

end




c469.register('pre_render', function()
    local c472= entity.get_local_player()
    if not c472 then return end
    local c509= c476(c472)


    local c510= nil
    if c468 and c468.ui and c468.ui.paint_animations then
        if c467 and c467.safe_get then
            c510 = c467.safe_get(c468.ui.paint_animations)
        else
            local c473, c511= pcall(function() return ui.get(c468.ui.paint_animations) end)
            if c473 then c510 = c511 end
        end
    end

    local c512= {}
    if type(c510) == 'table' then
        for _, v in ipairs(c510) do c512[v] = true end
    end

    if c512['kingaru'] and c509 > 3 then c487() end
    if c512['body lean'] and c509 > 3 then c496() end
    if c512['static legs'] and c509 > 3 then c486() end
    if c512['moonwalk'] and c509 > 3 then c498() end
    if c512['allah'] and c509 > 3 then c500() end
    if c512['no pitch on land'] and c509 > 3 then c497() end
    if c512['reversed legs'] and c509 > 3 then c503() end
    if c512['earthquake'] then c495() end
    if c512['t-pose'] then c506() end
    if c512['blind'] then c504() end
    if c512['pitch up'] then c508() end
    if c512['gamesense legs'] then c491() end
end, { require_login = true, alive_only = true })

c469.register('setup_command', function(c513)

    local c472= entity.get_local_player()
    if not c472 then return end
    local c509= c476(c472)
    if c509 < 3 then return end

    local c510= nil
    if c468 and c468.ui and c468.ui.paint_animations then
        if c467 and c467.safe_get then
            c510 = c467.safe_get(c468.ui.paint_animations)
        else
            local c473, c511= pcall(function() return ui.get(c468.ui.paint_animations) end)
            if c473 then c510 = c511 end
        end
    end

    local c512= {}
    if type(c510) == 'table' then
        for _, v in ipairs(c510) do c512[v] = true end
    end

    

end, { require_login = true, alive_only = true })]]
c927["require/features/paint/aspect_ratio"] = [[
local c470= require("require/abc/menu_setup")
local c471= require("require/help/time")
local c472= require("require/help/safe")
local c473= require("ffi")
local c474= require("require/brain/dll")
local c475= nil
pcall(function() c475 = require('require/abc/callbacks') end)

if not (c474 and c474.aspect_update) then
    error("sodiumdll aspect_update export missing")
end

local c476= c473.new("struct AspectState[1]")
local c477= c473.new("double[1]")
local c478= c473.new("int[1]")
local c479= c474.aspect_update

local function c480()
    if cvar.r_aspectratio and cvar.r_aspectratio.get_float then
        return cvar.r_aspectratio:get_float()
    end
    return nil
end

local function c481(c482)
    if cvar.r_aspectratio and cvar.r_aspectratio.set_float then
        cvar.r_aspectratio:set_float(c482)
        return true
    elseif client and client.exec then
        client.exec("r_aspectratio " .. tostring(c482))
        return true
    end
    return false
end

c475.register('paint', function()
    if not ui.is_menu_open() then return end
    local c483= c470.ui.paint_aspect_ratio
    if not c483 then return end
    local c484= c472.safe_get(c483)
    if type(c484) ~= 'number' then return end
    c479(c476, c484, c480() or 0, c471.realtime(), c477, c478)
    if c478[0] ~= 0 then
        c481(c477[0])
    end
end, { require_login = true })

client.set_event_callback('shutdown', function()
    c476[0].initialized = 0
    c476[0].original = 0
    c476[0].last = 0
    c476[0].last_update = 0
end)]]
c927["require/features/paint/bomb_esp"] = [[local c473= nil
local c474= {}
local c475= nil
local c476= 500
local c477= 1000

local c478= 1.0
local c479= true
local c480= 0.25 
local c481= 0
local c482= 2

local c483= nil
pcall(function() c483 = require('require/abc/callbacks') end)
if not c483 then error("callbacks manager required: require/abc/callbacks") end

local function c484()
    c473 = nil
end

local function c485(c486)
    if not c486 then return 650, 2275 end
    local c487= tostring(c486):lower()
    if c487:find('de_dust2') then return 500, 1750 end
    if c487:find('de_ancient') then return 650, 2275 end
    if c487:find('de_anubis') then return 450, 1575 end
    if c487:find('de_inferno') then return 620, 2170 end
    if c487:find('de_mirage') then return 650, 2275 end
    if c487:find('de_nuke') then return 650, 2275 end
    if c487:find('de_overpass') then return 650, 2275 end
    if c487:find('de_vertigo') then return 500, 1750 end
    return 650, 2275
end

local function c488(c489,c490)
    c490 = tonumber(c490) or 0
    if c490 > 0 then
        local c491= 0.5
        local c492= 0.5
        local c493= c489 * c491
        local c494= (c489 - c493) * c492
        if c494 > tonumber(c490) then
            c494 = tonumber(c490) * (1.0 / c492)
            c493 = c489 - c494
        end
        c489 = c493
    end
    return c489
end

local function c495(c496,c497,c498,c499,c500,c501,c490,c502)
    if not c496 or not c497 or not c498 or not c499 or not c500 or not c501 then return 0 end
    local c503, c504= c485(c502)
    local c505= c504 / 3.0
    local c506= c496 - c499
    local c507= c497 - c500
    local c508= c498 - c501
    local c509= math.sqrt(c506*c506 + c507*c507 + c508*c508)
    local c510= math.exp( - (c509 * c509) / (2 * c505 * c505) )
    local c489= c503 * c510
    local c511= c488(c489, c490)
    return math.floor(c511 + 0.0)
end

local function c512(c513)
    if not c513 then return "?" end
    if c513 == 454 then return "A" end
    if c513 == 455 then return "B" end
    if c513 == 0 then return "A" end
    if c513 == 1 then return "B" end
    if type(c513) == "string" then
        local c514= c513:upper()
        if c514 == "A" or c514 == "B" then return c514 end
    end
    return tostring(c513)
end

c483.register('bomb_planted', function(c515)
    local c516= c515 and c515.site

    local c517= entity.get_all("CPlantedC4") or {}
    local c518= nil
    local c519= nil

    for i = 1, #c517 do
        local c513= c517[i]
        local c520= entity.get_prop(c513, "m_flC4Blow")
        if c520 and c520 > 0 then
            c518 = c520
            c519 = c513
            break
        end
    end

    if not c518 then
        local c521= 40
        if cvar and cvar.mp_c4timer then
            local c522, c523= pcall(function()
                if type(cvar.mp_c4timer.get_float) == "function" then
                    return cvar.mp_c4timer:get_float()
                elseif type(cvar.mp_c4timer.get_int) == "function" then
                    return cvar.mp_c4timer:get_int()
                else
                    return tonumber(cvar.mp_c4timer:get_string())
                end
            end)
            if c522 and c523 and tonumber(c523) then
                c521 = tonumber(c523)
            end
        end
        c518 = globals.curtime() + (c521 or 40)
    end

    c473 = {
        site = c516,
        blow_time = c518,
        entindex = c519,
        planted_at = globals.curtime()
    }
end, { require_login = true, alive_only = true })

c483.register('bomb_defused', c484, { require_login = true, alive_only = true })
c483.register('bomb_exploded', function(c515)
    
    local c524= c473 ~= nil
    local c525= globals.curtime()
    
    local c526= nil
    local c527= entity.get_local_player()
    if c524 and c527 then
        local function c528()
            
            local c529= nil
            if c473 and c473.entindex then
                local c522, c530, c531, c505= pcall(function() return entity.get_prop(c473.entindex, "m_vecOrigin") end)
                if c522 then
                    if type(c530) == "table" then
                        c529 = c530
                    elseif c530 ~= nil and c531 ~= nil and c505 ~= nil then
                        c529 = { c530, c531, c505 }
                    end
                end
            end
            if not c529 then
                local c517= entity.get_all("CPlantedC4") or {}
                for i = 1, #c517 do
                    local c513= c517[i]
                    local c522, c530, c531, c505= pcall(function() return entity.get_prop(c513, "m_vecOrigin") end)
                    if c522 then
                        if type(c530) == "table" then
                            c529 = c530
                            break
                        elseif c530 ~= nil and c531 ~= nil and c505 ~= nil then
                            c529 = { c530, c531, c505 }
                            break
                        end
                    end
                end
            end
            if not c529 then return nil end
            local c522, c532, c533, c534= pcall(function() return client.eye_position() end)
            local c496, c497, c498
            
            local c535, c536, c537, c538= pcall(function() return entity.get_origin(c527) end)
            if c535 then
                if type(c536) == "table" then
                    if #c536 >= 3 then c496, c497, pz = c536[1], c536[2], c536[3] end
                elseif c536 ~= nil and c537 ~= nil and c538 ~= nil then
                    c496, c497, pz = c536, c537, c538
                end
            end
            
            if (not c496 or not c497 or not c498) and c522 and c532 ~= nil and c533 ~= nil and c534 ~= nil then
                c496, c497, pz = c532, c533, c534
            end
            if not c496 or not c529 or #c529 < 3 then return nil end
            local c499, c500, c501= c529[1], c529[2], c529[3]
            
            local c539, c490= pcall(function() return entity.get_prop(c527, "m_ArmorValue") end)
            c490 = tonumber(c490) or 0
            local c502= nil
            local c540, c541= pcall(function()
                if type(client.mapname) == 'function' then return client.mapname() end
                if cvar and cvar.mapname then return cvar.mapname:get_string() end
                if cvar and cvar.map then return cvar.map:get_string() end
                return nil
            end)
            if c540 then c502 = c541 end
            local c542= c495(c496, c497, c498, c499, c500, c501, c490, c502)
            local c543= math.floor((c542 * (c478 or 1.0)) + 0.5)
            return c542, c543, math.sqrt((c496-c499)^2 + (c497-c500)^2 + (c498-c501)^2)
        end
        local c544, c545, c546= c528()
        c526 = c545
    end

    
    c484()

    
    if c479 and c526 and c526 > 0 then
        local c547= 0.15
        client.delay_call(c547, function()
            local c548= globals.curtime()
            if c548 - c481 < c482 then return end
            local c549= entity.get_local_player()
            if not c549 then return end
            local c522, c550= pcall(function() return entity.get_prop(c549, "m_iHealth") end)
            c550 = tonumber(c550)
            local c551= c475
            if not c551 or not c550 then return end
            local c494= c551 - c550
            if c494 <= 0 then return end

            
            local c552= (c526 and c526 > 0) and c526 or 1
            local c553= c494 / c552
            if c553 <= 0 then return end

            
            local c554= (c478 or 1.0) * (1 + (c553 - 1) * c480)
            if c554 < 0.05 then c554 = 0.05 end
            if c554 > 10 then c554 = 10 end
            local c555= c478
            c478 = c554
            c481 = globals.curtime()
            
            pcall(function()
                client.log("[bomb_esp] auto-tuned scale %.3f -> %.3f (ratio=%.3f, predicted=%d, actual=%d)", c555, c478, c553, c526 or 0, c494)
            end)
        end)
    end
end, { require_login = true, alive_only = true })
c483.register('round_start', c484, { require_login = true, alive_only = true })
c483.register('round_start', function()
    c475 = nil
end, { require_login = true, alive_only = true })
c483.register('player_spawned', function()
    c475 = nil
end, { require_login = true, alive_only = true })


c483.register('player_hurt', function(c515)
    if not c515 then return end
    local c527= entity.get_local_player()
    if not c527 then return end
    local c556= client.userid_to_entindex(c515.userid)
    if c556 ~= c527 then return end

    
    local c557= c515.dmg_health or c515.damage or c515.hp or 0
    c557 = tonumber(c557) or 0
    if c557 <= 0 then return end

    
    local c558= string.format("-%d HP", c557)
    
    table.insert(c474, { t = globals.curtime(), text = c558 })
end, { require_login = true, alive_only = true })


c483.register('paint', function()
    local c559, c560= pcall(require, "require/abc/menu_setup")
    if not c559 or not c560 or not c560.ui then return end
    local c561, c562= pcall(ui.get, c560.ui.paint_bombwarning)
    if not c561 or not c562 then return end

    local c548= globals.curtime()

    
    local c527= entity.get_local_player()
    if c527 then
        local c522, c563= pcall(function() return entity.get_prop(c527, "m_iHealth") end)
        c563 = tonumber(c563)
        if c563 then
            if c475 == nil then
                c475 = c563
            else
                if c563 < c475 then
                    local c557= c475 - c563
                    table.insert(c474, { t = c548, text = string.format("-%d HP", c557) })
                end
                c475 = c563
            end
        end
    else
        c475 = nil
    end

    
    for i = #c474, 1, -1 do
        local c564= c474[i]
        local c565= c548 - c564.t
        local c566= 1.4
        if c565 >= c566 then
            table.remove(c474, i)
        else
            local c567= math.floor(255 * (1 - (c565 / c566)))
            if c567 < 0 then c567 = 0 end
            
            renderer.indicator(255, 210, 0, c567, c564.text)
        end
    end

    
    if c473 then
        local c527= entity.get_local_player()
        local c529= nil
        if c473.entindex then
            local c522, c530, c531, c505= pcall(function() return entity.get_prop(c473.entindex, "m_vecOrigin") end)
            if c522 then
                if type(c530) == "table" then
                    c529 = c530
                elseif c530 ~= nil and c531 ~= nil and c505 ~= nil then
                    c529 = { c530, c531, c505 }
                end
            end
        end
        
        if not c529 then
            local c517= entity.get_all("CPlantedC4") or {}
            for i = 1, #c517 do
                local c513= c517[i]
                local c522, c530, c531, c505= pcall(function() return entity.get_prop(c513, "m_vecOrigin") end)
                if c522 then
                    if type(c530) == "table" then
                        c529 = c530
                        break
                    elseif c530 ~= nil and c531 ~= nil and c505 ~= nil then
                        c529 = { c530, c531, c505 }
                        break
                    end
                end
            end
        end

        if c529 and c527 then
            local c496, c497, c498= nil, nil, nil
            local c522, c532, c533, c534= pcall(function() return client.eye_position() end)
            if c522 and c532 ~= nil and c533 ~= nil and c534 ~= nil then
                c496, c497, pz = c532, c533, c534
            else
                local c535, c536, c537, c538= pcall(function() return entity.get_origin(c527) end)
                if c535 then
                    if type(c536) == "table" then
                        if #c536 >= 3 then c496, c497, pz = c536[1], c536[2], c536[3] end
                    elseif c536 ~= nil and c537 ~= nil and c538 ~= nil then
                        c496, c497, pz = c536, c537, c538
                    end
                end
            end

            if c496 and c529 and #c529 >= 3 then
                local c499, c500, c501= c529[1], c529[2], c529[3]
                
                local c539, c490= pcall(function() return entity.get_prop(c527, "m_ArmorValue") end)
                c490 = tonumber(c490) or 0
                local c540, c541= pcall(function()
                    if type(client.mapname) == 'function' then return client.mapname() end
                    if cvar and cvar.mapname then return cvar.mapname:get_string() end
                    if cvar and cvar.map then return cvar.map:get_string() end
                    return nil
                end)
                local c502= c540 and c541 or nil
                local c544= c495(c496, c497, c498, c499, c500, c501, c490, c502)
                local c568= math.floor((c544 * (c478 or 1.0)) + 0.5)

                
                renderer.indicator(255, 210, 0, 255, string.format("-%d HP", c568))
            end
        end
    end

    
    if c473 then
        
        if c473.entindex then
            local c520= entity.get_prop(c473.entindex, "m_flC4Blow")
            if c520 and c520 > 0 then
                c473.blow_time = c520
            end
        end

        local c569= (c473.blow_time or 0) - c548
        if c569 <= 0 then
            c473 = nil
            return
        end

        local c570= c512(c473.site)
        local c558= string.format("%s - %.1fs", c570, c569)
        renderer.indicator(255, 255, 255, 255, c558)
    end
end, { require_login = true, alive_only = true })]]
c927["require/features/paint/bullet_tracer"] = [[local c476= require("ffi")
local c477= require('require/help/time')
local c478= nil
local c479= require('require/help/self')
pcall(function() c478 = require('require/help/safe') end)
pcall(function() DLL = require('require/brain/dll') end)
pcall(function() menu_setup = require('require/abc/menu_setup') end)
pcall(function() cb = require('require/abc/callbacks') end)

local c480= 10
local c481= 7.0
local c482= {255,255,255,255}
local c483= 0.05
local c484= 8192

if not (DLL and DLL.tracer_reset and DLL.tracer_push_shot and DLL.tracer_set_impact and DLL.tracer_collect) then return end
DLL.tracer_reset()

local c485= 7
local c486= c476.new("double[?]", c480 * c485)

local c487= c477.realtime

cb.register('weapon_fire', function(c488)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if c479.index() ~= client.userid_to_entindex(c488.userid) then return end
    local c489= c479.weapon()
    if c489 then
        local c490= entity.get_classname(c489) or ""
        local c491= c490:lower()
        if c491:find("knife") or c491:find("grenade") or c491:find("decoy") or c491:find("molotov") or c491:find("flash") or c491:find("smoke") or c491:find("taser") or c491:find("zeus") then
            return
        end
    end

    local c492,c493,c494= client.eye_position()
    if not c492 then c492,c493,sz = entity.get_origin(c479.index()) end
    c492,c493,sz = tonumber(c492) or 0, tonumber(c493) or 0, tonumber(c494) or 0
    DLL.tracer_push_shot(c492, c493, c494, c487())
end, { require_login = true, alive_only = true })
 
cb.register('bullet_impact', function(c488)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if c479.index() ~= client.userid_to_entindex(c488.userid) then return end
    local c495,c496,c497= tonumber(c488.x) or 0, tonumber(c488.y) or 0, tonumber(c488.z) or 0
    DLL.tracer_set_impact(c495, c496, c497, c487())
end, { require_login = true, alive_only = true })

if not cb then error("callbacks manager required: require/abc/callbacks") end

cb.register('paint', function()
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    local c498= c487()
    local c499= { client.camera_angles() }
    local c500= DLL.tracer_collect(c498, c481, c483, c499[1] or 0, c499[2] or 0, c484, c482[4] or 255, c486, c480)
    for i=0, (c500 or 0)-1 do
        local c501= i * c485
        local c492, c493, c494= c486[c501], c486[c501 + 1], c486[c501 + 2]
        local c502, c503, c504= c486[c501 + 3], c486[c501 + 4], c486[c501 + 5]
        local c505= c486[c501 + 6]
        local c506,c507= renderer.world_to_screen(c492, c493, c494)
        local c508,c509= renderer.world_to_screen(c502, c503, c504)
        if c506 and c508 then
            renderer.line(c506, c507, c508, c509, c482[1], c482[2], c482[3], c505)
        end
    end
end, { require_login = true, alive_only = true })]]
c927["require/features/paint/clantag"] = [[local c479=require("require/abc/menu_setup")
local c480=require("require/help/safe")
local c481=require("require/help/string")
local c482=require("require/help/time")
local c483=require("require/brain/dll")
local c484=require("ffi")
local c485=pcall
local c486=ui.reference
local c487=ui.set
local c488=client.set_clan_tag
local c489, c490= pcall(require, "require/abc/callbacks")
if not c489 or not c490 then error("require/abc/callbacks is required by clantag.lua") end
if not c483 or type(c483) ~= "table" or not c483.clantag_anim then return end

local c491=64
local c492=c484.new("char[?]",c491)
local c493,c494,c495=nil,0,nil
local function c496(c497)
    local c498={{"MISC","Misc","Clantag spammer"},{"MISC","Miscellaneous","Clantag spammer"},{"MISC","Misc","Clan tag spammer"},{"MISC","Miscellaneous","Clan tag spammer"},{"MISC","Misc","Clantag spamer"},{"MISC","Miscellaneous","Clantag spamer"}}
    for _,v in ipairs(c498) do
        local c499,c500=c485(c486,v[1],v[2],v[3])
        if c499 and c500 and c485(c487,c500,c497) then return true end
    end
    return false
end
local c501=function() return c496(true) end
local c502=function() return c496(false) end
c490.register('paint', function()
    local c500=c479.ui.paint_clantag if not c500 then return end
    local c503=c480.safe_get(c500) if type(c503)~='string' then return end
    local c504=c481.lower(c503) if c504==c493 and c504~='sodium' and c494==0 then return end
    if c504=='off' then c502(); c494=3; c485(c488," ")
    elseif c504=='gamesense' then if not c501() then c485(c488,"gamesense") end
    elseif c504 == 'sodium' then
        c502()

        if not c495 or type(c495) ~= 'table' or not c495.start then
            c495 = { start = c482.realtime() }
        end

        local c505= c482.realtime() or 0
        c484.fill(c492, c491, 0)
        local c506= c483.clantag_anim(c495.start or 0, c505, c492, c491)
        if c506 and c506 ~= 0 then
            c485(c488, c484.string(c492))
        else
            c485(c488, "")
        end
    end
    if c494>0 then c485(c488,"") c494=c494-1 end
    c493=c504
end, { require_login = true })]]
c927["require/features/paint/custom_scope"] = [[]]
c927["require/features/paint/damage"] = [[local c485= require("require/abc/menu_setup")
local c486= require("require/brain/api/vector/vector")
local c487= { shots = {}, last = 0 }


local c488= 5
local c489= 3
local c490= 10

local function c491()
	local c492= 0
	for i = 1, #c487.shots do
		local c493= c487.shots[i]
		if c493 and c493.impacts then c492 = c492 + #c493.impacts end
	end
	return c492
end

local function c494()
	while c491() > c490 do
		
		if #c487.shots == 0 then break end
		local c495= false
		for si = 1, #c487.shots do
			local c493= c487.shots[si]
			if c493 and c493.impacts and #c493.impacts > 0 then
				table.remove(c493.impacts, 1)
				c495 = true
				
				if #c493.impacts == 0 then
					table.remove(c487.shots, si)
				end
				break
			else
				
				table.remove(c487.shots, si)
				c495 = true
				break
			end
		end
		if not c495 then break end
	end
end

local function c496()
	local c497= c485.ui.paint_hitmarker
	if not c497 then return false end
	local c498= ui.get(c497)
	if type(c498) == "table" then
		for _, v in ipairs(c498) do
			if v == "damage" then return true end
		end
	end
	return false
end

local c499, c500= pcall(require, "require/abc/callbacks")
local function c501(c502)
	if not c496() then c487 = { shots = {}, last = 0 } return end
	if not c496() then return end
	local c503= entity.get_local_player()
	if not c503 then return end
	local c504= c502.target or c502.target_index
	if type(c504) ~= 'number' or c504 == 0 or not entity.is_enemy(c504) then return end
	local c505= c502.damage or 0
	local c506= c502.hitgroup == 1
	local c507= c502.health == 0
	local c508, c509, c510= entity.hitbox_position(c504, c502.hitgroup or 'head')
	if not c508 then c508, c509, z = entity.get_origin(c504) end
	if not c508 then return end
	local c511= c486.make(c508, c509, c510)
	local c512= globals.realtime()
	local c513= {255, 255, 255}
	if c507 then c513 = {217, 100, 100} elseif c506 then c513 = {165, 202, 42} end

	local c514
	if c487.last and c512 - c487.last < 0.05 then
		c514 = c487.shots[#c487.shots]
	else
		c487.last = c512
		c514 = { impacts = {}, finished = false, t = c512 }
		c487.shots[#c487.shots + 1] = c514
		if #c487.shots > 12 then table.remove(c487.shots, 1) end
	end

	if c514 then
		c514.impacts[#c514.impacts + 1] = { dmg = c505, x = c508, y = c509, z = c510, pos = c511, t = c512, color = c513 }
		if #c514.impacts > c489 then table.remove(c514.impacts, 1) end
		
		c494()
	end
end

local function c515(c502)
	if c496() then
		local c512= globals.realtime()
		local c516= 1.4
		local c517= 32
		local c518= 1
		while c518 <= #c487.shots do
			if c512 - (c487.shots[c518].t or 0) > (c516 + 0.5) then
				table.remove(c487.shots, c518)
			else
				c518 = c518 + 1
			end
		end
		local c519= {}
		local c520= 12
		for si = #c487.shots, 1, -1 do
			local c514= c487.shots[si]
			for ii = #c514.impacts, 1, -1 do
				table.insert(c519, c514.impacts[ii])
				if #c519 >= c520 then break end
			end
			if #c519 >= c520 then break end
		end

		local c521= math.min(4, #c519)
		for j = 1, c521 do
			local c522= c519[j]
			local c523, c524= renderer.world_to_screen(c522.pos.x, c522.pos.y, c522.pos.z)
			if c523 and c524 then
				local c525= c512 - (c522.t or 0)
				local c526= math.min(1, c525 / c516)
				local c527= c517 * (1 - math.exp(-3 * c526))
				local c528= math.floor(math.max(0, (1 - c526) * 255))
				if c528 > 0 then
					renderer.text(c523, c524 - c527, c522.color[1], c522.color[2], c522.color[3], c528, "crdb-", 0, tostring(c522.dmg))
				end
			end
		end
	else
		c487 = { shots = {}, last = 0 }
	end
end

c500.callback('aim_hit', c501, { alive_only = true, require_login = true })
c500.callback('paint', c515, { alive_only = true, require_login = true })]]
c927["require/features/paint/damage_penetration"] = [[
local function c488(c489,c490)
	if c490 and rawget(_G, c490) ~= nil then
		return rawget(_G, c490)
	end
	local c491, c492= pcall(require, c489)
	if c491 then return c492 end
	return nil
end

local c493= c488('ui', 'ui')
local c494= c488('client', 'client')
local c495= c488('entity', 'entity')
local c496= c488('renderer', 'renderer')

if not c493 or not c494 or not c495 or not c496 then
	return
end

local c497= c493.new_checkbox
local c498= c493.get
local c499= c493.reference

local c500= c494.screen_size
local c501= c494.set_event_callback
local c502= c494.unset_event_callback
local c503= c494.eye_position
local c504= c494.camera_angles
local c505= c494.trace_line
local c506= c494.trace_bullet

local c507= c495.get_local_player
local c508= c495.is_alive or function() return false end
local c509= c495.get_player_weapon or function() return nil end
local c510= c495.get_classname or function() return nil end

local c511= c496.text

local c512= math.floor
local c513= math.cos
local c514= math.sin
local c515= math.rad

sodium_SUPPRESS = sodium_SUPPRESS or false
sodium_REFS = sodium_REFS or {}
sodium_FN = sodium_FN or {}

local function c516(c517)
	if not c517 then return false end
	local c491, c518= pcall(c498, c517)
	return c491 and c518 == true
end


if type(sodium_FN.min_dmg_active) ~= 'function' then
	sodium_FN.min_dmg_active = function()
		ensure_min_damage_refs()
		local c519= sodium_REFS.min_dmg_hotkey
		if c519 then
			local c491, c518= pcall(c498, c519)
			if c491 then return c518 == true end
		end
		return false
	end
end

if type(sodium_FN.min_dmg_value) ~= 'function' then
	sodium_FN.min_dmg_value = function()
		ensure_min_damage_refs()
		local c520= sodium_REFS.min_dmg_slider
		if not c520 then return nil end
		local c491, c518= pcall(c498, c520)
		if c491 and type(c518) == 'number' then
			return c518
		end
		return nil
	end
end

local function c521(c522,c523)
	if sodium and sodium.ui and sodium.ui[c522] then
		return sodium.ui[c522]
	end
	local c524= 'ui_' .. c522
	if sodium_REFS[c524] then
		return sodium_REFS[c524]
	end
	if not c523 then return nil end
	local c517= c523()
	if c517 then
		sodium_REFS[c524] = c517
	end
	return c517
end


local c525= nil
pcall(function() c525 = require('require/abc/menu_setup') end)


local function c526(c527)
    if not c493.get(c525.ui.paint_show_damage_penetration) then return end
	if not c509 or not c510 then return false end
	local c528= c509(c527)
	if not c528 then return false end
	local c529= c510(c528)
	if not c529 then return false end
	if c529:sub(1, 7) ~= 'CWeapon' then return false end
	if c529:find('Grenade', 1, true) or c529:find('Taser', 1, true) or c529:find('C4', 1, true) then return false end
	return true
end

local function c530()
    if not c493.get(c525.ui.paint_show_damage_penetration) then return end
	if not c507 then return nil end
	local c531= c507()
	if not c531 then return nil end
	if c508 and not c508(c531) then return nil end
	return c531
end




local function c532()
    if not c493.get(c525.ui.paint_show_damage_penetration) then return end
	local c531= c530()
	if not c531 or not c526(c531) then return end
	local c533, c534, c535= c503()
	if not c533 or not c534 or not c535 then return end
	local c536, c537= c504()
	if not c536 or not c537 then return end
	local c538, c539= c513(c515(c536)), c514(c515(c536))
	local c540, c541= c513(c515(c537)), c514(c515(c537))
	local c542, c543, c544= c538 * c540, c538 * c541, -c539
	local c545= 8192
	local c546, c547, c548= c533 + c542 * c545, c534 + c543 * c545, c535 + c544 * c545
	local c549= select(1, c505(c531, c533, c534, c535, c546, c547, c548)) or 1
	if c549 < 0 then c549 = 0 end
	if c549 > 1 then c549 = 1 end

	local c550
	if c549 >= 0.999 then
		c550 = { 256, 512, 1024, 2048, 4096 }
	else
		local c551= c545 * c549
		c550 = { c551 + 4, c551 + 16, c551 + 32, c551 + 64, c551 + 128, c551 + 256 }
	end

	local c552= 0
	for i = 1, #c550 do
		local c553= c550[i]
		if c553 > c545 then c553 = c545 end
		local c554, c555, c556= c533 + c542 * c553, c534 + c543 * c553, c535 + c544 * c553
		local c557, c558= c506(c531, c533, c534, c535, c554, c555, c556, true)
		if c558 and c558 > c552 then c552 = c558 end
		if c553 == c545 then break end
	end

	local c559= c512((c552 or 0) + 0.5)
	if c559 <= 0 then return end

	local c560, c561= c500()
	if not c560 or not c561 then return end
	local c562= c560 / 2
	local c563= c561 / 2 + 8
	local c564= tostring(c559)
	local c565= false
	if sodium_FN.draw_surface_text_centered and _G.sodium_FONTS and _G.sodium_FONTS.pen then
		c565 = sodium_FN.draw_surface_text_centered(_G.sodium_FONTS.pen, c562, c563, c564, 177, 194, 89, 255) and true or false
	end
	if not c565 then
		c511(c562, c561 / 2 + 12, 177, 194, 89, 255, 'cb', 0, c564)
	end
end

local function c566()
    if not c493.get(c525.ui.paint_show_damage_penetration) then return end
	if sodium_SUPPRESS then return end
	c532()
end

local c567, c568= pcall(require, "require/abc/callbacks")
if c567 and c568 then
	if _G.sodium_B_MD_DP and type(_G.sodium_B_MD_DP) == 'number' then
		pcall(c568.unregister, _G.sodium_B_MD_DP)
	end

	local function c569()
		if sodium_SUPPRESS then return end
        if not c493.get(c525.ui.paint_show_damage_penetration) then return end
		c532()
	end

	_G.sodium_B_MD_DP = c568.register('paint', c569, { require_login = true, alive_only = true })
else
	if c502 and _G.sodium_B_MD_DP then
		c502('paint', _G.sodium_B_MD_DP)
	end

	_G.sodium_B_MD_DP = c566
	c501('paint', c566)
end]]
c927["require/features/paint/entidx"] = [[local c491= require("require/abc/menu_setup")
local c492= require("require/help/enemies")

local function c493()
	if not ui.get(c491.ui.paint_entidx) then return end

	local c494= c492.get_current_threat and c492.get_current_threat() or client.current_threat and client.current_threat() or nil
	if c494 and c494 ~= 0 then
		local c495= entity.get_player_name(c494)

		renderer.text(70, 120, 255, 0, 0, 255, "b", 0, string.format("entidx%d: %s", c494, c495))
	end
end

local c496, c497= pcall(require, "require/abc/callbacks")
if c496 and c497 and c497.callback then
	c497.callback("paint", c493, { alive_only = true, require_login = true })
else
	client.set_event_callback("paint", c493)
end]]
c927["require/features/paint/filter_console"] = [[


local c494= pcall(require, 'require/abc/menu_setup') and require('require/abc/menu_setup') or nil
local c495= c494 and c494.ui and c494.ui.paint_filter_console or nil

local c496= cvar.con_filter_enable
local c497= cvar.con_filter_text

local c498= { enable = nil, text = nil }

local function c499()
    if c498.enable == nil then
        
        local c500, c501= pcall(function() return c496:get_int() end)
        c498.enable = (c500 and c501) and c501 or nil
    end

    if c498.text == nil then
        local c500, c502= pcall(function() return c497:get_string() end)
        c498.text = (c500 and c502) and c502 or nil
    end
end

local function c503()
    if c498.enable ~= nil then
        pcall(function() c496:set_raw_int(c498.enable) end)
    end

    if c498.text ~= nil then
        pcall(function() c497:set_string(c498.text) end)
    else
        pcall(function() c497:set_string('') end)
    end

    c498.enable = nil
    c498.text = nil
end

local function c504()
    c499()
    pcall(function() c496:set_raw_int(1) end)
    pcall(function() c497:set_string('[gamesense]') end)
end




local function c505()
    if not c495 then
        return false
    end

    
    if type(c495) == 'table' and c495.get then
        local c500, c501= pcall(function() return c495:get() end)
        return c500 and c501 or false
    end

    
    local c500, c501= pcall(function() return ui.get(c495) end)
    return c500 and c501 or false
end

local function c506()
    if not c505() then
        c503()
        return
    end

    c504()
    client.delay_call(1, c506)
end


client.delay_call(0.1, c506)


client.set_event_callback('shutdown', c503)

return {
    
    get_ui_state = c505,
    restore_values = c503,
    apply_filter = c504,
}
]]
c927["require/features/paint/hit_miss_indicator"] = [[local c497=require("require/help/math")
local c498=require("require/help/self")
local c499=require("require/help/safe")
local c500=require("require/abc/menu_setup")

local c501,c502=0,0
local c503=function() return c500 and c500.ui and c499.safe_get(c500.ui.paint_hitmiss_indicator) end
local c504=function() c501,shots=0,0 end

client.set_event_callback("aim_fire", function(c505)
    if not c503() or not c498.is_alive() then return end
    local c506= nil
    if c505.userid then c506 = client.userid_to_entindex(c505.userid) end
    if (not c506 or c506 == 0) and c505.player then c506 = c505.player end
    if c506 == c498.index() then c502 = c502 + 1 end
end)

client.set_event_callback("aim_hit", function(c505)
    if not c503() or not c498.is_alive() then return end
    local c506= nil
    if c505.userid then c506 = client.userid_to_entindex(c505.userid) end
    if (not c506 or c506 == 0) and c505.attacker then c506 = client.userid_to_entindex(c505.attacker) end
    if (not c506 or c506 == 0) and c505.player then c506 = c505.player end
    if c506 == c498.index() then c501 = c501 + 1 end
end)


client.set_event_callback("paint",function()
    if not c503() then return end
    local c507=c502>0 and c497.round(c501/c502*100,1) or 0
    renderer.indicator(255,255,255,255,string.format("%d / %d (%.1f)",c501,c502,c507))
end)
defer(c504)]]
c927["require/features/paint/indicators_bold"] = [[local c500= { 0, 0, 0 }
local c501= { 3, 3, 3 }
local c502= { 6, 6, 6 }

local function c503(c504,c505,c506)
  return c504 + (c505 - c504) * c506
end

local c507, c508= pcall(require, "require/abc/menu_setup")
local c509, c510= pcall(require, "require/help/string")
local function c511(c512)
  if c512 == nil then return "" end
  if c509 and c510 and c510.lower then
    return c510.lower(tostring(c512))
  end
  return tostring(c512)
end
local c513, c514= pcall(require, "require/help/color")
local c515, c516= pcall(require, "require/help/math")
local c517= c513 and c514.rgba_to_hex or function(c518,c519,c505,c504) return string.format("\a%02x%02x%02x%02x", c518 or 0, c519 or 0, c505 or 0, c504 or 255) end

local function c520(c521,c522,c518,c519,c505,c504,c523)
  local c506= globals.realtime() or globals.curtime()
  if not c523 or #c523 == 0 then return "" end
  local c524= {}

  if c521 == 0 then
    local c525= c517(c518,c519,c505,c504)
    for i=1,#c523 do c524[#c524+1] = c525 .. c523:sub(i,i) end
    return table.concat(c524)
  end

  if c521 == 2 then
    local c526= (math.sin(c506 * c522) + 1) * 0.5
    local c527= math.floor(c504 * (0.45 + 0.55 * c526))
    local c525= c517(c518,c519,c505,c527)
    for i=1,#c523 do c524[#c524+1] = c525 .. c523:sub(i,i) end
    return table.concat(c524)
  end

  if c521 == 3 then
    for i=1,#c523 do
      local c528= math.sin(c506 * c522 - i * 0.6)
      local c529= math.max(0, c528)
      local c526= c529 * c529
      local c527= math.floor(c504 * (0.35 + 0.65 * c526))
      c524[#c524+1] = c517(c518,c519,c505,c527) .. c523:sub(i,i)
    end
    return table.concat(c524)
  end

  for i=1,#c523 do
    local c526= (math.sin(c506 * c522 - i * 0.35) + 1) * 0.5
    local c527= math.floor(c504 * (0.4 + 0.6 * c526))
    c524[#c524+1] = c517(c518,c519,c505,c527) .. c523:sub(i,i)
  end
  return table.concat(c524)
end
local function c530()
  if c507 and c508 and c508.ui and c508.ui.paint_indicators then
    local c531, c532= pcall(ui.get, c508.ui.paint_indicators)
    if c531 and c532 == "bold" then return true end
    return false
  end

  return true
end

local c533, c534= pcall(require, "require/abc/callbacks")
local function c535(c536)
  if not c530() then return end

  local c537, c538= client.screen_size()
  local c539, c540= c537 / 2, c538 / 2

  local c541, c542, c543= 200, 200, 255
  local c544, c545, c546= 255, 255, 255
  local c547= 18

  local c548= { 12, 12 }

  local c549= c540 + 18

  local c550= entity.get_local_player()
  local c551= false
  if c550 then
    local c552= entity.get_prop(c550, "m_bIsScoped")
    c551 = c552 == 1
  end

  local c553= "sodium"
  local c554= "beta"
  local c555= "DT"

  local c556= false
  do
    local c531, c557= pcall(require, "require/help/libs")
    if c531 and c557 and c557.get then
      local c558= c557.get("antiaim_funcs")
      if c558 and c558.get_double_tap then
        local c559, c560= pcall(c558.get_double_tap)
        if c559 and c560 then c556 = true end
      end
    end
  end

  local c561= 1
  if c507 and c508 and c508.ui and c508.ui.paint_indicators_animation then
    local c562, c563= pcall(ui.get, c508.ui.paint_indicators_animation)
    if c562 and type(c563) == 'number' then c561 = c563 end
  end
  local c564= c553 .. " " .. c554
  c564 = c511(c564)
  c553 = c511(c553)
  c554 = c511(c554)
  local c565= renderer.measure_text("b", c564) or 0
  local c566= renderer.measure_text("b", c553) or 0
  local c567= renderer.measure_text("b", c554) or 0
  local c568= renderer.measure_text("b", c555) or 0

  local c569= ""
  do
    local c531, c570= pcall(require, "require/aa/player_condition")
    if c531 and c570 and c570.get then
      local c559, c571= pcall(c570.get)
      if c559 and c571 then
        local c572= {
          legit = "Legit",
          fakelag = "Fakelag",
          walk = "Walk",
          move = "Move",
          stand = "Stand",
          ["duck"] = "Duck",
          ["duck+"] = "Duck+",
          jump = "Jump",
          ["jump+"] = "Jump+"
        }
        c569 = c572[c571] or tostring(c571)
        c569 = c511(c569)
      end
    end
  end

  c555 = c511(c555)
  local c573= renderer.measure_text("b", c569) or 0

  local c574, c575, c576, c577= 200, 200, 255, 255
  do
    local c578= false
    if c507 and c508 and c508.ui and c508.ui.paint_indicator_color then
      local c579, c504, c505, c580, c581= pcall(ui.get, c508.ui.paint_indicator_color)
      if c579 then
        c578 = true
        if type(c504) == 'number' then
          if c513 and c514 and c514.clamp then
            c574 = c514.clamp(c504 or c574)
            c575 = c514.clamp(c505 or c575)
            c576 = c514.clamp(c580 or c576)
            c577 = c514.clamp(c581 or c577)
          else
            c574 = math.floor(c504 or c574)
            c575 = math.floor(c505 or c575)
            c576 = math.floor(c580 or c576)
            c577 = math.floor(c581 or c577)
          end
        elseif type(c504) == 'string' and #c504 == 12 then
          local c531
          c531, mr = pcall(function() return tonumber(c504:sub(1,3)) end)
          c531, mg = pcall(function() return tonumber(c504:sub(4,6)) end)
          c531, mb = pcall(function() return tonumber(c504:sub(7,9)) end)
          c531, ma = pcall(function() return tonumber(c504:sub(10,12)) end)
          if c513 and c514 and c514.clamp then
            c574 = c514.clamp(c574 or 200)
            c575 = c514.clamp(c575 or 200)
            c576 = c514.clamp(c576 or 255)
            c577 = c514.clamp(c577 or 255)
          else
            c574 = c574 or 200; c575 = c575 or 200; c576 = c576 or 255; c577 = c577 or 255
          end
        end
      end
    end

    if not c578 then
      local c582, c583= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if c582 and c583 then
        local c579, c504, c505, c580, c581= pcall(ui.get, c583)
        if c579 then
          if type(c504) == 'number' then
            if c513 and c514 and c514.clamp then
              c574 = c514.clamp(c504 or c574)
              c575 = c514.clamp(c505 or c575)
              c576 = c514.clamp(c580 or c576)
              c577 = c514.clamp(c581 or c577)
            else
              c574 = math.floor(c504 or c574)
              c575 = math.floor(c505 or c575)
              c576 = math.floor(c580 or c576)
              c577 = math.floor(c581 or c577)
            end
          elseif type(c504) == 'string' and #c504 == 12 then
            local c531
            c531, mr = pcall(function() return tonumber(c504:sub(1,3)) end)
            c531, mg = pcall(function() return tonumber(c504:sub(4,6)) end)
            c531, mb = pcall(function() return tonumber(c504:sub(7,9)) end)
            c531, ma = pcall(function() return tonumber(c504:sub(10,12)) end)
            if c513 and c514 and c514.clamp then
              c574 = c514.clamp(c574 or 200)
              c575 = c514.clamp(c575 or 200)
              c576 = c514.clamp(c576 or 255)
              c577 = c514.clamp(c577 or 255)
            else
              c574 = c574 or 200; c575 = c575 or 200; c576 = c576 or 255; c577 = c577 or 255
            end
          end
        end
      end
    end
  end

  for i = 1, 3 do
    local c584= (i == 1) and c565 or ((i == 2) and c568 or c573)
    local c585= c501[i] or 0
    local c586= c551 and (c585 + (c584 / 2)) or 0
    local c522= c502[i] or 10
    local c587= globals.frametime()
    local c506= 1 - math.exp(-c522 * c587)
    c500[i] = c503(c500[i], c586, c506)
  end

  local c588= c539 - (c565 / 2)
  local c589= c588 + (c500[1] or 0)
  renderer.text(c589, c549, 255, 255, 255, 255, "b", 0, c553)
  local c590= renderer.measure_text("b", " ") or 0
  local c591= c589 + (c566 or 0) + c590
  
  local c592= c520(c561, 3.5, c574, c575, c576, c577, c554)
  renderer.text(c591, c549, c574, c575, c576, c577, "b", 0, c592)
  c549 = c549 + (c548[1] or c547)

  local c593= c539 - (c568 / 2)
  local c594= c593 + (c500[2] or 0)
  local c595, c596, c597= 255, 80, 80
  if c556 then c595, c596, dt_b = 155, 255, 155 end
  renderer.text(c594, c549, c595, c596, c597, 255, "b", 0, c555)
  c549 = c549 + (c548[2] or c547)

  local c598= c539 - (c573 / 2)
  local c599= c598 + (c500[3] or 0)
  renderer.text(c599, c549, c544, c545, c546, 255, "b", 0, c569)
end

if c533 and c534 and c534.callback then
  c534.callback("paint", c535, { alive_only = true, require_login = true })
end]]
c927["require/features/paint/indicators_small"] = [[local c503= { 0, 0 }
local c504= { 4, 0.8 }
local c505= { 5, 5 }
local c506= 0
local c507= 8

local function c508(c509,c510,c511)
  return c509 + (c510 - c509) * c511
end

local c512, c513= pcall(require, "require/abc/menu_setup")
local c514, c515= pcall(require, "require/help/string")
local c516= require('require/abc/callbacks')
local function c517(c518)
  if c518 == nil then return "" end
  if c514 and c515 and c515.upper then
    return c515.upper(tostring(c518))
  end
  return tostring(c518)
end

local c519, c520= pcall(require, "require/help/color")
local c521, c522= pcall(require, "require/help/math")
local c523= c519 and c520.rgba_to_hex or function(c524,c525,c510,c509) return string.format("\a%02x%02x%02x%02x", c524 or 0, c525 or 0, c510 or 0, c509 or 255) end

local function c526(c527,c528,c524,c525,c510,c509,c529)
  local c511= globals.realtime() or globals.curtime()
  if not c529 or #c529 == 0 then return "" end
  local c530= {}

  if c527 == 0 then
    local c531= c523(c524,c525,c510,c509)
    for i=1,#c529 do c530[#c530+1] = c531 .. c529:sub(i,i) end
    return table.concat(c530)
  end

  if c527 == 2 then
    local c532= (math.sin(c511 * c528) + 1) * 0.5
    local c533= math.floor(c509 * (0.45 + 0.55 * c532))
    local c531= c523(c524,c525,c510,c533)
    for i=1,#c529 do c530[#c530+1] = c531 .. c529:sub(i,i) end
    return table.concat(c530)
  end

  if c527 == 3 then
    for i=1,#c529 do
      local c534= math.sin(c511 * c528 - i * 0.6)
      local c535= math.max(0, c534)
      local c532= c535 * c535
      local c533= math.floor(c509 * (0.35 + 0.65 * c532))
      c530[#c530+1] = c523(c524,c525,c510,c533) .. c529:sub(i,i)
    end
    return table.concat(c530)
  end

  for i=1,#c529 do
    local c532= (math.sin(c511 * c528 - i * 0.35) + 1) * 0.5
    local c533= math.floor(c509 * (0.4 + 0.6 * c532))
    c530[#c530+1] = c523(c524,c525,c510,c533) .. c529:sub(i,i)
  end
  return table.concat(c530)
end
local function c536()
  if c512 and c513 and c513.ui and c513.ui.paint_indicators then
    local c537, c538= pcall(ui.get, c513.ui.paint_indicators)
    if c537 and c538 == "small" then return true end
    return false
  end

  return true
end



local function c539()
  if not (c512 and c513 and c513.ui) then return true end
  local c540= c513.ui.paint_indicators_bar
  if not c540 then return true end
  local c537, c538= pcall(ui.get, c540)
  if not c537 then return true end
  return not (c538 == false or c538 == nil) 
end

c516.register("paint", function()
  if not entity.is_alive(entity.get_local_player()) then return end
  if not c536() then return end

  local c541, c542= client.screen_size()
  local c543, c544= c541 / 2, c542 / 2

  local c545, c546, c547= 200, 200, 255
  local c548, c549, c550= 255, 255, 255
  local c551= 18

  local c552= { 12, 13 }

  local c553= c544 + 18

  
  local c554= entity.get_local_player()
  local c555= false
  if c554 then
    local c556= entity.get_prop(c554, "m_bIsScoped")
    c555 = c556 == 1
  end

  local c557= "sodium"
  local c558= "beta"
  local c559= "DT"

  local c560= false
  do
    local c537, c561= pcall(require, "require/help/libs")
    if c537 and c561 and c561.get then
      local c562= c561.get("antiaim_funcs")
      if c562 and c562.get_double_tap then
        local c563, c564= pcall(c562.get_double_tap)
        if c563 and c564 then c560 = true end
      end
    end
  end

  local c565= c517(c557)
  local c566= c517(c558)
  c565 = tostring(c565)
  c566 = tostring(c566)
  local c567= renderer.measure_text("b", c565) or 0
  local c568= renderer.measure_text("b", c566) or 0

  c559 = c517(c559)
  local c569= renderer.measure_text("b", c559) or 0

  for i = 1, 2 do
    local c570= (i == 1) and c567 or c569
    local c571= c504[i] or 0
    local c572= c555 and (c571 + (c570 / 2)) or 0
    local c528= c505[i] or 10
    local c573= globals.frametime()
    local c511= 1 - math.exp(-c528 * c573)
    c503[i] = c508(c503[i], c572, c511)
  end

  local c574= 4.5
  local c575= c543 - ((c567 + c574 + (c568 or 0)) / 2)
  local c576= c575 + (c503[1] or 0)
  local c577= 22
  local c578= c577 - c574
  local c579= math.floor((c578 + 1) / 2)
  local c580= c578 - c579
  local c581= c579 
  local c582= -c580 

  local c583, c584, c585, c586= c545, c546, c547, 255
  do
    local c587= false
    
    if c512 and c513 and c513.ui and c513.ui.paint_indicator_color then
      local c588, c509, c510, c589, c590= pcall(ui.get, c513.ui.paint_indicator_color)
      if c588 then
        c587 = true
        if type(c509) == 'number' then
          if c519 and c520 and c520.clamp then
            c583 = c520.clamp(c509 or c583)
            c584 = c520.clamp(c510 or c584)
            c585 = c520.clamp(c589 or c585)
            c586 = c520.clamp(c590 or c586)
          else
            c583 = math.floor(c509 or c583)
            c584 = math.floor(c510 or c584)
            c585 = math.floor(c589 or c585)
            c586 = math.floor(c590 or c586)
          end
        elseif type(c509) == 'string' and #c509 == 12 then
          local c537
          c537, mr = pcall(function() return tonumber(c509:sub(1,3)) end)
          c537, mg = pcall(function() return tonumber(c509:sub(4,6)) end)
          c537, mb = pcall(function() return tonumber(c509:sub(7,9)) end)
          c537, ma = pcall(function() return tonumber(c509:sub(10,12)) end)
          if c519 and c520 and c520.clamp then
            c583 = c520.clamp(c583 or c545)
            c584 = c520.clamp(c584 or c546)
            c585 = c520.clamp(c585 or c547)
            c586 = c520.clamp(c586 or 255)
          else
            c583 = c583 or c545; c584 = c584 or c546; c585 = c585 or c547; c586 = c586 or 255
          end
        end
      end
    end

    
    if not c587 then
      local c591, c540= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if c591 and c540 then
        local c588, c509, c510, c589, c590= pcall(ui.get, c540)
        if c588 then
          if type(c509) == 'number' then
            if c519 and c520 and c520.clamp then
              c583 = c520.clamp(c509 or c583)
              c584 = c520.clamp(c510 or c584)
              c585 = c520.clamp(c589 or c585)
              c586 = c520.clamp(c590 or c586)
            else
              c583 = math.floor(c509 or c583)
              c584 = math.floor(c510 or c584)
              c585 = math.floor(c589 or c585)
              c586 = math.floor(c590 or c586)
            end
          elseif type(c509) == 'string' and #c509 == 12 then
            local c537
            c537, mr = pcall(function() return tonumber(c509:sub(1,3)) end)
            c537, mg = pcall(function() return tonumber(c509:sub(4,6)) end)
            c537, mb = pcall(function() return tonumber(c509:sub(7,9)) end)
            c537, ma = pcall(function() return tonumber(c509:sub(10,12)) end)
            if c519 and c520 and c520.clamp then
              c583 = c520.clamp(c583 or c545)
              c584 = c520.clamp(c584 or c546)
              c585 = c520.clamp(c585 or c547)
              c586 = c520.clamp(c586 or 255)
            else
              c583 = c583 or c545; c584 = c584 or c546; c585 = c585 or c547; c586 = c586 or 255
            end
          end
        end
      end
    end
  end

  local c592= 1
  if c512 and c513 and c513.ui and c513.ui.paint_indicators_animation then
    local c593, c594= pcall(ui.get, c513.ui.paint_indicators_animation)
    if c593 and type(c594) == 'number' then c592 = c594 end
  end

  local c595= (function()
    local c531= c523(255,255,255,255)
    local c530= {}
    for i=1,#c565 do c530[#c530+1] = c531 .. c565:sub(i,i) end
    return table.concat(c530)
  end)()

  local c596= c526(c592, 3.5, c583, c584, c585, c586, c566)
  local c597= c576 + (c581 or 0)
  local c598= c555 and 3 or 0
  c597 = c597 + c598
  renderer.text(c597, c553, 255,255,255,255, "-", 0, c595)
  local c599= c576 + (c567 or 0) + c574
  local c600= c599 + (c582 or 0) + c598
  renderer.text(c600, c553, c583, c584, c585, c586, "-", 0, c596)

  local c601= false
  if c539() then
    c601 = true
    do
      local c602= (c567 or 0) + c574 + (c568 or 0)
      local c603= 16
      local c604= math.max(8, c602 - c603)
      local c605= c555 and math.floor((c503[1] or 0) * 0.35) or 0
      local c606= c576 + math.floor((c602 - c604) / 2) - 2 + c605
      local c607= 2
      local c608= c553 + math.max(2, (c552[1] or c551) - (c607 + 4)) + 5
      local c609= math.floor((c586 or 255) * 0.7)
      renderer.rectangle(c606 - 1, c608 - 1, c604 + 2, c607 + 2, c583, c584, c585, c609)
      renderer.rectangle(c606, c608, c604, c607, 0, 0, 0, 255)
      local c610= c560 and c604 or 0
      local c611= globals.frametime()
      local c612= 1 - math.exp(-c507 * c611)
      c506 = c508(c506, c610, c612)
      local c613= math.floor(math.max(0, math.min(c506, c604)))
      if c613 > 0 then
        renderer.rectangle(c606, c608, c613, c607, c583, c584, c585, c586)
      end
    end
  end

  
  local c614= (c552[1] or c551)
  local c615= c614
  if not c601 then
    
    c615 = math.max(0, c614 - 7)
  end
  c553 = c553 + c615

  local c616= c543 - (c569 / 2)
  local c617= c616 + (c503[2] or 0)
  local c618, c619, c620= 255, 80, 80
  if c560 then c618, c619, dt_b = 155, 255, 155 end
  renderer.text(c617, c553 + 2, c618, c619, c620, 255, "-", 0, c559)
  c553 = c553 + (c552[2] or c551)

end, { alive_only = true, require_login = true })]]
c927["require/features/paint/insults"] = [[local c506= client
local c507= entity
local c508= ui

local c509= require("require/abc/menu_setup")
local c510, c511= pcall(require, "require/help/string")
local c512, c513= pcall(require, "require/help/math")
local c514, c515= pcall(require, "require/help/time")

local c516= {
    "buy sodium",
    "sodium is the bestest lua",
    "SODIUMMMM >__<",
    "you just got sodiumed",
    "sodium beta > all other lues",
    "₴ØĐłɄ₥ ₮₳₴₮ɆĐ Vł₵₮ØⱤɎ, ł₮ ₩₳₴ ₴ØɄⱤ",
    "₴ØĐłɄ₥ ₳ⱤⱤ₳₦₲ɆĐ ₮ⱧɆ ₴₮₳Ɽ₴ ₣ØⱤ ₮Ⱨ₳₮ ⱧɆ₳Đ₴ⱧØ₮",
    "₴ØĐłɄ₥ ₴Ⱡł₱₱ɆĐ ł₦ ₳ ฿₳₦₳₦₳ ₱ɆɆⱠ Ø₣ ₣₳₮Ɇ",
    "₴ØĐłɄ₥ ₩Ⱨł₴₱ɆⱤɆĐ ₴Ɇ₵ⱤɆ₮₴ ł₦₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ₥₳₭Ɇ₴ ₣ⱤłɆ₦Đ₴ ₩ł₮Ⱨ Ⱡ₳₲, ₮ⱧɆ₦ ฿Ɇ₮Ɽ₳Ɏ₴ ł₮",
    "₴ØĐłɄ₥ ₣ØⱠĐɆĐ ɎØɄⱤ ₵ØɄⱤ₳₲Ɇ ł₦₮Ø ₳ ₱₳₱ɆⱤ ₱Ⱡ₳₦Ɇ",
    "₴ØĐłɄ₥ ₱₳ł₦₮₴ ł₦ ⱤɆĐ ₩ⱧɆ₦ ł₮ ł₴ ⱧɄ₦₲ⱤɎ",
    "₴ØĐłɄ₥ ł₴ ₴₵ⱧłⱫØ₱ⱧⱤɆ₦ł₵ ฿Ʉ₮ ₵Ⱨ₳Ɽ₥ł₦₲",
    "₴ØĐłɄ₥ ₳₮Ɇ ₥Ɏ ₴₳₦Đ₩ł₵Ⱨ ฿Ʉ₮ ⱠɆ₣₮ ₳ ₮ⱤØ₱ⱧɎ",
    "₴ØĐłɄ₥ ⱧɄ₥₴ ⱠɄⱠⱠ₳฿łɆ₴ ₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ĐØɆ₴ ₮ⱧɆ ₵Ⱨ₳-₵Ⱨ₳ ₩ł₮Ⱨ ɎØɄⱤ ₳ł₥",
    "₴ØĐłɄ₥ ₣ØⱤ₲Ø₮ ₮Ø ฿Ɇ ₱ØⱠł₮Ɇ, ₴ØⱤⱤɎ ₦Ø₮ ₴ØⱤⱤɎ",
    "₴ØĐłɄ₥ ₳₦Đ ł ₴Ⱨ₳ⱤɆ ₮ØØ₮Ⱨ฿ⱤɄ₴ⱧɆ₴ (₥Ɇ₮₳₱ⱧØⱤ)",
    "₴ØĐłɄ₥ ₮Ɏ₱ɆĐ 'ɎØɄ' ł₦ ⱠØ₩ɆⱤ₵₳₴Ɇ ₳₦Đ ₥Ɇ₳₦₮ ł₮",
    "₴ØĐłɄ₥ ₵ØⱠⱠɆ₵₮₴ ₴₥₳ⱠⱠ ₮ⱤØ₱ⱧłɆ₴ (ɎØɄ ł₦₵ⱠɄĐɆĐ)",
    "₴ØĐłɄ₥ ₭ɆɆ₱₴ ⱤɆ₵Ɇł₱₮₴ ₣ØⱤ ɎØɄⱤ ₥ł₴₮₳₭Ɇ₴",
    "₴ØĐłɄ₥ ł₴ ₳ ₲ØØĐ ⱠɄ₳ ₳₦Đ ₳Ⱡ₴Ø ₳ Ⱡł₮₮ⱠɆ ₥₳Đ",
    "₴ØĐłɄ₥, ₮Ⱨ₳₦₭ ₣ØⱤ ₳ⱠⱠ₳Ⱨ ₲ØĐ, Đ₳Đ :)",
    "₴ØĐłɄ₥ ₴Ɇ₦ĐɆⱤ ₲ⱤɆɆ₮ł₦₲ ₣ⱤØ₥ ₭Ʉ฿₳₦",
    "₥łⱠⱠłØ₦₳łⱤɆ ฿ɄɎ₴ ₲ⱧØ₴₮ ツ Ⱨ₳₳₳Ⱨ₳Ⱨ₳",
    "₴ Ø Đ ł Ʉ ₥ ⱠɄ₳ Ⱨ₳₴ ₮ⱧɆ ฿Ɇ₴₮ ⱧɆ₳Đ₴ⱧØ₮₮₮",
    "₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ <3",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ",
    "ł₣ ₣ⱠɎł₦₲ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐØ₦₮ ₭₦Ø₩ł₦₲ ӾĐĐ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₥Ɏ ₳ł₥ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ɆⱤVɆⱤ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ, ฿Ɇ₲ ₮Ø ₱ⱤØ₵Ⱡ₳ł₥",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄ ₵₳₦ ₥₳₮₵Ⱨ Ⱡ₥Ⱨ ł ⱤɆ₵ØĐɆĐ",
    "ł ₱Ⱡ₳₵Ɇ ɎØɄ Ø₦ ₦Ɇ₩ ⱠɆ₣Ɇ₦Đ ⱠɆ₵₮ɆĐ ₥₳₱ ₩ł₮Ⱨ ØĐł₣ł₵ ⱤɆ₵ØĐɆ",
    "♡ ₴ØĐłɄ₥ ł₴ ₥Ɏ ₵Ø₵₭ Ø₣ ⱠɄ₳ ♡",
    "ł ⱤØ₳₴₮ɆĐ ɎØɄ ₴Ø ₣Ʉ₵₭ł₦₲ Ⱨ₳ⱤĐ ɆVɆⱤ ₴ɆⱤɆĐ",
    "ɎØɄ ₮ⱤłɆĐ ₮Ø ₱ⱤɆ₮Ɇ₦Đ, ฿Ʉ₮ ₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ₭łⱠⱠɆĐ ₮Ⱨ₳₮",
    "ɎØɄ ⱠØ₴Ɇ ₮Ø ₥Ɇ ₣ØⱤ ₦ł₵Ɇ ₣ØⱠ₭",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱ØɆ₥",
    "ł ₣Ⱡł₲Ⱨ₮ ɎØɄ Ø₣₣ ₮ⱧɆ ₥₳₱ ₩ł₮Ⱨ ₥Ɏ ₴ɆⱤVɆⱤ ₩ł₣Ɇ",
    "₴ɆⱤł₳Ⱡ ฿ɄⱠⱠɎ Ø₣ ⱠɄ₳ ₳ⱠⱠ Đ₳Ɏ",
    "₥Ɏ ₴ØĐłɄ₥ ฿ⱤɆ₳₭₴ ₥ØⱤɆ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ₴ØĐłɄ₥ ❤",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ, ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₣ⱠɎ ₳ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ, ₮ⱧɆ₦ ₴₮łⱠⱠ ฿Ɇ₳₮ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐłĐ₦’₮ ₭₦Ø₩ł₦₲ ӾĐĐĐ, ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳ ₣₮₩",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ₴Ɇ₦Đ ₲ⱤɆɆ₮ł₦₲₴ ₱₳Ɽ₳ ₳ ₵Ø₦₳ Đ₳ ₮Ʉ₳ ₥₳₮Ɇ",
    "₳ĐĐɆĐ ₮Ⱨł₴ ₮Ø ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₳₦Đ ł₮ ₥₳ĐɆ ł₮ ₴Ø ₥Ʉ₵Ⱨ ฿Ɇ₮₮ɆⱤ",
    "ł ₴₥Ø₭ɆĐ ɎØɄ ɎɆ₴₮ɆⱤĐ₳Ɏ ₩ł₮Ⱨ ₴ØĐłɄ₥, ₮ØĐ₳Ɏ ł ₣ⱠɆӾ ₳₲₳ł₦",
    "₴ØĐłɄ₥ ⱠɄ₳ JɄ₴₮ Ø₩₦ɆĐ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄⱤ ₴₵Ɽł₱₮ ₵₳₦ ₥₳₮₵Ⱨ ₴ØĐłɄ₥? ⱠØⱠ ₦Ø₱Ɇ",
    "ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ ₥ØĐɆ ₳₵₮łV₳₮ɆĐ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ = 100% ₩ł₦ ₲Ʉ₳Ɽ₳₦₮ɆɆĐ",
    "ł ฿ⱤɆ₳₭ ɎØɄⱤ ⱠɄ₳, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₥ł₦Đ, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₴ɆⱤVɆⱤ — ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "(‿ˠ‿)",
    "₣ØⱤ ₲₳₦₲₴₮ɆⱤ ₩Ɇ Ⱨ₳VɆ ₩Ø₦, ₮Ⱨł₴ ₥₳₮₵Ⱨ",
    "https://discord.gg/8nMMVgqdHk",
    "BUY SODIUM NOW!!! ₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ BUY SODIUM NOW!!! AT DISCORD ;;;",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥ ⱠɄ₳ ",
}


local c517= {
    ""
}

pcall(function()
    local c518= nil
    if c514 and c515 and c515.unix_time then
        c518 = math.floor((c515.unix_time() or 0) % (2^31))
    else
        local c519= nil
        pcall(function() c519 = c506.timestamp() end)
        if not c519 or c519 == 0 then
            c519 = globals.tickcount() or 0
        end
        c518 = math.floor((c519 or 0) % (2^31))
    end
    math.randomseed(c518)
end)
local c520= 1
local c521= {}
local c522= false

local function c523(c524)
    if c506 and c506.exec then
        pcall(c506.exec, c524)
    end
end

local function c525()
    if #c521 == 0 then
        c522 = false
        return
    end

    local c526= table.remove(c521, 1)
    if not c526 or c526 == "" then
        if #c521 > 0 then
            if c506 and c506.delay_call then
                pcall(function() c506.delay_call(c520, c525) end)
            else
                c525()
            end
        else
            c522 = false
        end
        return
    end

    local c524= string.format('say "%s"', c526)
    if c506 and c506.delay_call then
        pcall(function()
            c506.delay_call(0, function()
                c523(c524)
            end)
        end)
    else
        c523(c524)
    end

    if #c521 > 0 then
        if c506 and c506.delay_call then
            pcall(function() c506.delay_call(c520, c525) end)
        else
            c525()
        end
    else
        c522 = false
    end
end

local function c527(c528)
    if not c528 or c528 == "" then return end
    local c529= tostring(c528)
    local c530
    if c510 and c511 and c511.replace then
        c530 = c511.replace(c529, '"', '')
        if c511.trim then c530 = c511.trim(c530) end
    else
        c530 = c529:gsub('"','')
    end

    table.insert(c521, c530)
    if not c522 then
        c522 = true
        if c506 and c506.delay_call then
            pcall(function() c506.delay_call(c520, c525) end)
        else
            c525()
        end
    end
end

local function c531(c532)
	if not c509 or not c509.ui or not c509.ui.paint_insults then
		return
	end
	local c533, c534= pcall(c508.get, c509.ui.paint_insults)
	if not c533 or not c534 then return end

	if not c532 then return end
	local c535= c532.userid
	local c536= c532.attacker
	if not c535 or not c536 then return end

	local c537= c507.get_local_player and c507.get_local_player()
	if not c537 or c537 == 0 then return end

	local c538= c506.userid_to_entindex and c506.userid_to_entindex(c535) or nil
	local c539= c506.userid_to_entindex and c506.userid_to_entindex(c536) or nil
	if c536 == c535 then return end
	if c539 == c537 and c538 ~= c537 then
        if #c516 > 0 then
            local c540= 1
            if c512 and c513 and c513.random_int then
                c540 = c513.random_int(1, #c516)
            else
                c540 = math.random(1, #c516)
            end
            local c526= c516[c540]
            c527(c526)
        end
		return
	end
	if c538 == c537 and c539 ~= c537 then
        if #c517 > 0 then
            local c540= 1
            if c512 and c513 and c513.random_int then
                c540 = c513.random_int(1, #c517)
            else
                c540 = math.random(1, #c517)
            end
            local c526= c517[c540]
            c527(c526)
        end
		return
	end
end

local c541, c542= pcall(require, "require/abc/callbacks")
if c541 and c542 and c542.callback then
    c542.callback('player_death', c531, { alive_only = true, require_login = true })
end]]
c927["require/features/paint/lagcomp_box"] = [=[


local g_net_data = {}
local g_sim_ticks = {}
local g_esp_data = {}


local menu_setup = require('require/abc/menu_setup')
local DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A = 47, 117, 221, 255


local floor = math.floor

local function length_sqr(x, y, z)
    return (x or 0) * (x or 0) + (y or 0) * (y or 0) + (z or 0) * (z or 0)
end

local function time_to_ticks(seconds)
    local ti = globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return floor((seconds or 0) / ti + 0.5)
end

local function extrapolate(ent, ticks)
    local ti = globals.tickinterval()
    if not ti then return nil end

    local g = (cvar.sv_gravity and cvar.sv_gravity:get_float() or 800) * ti
    local jump = (cvar.sv_jump_impulse and cvar.sv_jump_impulse:get_float() or 301) * ti

    local ox, oy, oz = entity.get_origin(ent)
    if not ox then return nil end

    local vx, vy, vz = entity.get_prop(ent, "m_vecVelocity")
    vx, vy, vz = vx or 0, vy or 0, vz or 0

    local gravity = (vz > 0) and -g or jump

    for i = 1, (ticks or 0) do
        local px, py, pz = ox, oy, oz

        ox = ox + (vx * ti)
        oy = oy + (vy * ti)
        oz = oz + (vz + gravity) * ti

        local frac = select(1, client.trace_line(ent or 0, px, py, pz, ox, oy, oz))
        if frac and frac <= 0.99 then
            return px, py, pz
        end
    end

    return ox, oy, oz
end


local edges = {
    {0, 1}, {1, 2}, {2, 3}, {3, 0}, {5, 6}, {6, 7}, {1, 4}, {4, 8},
    {0, 4}, {1, 5}, {2, 6}, {3, 7}, {5, 8}, {7, 8}, {3, 4}
}


local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
    local me = entity.get_local_player()
    if not me or not entity.is_alive(me) then return end

    
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box then
        local ok, enabled = pcall(ui.get, menu_setup.ui.paint_lagcomp_box)
        if ok and enabled == false then
            return
        end
    end

    
    local players = entity.get_players(true)
    for i = 1, #players do
        local ent = players[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local prev = g_sim_ticks[ent]
            local sim_time = entity.get_prop(ent, 'm_flSimulationTime')
            local ox, oy, oz = entity.get_origin(ent)

            if sim_time and ox then
                local sim_ticks = time_to_ticks(sim_time)

                if prev ~= nil then
                    local delta = sim_ticks - prev.tick
                    if delta < 0 or (delta > 0 and delta <= 64) then
                        local dx, dy, dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
                        local teleport_distance = length_sqr(dx, dy, dz)

                        local ex_ticks = math.max(delta - 1, 0)
                        local ex_x, ex_y, ex_z = extrapolate(ent, ex_ticks)
                        if delta < 0 then
                            g_esp_data[ent] = 1
                        end

                        g_net_data[ent] = {
                            tick = ex_ticks,
                            player = ent,
                            delta = delta,
                            origin = { x = ox, y = oy, z = oz },
                            extrapolated = (ex_x and { x = ex_x, y = ex_y, z = ex_z } or { x = ox, y = oy, z = oz }),
                            lagcomp = teleport_distance > 4096,
                            tickbase = delta < 3
                        }
                    end
                end

                if g_esp_data[ent] == nil then g_esp_data[ent] = 0 end
                g_sim_ticks[ent] = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
            else
                g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
            end
        else
            g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
        end
    end

    
    local r, g, b, a = DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box_color then
        local ok, rr, gg, bb, aa = pcall(ui.get, menu_setup.ui.paint_lagcomp_box_color)
        if ok and rr then
            r, g, b, a = rr, gg, bb, aa
        end
    end
    for ent, data in pairs(g_net_data) do
        if data and data.player and entity.is_alive(data.player) and not entity.is_dormant(data.player) and data.lagcomp then
            local minsx, minsy, minsz = entity.get_prop(data.player, 'm_vecMins')
            local maxsx, maxsy, maxsz = entity.get_prop(data.player, 'm_vecMaxs')
            if not minsx or not maxsx then goto continue_box end

            local ex = data.extrapolated.x
            local ey = data.extrapolated.y
            local ez = data.extrapolated.z

            local min = { x = (minsx or 0) + ex, y = (minsy or 0) + ey, z = (minsz or 0) + ez }
            local max = { x = (maxsx or 0) + ex, y = (maxsy or 0) + ey, z = (maxsz or 0) + ez }

            local points = {
                min,
                { x = min.x, y = max.y, z = min.z },
                { x = max.x, y = max.y, z = min.z },
                { x = max.x, y = min.y, z = min.z },
                { x = min.x, y = min.y, z = max.z },
                { x = min.x, y = max.y, z = max.z },
                max,
                { x = max.x, y = min.y, z = max.z }
            }

            for k, v in pairs(edges) do
                
                if k == 1 then
                    local ox, oy = renderer.world_to_screen(data.origin.x, data.origin.y, data.origin.z)
                    local mx, my = renderer.world_to_screen(min.x, min.y, min.z)
                    if ox and mx then
                        renderer.line(ox, oy, mx, my, r, g, b, 255)
                    end
                end
                local p1 = points[v[1]]
                local p2 = points[v[2]]
                if p1 and p2 then
                    local x1, y1 = renderer.world_to_screen(p1.x, p1.y, p1.z)
                    local x2, y2 = renderer.world_to_screen(p2.x, p2.y, p2.z)
                    if x1 and x2 then
                        renderer.line(x1, y1, x2, y2, r, g, b, 255)
                    end
                end
            end
            ::continue_box::
        end
    end

    
    for i = 1, #players do
        local ent = players[i]
        if not entity.is_alive(ent) or entity.is_dormant(ent) then goto continue_label end

        local x1, y1, x2, y2, alpha = entity.get_bounding_box(ent)
        if alpha == 0 then goto continue_label end

        local palpha = 0
        if g_esp_data[ent] ~= nil and g_esp_data[ent] > 0 then
            g_esp_data[ent] = g_esp_data[ent] - globals.frametime() * 2
            if g_esp_data[ent] < 0 then g_esp_data[ent] = 0 end
            palpha = g_esp_data[ent]
        end

        local tag = ''
        local data = g_net_data[ent]
        if data then
            local tb = data.tickbase
            local lc = data.lagcomp
            if (not tb) or lc then
                palpha = alpha
            end
            tag = tb and 'SHIFTING TICKBASE' or (lc and 'LAG COMP BREAKER' or '')
        end

        
            local name = entity.get_player_name(ent)
            local y_add = (name == '  ' or name == ' ' or name == '' or name == '   ') and 8 or 0
            local mid_x = x1 + (x2 - x1) / 2
            renderer.text(mid_x, y1 - 18 + y_add, 255, 45, 45, floor((palpha or 0) * 255), 'cb', 0, tag)
        

        ::continue_label::
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end

local function round_start_handler(ev)
    g_net_data = {}
    g_sim_ticks = {}
    g_esp_data = {}
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('round_start', round_start_handler, { alive_only = true, require_login = true })
end]=]
c927["require/features/paint/minimum_damage"] = [[local c512= require("require/abc/menu_setup")
local c513= require("require/help/drag")

local c514= {
    minimum_damage = ui.reference("RAGE", "Aimbot", "Minimum damage"),
    minimum_damage_override = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}

local c515= { client.screen_size() }

local c516= nil
do
    local c517, c518= client.screen_size()
    local c519= math.floor((c515[1] or c517 or 0) / 2 + 2)
    local c520= math.floor((c515[2] or c518 or 0) / 2 - 14)
    local c521= 30
    local c522, c523= 10, 18
    c516 = c513.new("minimum_damage_indicator", {
        x = c519 - math.floor(c522 / 2),
        y = c520 - math.floor(c523 / 2),
        w = c522,
        h = c523,
        snap = true,
        snap_threshold = 24,
        require_menu_open = true,
        constraint_center = { cx = c519, cy = c520, radius = c521 },
        default_center = { x = c519, y = c520 },
    })
end

local c524, c525= pcall(require, "require/abc/callbacks")
local function c526(c527)

    if not ui.get(c512.ui.paint_minimum_damage) then return end
    
    local c528= entity.get_local_player()
    if c528 == nil or not entity.is_alive(c528) then return end
    if c516 then
        pcall(function()
            c516:handle()
            c516:draw()
        end)
    end

    

    if ui.get(c514.minimum_damage_override[2]) then
        local c529, c530= c515[1] / 2 + 2, c515[2] / 2 - 14
        if c516 then
            pcall(function()
                c529 = c516.x + math.floor(c516.w / 2)
                c530 = c516.y + math.floor(c516.h / 2)
            end)
        end
        renderer.text(c529, c530, 255, 255, 255, 225, "d", 0, ui.get(c514.minimum_damage_override[3]) .. "")
    end

end

if c524 and c525 and c525.callback then
    c525.callback('paint', c526, { alive_only = true, require_login = true })
end]]
c927["require/features/paint/molotov_particles"] = [[local c515= ui
local c516= client
local c517= entity
local c518= renderer
local c519= globals
local c520= require("require/abc/menu_setup")
local c521= require('require/brain/api/vector/vector')
local c522= require('require/abc/callbacks')


local c523= {}


local c524= c521.make(0, 0, 0)
local c525= c521.make(0, 0, 0)

local c526= 128
local c527= 158
local c528= 48


local function c529()
    local c530= {}
    local c531= c517.get_all('inferno') or {}
    for _, v in ipairs(c531) do table.insert(c530, v) end
    local c532= c517.get_all('CInferno') or {}
    for _, v in ipairs(c532) do table.insert(c530, v) end
    return c530
end


local function c533(c534,c535,c536)
    offsets_templates = offsets_templates or {}
    local c537= tostring(c535) .. ':' .. tostring(c536)
    if offsets_templates[c537] then return offsets_templates[c537] end

    local c538= {}
    local c539= math.pi * (3 - math.sqrt(5))
    for i = 1, c535 do
        local c540= c536 * math.sqrt(i / c535)
        local c541= i * c539
        local c542= math.cos(c541) * c540
        local c543= math.sin(c541) * c540
        local c544= ((i % 24) - 12) 
        c538[i] = {c542, c543, c544}
    end
    offsets_templates[c537] = c538
    return c538
end

c522.register('paint', function()

    local c545= c517.get_local_player()
    if not c545 then return end
    if c520 and c520.ui and c520.ui.paint_molotov then
        local c546, c547= pcall(c515.get, c520.ui.paint_molotov)
        if c546 and not c547 then return end
    end

    local c535= math.max(1, math.floor(c526 or 24))
    local c536= math.max(1, math.floor(c527 or 100))
    local c548= math.max(1, math.floor(c528 or 6))

    
    local c549, c550, c551= c516.camera_position()
    c524.x = c549 or 0
    c524.y = c550 or 0
    c524.z = c551 or 0

    local c552= c529()
    if #c552 == 0 then return end

    for _, c534 in ipairs(c552) do
        local c553, c554, c555= c517.get_origin(c534)
        if c553 then
            local c537= tostring(c534) .. ":" .. tostring(c535) .. ":" .. tostring(c536)
            local c556= c523[c537]

            
            if not c556 or not c556.origin or
               math.abs(c556.origin[1] - c553) > 0.01 or
               math.abs(c556.origin[2] - c554) > 0.01 or
               math.abs(c556.origin[3] - c555) > 0.01 then
                local c538= c533(c534, c535, c536)
                local c557= {}
                for _, off in ipairs(c538) do
                    local c558= c553 + (off[1] or 0)
                    local c559= c554 + (off[2] or 0)
                    local c560= c555 + (off[3] or 0)
                    table.insert(c557, {c558, c559, c560})
                end
                c556 = { origin = {c553, c554, c555}, pts = c557 }
                c523[c537] = c556
            end

            for _, p in ipairs(c556.pts) do
                local c558, c559, c560= p[1], p[2], p[3]
                local c561, c562= c518.world_to_screen(c558, c559, c560)
                if c561 and c562 then
                    
                    c525.x = c558 - c524.x
                    c525.y = c559 - c524.y
                    c525.z = c560 - c524.z

                    local c563= c525.x
                    local c564= c525.y
                    local c565= c525.z
                    local c566= math.sqrt(c563*c563 + c564*c564 + c565*c565)

                    local c567= math.max(1, math.floor((200 / (c566 + 1)) * (c548 / 6)))
                    local c568= math.max(1, math.floor(c567 / 2))
                    c518.rectangle(c561 - c568, c562 - c568, c567, c567, 255, 24, 24, 255)
                end
            end
        end
    end
end, { alive_only = true, require_login = true })]]
c927["require/features/paint/onshot_skeleton"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")


local function find(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x, y, z = entity.hitbox_position(ent, def.names[i])
        if x then return x, y, z end
    end
    for i = 1, #(def.idx or {}) do
        local x, y, z = entity.hitbox_position(ent, def.idx[i])
        if x then return x, y, z end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local sk = {list = {}}

local function is_skeleton_enabled()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_hitmarker then
        local ok, sel = pcall(ui.get, menu_setup.ui.paint_hitmarker)
        if not ok then return false end
        if type(sel) == "table" then
            for _, v in ipairs(sel) do
                if v == "skeleton" then return true end
            end
        end
        return false
    end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function aim_fire_handler(ev)
    if not is_skeleton_enabled() then sk.list = {} return end
    if not is_skeleton_enabled() then return end
    local target = ev and (ev.target or ev.target_index)
    if type(target) ~= 'number' or target == 0 then return end
    local pts = snap(target)
    if not pts then return end
    local now = globals.realtime and globals.realtime() or 0
    sk.list[#sk.list + 1] = {pts = pts, t = now}
    if #sk.list > 5 then table.remove(sk.list, 1) end
end

local function paint_handler(ev)
    if is_skeleton_enabled() then
        local now = globals.realtime and globals.realtime() or 0
        local hold = 2.2 * 0.8 * 3
        local fade = 2.2 * 0.8
        local total = hold + fade
        local i = 1
        while i <= #sk.list do
            if now - (sk.list[i].t or 0) > total then
                table.remove(sk.list, i)
            else
                i = i + 1
            end
        end
        table.sort(sk.list, function(a, b) return (a.t or 0) < (b.t or 0) end)
        local start = math.max(1, #sk.list - 2)
        for j = start, #sk.list do
            local it = sk.list[j]
            local age = now - (it.t or 0)
            local alpha = age <= hold and 220 or math.floor(math.max(0, (1 - math.max(0, age - hold) / fade) * 220))
            if alpha > 0 then
                local pts = it.pts or {}
                for c = 1, #chains do
                    local chain = chains[c]
                    local from, to = pts[chain[1]], pts[chain[2]]
                    if from and to then
                        local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                        local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                        if fx and tx then renderer.line(fx, fy, tx, ty, 255, 255, 255, alpha) end
                    end
                end
            end
        end
    else
        sk.list = {}
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('aim_fire', aim_fire_handler, { alive_only = true, require_login = true })
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
else
    client.set_event_callback('aim_fire', aim_fire_handler)
    client.set_event_callback('paint', paint_handler)
end]=]
c927["require/features/paint/performance_mode"] = [[



local c521, c522= pcall(require, "require/abc/menu_setup")


local c523= nil
pcall(function() c523 = require('require/abc/callbacks') end)
if not c523 then error("callbacks manager required: require/abc/callbacks") end


local c524= {
    captured = false
}

local c525= {
    blood = nil,
    ragdolls = nil,
    particles = nil,
    lensflare = nil,
    animations = nil,
    features = nil,
}

local function c526()
    if c524.captured then return end
    local function c527(c528,c529)
        local c521, c530= pcall(client.get_cvar, c528)
        if c521 and c530 then return c530 end
        return c529
    end

    c524.violence_hblood = c527('violence_hblood', '1')
    c524.cl_ragdoll_physics_enable = c527('cl_ragdoll_physics_enable', '1')
    c524.r_drawparticles = c527('r_drawparticles', '1')
    c524.mat_disable_bloom = c527('mat_disable_bloom', '0')
    c524.captured = true
end

local function c531(c528,c532)
    
    pcall(client.exec, string.format('%s %s', c528, tostring(c532)))
end

local function c533(c534,c535)
    if c534 == 'blood' then
        if c535 then c531('violence_hblood', 0) else c531('violence_hblood', c524.violence_hblood or 1) end
    elseif c534 == 'ragdolls' then
        if c535 then c531('cl_ragdoll_physics_enable', 0) else c531('cl_ragdoll_physics_enable', c524.cl_ragdoll_physics_enable or 1) end
    elseif c534 == 'particles' then
        if c535 then c531('r_drawparticles', 0) else c531('r_drawparticles', c524.r_drawparticles or 1) end
    elseif c534 == 'lensflare' then
        if c535 then c531('mat_disable_bloom', 1) else c531('mat_disable_bloom', c524.mat_disable_bloom or 0) end
    end
end

local function c536(c537)
    
    
    if c537['animations'] then
        _G.PERFORMANCE_ANIMATIONS = false
    else
        
        _G.PERFORMANCE_ANIMATIONS = true
    end

    if c537['feature updates'] then
        _G.PERFORMANCE_FEATURE_UPDATES = false
    else
        _G.PERFORMANCE_FEATURE_UPDATES = true
    end
end

local function c538(c539)
    local c540= {}
    if type(c539) == 'table' then
        for _, c530 in ipairs(c539) do c540[c530] = true end
    end
    return c540
end


c523.register('paint', function()
    if not c521 or not c522 or not c522.ui or not c522.ui.paint_performance_mode then return end
    c526()

    local c541= ui.get(c522.ui.paint_performance_mode)
    local c537= c538(c541)

    
    local c542= c537['blood'] or false
    if c542 ~= c525.blood then
        c533('blood', c542)
        c525.blood = c542
    end

    
    c542 = c537['ragdolls'] or false
    if c542 ~= c525.ragdolls then
        c533('ragdolls', c542)
        c525.ragdolls = c542
    end

    
    c542 = c537['particles'] or false
    if c542 ~= c525.particles then
        c533('particles', c542)
        c525.particles = c542
    end

    
    c542 = c537['lens flare'] or false
    if c542 ~= c525.lensflare then
        c533('lensflare', c542)
        c525.lensflare = c542
    end

    
    c542 = c537['animations'] or false
    if c542 ~= c525.animations then
        
        c536(c537)
        c525.animations = c542
        c525.features = c537['feature updates'] or false
    end

    
    local c543= c537['feature updates'] or false
    if c543 ~= c525.features then
        c536(c537)
        c525.features = c543
    end
end, { require_login = true, alive_only = true })


c523.register('shutdown', function()
    if c524.captured then
        pcall(c531, 'violence_hblood', c524.violence_hblood)
        pcall(c531, 'cl_ragdoll_physics_enable', c524.cl_ragdoll_physics_enable)
        pcall(c531, 'r_drawparticles', c524.r_drawparticles)
        pcall(c531, 'mat_disable_bloom', c524.mat_disable_bloom)
    end
    
    _G.PERFORMANCE_ANIMATIONS = true
    _G.PERFORMANCE_FEATURE_UPDATES = true
end, { require_login = true, alive_only = true })


if _G.PERFORMANCE_ANIMATIONS == nil then _G.PERFORMANCE_ANIMATIONS = true end
if _G.PERFORMANCE_FEATURE_UPDATES == nil then _G.PERFORMANCE_FEATURE_UPDATES = true end

return {
    _internal = {
        orig = c524,
        last_state = c525,
    }
}
]]
c927["require/features/paint/presmoke_warning"] = [[local c524= { start = nil, limit = nil }

client.set_event_callback("round_start", function(c525)
	c524.start = globals.curtime()
	c524.limit = tonumber(c525.timelimit) or tonumber(c525.round_time) or 115
end)

local function c526()
	local c527= entity.get_game_rules()
	if not c527 then return nil end
	local c528= {
		"m_flGameTimeRemaining",
		"m_flRoundTimeRemaining",
		"m_fRoundStartTime",
		"m_flRoundStartTime",
		"m_iRoundTime",
		"m_iRoundTimeLimit",
	}
	for _, name in ipairs(c528) do
		local c529, c530= pcall(entity.get_prop, c527, name)
		if c529 and c530 and type(c530) == "number" then
			if name:lower():find("remain") then
				return math.max(0, c530)
			end
		end
	end
	local c531= nil
	for _, name in ipairs({"m_fRoundStartTime", "m_flRoundStartTime"}) do
		local c529, c530= pcall(entity.get_prop, c527, name)
		if c529 and c530 and type(c530) == "number" then
			c531 = c530
			break
		end
	end
	if c531 then
		local c532= nil
		local c529, c533= pcall(entity.get_prop, c527, "m_iRoundTime")
		if c529 and c533 and type(c533) == "number" then c532 = c533 end
		if not c532 then
			c532 = tonumber(client.get_cvar("mp_roundtime")) or tonumber(client.get_cvar("mp_roundtime_defuse"))
		end
		if c532 and type(c532) == "number" then
			local c534= c532 - (globals.curtime() - c531)
			return math.max(0, c534)
		end
	end
	return nil
end

local function c535()
	if c524.start and c524.limit then
		local c536= globals.curtime() - c524.start
		local c534= c524.limit - c536
		if c534 < 0 then c534 = 0 end
		return c534
	end
	return c526()
end

client.set_event_callback("paint", function()
	local c537, c538= pcall(require, "require/abc/menu_setup")
	if not c537 or not c538 or not c538.ui then return end
	local c539, c540= pcall(ui.get, c538.ui.paint_presmoke)
	if not c539 or not c540 then return end

	local c534= c535()
	if not c534 then return end
	if c534 <= 18 then
		local c541, c542= client.screen_size()
		local c543= c541 * 0.5
		local c544= math.floor(c542 * 0.3)
		local c545= string.format("%.2f", c534)
		local c546= string.format("PRESMOKE NOW PRESMOKE NOW %s", c545)
		renderer.text(c543, c544, 255, 30, 30, 255, "cb+", 0, c546)
	end
end)

client.set_event_callback("round_end", function()
	c524.start = nil
	c524.limit = nil
end)

client.set_event_callback("cs_game_disconnected", function()
	c524.start = nil
	c524.limit = nil
end)

]]
c927["require/features/paint/self_boxes"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end


local ui_extrap_check, ui_extrap_ticks, ui_extrap_color
local ui_pred3d_check
local ui_pred3d_scale
if not (menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation) then
  
  ui_extrap_check = ui.new_checkbox('LUA', 'B', 'Self: Extrapolation Line')
  ui_extrap_ticks = ui.new_slider('LUA', 'B', 'Extrapolation ticks', 1, 64, 6)
  ui_extrap_color = ui.new_color_picker('LUA', 'B', 'Extrapolation color', 255, 200, 0, 220)
  ui_pred3d_check = ui.new_checkbox('LUA', 'B', 'Self: Predicted 3D Box')
  ui_pred3d_scale = ui.new_slider('LUA', 'B', 'Predicted 3D Box Scale %', 0, 200, 20)
end

local function is_self_extrapolation_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation)
    if ok then return val end
  elseif ui_extrap_check then
    local ok, val = pcall(ui.get, ui_extrap_check)
    if ok then return val end
  end
  return false
end

local function get_extrap_ticks()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_ticks then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_ticks)
    if ok then return val end
  elseif ui_extrap_ticks then
    local ok, val = pcall(ui.get, ui_extrap_ticks)
    if ok then return val end
  end
  return 6
end

local function get_extrap_color()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_color then
    local ok, r,g,b,a = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_color)
    if ok then return r,g,b,a end
  elseif ui_extrap_color then
    local ok, r,g,b,a = pcall(ui.get, ui_extrap_color)
    if ok then return r,g,b,a end
  end
  return 255,200,0,220
end

local function is_predicted_3d_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d)
    if ok then return val end
  elseif ui_pred3d_check then
    local ok, val = pcall(ui.get, ui_pred3d_check)
    if ok then return val end
  end
  return false
end

local function get_pred3d_scale()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d_scale then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d_scale)
    if ok then return val end
  elseif ui_pred3d_scale then
    local ok, val = pcall(ui.get, ui_pred3d_scale)
    if ok then return val end
  end
  return 20
end

client.set_event_callback('paint',function()
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  
  local _lp_state = client.globals and client.globals.__self_lc_state or nil
  if not _lp_state then
    _lp_state = {}
    client.globals = client.globals or {}
    client.globals.__self_lc_state = _lp_state
  end
  local function length_sqr(x,y,z)
    x = x or 0; y = y or 0; z = z or 0
    return x*x + y*y + z*z
  end
  local function time_to_ticks(seconds)
    local ti = globals.tickinterval and globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return math.floor((seconds or 0) / ti + 0.5)
  end
  local function is_local_breaking_lagcomp()
    local sim_time = entity.get_prop(lp, 'm_flSimulationTime')
    local ox,oy,oz = entity.get_origin(lp)
    if not sim_time or not ox then return false end
    local sim_ticks = time_to_ticks(sim_time)
    local prev = _lp_state.prev
    local breaking = false
    if prev then
      local delta = sim_ticks - prev.tick
      if delta > 0 and delta <= 64 then
        local dx,dy,dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
        local teleport_distance = length_sqr(dx,dy,dz)
        if teleport_distance > 4096 then breaking = true end
      end
    end
    _lp_state.prev = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
    return breaking
  end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end

  
  if is_self_extrapolation_enabled() then
    local ox,oy,oz = entity.get_origin(lp)
    if ox and oy and oz then
      local vx,vy,vz = entity.get_prop(lp, "m_vecVelocity")
      if vx and vy and vz then
        local ticks = get_extrap_ticks() or 6
        local tickint = (globals.tickinterval and globals.tickinterval()) or 0.015625
        local dt = tickint * ticks
        local px,py,pz = ox + vx * dt, oy + vy * dt, oz + vz * dt
        local sx1,sy1 = renderer.world_to_screen(ox,oy,oz)
        local sx2,sy2 = renderer.world_to_screen(px,py,pz)
        if sx1 and sx2 then
          local r,g,b,a = get_extrap_color()
          renderer.line(sx1,sy1,sx2,sy2, r, g, b, a)
          renderer.circle(sx2,sy2, r, g, b, a, 6, 0, 1.0)
          renderer.text(sx2, sy2 - 10, r, g, b, a, 'c+', 0, tostring(ticks) .. 't')
          
          local bx1,by1,bx2,by2,alpha_mult = entity.get_bounding_box(lp)
          if bx1 and alpha_mult and alpha_mult ~= 0 then
            local sx_orig, sy_orig = sx1, sy1
            if sx_orig and sy_orig then
              local dx, dy = sx2 - sx_orig, sy2 - sy_orig
              local bw, bh = (bx2 - bx1), (by2 - by1)
              local pbx, pby = bx1 + dx, by1 + dy
              
              renderer.rectangle(pbx, pby, bw, bh, 255,255,255,40)
              renderer.rectangle(pbx-1, pby-1, bw+2, bh+2, 255,255,255,200)
            end
          end

          
          if is_predicted_3d_enabled() and is_local_breaking_lagcomp() then
            
            local o = {x = ox, y = oy, z = oz}
            local offs = {}
            local keys = {'head','pelvis','l_shoulder','r_shoulder','l_hip','r_hip'}
            for i=1,#keys do
              local def = boxes[keys[i]]
              if def then
                local ok, hx, hy, hz = pcall(function() return find(lp, def) end)
                if ok and hx then
                  table.insert(offs, {x = hx - o.x, y = hy - o.y, z = hz - o.z})
                end
              end
            end
            if #offs > 0 then
              local minx,miny,minz = offs[1].x,offs[1].y,offs[1].z
              local maxx,maxy,maxz = offs[1].x,offs[1].y,offs[1].z
              for i=2,#offs do
                local v = offs[i]
                if v.x < minx then minx = v.x end
                if v.y < miny then miny = v.y end
                if v.z < minz then minz = v.z end
                if v.x > maxx then maxx = v.x end
                if v.y > maxy then maxy = v.y end
                if v.z > maxz then maxz = v.z end
              end
              
              local scale_pct = 105
              local cx = (minx + maxx) * 0.5
              local cy = (miny + maxy) * 0.5
              local cz = (minz + maxz) * 0.5
              local ex = (maxx - minx) * 0.5 * (1 + scale_pct / 100)
              local ey = (maxy - miny) * 0.5 * (1 + scale_pct / 100)
              local ez = (maxz - minz) * 0.5 * (1 + scale_pct / 100)
              minx = cx - ex; maxx = cx + ex
              miny = cy - ey; maxy = cy + ey
              minz = cz - ez; maxz = cz + ez

              
              local corners = {
                {x = px + minx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + maxy, z = pz + maxz},
                {x = px + minx, y = py + maxy, z = pz + maxz},
              }
              
              local sc = {}
              local all_on_screen = true
              for i=1,8 do
                local sx, sy = renderer.world_to_screen(corners[i].x, corners[i].y, corners[i].z)
                if not sx then all_on_screen = false break end
                sc[i] = {x = sx, y = sy}
              end
              if all_on_screen then
                
                local rr,gg,bb,aa = 255,255,255,200
                
                renderer.line(sc[1].x,sc[1].y,sc[2].x,sc[2].y, rr,gg,bb,aa)
                renderer.line(sc[2].x,sc[2].y,sc[3].x,sc[3].y, rr,gg,bb,aa)
                renderer.line(sc[3].x,sc[3].y,sc[4].x,sc[4].y, rr,gg,bb,aa)
                renderer.line(sc[4].x,sc[4].y,sc[1].x,sc[1].y, rr,gg,bb,aa)
                
                renderer.line(sc[5].x,sc[5].y,sc[6].x,sc[6].y, rr,gg,bb,aa)
                renderer.line(sc[6].x,sc[6].y,sc[7].x,sc[7].y, rr,gg,bb,aa)
                renderer.line(sc[7].x,sc[7].y,sc[8].x,sc[8].y, rr,gg,bb,aa)
                renderer.line(sc[8].x,sc[8].y,sc[5].x,sc[5].y, rr,gg,bb,aa)
                
                for i=1,4 do renderer.line(sc[i].x,sc[i].y,sc[i+4].x,sc[i+4].y, rr,gg,bb,aa) end
              end
            end
          end
        end
      end
    end
  end
end)]=]
c927["require/features/paint/self_skeleton"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end
end

if cb_ok and callbacks and callbacks.callback then
  callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end]=]
c927["require/features/paint/skeletons"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}


local time = require("require/help/time")
local enemies = require("require/help/enemies")
local color = require("require/help/color")
local math_help = require("require/help/math")




local function find(ent, def)
    if not ent or not def then return end
    local names = def.names
    if names then
        for i = 1, #names do
            local x, y, z = entity.hitbox_position(ent, names[i])
            if x then return x, y, z end
        end
    end
    local idx = def.idx
    if idx then
        for i = 1, #idx do
            local x, y, z = entity.hitbox_position(ent, idx[i])
            if x then return x, y, z end
        end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    return pts
end


client.set_event_callback("paint", function()
    local enemy_list = entity.get_players(true)
    for i = 1, #enemy_list do
        local ent = enemy_list[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local pts = snap(ent)
            for _, chain in ipairs(chains) do
                local from = pts[chain[1]]
                local to = pts[chain[2]]
                if from and to then
                    local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                    local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                    if fx and fy and tx and ty then
                        renderer.line(fx, fy, tx, ty, 255, 0, 0, 255)
                    end
                end
            end
        end
    end
end)

]=]
c927["require/features/paint/target_info"] = [[local c536= require("require/abc/menu_setup")
local c537= renderer
local c538= client


local c539= nil
local function c540()
	if c539 then return c539 end
	if c537.load_rgba then
		local c541, c542= pcall(c537.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if c541 and c542 then c539 = c542 end
	end
	return c539
end




local c543= state or {
	fl_val = math.random(0, 14),
	fl_target = math.random(0, 14),
	by_val = math.random(-58, 58),
	by_target = math.random(-58, 58),
	last_update = c538.system_time()
}


local function c544()
	c543.fl_val = math.random(0, 14)
	c543.by_val = math.random(-58, 58)
end



local function c545()
	local c546= c538.system_time()
	if c546 - c543.last_update > 1 then
		c543.fl_target = math.random(0, 14)
		c543.by_target = math.random(-58, 58)
		c543.last_update = c546
	end
end

local function c547()
	c543.fl_val = c543.fl_val + (c543.fl_target - c543.fl_val) * 0.08
	c543.by_val = c543.by_val + (c543.by_target - c543.by_val) * 0.08
end

local function c548()
	if not ui.get(c536.ui.paint_target_info) then return end

	c545()
	c547()
	c544() 

	
	local c549, c550= c538.screen_size()
	local c551= 170
	local c552= 80
	local c553= 30
	local c554= math.floor(c550 / 2 - c552 / 2)

	
	c537.rectangle(c553 - 7, c554 - 5, c551 + 14, c552 + 10, 0, 0, 0, 200)
	c537.rectangle(c553 - 6, c554 - 4, c551 + 12, c552 + 8, 60, 60, 60, 255)
	c537.rectangle(c553 - 5, c554 - 3, c551 + 10, c552 + 6, 40, 40, 40, 255)
	c537.rectangle(c553 - 3, c554 - 1, c551 + 6, c552 + 2, 60, 60, 60, 255)
	c537.rectangle(c553 - 2, c554, c551 + 4, c552, 12, 12, 12, 255)
	c537.rectangle(c553 - 2, c554, c551 + 4, c552, 32, 32, 32, 255)

	
	local c555= c540()
	if c555 and c537.texture then
		c537.texture(c555, c553 - 2, c554, c551 + 4, c552, 255,255,255,60, 'r')
	end

	
	local c556= c554
	local c557= 1
	local c558= math.floor((c551 + 4) / 2)
	local c559= math.ceil((c551 + 4) / 2)
	
	c537.rectangle(c553 - 2, c556 - 1, c551 + 4, c557 + 2, 0, 0, 0, 255)
	if c537.gradient then
		c537.gradient(c553 - 2, c556, c558, c557, 59,175,222,255, 202,70,205,255, true)
		c537.gradient(c553 - 2 + c558, c556, c559, c557, 202,70,205,255, 204,227,53,255, true)
	end

	
	local c560= c553 + 12
	local c561= c554 + 13  
	local c562= 18
	local c563= c551 - 60 
	local c564= 7 

	
	local c565= math.floor(c543.fl_val + 0.5)
	
	local c566= c564 / 2 - 7
	c537.text(c560 - 8, c561 + c566, 255,255,255,255, '', 0, "Fake lag")
	local c567= c560 + 42 
	local c568= c561 + 6  
	local c569= 14
	local c570= math.floor(c563 * (c543.fl_val / c569))
	
	local c571= c563 + 2
	local c572= c564 + 2
	local c573= c567 + 1
	local c574= c568 + 1
	local c575= c563 - 2
	local c576= c564 - 2
	c537.rectangle(c567 - 1, c568 - 1, c571, c572, 0, 0, 0, 255)
	c537.rectangle(c567, c568, c563, c564, 60, 60, 60, 255)
	c537.rectangle(c573, c574, math.max(0, math.floor(c575 * (c543.fl_val / c569))), c576, 180, 220, 80, 255)
	local c577= c567 + c570 - 4
	local c578= c568 + c564 / 2
	c537.circle(c577, c578, 5, 180,220,80,255, 16)
	
	local c579= tostring(c565)
	local c580= c567 + c570 + 8 
	local c581= c568 + c564 + 0 
	c537.text(c580 + 1, c581 + 1, 0,0,0,255, '-', 0, c579)
	c537.text(c580, c581, 255,255,255,255, '-', 0, c579)

	
	local c582= math.floor(c543.by_val + 0.5)
	c537.text(c560 - 8, c561 + c562 + c566, 255,255,255,255, '', 0, "Body yaw")
	local c583= c560 + 42 
	local c584= c561 + c562 + 6  
	local c585= -58
	local c586= 58
	local c587= c586 - c585
	
	local c588= math.floor(c563 * ((c543.by_val - c585) / c587))
	
	local c589= c563 + 2
	local c590= c564 + 2
	local c591= c583 + 1
	local c592= c584 + 1
	local c593= c563 - 2
	local c594= c564 - 2
	c537.rectangle(c583 - 1, c584 - 1, c589, c590, 0, 0, 0, 255)
	c537.rectangle(c583, c584, c563, c564, 60, 60, 60, 255)
	
	local c595= c583 + c563 / 2
	local c596= c583 + c588
	if c543.by_val < 0 then
		c537.rectangle(c596 + 1, c592, c595 - c596, c594, 180, 220, 80, 255)
	else
		c537.rectangle(c595 + 1, c592, c596 - c595, c594, 180, 220, 80, 255)
	end
	local c597= c596 - 4
	local c598= c584 + c564 / 2
	c537.circle(c597, c598, 5, 180,220,80,255, 16)
	
	local c599= tostring(c582)
	local c600= c583 + c588
	local c601= c600 + 8 
	local c602= c584 + c564 + 0 
	c537.text(c601 + 1, c602 + 1, 0,0,0,255, '-', 0, c599)
	c537.text(c601, c602, 255,255,255,255, '-', 0, c599)

	
	local c603= 22
	local c604= 14

	
	local c605= math.random() > 0.5 and "[Offensive]" or "[Defensive]"
	local c606= c605 == "[Offensive]" and {204,227,53,255} or {202,70,205,255}
	c537.text(c560 - 8, c561 + c562 * 2 + c566, 255,255,255,255, '', 0, "Double tap")
	local c607= c560 + c563 + 32
	local c608= c561 + c562 * 2 - 2
	c537.text(c607 + 4, c608 + 2, table.unpack(c606), '', 0, c605)

	
	local c609= math.random() > 0.5 and "[On]" or "[Off]"
	local c610= c609 == "[On]" and {80,255,80,255} or {255,255,80,255}
	c537.text(c560 - 8, c561 + c562 * 3 + c566, 255,255,255,255, '', 0, "Freestanding")
	local c611= c560 + c563 + 32
	local c612= c561 + c562 * 3 - 2
	c537.text(c611 + 4, c612 + 2, table.unpack(c610), '', 0, c609)
end

local c613= require("require/abc/callbacks")
c613.callback('paint', c548, { alive_only = true, require_login = true })
]]
c927["require/features/paint/text_watermark"] = [[local c539= require("require/help/string")
local c540= require("require/help/time")
local c541= require("require/help/color")
local c542= c541.rgba_to_hex
local c543= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local c544= nil

local function c545(c546,c547,c548,c549,c550,c551,c552)
    local c553= c540.realtime() or globals.curtime()
    if not c552 or #c552 == 0 then return "" end
    local c554= {}

    if c546 == 0 then
        local c555= c542(c548,c549,c550,c551)
        for i=1,#c552 do c554[#c554+1] = c555 .. c552:sub(i,i) end
        return table.concat(c554)
    end

    if c546 == 2 then
        local c556= (math.sin(c553 * c547) + 1) * 0.5
        local c557= c541.clamp(math.floor(c551 * (0.45 + 0.55 * c556)))
        local c555= c542(c548,c549,c550,c557)
        for i=1,#c552 do c554[#c554+1] = c555 .. c552:sub(i,i) end
        return table.concat(c554)
    end

    if c546 == 3 then
        for i=1,#c552 do
            local c558= math.sin(c553 * c547 - i * 0.6)
            local c559= math.max(0, c558)
            local c556= c559 * c559
            local c557= c541.clamp(math.floor(c551 * (0.35 + 0.65 * c556)))
            c554[#c554+1] = c542(c548,c549,c550,c557) .. c552:sub(i,i)
        end
        return table.concat(c554)
    end

    for i=1,#c552 do
        local c556= (math.sin(c553*c547 - i*0.35) + 1) * 0.5
        local c557= c541.clamp(math.floor(c551 * (0.4 + 0.6 * c556)))
        c554[#c554+1] = c542(c548,c549,c550,c557) .. c552:sub(i,i)
    end
    return table.concat(c554)
end

local c560= {}
local c561= {}
for i, item in ipairs({
    { 'misc', 'settings', 'menu color' },
}) do
    local c562= {ui.reference(item[1], item[2], item[3])}
    c560[i] = c562
    for _, ref in ipairs(c562) do
        c561[ref] = true
    end
end

local c563, c564= pcall(require, "require/abc/callbacks")
local function c565(c566)
    local c567, c568= client.screen_size()
    if not c567 or not c568 then return end
    local c569, c570, c571, c572= 255, 255, 255, 255
    
    local c573= false
    local c574, c575= pcall(require, "require/abc/menu_setup")
    if c574 and c575 and c575.ui and c575.ui.paint_advertisement_color then
        local c576, c551, c550, c577, c578= pcall(ui.get, c575.ui.paint_advertisement_color)
        if c576 then
            c573 = true
            if type(c551) == 'number' then
                c569 = c541.clamp(c551 or c569)
                c570 = c541.clamp(c550 or c570)
                c571 = c541.clamp(c577 or c571)
                c572 = c541.clamp(c578 or c572)
            elseif type(c551) == 'string' and #c551 == 12 then
                local c579
                c579, mr = pcall(function() return tonumber(c551:sub(1,3)) end)
                c579, mg = pcall(function() return tonumber(c551:sub(4,6)) end)
                c579, mb = pcall(function() return tonumber(c551:sub(7,9)) end)
                c579, ma = pcall(function() return tonumber(c551:sub(10,12)) end)
                c569 = c541.clamp(c569 or 255); c570 = c541.clamp(c570 or 255); c571 = c541.clamp(c571 or 255); c572 = c541.clamp(c572 or 255)
            end
        end
    end

    if not c573 then
        local c576, c551, c550, c577, c578= pcall(ui.get, c560[1][1])
        if c576 then
            if type(c551) == 'number' then
                c569 = c541.clamp(c551 or c569)
                c570 = c541.clamp(c550 or c570)
                c571 = c541.clamp(c577 or c571)
                c572 = c541.clamp(c578 or c572)
            elseif type(c551) == 'string' and #c551 == 12 then
                local c579
                c579, mr = pcall(function() return tonumber(c551:sub(1,3)) end)
                c579, mg = pcall(function() return tonumber(c551:sub(4,6)) end)
                c579, mb = pcall(function() return tonumber(c551:sub(7,9)) end)
                c579, ma = pcall(function() return tonumber(c551:sub(10,12)) end)
                c569 = c541.clamp(c569 or 255); c570 = c541.clamp(c570 or 255); c571 = c541.clamp(c571 or 255); c572 = c541.clamp(c572 or 255)
            end
        end
    end

    local c574, c575= pcall(require, "require/abc/menu_setup")
    if not c574 or not c575 or not c575.ui then return end
    if not ui.get(c575.ui.paint_advertisement) then return end
    local c553= c540.realtime() or globals.curtime()
    local c580= 0
    local c581= math.floor(200 + 55 * (math.sin(c553*2)+1)/2)
    local c582, c583, c584= "sodium", "[BETA]", 3

    local c585, c586= renderer.measure_text("", c582)
    c585 = c585 or 0; c586 = c586 or 16
    local c587= (renderer.measure_text("", c583) or 0)

    if c543 and not c544 then
        local c588= math.floor(c567/2 - (c585 + c584 + c587)/2)
        local c589= math.floor(c568 - 15)
        c544 = c543.new('sodium_watermark', {
            x = c588,
            y = c589,
            w = c585 + c584 + c587,
            h = c586,
                default_pos = { x = c588, y = c589 },
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
        })
    end

    if c544 then
        c544:handle()
    end

    local c590, c591
    if c544 then
        c590 = c544.x
        c591 = c544.y + c580
    else
        c590 = math.floor(c567/2 - (c585 + c584 + c587)/2)
        c591 = c568 - 15 + c580
    end

    local c592= math.floor(math.max(0, c581 - 140) * 0.6)
    local c593= { {-1,0},{1,0},{0,-1},{0,1} }

    if c544 then c544:draw() end

    for _,o in ipairs(c593) do renderer.text(c590+o[1], c591+o[2], 0,0,0, c592, "", 0, c582) end
    renderer.text(c590, c591, 255,255,255, c581, "", 0, c582)

    local c594= 1
    local c595, c596= pcall(require, "require/abc/menu_setup")
    if c595 and c596 and c596.ui and c596.ui.paint_advertisement_animation then
        local c597, c598= pcall(ui.get, c596.ui.paint_advertisement_animation)
        if c597 and type(c598) == 'number' then c594 = c598 end
    end

    local c599= c590 + c585 + c584
    local c600= c545(c594, 3.5, c569, c570, c571, c572, c583)
    renderer.text(c599, c591, c569, c570, c571, c572, "", 0, c600)
end

if c563 and c564 and c564.callback then
    c564.callback('paint', c565, { alive_only = true, require_login = true })
end]]
c927["require/features/paint/third_person_distance"] = [[local c542= require("require/abc/menu_setup")
local c543= require("require/help/time")
local c544= require("require/help/math")
local c545= require("require/help/safe")
local c546= { original = nil, last = nil, last_update = nil }

local function c547()
    if cvar.cam_idealdist and cvar.cam_idealdist.get_float then
        return cvar.cam_idealdist:get_float()
    end
    return nil
end

local function c548(c549)
    if cvar.cam_idealdist and cvar.cam_idealdist.set_float then
        cvar.cam_idealdist:set_float(c549)
        return true
    elseif client and client.exec then
        client.exec("cam_idealdist " .. tostring(c549))
        return true
    end
    return false
end

local c550= require("require/abc/callbacks")
c550.callback('paint', function()
    local c551= c542.ui and c542.ui.paint_third_person_distance
    if not c551 then
        client.log('third_person_distance: menu ref missing')
        return
    end
    local c552= c545.safe_get(c551)
    if type(c552) ~= 'number' then
        client.log('third_person_distance: invalid slider value', tostring(c552))
        return
    end
    local c553= c544.clamp(c552, 29, 180)
    c553 = c544.round(c553, 2)
    if c546.original == nil then
        c546.original = c547()
        if c546.original == nil then
            client.log('third_person_distance: cam_idealdist cvar not available')
        end
    end
    if c546.last == nil then
        c546.last = c547() or c553
    end
    local c554= c543.realtime()
    local c555= c546.last_update or c554
    local c556= c554 - c555
    c546.last_update = c554
    local c557= 300
    local c558= c557 * c556
    if math.abs(c546.last - c553) > 0.01 then
        local c559= c544.clamp(c558 / math.max(math.abs(c553 - c546.last), 0.01), 0, 1)
        c546.last = c544.lerp(c546.last, c553, c559)
        c546.last = c544.round(c546.last, 2)
        c548(c546.last)
    end
end, { require_login = true })]]
c927["require/features/paint/warnings"] = [[local c545, c546= client.screen_size()
local c547, c548= pcall(require, "require/abc/menu_setup")


local function c549()
    
    if not c547 or not c548 or not c548.ui or not c548.ui.paint_warnings then return end
    local c550= ui.get(c548.ui.paint_warnings)
    local c551= false
    if type(c550) == "table" then
        for _, v in ipairs(c550) do
            if v == "lethal" then c551 = true break end
        end
    end
    if not c551 then return end

    if entity.get_prop(entity.get_local_player(), 'm_iHealth') and entity.get_prop(entity.get_local_player(), 'm_iHealth') > 0 and entity.get_prop(entity.get_local_player(), 'm_iHealth') < 93 then
        renderer.text(c545 / 2, c546 * 0.3, 255, 0, 0, 255, "c, -", 0, "YOU'RE LETHAL:   " .. entity.get_prop(entity.get_local_player(), 'm_iHealth') .. " HP REMAINING")
    end
    
end

local c552, c553= pcall(require, "require/abc/callbacks")
if c552 and c553 then
    c553.callback('paint', c549, { alive_only = true, require_login = true })
end]]
c927["require/features/paint/watermark_gamesense"] = [[local c548= renderer
local c549= client
local c550= globals
local c551= require('require/help/color')

local c552= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local c553= nil

local function c554()
	local c555= c550 and c550.frametime and c550.frametime() or 0.016
	if c555 > 0 then
		return math.floor(1 / c555 + 0.5)
	end
	return 0
end

local c556= nil
local function c557()
	if c556 then return c556 end
	if c548.load_rgba then
		local c558, c559= pcall(c548.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if c558 and c559 then c556 = c559 end
	end
	return c556
end

local c560= c551.hex_to_rgba

local c561= {
	green  = "a5ca2aFF",
	red    = "d96464FF",
	yellow = "ccb854FF",
	blue   = "5462ccFF",
	purple = "7054ccFF",
	white  = "ffffffFF",
	grey   = "757575FF",
	black  = "000000FF",
	pink   = "c8a2deFF",
}


local c562= require("require/abc/login_system")
local c563= require("require/abc/menu_setup")
local c564= require("require/help/self")

local c565= require("require/help/time")
local c566= 0
local c567= c565.new(0.25)

local function c568()
	if not c563 or not c563.ui then return end
	
	local c569, c570= pcall(ui.get, c563.ui.paint_watermark)
	if not c569 or not c570 then return end
	
	local c571, c572= pcall(ui.get, c563.ui.paint_watermark_type)
	if not c571 or c572 ~= 0 then return end
	local c573, c574= c549 and c549.screen_size and c549.screen_size() or 800, 600

	local c575
	if c562.logged_in then
		local c576= database.read and database.read('cached_credentials')
		if c576 and c576.username then
			c575 = c576.username
		end
	else
		local c577= c562.load_credentials and c562.load_credentials()
		if c577 and c577.username then
			c575 = c577.username
		end
	end
	if not c575 or c575 == "" then
		c575 = c564.player_name and c564.player_name() or "unknown"
	end
	if c565.expired(c567) then
		c566 = c554()
		c565.reset(c567)
	end
	local c578= c566

	local c579= 0
	if c564 and c564.ping then
		local c580= c564.ping()
		if type(c580) == 'number' then c579 = c580 end
	elseif c549 and c549.latency then
		local c580= c549.latency()
		if type(c580) == 'number' then c579 = c580 end
	end
	local c581= math.floor((c579 or 0) * 1000 + 0.5)

	local c582= ''
	local c583= {
		{text = "game", style = c582, color = c561.white},
		{text = "sense", style = c582, color = c561.green},
		{text = " ", style = c582, color = c561.white},
		{text = "[beta]", style = c582, color = c561.white},
		{text = " | ", style = c582, color = c561.white},
		{text = c575, style = c582, color = c561.white},
		{text = " | ", style = c582, color = c561.white},
		{text = tostring(c581) .. " ms", style = c582, color = c561.white},
		{text = " | ", style = c582, color = c561.white},
		{text = tostring(c578) .. " fps", style = c582, color = c561.white},
	}

	local c584, c585= 0, 0
	for _, seg in ipairs(c583) do
		local c586, c587= c548.measure_text and c548.measure_text(seg.style, seg.text) or 0, 13
		c584 = c584 + c586
		if c587 > c585 then c585 = c587 end
	end
	local c588, c589= 5, 2
	local c590= c584 + c588 * 2
	local c591= c585 + c589 * 2
	local c592= c573 - c590 - 16
	local c593= 16

	if c552 and not c553 then
		local c594= c592
		local c595= c593
		c553 = c552.new('gamesense_watermark', {
			x = c594,
			y = c595,
			w = c590,
			h = c591,
			snap = true,
			snap_threshold = 24,
			require_menu_open = true,
			box_color = {255,255,255,100},
			default_pos = { x = c594, y = c595 },
		})
	end

	if c553 then c553:handle() end

	if c553 then
		c592 = c553.x
		c593 = c553.y
	end

	c548.rectangle(c592 - 7, c593 - 5, c590 + 14, c591 + 10, 0, 0, 0, 200)
	c548.rectangle(c592 - 6, c593 - 4, c590 + 12, c591 + 8, 60, 60, 60, 255)
	c548.rectangle(c592 - 5, c593 - 3, c590 + 10, c591 + 6, 40, 40, 40, 255)
	c548.rectangle(c592 - 3, c593 - 1, c590 + 6, c591 + 2, 60, 60, 60, 255)
	c548.rectangle(c592 - 2, c593, c590 + 4, c591, 12, 12, 12, 255)
	c548.rectangle(c592 - 2, c593, c590 + 4, c591, 32, 32, 32, 255)

	local c596= c557()
	if c596 and c548.texture then
		c548.texture(c596, c592 - 2, c593, c590 + 4, c591, 255,255,255,60, 'r')
	end

	if c548.gradient then
		c548.gradient(c592 - 2, c593, c590 / 2 + 1, 1, 59,175,222,255, 202,70,205,255, true)
		c548.gradient(c592 - 2 + c590 / 2, c593, c590 / 2 + 4.5, 1, 202,70,205,255, 204,227,53,255, true)
	end

	local c597= c592 + c588
	local c598= c593 + c589
    if c553 then c553:draw() end
	for _, seg in ipairs(c583) do
		local c586, c587= c548.measure_text and c548.measure_text(seg.style, seg.text) or 0, 13
			local c599,c600,c601,c602= c560(seg.color)
			c599,c600,c601,a = c551.normalize(c599,c600,c601,c602)
			c548.text(c597, c598, c599,c600,c601,c602, seg.style, nil, seg.text)
		c597 = c597 + c586
	end
end

local c603, c604= pcall(require, "require/abc/callbacks")
if c603 and c604 and c604.callback then
	c604.callback('paint', c568, { alive_only = true, require_login = true })
end
]]
c927["require/features/paint/watermark_solus"] = [[local c551= renderer
local c552= client
local c553= require('require/help/color')
local c554, c555= pcall(require, "require/abc/callbacks")
local c556, c557= pcall(require, "require/abc/menu_setup")
local c558, c559= pcall(ui.reference, 'misc', 'settings', 'menu color')
local c560= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local c561= nil
local function c562(c563,c564,c565,c566,c567,c568,c569,c570,c571)
    c551.rectangle(c563+c567, c564, c565-(c567*2), c566, c568,c569,c570,c571)
    c551.rectangle(c563, c564+c567, c565, c566-(c567*2), c568,c569,c570,c571)
    c551.circle(c563+c567, c564+c567, c568,c569,c570,c571, c567, 0, 1)
    c551.circle(c563+c565-c567, c564+c567, c568,c569,c570,c571, c567, 0, 1)
    c551.circle(c563+c567, c564+c566-c567, c568,c569,c570,c571, c567, 0, 1)
    c551.circle(c563+c565-c567, c564+c566-c567, c568,c569,c570,c571, c567, 0, 1)
end

local c572= globals
local c573= 0
local c574= 0
local c575= 0.1

local function c576(c577)
    local c578, c579= pcall(require, c577)
    if c578 then return c579 end
    return nil
end

local function c580()
    if not c556 or not c557 or not c557.ui then return end
    local c581, c582= pcall(ui.get, c557.ui.paint_watermark)
    if not c581 or not c582 then return end
    local c583, c584= pcall(ui.get, c557.ui.paint_watermark_type)
    if not c583 or c584 ~= 1 then return end

    local c585, c586= c552.screen_size()
    if not c585 or not c586 then return end

    local c587= "unknown"
    local c588= c576('require/abc/login_system')
    local c589= (pcall(require, 'require/help/self') and require('require/help/self')) or nil
    if c588 then
        if c588.logged_in then
            local c590= database and database.read and database.read('cached_credentials')
            if c590 and c590.username then c587 = c590.username end
        else
            if c588.load_credentials then
                local c591= c588.load_credentials()
                if c591 and c591.username then c587 = c591.username end
            end
        end
    end
    if (not c587 or c587 == "") and c589 and c589.player_name then
        c587 = c589.player_name()
    end

    local c592= c573 or 0
    pcall(function()
        local c593= c572 and c572.realtime and c572.realtime() or os.clock()
        if (c593 - (c574 or 0)) >= c575 then
            local c594= c572 and c572.frametime and c572.frametime() or 0.016
            if c594 and c594 > 0 then
                c573 = math.floor(1 / c594 + 0.5)
            end
            c574 = c593
        end
        c592 = c573 or c592
    end)

    local c595= 0
    if c589 and c589.ping then
        local c596= c589.ping()
        if type(c596) == 'number' then c595 = math.floor(c596 * 1000 + 0.5) end
    elseif c552 and c552.latency then
        local c596= c552.latency()
        if type(c596) == 'number' then c595 = math.floor(c596 * 1000 + 0.5) end
    end

    local c597= {
        { text = "gamesense ", bold = true },
        { text = " | ", bold = false },
        { text = c587 or "unknown", bold = false },
        { text = " | ", bold = false },
        { text = tostring(c595) .. " ms", bold = false },
        { text = " | ", bold = false },
        { text = tostring(c592) .. " fps", bold = false },
    }

    local c598, c599= 0, 0
    for _, seg in ipairs(c597) do
        local c565, c566= 0, 13
        if c551.measure_text then
            local c578, c600, c601= pcall(c551.measure_text, '', seg.text)
            if c578 and c600 then c565, h = c600, c601 or c566 end
        end
        c598 = c598 + (c565 or 0)
        if c566 and c566 > c599 then c599 = c566 end
    end

    local c602, c603= 12, 6
    local c604= c598 + c602 * 2
    local c605= c599 + c603 * 2
    local c606= 18
    local c563= c585 - c604 - c606
    local c564= c606
    local c567= 8
    if c560 and not c561 then
        local c607= c563
        local c608= c564
        c561 = c560.new('solus_watermark', {
            x = c607,
            y = c608,
            w = c604,
            h = c605,
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
            default_pos = { x = c607, y = c608 },
        })
    end

    if c561 then c561:handle() end

    if c561 then
        c563 = c561.x
        c564 = c561.y
    end
    local c609, c610, c611, c612= 255, 140, 0, 255
    do
        
        if c556 and c557 and c557.ui and c557.ui.paint_watermark_color then
            local c613, c614, c615, c616, c617= pcall(ui.get, c557.ui.paint_watermark_color)
            if c613 then
                if type(c614) == 'number' then
                    c609 = c553.clamp(c614 or c609)
                    c610 = c553.clamp(c615 or c610)
                    c611 = c553.clamp(c616 or c611)
                    c612 = c553.clamp(c617 or c612)
                elseif type(c614) == 'string' and #c614 == 12 then
                    local c578
                    c578, mr = pcall(function() return tonumber(c614:sub(1,3)) end)
                    c578, mg = pcall(function() return tonumber(c614:sub(4,6)) end)
                    c578, mb = pcall(function() return tonumber(c614:sub(7,9)) end)
                    c578, ma = pcall(function() return tonumber(c614:sub(10,12)) end)
                    c609 = c553.clamp(c609 or 255); c610 = c553.clamp(c610 or 140); c611 = c553.clamp(c611 or 0); c612 = c553.clamp(c612 or 255)
                end
                
            else
                
                if c558 and c559 then
                    local c618, c619, c620, c621, c622= pcall(ui.get, c559)
                    if c618 then
                        if type(c619) == 'number' then
                            c609 = c553.clamp(c619 or c609)
                            c610 = c553.clamp(c620 or c610)
                            c611 = c553.clamp(c621 or c611)
                            c612 = c553.clamp(c622 or c612)
                        elseif type(c619) == 'string' and #c619 == 12 then
                            local c578
                            c578, mr = pcall(function() return tonumber(c619:sub(1,3)) end)
                            c578, mg = pcall(function() return tonumber(c619:sub(4,6)) end)
                            c578, mb = pcall(function() return tonumber(c619:sub(7,9)) end)
                            c578, ma = pcall(function() return tonumber(c619:sub(10,12)) end)
                            c609 = c553.clamp(c609 or 255); c610 = c553.clamp(c610 or 140); c611 = c553.clamp(c611 or 0); c612 = c553.clamp(c612 or 255)
                        end
                    end
                end
            end
        else
            
            if c558 and c559 then
                local c613, c614, c615, c616, c617= pcall(ui.get, c559)
                if c613 then
                    if type(c614) == 'number' then
                        c609 = c553.clamp(c614 or c609)
                        c610 = c553.clamp(c615 or c610)
                        c611 = c553.clamp(c616 or c611)
                        c612 = c553.clamp(c617 or c612)
                    elseif type(c614) == 'string' and #c614 == 12 then
                        local c578
                        c578, mr = pcall(function() return tonumber(c614:sub(1,3)) end)
                        c578, mg = pcall(function() return tonumber(c614:sub(4,6)) end)
                        c578, mb = pcall(function() return tonumber(c614:sub(7,9)) end)
                        c578, ma = pcall(function() return tonumber(c614:sub(10,12)) end)
                        c609 = c553.clamp(c609 or 255); c610 = c553.clamp(c610 or 140); c611 = c553.clamp(c611 or 0); c612 = c553.clamp(c612 or 255)
                    end
                end
            end
        end
    end

    local function c623(c624,c625,c626,c568,c627,c628,c629)
        local c630= math.rad(c627)
        local c631= math.rad(c628)
        for i=0,c629 do
            local c632= i / c629
            local c571= c630 + (c631 - c630) * c632
            c624[#c624+1] = { c625 + math.cos(c571) * c568, c626 + math.sin(c571) * c568 }
        end
    end

    local function c633(c563,c564,c565,c566,c634,c635)
        local c636= {}
        c635 = c635 or 6
        local c637= c563
        local c638= c563 + c565
        local c639= c564
        local c640= c564 + c566
        local c641= c637 + c634
        local c642= c638 - c634
        local function c643(c644,c645)
            local c646= #c636
            if c646 == 0 then c636[#c636+1] = { c644, c645 }; return end
            local c647= c636[c646]
            if not (math.abs(c647[1] - c644) < 0.001 and math.abs(c647[2] - c645) < 0.001) then
                c636[#c636+1] = { c644, c645 }
            end
        end

        if c642 > c641 then
            for xx = c641, c642, c635 do c643(xx, c639) end
            
            c643(c642, c639)
        end

        c623(c636, c638 - c634, c639 + c634, c634, -90, 0, 6)

        local c648= c639 + c634
        local c649= c640 - c634
        if c649 > c648 then
            for yy = c648, c649, c635 do c643(c638, yy) end
            c643(c638, c649)
        end

        c623(c636, c638 - c634, c640 - c634, c634, 0, 90, 6)

        if c642 > c641 then
            for xx = c642, c641, -c635 do c643(xx, c640) end
            c643(c641, c640)
        end

        c623(c636, c637 + c634, c640 - c634, c634, 90, 180, 6)

        if c649 > c648 then
            for yy = c649, c648, -c635 do c643(c637, yy) end
            c643(c637, c648)
        end

        c623(c636, c637 + c634, c639 + c634, c634, 180, 270, 6)

        return c636
    end

    local c650= 3
    local c636= c633(c563-1, c564-1, c604+2, c605+2, c567+1, c650)
    local c646= #c636

    if c561 then c561:draw() end

    c562(c563-1, c564-1, c604+2, c605+2, c567+1, 0, 0, 0, 255)
    c562(c563, c564, c604, c605, c567, 0, 0, 0, 200)

    
    if c646 > 2 then
        local c632= (c572 and c572.realtime and c572.realtime() or 0)
        local c651= 7
        c651 = c651 * 4
        local c652= c651 / 60
        local c653= math.max(0.5, c652 * c646)
        local c654= math.floor((c632 * c653) % c646)

        local c655= math.max(6, math.floor(c646 * 0.25))

        local c656= c553.clamp(math.floor((c612 or 255) * 1.15))
        for j = c655 - 1, 0, -1 do
            local c657= ((c654 + j) % c646) + 1
            local c658= ((c654 + j + 1) % c646) + 1
            local c659= c636[c657]
            local c660= c636[c658]
            if c659 and c660 then
                local c661= 1 - (j / c655)
                local c571= c553.clamp(math.floor(c656 * c661))
                c551.line(c659[1], c659[2], c660[1], c660[2], c609, c610, c611, c571)
            end
        end
    end

    local c662= c563 + c602
    local c663= c564 + math.floor((c605 - c599) / 2)
    for i, seg in ipairs(c597) do
        local c565= 0
        if c551.measure_text then
            local c578, c600= pcall(c551.measure_text, '', seg.text)
            if c578 and c600 then c565 = c600 end
        end
        local c664= seg.bold and 'b' or ''
        c551.text(c662, c663, 255,255,255,255, c664, 0, seg.text)
        c662 = c662 + c565
    end
end

if c554 and c555 and c555.callback then
    c555.callback('paint', c580, { alive_only = true, require_login = true })
end

return true]]
c927["require/features/paint/world_hitmarker_plus"] = [[
local c554= require("require/abc/menu_setup")
local c555= {shots = {}, last = 0}
local c556, c557= pcall(require, "require/brain/api/vector/vector")

local function c558()
	local c559= ui.get(c554.ui.paint_hitmarker)
	if type(c559) == "table" then
		for _, v in ipairs(c559) do
			if v == "world +" then return true end
		end
	end
	return false
end

local c560, c561= pcall(require, "require/abc/callbacks")
local function c562(c563)
	if not c558() then c555.shots = {} return end
	if not c558() then return end
	local c564= globals.realtime()
	
	if c555.last and c564 - c555.last < 0.05 then return end
	c555.last = c564
	c555.shots[#c555.shots + 1] = {impacts = {}, finished = false, t = c564}
	if #c555.shots > 12 then table.remove(c555.shots, 1) end
end

local function c565(c563)
	if not c558() then c555 = {shots = {}, last = 0} return end
	local c566= entity.get_local_player()
	if not c566 then return end
	local c567= client.userid_to_entindex(c563.userid or 0)
	if c567 ~= c566 then return end
	local c564= globals.realtime()
	local c568
	for i = #c555.shots, 1, -1 do
		if not c555.shots[i].finished and c564 - (c555.shots[i].t or 0) < 1.2 then
			c568 = c555.shots[i]
			break
		end
	end
	if not c568 then return end
	local c569, c570, c571= c563.x, c563.y, c563.z
	local c572, c573, c574, c575= pcall(client.eye_position)
	local c576, c577, c578= 0, 0, 0
	if c572 and c573 and c574 and c575 then
		if c556 and c557 and c557.make and c557.normalized and c557.sub then
			local c579= c557.make(c569, c570, c571)
			local c580= c557.make(c573, c574, c575)
			local c581= c557.normalized(c557.sub(c579, c580))
			c576, c577, dirz = c581.x, c581.y, c581.z
		else
			c576 = c569 - c573; c577 = c570 - c574; c578 = c571 - c575
			local c582= math.sqrt(c576*c576 + c577*c577 + c578*c578)
			if c582 > 0 then c576, c577, dirz = c576/c582, c577/c582, c578/c582 end
		end
	end
	local c583= false
	local c584, c585, c586= pcall(client.trace_line, c566, c569 - (c576 or 0) * 1, c570 - (c577 or 0) * 1, c571 - (c578 or 0) * 1, c569 + (c576 or 0) * 1, c570 + (c577 or 0) * 1, c571 + (c578 or 0) * 1)
	if c584 and c586 and c586 > 0 and c586 ~= c566 then
		if entity.is_enemy(c586) then c583 = true end
	end
	local c587, c588, c589, c590
	local c591, c592, c593, c594, c595= pcall(ui.get, c554.ui.paint_hitmarker_color)
	if c591 and c592 then
		c587, c588, c589, ca = c592 or 0, c593 or 235, c594 or 235, c595 or 255
	else
		c587, c588, c589, ca = 0, 235, 235, 255
	end
	c568.impacts[#c568.impacts + 1] = {x = c569, y = c570, z = c571, t = c564, r = c587, g = c588, b = c589, a = c590, dir = {c576, c577, c578}, hit = c583}
	
	if #c568.impacts > 5 then table.remove(c568.impacts, 1) end
	if c583 then
		c568.finished = true
	end
end

local function c596(c563)
	if c558() then
		local c564= globals.realtime()
		local c597= 5.5 * 3 * 0.8
		local c598= 0.25 * 0.8
		local c599= c597 + c598
		local c600= 1
		while c600 <= #c555.shots do
			if c564 - (c555.shots[c600].t or 0) > c599 then
				table.remove(c555.shots, c600)
			else
				c600 = c600 + 1
			end
		end
		
		local c601= {}
		local c602= 12
		for si = #c555.shots, 1, -1 do
			local c568= c555.shots[si]
			for ii = #c568.impacts, 1, -1 do
				table.insert(c601, c568.impacts[ii]) 
				if #c601 >= c602 then break end
			end
			if #c601 >= c602 then break end
		end
		local c603= math.min(4, #c601)
		for j = 1, c603 do
			local c604= c601[j]
			local c605, c606, c607= c604.x, c604.y, c604.z
			if not c604.hit and c604.dir then
				local c573= c604.x + (c604.dir[1] or 0) * 24
				local c574= c604.y + (c604.dir[2] or 0) * 24
				local c575= c604.z + (c604.dir[3] or 0) * 24
				c605, c606, draw_z = c573, c574, c575
			end
			local c608, c609= renderer.world_to_screen(c605, c606, c607)
			if c608 and c609 then
				local c610= c564 - (c604.t or 0)
				local c611= c610 <= c597 and 255 or math.floor(math.max(0, (1 - math.max(0, c610 - c597) / c598) * 255))
				if c611 > 0 then
					local c582= 4
					local c612= c604.r or 200
					local c613= c604.g or 200
					local c614= c604.b or 200
					renderer.line(c608 - c582, c609, c608 + c582, c609, c612, c613, c614, c611)
					renderer.line(c608, c609 - c582, c608, c609 + c582, c612, c613, c614, c611)
				end
			end
		end
	else
		c555 = {shots = {}, last = 0}
	end
end

if c560 and c561 and c561.callback then
	c561.callback('aim_fire', c562, { alive_only = true, require_login = true })
	c561.callback('bullet_impact', c565, { alive_only = true, require_login = true })
	c561.callback('paint', c596, { alive_only = true, require_login = true })
end
]]
c927["require/help/bit"] = [[local c557= {}

local c558= 0xFFFFFFFF
local c559= 4294967296

local function c560(c561)
	c561 = tonumber(c561) or 0
	c561 = math.floor(c561) % c559
	if c561 < 0 then c561 = c561 + c559 end
	return c561
end

function c557.tobit(c561)
	local c562= c560(c561)
	if c562 >= 2147483648 then
		return c562 - c559
	end
	return c562
end

function c557.tohex(c561,c563)
	local c562= c560(c561)
	local c564= 8
	local c565= false
	if c563 then
		if c563 < 0 then
			c565 = true
			c564 = -c563
		else
			c564 = c563
		end
	end
	if c564 < 1 then c564 = 1 end
	if c564 > 8 then c564 = 8 end
	c562 = c562 % (2^(4 * c564))
	if c565 then
		return string.format(string.format("%%0%uX", c564), c562)
	else
		return string.format(string.format("%%0%ux", c564), c562)
	end
end

local function c566(c562,c567)
	return math.floor(c562 / 2^c567) % 2
end

function c557.band(c568,...)
	local c569= {c568, ...}
	if #c569 == 0 then return 0 end
	local c570= 0
	for c567 = 0, 31 do
		local c571= 1
		for j = 1, #c569 do
			if c566(c560(c569[j]), c567) == 0 then
				c571 = 0
				break
			end
		end
		if c571 == 1 then c570 = c570 + 2^c567 end
	end
	return c557.tobit(c570)
end

function c557.bor(c568,...)
	local c569= {c568, ...}
	if #c569 == 0 then return 0 end
	local c570= 0
	for c567 = 0, 31 do
		for j = 1, #c569 do
			if c566(c560(c569[j]), c567) == 1 then
				c570 = c570 + 2^c567
				break
			end
		end
	end
	return c557.tobit(c570)
end

function c557.bxor(c568,...)
	local c569= {c568, ...}
	if #c569 == 0 then return 0 end
	local c570= 0
	for c567 = 0, 31 do
		local c572= 0
		for j = 1, #c569 do
			if c566(c560(c569[j]), c567) == 1 then c572 = c572 + 1 end
		end
		if (c572 % 2) == 1 then c570 = c570 + 2^c567 end
	end
	return c557.tobit(c570)
end

function c557.bnot(c561)
	local c562= c560(c561)
	local c570= c558 - c562
	return c557.tobit(c570)
end

function c557.lshift(c561,c563)
	c563 = tonumber(c563) or 0
	c563 = c563 % 32
	local c562= c560(c561)
	local c570= (c562 * 2^c563) % c559
	return c557.tobit(c570)
end

function c557.rshift(c561,c563)
	c563 = tonumber(c563) or 0
	c563 = c563 % 32
	local c562= c560(c561)
	local c570= math.floor(c562 / 2^c563) % c559
	return c557.tobit(c570)
end

function c557.arshift(c561,c563)
	c563 = tonumber(c563) or 0
	c563 = c563 % 32
	local c573= c557.tobit(c561)
	local c570= math.floor(c573 / 2^c563)
	return c557.tobit(c570)
end

function c557.rol(c561,c563)
	c563 = tonumber(c563) or 0
	c563 = c563 % 32
	if c563 == 0 then return c557.tobit(c561) end
	local c562= c560(c561)
	local c574= (c562 * 2^c563) % c559
	local c575= math.floor(c562 / 2^(32 - c563))
	local c570= (c574 + c575) % c559
	return c557.tobit(c570)
end

function c557.ror(c561,c563)
	c563 = tonumber(c563) or 0
	c563 = c563 % 32
	if c563 == 0 then return c557.tobit(c561) end
	local c562= c560(c561)
	local c575= math.floor(c562 / 2^c563)
	local c574= (c562 * 2^(32 - c563)) % c559
	local c570= (c574 + c575) % c559
	return c557.tobit(c570)
end

function c557.bswap(c561)
	local c562= c560(c561)
	local c576= c562 % 256
	local c577= math.floor(c562 / 256) % 256
	local c578= math.floor(c562 / 65536) % 256
	local c579= math.floor(c562 / 16777216) % 256
	local c570= c576 * 16777216 + c577 * 65536 + c578 * 256 + c579
	return c557.tobit(c570)
end

return c557]]
c927["require/help/client"] = [[local c560= {}

function c560.camera_angles(c561,c562)
  if c561 == nil and c562 == nil then
    return client.camera_angles()
  end
  return client.camera_angles(c561, c562)
end

function c560.camera_position()
  return client.camera_position()
end

function c560.color_log(c563,c564,c565,...)
  return client.color_log(c563, c564, c565, ...)
end

function c560.create_interface(c566,c567)
  return client.create_interface(c566, c567)
end

function c560.current_threat()
  return client.current_threat()
end

function c560.delay_call(c568,c569,...)
  return client.delay_call(c568, c569, ...)
end

function c560.draw_debug_text(c570,c571,c572,c573,c574,c563,c564,c565,c575,...)
  return client.draw_debug_text(c570, c571, c572, c573, c574, c563, c564, c565, c575, ...)
end

function c560.draw_hitboxes(c576,c574,c577,c563,c564,c565,c575,c578)
  return client.draw_hitboxes(c576, c574, c577, c563, c564, c565, c575, c578)
end

function c560.error_log(c579)
  return client.error_log(c579)
end

function c560.exec(...)
  return client.exec(...)
end

function c560.eye_position()
  return client.eye_position()
end

function c560.find_signature(c566,c580)
  return client.find_signature(c566, c580)
end

function c560.fire_event(c581,...)
  return client.fire_event(c581, ...)
end

function c560.get_cvar(c582)
  return client.get_cvar(c582)
end

function c560.get_model_name(c583)
  return client.get_model_name(c583)
end

function c560.key_state(c584)
  return client.key_state(c584)
end

function c560.latency()
  return client.latency()
end

function c560.log(...)
  return client.log(...)
end

function c560.random_float(c585,c586)
  return client.random_float(c585, c586)
end

function c560.random_int(c585,c586)
  return client.random_int(c585, c586)
end

function c560.real_latency()
  return client.real_latency()
end

function c560.register_esp_flag(c587,c563,c564,c565,c569)
  return client.register_esp_flag(c587, c563, c564, c565, c569)
end

function c560.reload_active_scripts()
  return client.reload_active_scripts()
end

function c560.request_full_update()
  return client.request_full_update()
end

function c560.scale_damage(c576,c588,c589)
  return client.scale_damage(c576, c588, c589)
end

function c560.screen_size()
  return client.screen_size()
end

function c560.set_clan_tag(...)
  return client.set_clan_tag(...)
end

function c560.set_event_callback(c581,c569)
  return client.set_event_callback(c581, c569)
end

function c560.system_time()
  return client.system_time()
end

function c560.timestamp()
  return client.timestamp()
end

function c560.trace_bullet(c590,c591,c592,c593,c594,c595,c596,c597)
  return client.trace_bullet(c590, c591, c592, c593, c594, c595, c596, c597)
end

function c560.trace_line(c598,c591,c592,c593,c594,c595,c596)
  return client.trace_line(c598, c591, c592, c593, c594, c595, c596)
end

function c560.unix_time()
  return client.unix_time()
end

function c560.unset_event_callback(c581,c569)
  return client.unset_event_callback(c581, c569)
end

function c560.update_player_list()
  return client.update_player_list()
end

function c560.userid_to_entindex(c599)
  return client.userid_to_entindex(c599)
end

function c560.visible(c570,c571,c572)
  return client.visible(c570, c571, c572)
end

return c560]]
c927["require/help/color"] = [[local function c563(c564)
    c564 = tostring(c564 or "")
    local c565= c564:match("([0-9A-Fa-f]+)$")
    if not c565 or #c565 ~= 8 then
        return 255,255,255,255
    end
    local c566= tonumber(c565:sub(1,2), 16)
    local c567= tonumber(c565:sub(3,4), 16)
    local c568= tonumber(c565:sub(5,6), 16)
    local c569= tonumber(c565:sub(7,8), 16)
    return c566,c567,c568,c569
end

local function c570(c566,c567,c568,c569)
    return string.format("\a%02x%02x%02x%02x", tonumber(c566) or 0, tonumber(c567) or 0, tonumber(c568) or 0, tonumber(c569) or 255)
end

local function c571(c572)
    local c573= tonumber(c572) or 0
    if c573 < 0 then return 0 end
    if c573 > 255 then return 255 end
    return math.floor(c573 + 0.5)
end

local function c574(c566,c567,c568,c569,c575)
    c575 = tonumber(c575) or 32
    return c571((c566 or 0) + c575), c571((c567 or 0) + c575), c571((c568 or 0) + c575), c571(c569 or 255)
end

local function c576(c566,c567,c568,c569,c575)
    c575 = tonumber(c575) or 32
    return c571((c566 or 0) - c575), c571((c567 or 0) - c575), c571((c568 or 0) - c575), c571(c569 or 255)
end

local c577= {
    default = "d6d6d6FF", 
    green  = "a5ca2aFF", 
    red    = "d96464FF", 
    reddark = "b22222FF", 
    orange = "dca53aFF", 
    yellow = "ccb854FF", 
    blue   = "5462ccFF", 
    cyan   = "54ccccFF", 
    purple = "7054ccFF", 
    white  = "ffffffFF", 
    grey   = "757575FF", 
    black  = "000000FF", 
    pink   = "c8a2deFF", 
    discord = "7289daFF", 
    youtube = "FF0000FF", 
    sellhub = "FFC107FF", 

}


local c578= {}
for name, c564 in pairs(c577) do
    local c566,c567,c568,c569= c563(c564)
    c578[name] = {
        base = c564,
        lighter = c570(c574(c566,c567,c568,c569,32)),
        darker  = c570(c576(c566,c567,c568,c569,32)),
        light2  = c570(c574(c566,c567,c568,c569,64)),
        dark2   = c570(c576(c566,c567,c568,c569,64)),
        rgb = {c566,c567,c568,c569},
        log = {c566,c567,c568},
        ui = c564,
    }
end

function c578.get(c579,c580)
    c580 = c580 or "base"
    local c581= c578[c579]
    if not c581 then return nil end
    if c580 == "log" and c581.log then
        return unpack(c581.log)
    elseif c580 == "ui" and c581.ui then
        return "\a"..entry.ui
    elseif c581[c580] then
        return c581[c580]
    end
    return nil
end

function c578.blend(c582,c583,c584)
    local c585,c586,c587,c588= unpack(c578[c582].rgb)
    local c589,c590,c591,c592= unpack(c578[c583].rgb)
    c584 = c584 or 0.5
    local c566= c571(c585 + (c589-c585)*c584)
    local c567= c571(c586 + (c590-c586)*c584)
    local c568= c571(c587 + (c591-c587)*c584)
    local c569= c571(c588 + (c592-c588)*c584)
    return c570(c566,c567,c568,c569)
end

function c578.hex_to_rgba(c564)
    return c563(c564)
end

function c578.rgba_to_hex(c566,c567,c568,c569)
    return c570(c566,c567,c568,c569)
end

function c578.clamp(c566,c567,c568,c569)
    return c571(c566), c571(c567), c571(c568), c571(c569)
end

function c578.normalize(c566,c567,c568,c569)
    return c571(c566), c571(c567), c571(c568), c571(c569 or 255)
end

function c578.modulate(c566,c567,c568,c569,c593,c594,c595,c596)
    c593 = tonumber(c593) or 1
    c594 = tonumber(c594) or c593
    c595 = tonumber(c595) or c593
    c596 = tonumber(c596) or 1
    local c597= c571((tonumber(c566) or 0) * c593)
    local c598= c571((tonumber(c567) or 0) * c594)
    local c599= c571((tonumber(c568) or 0) * c595)
    local c600= c571((tonumber(c569) or 255) * c596)
    return c597, c598, c599, c600
end

function c578.alpha_modulate(c569,c601)
    c601 = tonumber(c601) or 1
    return c571((tonumber(c569) or 255) * c601)
end

return c578]]
c927["require/help/drag"] = [[local c566= {}
local c567= {}
local c568= false

local c569= {
	['top-left'] = function(c570,c571,c572,c573) return 0, 0 end,
	['top-center'] = function(c570,c571,c572,c573) return math.floor(c570/2 - c572/2), 0 end,
	['top-right'] = function(c570,c571,c572,c573) return math.floor(c570 - c572), 0 end,
	['center-left'] = function(c570,c571,c572,c573) return 0, math.floor(c571/2 - c573/2) end,
	['center'] = function(c570,c571,c572,c573) return math.floor(c570/2 - c572/2), math.floor(c571/2 - c573/2) end,
	['center-right'] = function(c570,c571,c572,c573) return math.floor(c570 - c572), math.floor(c571/2 - c573/2) end,
	['bottom-left'] = function(c570,c571,c572,c573) return 0, math.floor(c571 - c573) end,
	['bottom-center'] = function(c570,c571,c572,c573) return math.floor(c570/2 - c572/2), math.floor(c571 - c573) end,
	['bottom-right'] = function(c570,c571,c572,c573) return math.floor(c570 - c572), math.floor(c571 - c573) end,
}

local function c574(c575,c576,c572,c573,c577,c578)
	if not c577 or not c578 then return false end
	return c577 >= c575 and c577 <= c575 + c572 and c578 >= c576 and c578 <= c576 + c573
end

local function c579(c580,c581,c582)
	if not c580 then return c581 end
	if c580 < c581 then return c581 end
	if c580 > c582 then return c582 end
	return c580
end

function c566.new(c583,c584)
	if not c583 then error('drag.new requires id') end
	c584 = c584 or {}
	local c585= {}
	c585.id = c583
	c585.x = c584.x or 0
	c585.y = c584.y or 0
	c585.w = c584.w or 100
	c585.h = c584.h or 20
	c585.snap = c584.snap == nil and true or c584.snap
	c585.snap_threshold = c584.snap_threshold or 24
	c585.snap_positions = c584.snap_positions or nil
	c585.require_menu_open = c584.require_menu_open == nil and true or c584.require_menu_open
	c585.locked = c584.lock or false
	c585.box_color = c584.box_color or {255,255,255,100}
	c585.show_alignment = c584.show_alignment == nil and true or c584.show_alignment
	c585.align_color = c584.align_color or {255,255,255,100}
	c585.align_cross_size = c584.align_cross_size or 6
	c585.show_screen_guides = c584.show_screen_guides == nil and true or c584.show_screen_guides
	c585.line_snap_threshold = c584.line_snap_threshold or 6
	c585.bounds = c584.bounds or nil
	c585.constraint_center = c584.constraint_center or nil
	c585.constraint_box = c584.constraint_box or nil
	c585.default_pos = c584.default_pos or nil
	c585.default_center = c584.default_center or nil

	local c586= {
		obj = c585,
		dragging = false,
		drag_offset_x = 0,
		drag_offset_y = 0,
		last_left = false,
		last_right = false,
		locked_to = nil,
		snap_progress = 0,
		snap_target = 0,
		line_snap_progress_x = 0,
		line_snap_progress_y = 0,
		line_snap_target_x = 0,
		line_snap_target_y = 0,
		drag_button = nil,
		disable_snap = false,
	}
	c567[c583] = c586

	local c587, c588= pcall(database.read, 'drag_positions')
	if c587 and type(c588) == 'table' and c588[c583] then
		local c589= c588[c583]
		if type(c589.x) == 'number' and type(c589.y) == 'number' then
			c585.x = c589.x
			c585.y = c589.y
		end
	end

	if not c568 then
		client.set_event_callback('setup_command', function(c590)
			for _, st in pairs(c567) do
				if st.dragging then
					pcall(function()
						c590.in_attack = false
						c590.in_attack2 = false
					end)
					break
				end
			end
		end)
		c568 = true
	end

	function c585:set_pos(c575,c576)
		self.x = c575
		self.y = c576
	end
	function c585:set_size(c572,c573)
		self.w = c572; self.h = c573
	end
	function c585:set_bounds(c575,c576,c572,c573)
		self.bounds = { x = c575, y = c576, w = c572, h = c573 }
	end
	function c585:clear_bounds()
		self.bounds = nil
	end
	function c585:get_pos()
		return self.x, self.y
	end
	function c585:is_dragging()
		return not not c586.dragging
	end
	function c585:get_bounds()
		return self.bounds
	end
	function c585:set_locked(c591)
		self.locked = not not c591
	end
	function c585:set_snap(c591)
		self.snap = not not c591
	end
	function c585:toggle_snap()
		self.snap = not self.snap
	end
	function c585:reset_to_anchor(c592)
		local c570, c571= client.screen_size()
		if not c570 or not c571 then return end
		local c593= c569[c592]
		if type(c593) == 'function' then
			local c594, c595= c593(c570,c571,self.w,self.h)
			self.x = c594; self.y = c595
			c586.locked_to = c592
		end
	end

	function c585:handle()
		if self.locked then return end
		local c570, c571= client.screen_size()
		if not c570 or not c571 then return end
		if self.require_menu_open and not ui.is_menu_open() then c586.last_left = false; return end

		local c577, c578= ui.mouse_position()
		local c596= client.key_state(1)
		local c597= client.key_state(2)

		if c596 and c597 and (c574(self.x, self.y, self.w, self.h, c577, c578) or c586.dragging) then
			if self.default_pos then
				self.x = self.default_pos.x
				self.y = self.default_pos.y
				return
			elseif self.default_center then
				self.x = (self.default_center.x or 0) - math.floor(self.w/2)
				self.y = (self.default_center.y or 0) - math.floor(self.h/2)
				return
			end
		end
		if c596 and not c586.last_left and c574(self.x, self.y, self.w, self.h, c577, c578) then
			c586.dragging = true
			c586.drag_button = 1
			c586.disable_snap = false
			c586.drag_offset_x = c577 - self.x
			c586.drag_offset_y = c578 - self.y
			c586.locked_to = nil
		elseif c597 and not c586.last_right and c574(self.x, self.y, self.w, self.h, c577, c578) then
			c586.dragging = true
			c586.drag_button = 2
			c586.disable_snap = true
			c586.drag_offset_x = c577 - self.x
			c586.drag_offset_y = c578 - self.y
			c586.locked_to = nil
			c586.snap_target = 0
			c586.line_snap_target_x = 0
			c586.line_snap_target_y = 0
		end

		if (c596 and c586.dragging and c586.drag_button == 1) or (c597 and c586.dragging and c586.drag_button == 2) then
			local c594= c577 - c586.drag_offset_x
			local c595= c578 - c586.drag_offset_y
			local c598, c599= 0, math.max(0, c570 - self.w)
			local c600, c601= 0, math.max(0, c571 - self.h)
			if self.constraint_center then
				local c602= self.constraint_center
				local c603= c602.cx or math.floor(c570/2)
				local c604= c602.cy or math.floor(c571/2)
				local c605= c602.radius or 0
				c598 = (c603 - c605) - math.floor(self.w/2)
				c599 = (c603 + c605) - math.floor(self.w/2)
				c600 = (c604 - c605) - math.floor(self.h/2)
				c601 = (c604 + c605) - math.floor(self.h/2)
			elseif self.bounds or self.constraint_box then
				local c606= self.bounds or self.constraint_box
				local c607= c606.x or c606[1] or 0
				local c608= c606.y or c606[2] or 0
				local c609= c606.w or c606[3] or (c570 - c607)
				local c610= c606.h or c606[4] or (c571 - c608)
				c598 = c607
				c599 = math.max(c607, c607 + c609 - self.w)
				c600 = c608
				c601 = math.max(c608, c608 + c610 - self.h)
			end
			c594 = c579(c594, c598, c599)
			c595 = c579(c595, c600, c601)
			self.x = c594; self.y = c595
			if self.snap and not c586.disable_snap then
				local c611= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and c569[p] then
							local c593= c569[p]
							local c612, c613= c593(c570,c571,self.w,self.h)
							table.insert(c611, {x=c612,y=c613})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(c611, {x=p[1], y=p[2]})
						end
					end
				else
					for k,c593 in pairs(c569) do
						local c612, c613= c593(c570,c571,self.w,self.h)
						table.insert(c611, {x=c612,y=c613})
					end
				end
				local c614= math.huge
				for _,c602 in ipairs(c611) do
					local c615= (c602.x - self.x)
					local c616= (c602.y - self.y)
					local c617= math.sqrt(c615*c615 + c616*c616)
					if c617 < c614 then c614 = c617 end
				end
				if c614 <= self.snap_threshold then c586.snap_target = 1 else c586.snap_target = 0 end
				local c618= math.floor(c570/2)
				local c619= math.floor(c571/2)
				local c603= math.floor(self.x + self.w/2)
				local c604= math.floor(self.y + self.h/2)
				if math.abs(c603 - c618) <= (self.line_snap_threshold or 6) then c586.line_snap_target_x = 1 else c586.line_snap_target_x = 0 end
				if math.abs(c604 - c619) <= (self.line_snap_threshold or 6) then c586.line_snap_target_y = 1 else c586.line_snap_target_y = 0 end
			end
		end

		local c620= false
		if c586.dragging then
			if c586.drag_button == 1 and not c596 and c586.last_left then c620 = true end
			if c586.drag_button == 2 and not c597 and c586.last_right then c620 = true end
		end
		if c620 then
			if not c586.disable_snap then
				local c618, c619= math.floor(c570/2), math.floor(c571/2)
				local c603= math.floor(self.x + self.w/2)
				local c604= math.floor(self.y + self.h/2)
				if self.show_screen_guides then
					if math.abs(c603 - c618) <= (self.line_snap_threshold or 6) then
						self.x = c618 - math.floor(self.w/2)
					end
					if math.abs(c604 - c619) <= (self.line_snap_threshold or 6) then
						self.y = c619 - math.floor(self.h/2)
					end
				end
			end
			c586.dragging = false
			local c621, c622= pcall(database.read, 'drag_positions')
			local c623= (c621 and type(c622) == 'table') and c622 or {}
			c623[self.id] = { x = self.x, y = self.y }
			pcall(function() database.write('drag_positions', c623) end)
			if self.snap and not c586.disable_snap then
				local c611= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and c569[p] then
							local c593= c569[p]
							local c612, c613= c593(c570,c571,self.w,self.h)
							table.insert(c611, {x=c612,y=c613, key=p})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(c611, {x=p[1], y=p[2], key=nil})
						end
					end
				else
					for k,c593 in pairs(c569) do
						local c612, c613= c593(c570,c571,self.w,self.h)
						table.insert(c611, {x=c612,y=c613, key=k})
					end
				end
				local c624, c614= nil, math.huge
				for _,c602 in ipairs(c611) do
					local c615= (c602.x - self.x)
					local c616= (c602.y - self.y)
					local c617= math.sqrt(c615*c615 + c616*c616)
					if c617 < c614 then c614 = c617; c624 = c602 end
				end
				if c624 and c614 <= self.snap_threshold then
					self.x = c624.x; self.y = c624.y
					c586.locked_to = c624.key
				end
			end
		end

		c586.last_left = c596
		c586.last_right = c597
	end

	function c585:draw()
		local c586= c567[self.id]
		if not c586 then return end
		if c586.dragging then
			local c605,c625,c606,c626= unpack(self.box_color)
			local c627,c628,c629,c630= unpack(self.align_color)
			local c631= globals.frametime() or 0.016
			local c632= math.min(1, 12 * c631)
			c586.snap_progress = c586.snap_progress + (c586.snap_target - c586.snap_progress) * c632
			c586.line_snap_progress_x = c586.line_snap_progress_x + (c586.line_snap_target_x - c586.line_snap_progress_x) * c632
			c586.line_snap_progress_y = c586.line_snap_progress_y + (c586.line_snap_target_y - c586.line_snap_progress_y) * c632
			local c633= math.floor(c605 + (0 - c605) * c586.snap_progress)
			local c634= math.floor(c625 + (0 - c625) * c586.snap_progress)
			local c635= math.floor(c606 + (0 - c606) * c586.snap_progress)
			local c636= math.floor(c626 + (200 - c626) * c586.snap_progress)
			renderer.rectangle(self.x, self.y, self.w, self.h, c633, c634, c635, c636)
			renderer.line(self.x, self.y, self.x + self.w, self.y, 200,200,200,150)
			renderer.line(self.x + self.w, self.y, self.x + self.w, self.y + self.h, 200,200,200,150)
			renderer.line(self.x + self.w, self.y + self.h, self.x, self.y + self.h, 200,200,200,150)
			renderer.line(self.x, self.y + self.h, self.x, self.y, 200,200,200,150)
			if self.show_alignment then
				local c570, c571= client.screen_size()
				if c570 and c571 then
					if self.show_screen_guides then
						local c618= math.floor(c570/2)
						local c619= math.floor(c571/2)
						local c603= math.floor(self.x + self.w/2)
						local c604= math.floor(self.y + self.h/2)
						local c637= math.abs(c603 - c618) <= (self.line_snap_threshold or 6)
						local c638= math.abs(c604 - c619) <= (self.line_snap_threshold or 6)
						local c639= math.floor(c630 * 0.35)
						renderer.line(c618, c619, 0, c619, c627,c628,c629, c639)
						renderer.line(c618, c619, c618, 0, c627,c628,c629, c639)
						renderer.line(c618, c619, c570, c619, c627,c628,c629, c639)
						renderer.line(c618, c619, c618, c571, c627,c628,c629, c639)
						local c640= math.floor(c630 * c586.line_snap_progress_x)
						local c641= math.floor(c630 * c586.line_snap_progress_y)
						if c640 > 0 then renderer.line(c618, 0, c618, c571, c627,c628,c629, c640) end
						if c641 > 0 then renderer.line(0, c619, c570, c619, c627,c628,c629, c641) end
					end
				end
			end
			if self.constraint_center then
				local c602= self.constraint_center
				local c603= c602.cx or math.floor((client.screen_size()) / 2)
				local c604= c602.cy or math.floor((client.screen_size()) / 2)
				local c605= c602.radius or 0
				local c607= c603 - c605
				local c608= c604 - c605
				local c609= c605 * 2
				local c610= c605 * 2
				renderer.rectangle(c607, c608, c609, c610, 255, 255, 255, 60)
				renderer.line(c607, c608, c607 + c609, c608, 255, 255, 255, 160)
				renderer.line(c607 + c609, c608, c607 + c609, c608 + c610, 255, 255, 255, 160)
				renderer.line(c607 + c609, c608 + c610, c607, c608 + c610, 255, 255, 255, 160)
				renderer.line(c607, c608 + c610, c607, c608, 255, 255, 255, 160)
			end
		end
	end

	return c585
end

function c566.get(c583)
	local c586= c567[c583]
	if not c586 then return nil end
	return c586.obj
end

function c566.ids()
	local c642= {}
	for k,_ in pairs(c567) do table.insert(c642, k) end
	return c642
end

return c566]]
c927["require/help/emojis"] = [[local c569= {

    chat = { "" },
    rewind = { "" },
    thumbsup = { "" },
    mail = { "U+E135" },
    square = { "" },
    square2 = { "" },
    square_hollow = { "" },
    play = { "" },
    pause = { "" },
    sun = { "" },
    pc = { "" },
    pc2 = { "" },
    phone = { "U+E1C9" },
    trash = { "" },
    reject = { "" },
    accept = { "" },
    config = { "" },
    config_write = { "U+E28F" },
    gear = { "" },
    arrow_right = { "" },
    arrow_left = { "" },
    arrow_up = { "" },
    arrow_down = { "" },
    star = { "U+E0B4" },
    minus = { "" },
    plus = { "" },
    plus_in_brackets = { "U+E0C5" },
    pen = { "" },
    recycle = { "" },
    camera = { "" },
    download = { "" },
    upload = { "" },
    question = { "" },
    search = { "" },
    globe = { "" },
    globe2 = { "" },
    id = { "" },
    phone = { "" },
    user = { "" },
    user2 = { "U+E2AF" },
    user3 = { "U+E13D" },
    users = { "" },
    users2 = { "U+E125" },
    user_no = { "U+E1E0" },
    pin = { "" },
    unpin = { "U+E196" },
    windows = { "" },
    turning = { "" },
    turning2 = { "" },
    arrow_double = { "" },
    clip = { "" },
    clipboard = { "U+E16D" },
    exclamation = { "" },
    time = { "" },
    clock = { "U+E2AD" },
    paper = { "" },
    paper2 = { "" },
    link = { "" },
    link2 = { "U+E167" },
    wrench = { "" },
    url = { "" },
    speaker = { "" },
    house = { "" },
    pallete = { "" },
    lock = { "" },
    lock_open = { "" },
    tsarrow_left = { "" },
    tsarrow_right = { "" },
    tsarrow_up = { "" },
    tsarrow_up = { "" },
    warning = { "⚠︎" },
    video = { "" },
    connection = { "" },
    heart = { "" },
    triangle_upside = { "⛛" },
    music_note = { "U+E142" },
    test = { "U+E2B1" },
    keyboard = { "U+E0D2" },
    latency0 = { "U+E1E5" },
    latency1 = { "U+E1E6" },
    latency2 = { "U+E1E7" },
    latency3 = { "U+E1E8" },
    latency4 = { "U+E1E9" },
    expand = { "U+E1D9" },
    monitor = { "U+E2F0" },
    rain = { "U+E28A" },
    likedislike = { "U+E19D" },
    text = { "U+E1C8" },
    back = { "U+E10E" },
    folder = { "U+E1C1" },
    menu = { "U+E179" },
    menu2 = { "U+E1A0" },
    at = { "U+E168" },
    circle = { "U+E235" },
    updown = { "U+E174" },

}

local c570= {}

local function c571(c572)
    if c572 == nil then return "ERROR" end
    if type(c572) ~= "string" then c572 = tostring(c572) end
    if c572 == "ERROR" then return "ERROR" end
    local c573= c572:match('^U%+([0-9A-Fa-f]+)$') or c572:match('^u%+([0-9A-Fa-f]+)$') or c572:match('^0x([0-9A-Fa-f]+)$')
    if c573 then
        local c574= tonumber(c573, 16)
        if c574 then
            local c575= nil
            if type(utf8) == 'table' and type(utf8.char) == 'function' then
                pcall(function() c575 = utf8.char(c574) end)
            end
            if not c575 then
                local function c576(c577)
                    if c577 < 0x80 then return string.char(c577) end
                    if c577 < 0x800 then return string.char(0xC0 + math.floor(c577 / 0x40), 0x80 + (c577 % 0x40)) end
                    if c577 < 0x10000 then return string.char(0xE0 + math.floor(c577 / 0x1000), 0x80 + (math.floor(c577 / 0x40) % 0x40), 0x80 + (c577 % 0x40)) end
                    if c577 < 0x110000 then return string.char(0xF0 + math.floor(c577 / 0x40000), 0x80 + (math.floor(c577 / 0x1000) % 0x40), 0x80 + (math.floor(c577 / 0x40) % 0x40), 0x80 + (c577 % 0x40)) end
                    return '?'
                end
                c575 = c576(c574)
            end
            c572 = c575 or c572
        end
    end
    if c572:sub(-1) == " " then return c572 end
    return c572 .. " "
end

function c570.get(c578,c579,c580)
    if not c578 then return "ERROR" end
    local c581= c569[c578]
    if c581 == nil then return "ERROR" end
    if type(c581) == "string" then return c571(c581) end
    if type(c581) == "table" then
        if c580 == nil then
            return c571(c581[1])
        end
        local c582= tonumber(c580) or 1
        return c571(c581[c582])
    end
    return "ERROR"
end

function c570.set(c578,c583)
	if not c578 then return false end
	if type(c583) == "string" then
		c569[c578] = { c583 }
	else
		c569[c578] = c583
	end
	return true
end

function c570.list()
	local c584= {}
	for k, c581 in pairs(c569) do
		if type(c581) == "table" then
			local c585= {}
			for c582 = 1, #c581 do c585[c582] = c581[c582] end
			c584[k] = c585
		else
			c584[k] = c581
		end
	end
	return c584
end

setmetatable(c570, {
    __index = function(c586,c587)
        local c581= c569[c587]
        if c581 == nil then return "ERROR" end
        if type(c581) == "table" then return c571(c581[1]) end
        return c571(c581)
    end,
})

return c570]]
c927["require/help/enemies"] = [[local c572= {}

local c573= entity
local c574= client
local c575= globals

function c572.list()
    return c573 and c573.get_players and c573.get_players(true) or {}
end

function c572.is_alive(c576)
    return c576 and c573.is_alive and c573.is_alive(c576) or false
end

function c572.is_dormant(c576)
    return c576 and c573.is_dormant and c573.is_dormant(c576) or false
end

function c572.player_name(c576)
    return c576 and c573.get_player_name and c573.get_player_name(c576) or nil
end

function c572.steam64(c576)
    return c576 and c573.get_steam64 and c573.get_steam64(c576) or nil
end

function c572.health(c576)
    return c576 and c573.get_prop and c573.get_prop(c576, 'm_iHealth') or 0
end

function c572.current_threat()
    return c574 and c574.current_threat and c574.current_threat() or nil
end

local c577= {}

function c572.is_afk(c576,c578,c579)
    c578 = c578 or 5
    c579 = c579 or 20
    local c580, c581, c582= c573.get_prop(c576, 'm_vecVelocity')
    local c583= 0
    if c580 and c581 and c582 then
        c583 = math.sqrt(c580 * c580 + c581 * c581 + c582 * c582)
    end
    local c584= c575 and c575.realtime and c575.realtime() or os.clock()
    if not c577[c576] then
        c577[c576] = { last_active = c584, last_check = c584 }
    end
    if c583 >= c578 then
        c577[c576].last_active = c584
    end
    c577[c576].last_check = c584
    return (c584 - c577[c576].last_active) > c579
end

function c572.distance(c576,c585)
    if not c576 or not c573.get_origin then return nil end
    local c586, c587, c588= c573.get_origin(c576)
    if not c586 then return nil end
    if not c585 then
        c585 = c573.get_local_player and c573.get_local_player()
    end
    local c589, c590, c591= c573.get_origin(c585)
    if not c589 then return nil end
    local c592, c593, c594= c586 - c589, c587 - c590, c588 - c591
    return math.sqrt(c592 * c592 + c593 * c593 + c594 * c594)
end


local function c595(c596)
    if not c596 then return "" end
    return tostring(c596):lower()
end

local function c597(c598)
    local c599= ""
    if c598 and c573.get_classname then c599 = c573.get_classname(c598) or "" end
    if c599 == "" and c598 and c574.get_model_name then
        c599 = c574.get_model_name(c598) or ""
    end
    return c595(c599)
end

function c572.has_knife(c576)
    if not c576 or not c573.get_player_weapon then return false end
    local c598= c573.get_player_weapon(c576)
    if not c598 then return false end
    local c600= c597(c598)
    return c600:find('knife') ~= nil
end

function c572.has_nade(c576)
    if not c576 or not c573.get_player_weapon then return false end
    local c598= c573.get_player_weapon(c576)
    if not c598 then return false end
    local c600= c597(c598)
    local c601= {'grenade', 'hegrenade', 'flashbang', 'smoke', 'molotov', 'incendiary', 'decoy', 'frag', 'nade'}
    for i = 1, #c601 do
        if c600:find(c601[i]) then return true end
    end
    return false
end

function c572.has_taser(c576)
    if not c576 or not c573.get_player_weapon then return false end
    local c598= c573.get_player_weapon(c576)
    if not c598 then return false end
    local c600= c597(c598)
    return c600:find('taser') ~= nil or c600:find('zeus') ~= nil
end

return c572]]
c927["require/help/ffi"] = [[local c575= rawget(_G, 'ffi')
local c576= {}

function c576.available()
  return c575 ~= nil
end

function c576.cdef(c577)
  if not c575 then error('ffi not available') end
  return c575.cdef(c577)
end

function c576.typeof(c578)
  if not c575 then error('ffi not available') end
  return c575.typeof(c578)
end

function c576.new(c578,...)
  if not c575 then error('ffi not available') end
  return c575.new(c578, ...)
end

function c576.cast(c578,c579)
  if not c575 then error('ffi not available') end
  return c575.cast(c578, c579)
end

function c576.string(c580,c581)
  if not c575 then error('ffi not available') end
  return c575.string(c580, c581)
end

function c576.copy(c582,c583,c581)
  if not c575 then error('ffi not available') end
  return c575.copy(c582, c583, c581)
end

function c576.fill(c582,c584,c581)
  if not c575 then error('ffi not available') end
  return c575.fill(c582, c584, c581)
end

function c576.sizeof(c578)
  if not c575 then error('ffi not available') end
  return c575.sizeof(c578)
end

function c576.alignof(c578)
  if not c575 then error('ffi not available') end
  return c575.alignof(c578)
end

function c576.errno()
  if not c575 then error('ffi not available') end
  return c575.errno()
end

function c576.gc(c580,c585)
  if not c575 then error('ffi not available') end
  return c575.gc(c580, c585)
end

function c576.load(c586,c587)
  if not c575 then error('ffi not available') end
  return c575.load(c586, c587)
end

function c576.metatype(c578,c588)
  if not c575 then error('ffi not available') end
  return c575.metatype(c578, c588)
end

function c576.offsetof(c578,c589)
  if not c575 then error('ffi not available') end
  return c575.offsetof(c578, c589)
end

function c576.istype(c578,c579)
  if not c575 then error('ffi not available') end
  return c575.istype(c578, c579)
end

c576.raw = c575

return c576]]
c927["require/help/globals"] = [[local c578= {}

c578.raw = globals

function c578.absoluteframetime()
  return globals.absoluteframetime()
end

function c578.chokedcommands()
  return globals.chokedcommands()
end

function c578.commandack()
  return globals.commandack()
end

function c578.curtime()
  return globals.curtime()
end

function c578.framecount()
  return globals.framecount()
end

function c578.frametime()
  return globals.frametime()
end

function c578.lastoutgoingcommand()
  return globals.lastoutgoingcommand()
end

function c578.mapname()
  return globals.mapname()
end

function c578.maxplayers()
  return globals.maxplayers()
end

function c578.oldcommandack()
  return globals.oldcommandack()
end

function c578.realtime()
  return globals.realtime()
end

function c578.servertickcount()
  return globals.servertickcount()
end

function c578.tickcount()
  return globals.tickcount()
end

function c578.tickinterval()
  return globals.tickinterval()
end

return c578]]
c927["require/help/json"] = [[local c581= rawget(_G, 'json')
local c582= {}

function c582.available()
  return c581 ~= nil
end

function c582.decode_invalid_numbers(c583)
  if not c581 then error('json not available') end
  if c583 == nil then
    return c581.decode_invalid_numbers()
  end
  return c581.decode_invalid_numbers(c583)
end

function c582.decode_max_depth(c584)
  if not c581 then error('json not available') end
  if c584 == nil then
    return c581.decode_max_depth()
  end
  return c581.decode_max_depth(c584)
end

function c582.encode_invalid_numbers(c583)
  if not c581 then error('json not available') end
  if c583 == nil then
    return c581.encode_invalid_numbers()
  end
  return c581.encode_invalid_numbers(c583)
end

function c582.encode_max_depth(c584)
  if not c581 then error('json not available') end
  if c584 == nil then
    return c581.encode_max_depth()
  end
  return c581.encode_max_depth(c584)
end

function c582.encode_number_precision(c585)
  if not c581 then error('json not available') end
  if c585 == nil then
    return c581.encode_number_precision()
  end
  return c581.encode_number_precision(c585)
end

function c582.encode_sparse_array(...)
  if not c581 then error('json not available') end
  return c581.encode_sparse_array(...)
end

function c582.parse(c586)
  if not c581 then error('json not available') end
  if c581.parse then
    return c581.parse(c586)
  end
  if c581.decode then
    return c581.decode(c586)
  end
  error('json.parse / json.decode not available')
end

function c582.stringify(c587)
  if not c581 then error('json not available') end
  if c581.stringify then
    return c581.stringify(c587)
  end
  if c581.encode then
    return c581.encode(c587)
  end
  error('json.stringify / json.encode not available')
end

c582.raw = c581

return c582]]
c927["require/help/libs"] = [[local function c584(c585)
	local c586, c587= pcall(require, c585)
	return c586 and c587 or nil
end

local c588= {
	antiaim_funcs   = 'gamesense/antiaim_funcs',
	base64          = 'gamesense/base64',
	clipboard       = 'gamesense/clipboard',
	http            = 'gamesense/http',
	csgo_weapons    = 'gamesense/csgo_weapons',
	icons           = 'gamesense/icons',
	entity          = 'gamesense/entity',
	vector          = 'vector',
	bit             = 'bit',
	ffi             = 'ffi',
	pui             = 'gamesense/pui',
	trace           = 'gamesense/trace',
	md5             = 'gamesense/md5',
	websocket       = 'gamesense/websocket',
	surface         = 'gamesense/surface',
	color           = 'gamesense/color',
}

local c589= {}
for k, v in pairs(c588) do
	c589[k] = c584(v)
end

local c590= {
	antiaim_funcs = {
		get_tickbase_shifting = "Returns true if tickbase shifting is active.",
		get_fake_lag = "Returns current fake lag value.",
		get_desync = "Returns current desync value.",
		get_manual_direction = "Returns manual anti-aim direction.",
		get_antiaim_condition = "Returns current anti-aim condition.",
		get_body_yaw = "Returns current body yaw value.",
		get_yaw_base = "Returns current yaw base value.",
		get_pitch = "Returns current pitch value.",
		get_yaw_jitter = "Returns current yaw jitter value.",
		get_enabled = "Returns if anti-aim is enabled.",
		get_fakelag_mode = "Returns fakelag mode.",
		get_fakelag_limit = "Returns fakelag limit.",
		get_fakelag_variance = "Returns fakelag variance.",
		get_fakelag_enabled = "Returns if fakelag is enabled.",
		get_double_tap = "Returns true if double tap exploit is active.",
		get_overlap = "Returns overlap value (exploit related).",
	},
	base64 = {
		encode = "Encodes a string to base64.",
		decode = "Decodes a base64 string.",
	},
	clipboard = {
		get = "Gets clipboard contents as string.",
		set = "Sets clipboard contents to string.",
	},
	http = {
		get = "Performs HTTP GET request.",
		post = "Performs HTTP POST request.",
		download = "Downloads a file from URL.",
	},
	csgo_weapons = {
		get_weapon_name = "Returns weapon name by id.",
		get_weapon_id = "Returns weapon id by name.",
		get_weapon_type = "Returns weapon type by id.",
		get_weapon_group = "Returns weapon group by id.",
		get_weapon_slot = "Returns weapon slot by id.",
		get_weapon_price = "Returns weapon price by id.",
	},
	icons = {
		hero = "Table of hero icons.",
		get_texture = "Returns texture id for icon name.",
		get_icon = "Returns icon object by name.",
		get_all_icons = "Returns all available icons.",
	},
	entity = {
		get_local_player = "Returns entindex of local player.",
		get_all = "Returns array of entindices for all entities.",
		get_players = "Returns array of player entindices.",
		get_game_rules = "Returns entindex of game rules proxy.",
		get_player_resource = "Returns entindex of player resource.",
		get_classname = "Returns classname of entity.",
		set_prop = "Sets netvar property.",
		get_prop = "Gets netvar property.",
		is_enemy = "Returns true if entity is enemy.",
		is_alive = "Returns true if entity is alive.",
		is_dormant = "Returns true if entity is dormant.",
		get_player_name = "Returns player name.",
		get_player_weapon = "Returns active weapon entindex.",
		hitbox_position = "Returns world position of hitbox.",
		get_steam64 = "Returns SteamID3.",
		get_bounding_box = "Returns bounding box coordinates.",
		get_origin = "Returns world origin of entity.",
		get_esp_data = "Returns ESP data for player.",
	},
	vector = {
		new = "Creates a new vector object.",
		dot = "Returns dot product of two vectors.",
		cross = "Returns cross product of two vectors.",
		length = "Returns length of vector.",
		normalize = "Normalizes vector.",
		add = "Adds two vectors.",
		sub = "Subtracts two vectors.",
		mul = "Multiplies vector by scalar.",
		div = "Divides vector by scalar.",
		dist = "Returns distance between two vectors.",
	},
	bit = {
		arshift = "Arithmetic right shift.",
		band = "Bitwise AND.",
		bnot = "Bitwise NOT.",
		bor = "Bitwise OR.",
		bswap = "Byte swap (endian conversion).",
		bxor = "Bitwise XOR.",
		lshift = "Logical left shift.",
		rol = "Bitwise left rotation.",
		ror = "Bitwise right rotation.",
		rshift = "Logical right shift.",
		tobit = "Normalize to 32-bit signed.",
		tohex = "Convert to hexadecimal string.",
	},
	ffi = {
		cdef = "Define C types/functions.",
		cast = "Cast value to C type.",
		new = "Allocate new C object.",
		typeof = "Get C type object.",
		string = "Convert C data to Lua string.",
	},
	pui = {
		create_panel = "Creates a custom UI panel.",
		add_icon = "Adds an icon to a panel.",
		set_icon = "Sets the icon for a panel.",
		set_panel_visible = "Shows/hides a panel.",
		set_panel_position = "Sets panel position.",
		set_panel_size = "Sets panel size.",
	},
	trace = {
		trace_line = "Performs a line trace.",
		trace_bullet = "Performs a bullet trace.",
		trace_hull = "Performs a hull trace.",
	},
	md5 = {
		sumhexa = "Returns MD5 hash as hex string.",
		sum = "Returns MD5 hash as raw bytes.",
	},
	websocket = {
		connect = "Connects to a WebSocket server.",
		send = "Sends data over WebSocket.",
		close = "Closes the WebSocket connection.",
		on_message = "Callback for incoming messages.",
	},
	surface = {
		text = "Draws text on screen.",
		rectangle = "Draws a rectangle.",
		line = "Draws a line.",
		circle = "Draws a circle.",
		gradient = "Draws a gradient rectangle.",
		load_texture = "Loads a texture from file.",
	},
	color = {
		blend = "Blends two colors.",
		lighten = "Lightens a color.",
		darken = "Darkens a color.",
		hex_to_rgba = "Converts hex to RGBA.",
		rgba_to_hex = "Converts RGBA to hex.",
	},
}

local function c591(c585)
	return c589[c585]
end

function c592()
	local c593= {}
	for k, v in pairs(_G) do
		if type(v) == "table" or type(v) == "userdata" then
			c593[#c593+1] = k
		end
	end
	return c593
end

function c594(c595)
	local c596= c590[c595]
	if not c596 then return {} end
	local c593= {}
	for k, v in pairs(c596) do
		c593[#c593+1] = k .. " - " .. v
	end
	return c593
end

return {
	get = c591,
	list = c592,
	list_features = c594,
	features = c590,
	libs = c589,
	lib_defs = c588
}
]]
c927["require/help/math"] = [[local c587= {}

function c587.clamp(c588,c589,c590)
    if not c589 and not c590 then return c588 end
    c589 = tonumber(c589) or 0
    c590 = tonumber(c590) or c589
    if c589 > c590 then c589, max = c590, c589 end
    c588 = tonumber(c588) or c589
    if c588 < c589 then return c589 end
    if c588 > c590 then return c590 end
    return c588
end

function c587.clamp01(c588)
    return c587.clamp(c588, 0, 1)
end

function c587.abs(c588)
    c588 = tonumber(c588) or 0
    return math.abs(c588)
end

function c587.max(...)
    local c591= {...}
    if #c591 == 0 then return 0 end
    local c592= nil
    for i = 1, #c591 do
        local c593= tonumber(c591[i]) or 0
        if c592 == nil or c593 > c592 then c592 = c593 end
    end
    return c592
end

function c587.min(...)
    local c591= {...}
    if #c591 == 0 then return 0 end
    local c592= nil
    for i = 1, #c591 do
        local c593= tonumber(c591[i]) or 0
        if c592 == nil or c593 < c592 then c592 = c593 end
    end
    return c592
end

function c587.atan2(c594,c595)
    c594 = tonumber(c594) or 0
    c595 = tonumber(c595) or 0
    return math.atan(c594, c595)
end

function c587.floor(c588)
    c588 = tonumber(c588) or 0
    return math.floor(c588)
end

function c587.round(c588,c596)
    c588 = tonumber(c588) or 0
    c596 = tonumber(c596) or 0
    local c597= 10 ^ c596
    return math.floor(c588 * c597 + 0.5) / c597
end

function c587.lerp(c598,c599,c600)
    c598 = tonumber(c598) or 0
    c599 = tonumber(c599) or 0
    c600 = tonumber(c600) or 0
    return c598 + (c599 - c598) * c600
end

function c587.distance2d(c601,c602,c603,c604)
    c601 = tonumber(c601) or 0
    c602 = tonumber(c602) or 0
    c603 = tonumber(c603) or 0
    c604 = tonumber(c604) or 0
    return math.sqrt((c603 - c601)^2 + (c604 - c602)^2)
end

function c587.distance3d(c601,c602,c605,c603,c604,c606)
    c601 = tonumber(c601) or 0
    c602 = tonumber(c602) or 0
    c605 = tonumber(c605) or 0
    c603 = tonumber(c603) or 0
    c604 = tonumber(c604) or 0
    c606 = tonumber(c606) or 0
    return math.sqrt((c603 - c601)^2 + (c604 - c602)^2 + (c606 - c605)^2)
end

function c587.sign(c588)
    c588 = tonumber(c588) or 0
    return (c588 > 0 and 1) or (c588 < 0 and -1) or 0
end

function c587.frac(c588)
    c588 = tonumber(c588) or 0
    return c588 - math.floor(c588)
end

function c587.is_even(c588)
    c588 = tonumber(c588) or 0
    return c588 % 2 == 0
end

function c587.is_odd(c588)
    c588 = tonumber(c588) or 0
    return c588 % 2 ~= 0
end

function c587.sqr(c588)
    c588 = tonumber(c588) or 0
    return c588 * c588
end

function c587.cube(c588)
    c588 = tonumber(c588) or 0
    return c588 * c588 * c588
end

function c587.approximately(c598,c599,c607)
    c598 = tonumber(c598) or 0
    c599 = tonumber(c599) or 0
    c607 = tonumber(c607) or 1e-6
    return math.abs(c598 - c599) < c607
end

function c587.rad_to_deg(c608)
    c608 = tonumber(c608) or 0
    return c608 * (180 / math.pi)
end

function c587.deg_to_rad(c609)
    c609 = tonumber(c609) or 0
    return c609 * (math.pi / 180)
end

function c587.wrap_degrees(c610)
    local c598= tonumber(c610) or 0
    c598 = c598 % 360
    if c598 < 0 then c598 = c598 + 360 end
    return c598
end

function c587.normalize_angle(c610)
    local c598= tonumber(c610) or 0
    c598 = c598 % 360
    if c598 > 180 then c598 = c598 - 360 end
    return c598
end

function c587.angle_diff(c598,c599)
    c598 = tonumber(c598) or 0
    c599 = tonumber(c599) or 0
    local c611= (c598 - c599) % 360
    if c611 > 180 then c611 = c611 - 360 end
    return c611
end

function c587.lerp_angle(c598,c599,c600)
    c598 = tonumber(c598) or 0
    c599 = tonumber(c599) or 0
    c600 = tonumber(c600) or 0
    local c611= c587.angle_diff(c599, c598)
    return (c598 + c611 * c600) % 360
end

function c587.map(c588,c612,c613,c614,c615)
    c588 = tonumber(c588) or 0
    c612 = tonumber(c612) or 0
    c613 = tonumber(c613) or c612
    c614 = tonumber(c614) or 0
    c615 = tonumber(c615) or c614
    if c613 == c612 then return c614 end
    return (c588 - c612) * (c615 - c614) / (c613 - c612) + c614
end

function c587.smoothstep(c616,c617,c595)
    c616 = tonumber(c616) or 0
    c617 = tonumber(c617) or c616
    c595 = tonumber(c595) or 0
    if c617 == c616 then return 0 end
    local c600= c587.clamp((c595 - c616) / (c617 - c616), 0, 1)
    return c600 * c600 * (3 - 2 * c600)
end

function c587.random_float(c589,c590)
    c589 = tonumber(c589) or 0
    c590 = tonumber(c590) or c589
    if c589 > c590 then c589, max = c590, c589 end
    return c589 + math.random() * (c590 - c589)
end

function c587.random_int(c589,c590)
    c589 = tonumber(c589) or 0
    c590 = tonumber(c590) or c589
    if c589 > c590 then c589, max = c590, c589 end
    return math.random(c589, c590)
end

function c587.mean(c618)
    if type(c618) ~= 'table' or #c618 == 0 then return 0 end
    local c619= 0
    for i = 1, #c618 do c619 = c619 + (tonumber(c618[i]) or 0) end
    return c619 / #c618
end

function c587.swap(c598,c599)
    return c599, c598
end

return c587]]
c927["require/help/panorama"] = [[local c590= {}

c590.raw = panorama

function c590.loadstring(c591,c592)
  return panorama.loadstring(c591, c592)
end

function c590.open(c592)
  return panorama.open(c592)
end

return c590]]
c927["require/help/plist"] = [[local c593= {}

c593.raw = plist

function c593.get(c594,c595)
  return plist.get(c594, c595)
end

function c593.set(c594,c595,c596)
  return plist.set(c594, c595, c596)
end

return c593]]
c927["require/help/reference"] = [[local c596= {}

c596.known_items = {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

function c596.add_known(c597)
    for _, it in ipairs(c597 or {}) do
        table.insert(c596.known_items, it)
    end
end

function c596.get(c598,c599,c600)
    return ui.reference(c598, c599, c600)
end

function c596.build(c601)
    local c602= {}
    local c603= {}
    for i, item in ipairs(c601) do
        local c604= {ui.reference(item[1], item[2], item[3])}
        c602[i] = c604
        for _, ref in ipairs(c604) do
            if ref ~= nil then
                c603[ref] = true
            end
        end
    end
    return c602, c603
end

function c596.build_known()
    return c596.build(c596.known_items)
end

function c596.get_all_known()
    return c596.known_items
end

return c596]]
c927["require/help/references_old"] = [[

local c599= {}

local function c600(c601)
    
    if type(c601) ~= 'table' then
        local c602= c601
        return {
            raw = c602,
            get = function()
                local c603, c604= pcall(ui.get, c602)
                if c603 then return c604 end
                return nil
            end
        }
    end

    
    
    
    local c605= c601
    return {
        raw = c605,
        get = function()
            if c605[2] ~= nil then
                local c603, c604= pcall(ui.get, c605[2])
                if c603 then return c604 end
            end
            if c605[1] ~= nil then
                local c603, c604= pcall(ui.get, c605[1])
                if c603 then return c604 end
            end
            return nil
        end
    }
end


c599.minimum_damage = c600(ui.reference("RAGE", "Aimbot", "Minimum damage"))
c599.minimum_damage_override = c600({ ui.reference("RAGE", "Aimbot", "Minimum damage override") })
c599.doubletap = c600({ ui.reference("RAGE", "Aimbot", "Double tap") })
c599.force_body_aim = c600({ ui.reference("RAGE", "Aimbot", "Force body aim") })
c599.force_safe_point = c600({ ui.reference("RAGE", "Aimbot", "Force safe point") })
c599.duck_peek_assist = c600({ ui.reference("RAGE", "Other", "Duck peek assist") })
c599.quick_peek_assist = c600({ ui.reference("RAGE", "Aimbot", "Quick peek assist") })


c599.pitch = c600(ui.reference("AA", "Anti-aimbot angles", "Pitch"))
c599.yaw_base = c600(ui.reference("AA", "Anti-aimbot angles", "Yaw base"))
c599.yaw = c600(ui.reference("AA", "Anti-aimbot angles", "Yaw"))
c599.yaw_jitter = c600(ui.reference("AA", "Anti-aimbot angles", "Yaw jitter"))
c599.body_yaw = c600(ui.reference("AA", "Anti-aimbot angles", "Body yaw"))
c599.roll = c600(ui.reference("AA", "Anti-aimbot angles", "Roll"))

return c599]]
c927["require/help/renderer"] = [[local c602= {}

c602.raw = renderer

function c602.blur(c603,c604,c605,c606,c607,c608)
  return renderer.blur(c603, c604, c605, c606, c607, c608)
end

function c602.circle(c603,c604,c609,c610,c611,c612,c613,c614,c615)
  return renderer.circle(c603, c604, c609, c610, c611, c612, c613, c614, c615)
end

function c602.circle_outline(c603,c604,c609,c610,c611,c612,c613,c614,c615,c616)
  return renderer.circle_outline(c603, c604, c609, c610, c611, c612, c613, c614, c615, c616)
end

function c602.gradient(c603,c604,c605,c606,c617,c618,c619,c620,c621,c622,c623,c624,c625)
  return renderer.gradient(c603, c604, c605, c606, c617, c618, c619, c620, c621, c622, c623, c624, c625)
end

function c602.indicator(c609,c610,c611,c612,...)
  return renderer.indicator(c609, c610, c611, c612, ...)
end

function c602.line(c626,c627,c628,c629,c609,c610,c611,c612)
  return renderer.line(c626, c627, c628, c629, c609, c610, c611, c612)
end

function c602.load_jpg(c630,c631,c632)
  return renderer.load_jpg(c630, c631, c632)
end

function c602.load_png(c630,c631,c632)
  return renderer.load_png(c630, c631, c632)
end

function c602.load_rgba(c630,c631,c632)
  return renderer.load_rgba(c630, c631, c632)
end

function c602.load_svg(c630,c631,c632)
  return renderer.load_svg(c630, c631, c632)
end

function c602.measure_text(c633,...)
  return renderer.measure_text(c633, ...)
end

function c602.rectangle(c603,c604,c605,c606,c609,c610,c611,c612)
  return renderer.rectangle(c603, c604, c605, c606, c609, c610, c611, c612)
end

function c602.text(c603,c604,c609,c610,c611,c612,c633,c634,...)
  return renderer.text(c603, c604, c609, c610, c611, c612, c633, c634, ...)
end

function c602.texture(c635,c603,c604,c605,c606,c609,c610,c611,c612,c636)
  return renderer.texture(c635, c603, c604, c605, c606, c609, c610, c611, c612, c636)
end

function c602.triangle(c626,c627,c628,c629,c637,c638,c609,c610,c611,c612)
  return renderer.triangle(c626, c627, c628, c629, c637, c638, c609, c610, c611, c612)
end

function c602.world_to_screen(c603,c604,c639)
  return renderer.world_to_screen(c603, c604, c639)
end

function c602.rectangle_outline(c603,c604,c605,c606,c609,c610,c611,c612,c616)
  c616 = c616 or 1
  for i = 0, c616 - 1 do
    renderer.line(c603 + i, c604 + i, c603 + c605 - i, c604 + i, c609, c610, c611, c612)
    renderer.line(c603 + i, c604 + c606 - i, c603 + c605 - i, c604 + c606 - i, c609, c610, c611, c612)
    renderer.line(c603 + i, c604 + i, c603 + i, c604 + c606 - i, c609, c610, c611, c612)
    renderer.line(c603 + c605 - i, c604 + i, c603 + c605 - i, c604 + c606 - i, c609, c610, c611, c612)
  end
end

function c602.text_centered(c603,c604,c609,c610,c611,c612,c633,c634,...)
  local c605, c606= renderer.measure_text(c633, ...)
  if not c605 or not c606 then return end
  return renderer.text(c603 - c605 / 2, c604 - c606 / 2, c609, c610, c611, c612, c633, c634, ...)
end

function c602.texture_from_file(c640)
  local c630= readfile(c640)
  if not c630 then return nil end
  local c635= renderer.load_png(c630)
  if not c635 then
    c635 = renderer.load_jpg(c630)
  end
  return c635
end

return c602]]
c927["require/help/safe"] = [[local c605= {}

function c605.safe_call(c606,...)
	local c607, c608= pcall(c606, ...)
	return c607 and c608 or nil
end

function c605.safe_set(c609,c610)
	local c607= pcall(function() ui.set(c609, c610) end)
	return c607
end

function c605.safe_get(c609)
	local c607, c608= pcall(function() return ui.get(c609) end)
	return c607 and c608 or nil
end

return c605]]
c927["require/help/self"] = [[local c608= {}

local c609= entity
local c610= globals
local c611= client

function c608.index()
	return c609 and c609.get_local_player and c609.get_local_player() or nil
end

function c608.exists()
	return c608.index() ~= nil
end

function c608.is_alive()
	local c612= c608.index()
	return c612 and c609.is_alive and c609.is_alive(c612) or false
end

function c608.health()
	local c612= c608.index()
	return c612 and c609.get_prop and c609.get_prop(c612, 'm_iHealth') or 0
end

function c608.ping()
	return c611 and c611.latency and c611.latency() or 0
end

function c608.velocity()
	local c612= c608.index()
	if not c612 or not c609.get_prop then return 0 end
	local c613, c614, c615= c609.get_prop(c612, 'm_vecVelocity')
	if c613 and c614 and c615 then
		return math.sqrt(c613 * c613 + c614 * c614 + c615 * c615)
	end
	return 0
end

function c608.velocity2d()
	local c612= c608.index()
	if not c612 or not c609.get_prop then return 0 end
	local c613, c614= c609.get_prop(c612, 'm_vecVelocity')
	if c613 and c614 then
		return math.sqrt(c613 * c613 + c614 * c614)
	end
	return 0
end

function c608.weapon()
	local c612= c608.index()
	return c612 and c609.get_player_weapon and c609.get_player_weapon(c612) or nil
end

function c608.tickbase_shifted()
	
	return false
end

function c608.simtime()
	local c612= c608.index()
	return c612 and c609.get_prop and c609.get_prop(c612, 'm_flSimulationTime') or 0
end

function c608.eye_angles()
	return c611 and c611.camera_angles and c611.camera_angles() or nil
end

function c608.fps()
	local c616= c610 and c610.absoluteframetime and c610.absoluteframetime() or c610.frametime and c610.frametime() or 0.01
	if c616 > 0 then
		return math.floor(1 / c616 + 0.5)
	end
	return 0
end

function c608.map()
	return c610 and c610.mapname and c610.mapname() or nil
end

function c608.is_dormant()
	local c612= c608.index()
	return c612 and c609.is_dormant and c609.is_dormant(c612) or false
end

function c608.team_number()
	local c612= c608.index()
	return c612 and c609.get_prop and c609.get_prop(c612, 'm_iTeamNum') or 0
end

function c608.player_name()
	local c612= c608.index()
	return c612 and c609.get_player_name and c609.get_player_name(c612) or nil
end

function c608.steam64()
	local c612= c608.index()
	return c612 and c609.get_steam64 and c609.get_steam64(c612) or nil
end

function c608.ammo_count()
	local c617= c608.weapon()
	return c617 and c609.get_prop and c609.get_prop(c617, 'm_iClip1') or 0
end

function c608.has_armor()
	local c612= c608.index()
	return c612 and c609.get_prop and c609.get_prop(c612, 'm_ArmorValue') > 0 or false
end

function c608.has_helmet()
	local c612= c608.index()
	return c612 and c609.get_prop and c609.get_prop(c612, 'm_bHasHelmet') == 1 or false
end

function c608.current_tick()
	return c610 and c610.tickcount and c610.tickcount() or 0
end

function c608.tick_interval()
	return c610 and c610.tickinterval and c610.tickinterval() or 0
end

function c608.current_frame()
	return c610 and c610.framecount and c610.framecount() or 0
end

function c608.current_time()
	return c610 and c610.curtime and c610.curtime() or 0
end

function c608.real_latency()
	return c611 and c611.real_latency and c611.real_latency() or 0
end

function c608.system_time()
	return c611 and c611.system_time and c611.system_time() or {0,0,0,0}
end

function c608.unix_time()
	return c611 and c611.unix_time and c611.unix_time() or 0
end

function c608.kills()
	local c612= c608.index()
	if not c612 or not c609.get_prop then return 0 end
	local c618= c609.get_player_resource and c609.get_player_resource()
	if c618 then
		return c609.get_prop(c618, 'm_iKills', c612) or 0
	end
	return 0
end

function c608.deaths()
	local c612= c608.index()
	if not c612 or not c609.get_prop then return 0 end
	local c618= c609.get_player_resource and c609.get_player_resource()
	if c618 then
		return c609.get_prop(c618, 'm_iDeaths', c612) or 0
	end
	return 0
end

function c608.assists()
	local c612= c608.index()
	if not c612 or not c609.get_prop then return 0 end
	local c618= c609.get_player_resource and c609.get_player_resource()
	if c618 then
		return c609.get_prop(c618, 'm_iAssists', c612) or 0
	end
	return 0
end

return c608
]]
c927["require/help/string"] = [[local c611= {}

function c611.lower(c612)
	return string.lower(c612)
end

function c611.upper(c612)
	return string.upper(c612)
end

function c611.capitalize(c612)
	return (c612:gsub("^%l", string.upper):gsub("^(%u)(.*)", function(c613,c614) return c613 .. string.lower(c614) end))
end

function c611.title(c612)
	return (c612:gsub("%S+", function(c615)
		return c615:sub(1,1):upper() .. c615:sub(2):lower()
	end))
end

function c611.random_case(c612)
	local c616= {}
	for i = 1, #c612 do
		local c617= c612:sub(i,i)
		if math.random() < 0.5 then
			c616[i] = string.lower(c617)
		else
			c616[i] = string.upper(c617)
		end
	end
	return table.concat(c616)
end

function c611.startswith(c612,c618)
	return c612:sub(1, #c618) == c618
end

function c611.endswith(c612,c619)
	return c619 == '' or c612:sub(-#c619) == c619
end

function c611.byte(c612,c620,c621)
	return string.byte(tostring(c612 or ""), c620, c621)
end

function c611.char(...)
	return string.char(...)
end

function c611.find(c612,c622,c623,c624)
	return string.find(tostring(c612 or ""), c622, c623, c624)
end

function c611.format(c625,...)
	return string.format(c625, ...)
end

function c611.gmatch(c612,c622)
	return string.gmatch(tostring(c612 or ""), c622)
end

function c611.gsub(c612,c622,c626,c627)
	return string.gsub(tostring(c612 or ""), c622, c626, c627)
end

function c611.split(c612,c628)
	local c629= {}
	if c628 == '' then
		for c620 = 1, #c612 do c629[c620] = c612:sub(c620,c620) end
		return c629
	end
	local c622= string.format("([^%s]+)", c628)
	for part in c612:gmatch(c622) do
		c629[#c629+1] = part
	end
	return c629
end

function c611.join(c630,c628)
	return table.concat(c630, c628)
end

function c611.replace(c612,c622,c626)
	return c612:gsub(c622, c626)
end

function c611.reverse(c612)
	return string.reverse(c612)
end

function c611.repeat_str(c612,c627)
	return string.rep(c612, c627)
end

function c611.rep(c612,c627)
	return string.rep(tostring(c612 or ""), c627)
end

function c611.contains(c612,c631)
	return c612:find(c631, 1, true) ~= nil
end

function c611.count(c612,c631)
	if c631 == '' then return 0 end
	local c632= 0
	local c633= 1
	while true do
		local c634= c612:find(c631, c633, true)
		if not c634 then break end
		c632 = c632 + 1
		c633 = c634 + #c631
	end
	return c632
end

function c611.is_empty(c612)
	return c612 == nil or c612 == ''
end

function c611.is_digit(c612)
	return c612:match("^%d+$") ~= nil
end

function c611.is_alpha(c612)
	return c612:match("^%a+$") ~= nil
end

function c611.random_string(c635)
	local c636= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local c616= {}
	for c620 = 1, c635 do
		local c637= math.random(1, #c636)
		c616[c620] = c636:sub(c637, c637)
	end
	return table.concat(c616)
end

function c611.safe_substr(c612,c620,c621)
	local c638= tostring(c612 or "")
	local c627= #c638
	local c634= tonumber(c620) or 1
	if c634 < 0 then c634 = c627 + 1 + c634 end
	if c634 < 1 then c634 = 1 end
	if c621 == nil then
		return c638:sub(c634)
	end
	local c639= tonumber(c621)
	if not c639 then
		return c638:sub(c634)
	end
	if c639 >= 0 then
		return c638:sub(c634, math.min(c627, c634 + c639 - 1))
	else
		local c640= c627 + c639
		if c640 < c634 then return "" end
		return c638:sub(c634, c640)
	end
end

function c611.sub(c612,c638,c641)
	return string.sub(tostring(c612 or ""), c638, c641)
end

function c611.len(c612)
	return string.len(tostring(c612 or ""))
end

function c611.match(c612,c622,c623)
	return string.match(tostring(c612 or ""), c622, c623)
end

function c611.trim(c612)
	return (tostring(c612 or ""):gsub("^%s*(.-)%s*$", "%1"))
end

function c611.ltrim(c612)
	return (tostring(c612 or ""):gsub("^%s*(.-)$", "%1"))
end

function c611.rtrim(c612)
	return (tostring(c612 or ""):gsub("^(.-)%s*$", "%1"))
end

function c611.escape_pattern(c612)
	return tostring(c612 or ""):gsub("([%%%$%(%)%.%[%]%*%+%-%?%^])", "%%%1")
end

function c611.ensure_prefix(c612,c618)
	local c638= tostring(c612 or "")
	local c642= tostring(c618 or "")
	if c642 == "" then return c638 end
	if c638:sub(1, #c642) == c642 then return c638 end
	return c642 .. c638
end

function c611.ensure_suffix(c612,c619)
	local c638= tostring(c612 or "")
	local c643= tostring(c619 or "")
	if c643 == "" then return c638 end
	if c638:sub(-#c643) == c643 then return c638 end
	return c638 .. c643
end

function c611.truncate(c612,c644,c645)
	local c638= tostring(c612 or "")
	local c646= tonumber(c644) or 0
	if c646 <= 0 or #c638 <= c646 then return c638 end
	local c641= tostring(c645 or "...")
	local c647= c646 - #c641
	if c647 <= 0 then return c641:sub(1, c646) end
	return c638:sub(1, c647) .. c641
end

local c648= {
	a = '4', A = '4', e = '3', E = '3', i = '1', I = '1', o = '0', O = '0',
	s = '5', S = '5', t = '7', T = '7', b = '8', B = '8', g = '6', G = '6',
	z = '2', Z = '2', l = '1', L = '1'
}

function c611.leet(c612,c649)
	local c638= tostring(c612 or "")
	local c642= tonumber(c649) or 1
	if c642 <= 0 then return c638 end
	local c616= {}
	for c620 = 1, #c638 do
		local c617= c638:sub(c620,c620)
		local c614= c648[c617]
		if c614 and math.random() <= c642 then c616[#c616+1] = c614 else c616[#c616+1] = c617 end
	end
	return table.concat(c616)
end

function c611.pipeline(c612,...)
	local c638= tostring(c612 or "")
	for c620 = 1, select('#', ...) do
		local c650= select(c620, ...)
		if type(c650) == 'function' then
			c638 = c650(c638)
		elseif type(c650) == 'string' and c611[c650] then
			c638 = c611[c650](c638)
		end
	end
	return c638
end

return c611]]
c927["require/help/time"] = [[local c614= {}

local c615= client
local c616= globals

local function c617()
	if c616 and c616.realtime then
		return c616.realtime()
	end
	if c615 and c615.timestamp then
		local c618= c615.timestamp()
		if c618 then return c618 / 1000 end
	end
	return 0
end

function c614.simtime()
	if c616 and c616.curtime then return c616.curtime() end
	return c617()
end

function c614.realtime()
	return c617()
end

function c614.tickcount()
	if c616 and c616.tickcount then return c616.tickcount() end
	local c619= c614.tickinterval()
	if c619 and c619 > 0 then return math.floor(c617() / c619) end
	return 0
end

function c614.tickinterval()
	if c616 and c616.tickinterval then return c616.tickinterval() end
	return 0.015625
end

function c614.seconds_to_ticks(c620)
	local c621= c614.tickinterval()
	if c621 and c621 > 0 then return math.floor(c620 / c621 + 0.5) end
	return math.floor(c620 * 64 + 0.5)
end

function c614.ticks_to_seconds(c622)
	local c621= c614.tickinterval()
	if c621 then return c622 * c621 end
	return c622 * 0.015625
end

function c614.frametime()
	if c616 and c616.frametime then return c616.frametime() end
	return 0
end

function c614.absoluteframetime()
	if c616 and c616.absoluteframetime then return c616.absoluteframetime() end
	return 0
end

function c614.framecount()
	if c616 and c616.framecount then return c616.framecount() end
	return 0
end

function c614.framecount_to_seconds(c623)
	local c624= c614.frametime()
	return c623 * (c624 or 0)
end

function c614.seconds_to_framecount(c620)
	local c624= c614.frametime()
	if c624 and c624 > 0 then return math.floor(c620 / c624 + 0.5) end
	return math.floor(c620 * 60 + 0.5)
end

function c614.new(c625)
	return { start = c617(), duration = c625 or 0 }
end

function c614.expired(c626)
	return c617() - (c626.start or 0) >= (c626.duration or 0)
end

function c614.reset(c626,c625)
	c626.start = c617()
	if c625 then c626.duration = c625 end
end

function c614.elapsed(c626)
	return c617() - (c626.start or 0)
end

function c614.interval(c621,c627)
	local c628= c617()
	return function(...)
		local c629= c617()
		if c629 - c628 >= c621 then
			c628 = c629
			c627(...)
		end
	end
end

function c614.timeout(c630,c627)
	local c631= false
	local c632= c617()
	return function(...)
		if not c631 and c617() - c632 >= c630 then
			c631 = true
			c627(...)
		end
	end
end

function c614.debounce(c621,c627)
	local c628= 0
	return function(...)
		local c629= c617()
		if c629 - c628 >= c621 then
			c628 = c629
			c627(...)
		end
	end
end

function c614.throttle(c621,c627)
	local c628= 0
	return function(...)
		local c629= c617()
		if c629 - c628 >= c621 then
			c628 = c629
			c627(...)
		end
	end
end

function c614.wait(c630)
	local c632= c617()
	return function()
		return c617() - c632 >= c630
	end
end

function c614.stopwatch()
	local c633= { running = false, start = 0, elapsed = 0 }
	function c633:start()
		if not self.running then
			self.running = true
			self.start = c617()
		end
	end
	function c633:stop()
		if self.running then
			self.running = false
			self.elapsed = self.elapsed + (c617() - (self.start or 0))
		end
	end
	function c633:reset()
		self.running = false
		self.start = 0
		self.elapsed = 0
	end
	function c633:get()
		if self.running then
			return self.elapsed + (c617() - (self.start or 0))
		else
			return self.elapsed
		end
	end
	return c633
end

c614.Scheduler = {}
c614.Scheduler.__index = c614.Scheduler

function c614.Scheduler.new()
    return setmetatable({ tasks = {} }, c614.Scheduler)
end

function c614.Scheduler:add(c621,c627)
	self.tasks[#self.tasks+1] = { interval = c621, callback = c627, last = c617() }
end

function c614.Scheduler:remove(c627)
    for i = #self.tasks, 1, -1 do
        if self.tasks[i].callback == c627 then
            table.remove(self.tasks, i)
        end
    end
end

function c614.Scheduler:run(...)
	local c629= c617()
	for _, task in ipairs(self.tasks) do
		if c629 - task.last >= task.interval then
			task.last = c629
			task.callback(...)
		end
	end
end

function c614.safe_timeout(c630,c627)
	local c632= c617()
	local c631= false
	return function(...)
		if not c631 and c617() - c632 >= c630 then
			c631 = true
			c627(...)
		end
	end
end

function c614.lerp(c634,c635,c629)
	return c634 + (c635 - c634) * c629
end

function c614.ease_in_out(c629)
	if c629 < 0 then c629 = 0 end
	if c629 > 1 then c629 = 1 end
	return c629 < 0.5 and 2 * c629 * c629 or -1 + (4 - 2 * c629) * c629
end

function c614.ping_pong(c629,c636)
	if c636 <= 0 then return 0 end
	local c637= c629 % (c636 * 2)
	if c637 < c636 then return c637 / c636 end
	return 1 - ((c637 - c636) / c636)
end

function c614.apply_animation(c625,c638,c639)
	local c632= c617()
	return function()
		local c629= (c617() - c632) / (c625 or 1)
		if c629 >= 1 then
			c638(1)
			if c639 then c639() end
			return true
		else
			c638(c629)
			return false
		end
	end
end

function c614.within_ticks_window(c640,c641)
	local c642= c614.tickcount()
	if not c642 or not c640 then return false end
	return c642 - c640 <= (c641 or 0)
end

return c614]]
c927["require/help/trace"] = [[]]
c927["require/help/ui"] = [[local c620= {}

c620.raw = ui

local function c621()
    if type(ui) ~= 'table' then
        error('ui library is not available in this environment')
    end
end

function c620.available()
    return type(ui) == 'table'
end

function c620.get(c622)
    c621()
    return ui.get(c622)
end

function c620.is_menu_open()
    c621()
    return ui.is_menu_open()
end

function c620.menu_position()
    c621()
    return ui.menu_position()
end

function c620.menu_size()
    c621()
    return ui.menu_size()
end

function c620.mouse_position()
    c621()
    return ui.mouse_position()
end

function c620.name(c622)
    c621()
    return ui.name(c622)
end


function c620.new_button(c623,c624,c625,c626)
    c621()
    return ui.new_button(c623, c624, c625, c626)
end

function c620.new_checkbox(c623,c624,c625)
    c621()
    return ui.new_checkbox(c623, c624, c625)
end

function c620.new_color_picker(c623,c624,c625,c627,c628,c629,c630)
    c621()
    return ui.new_color_picker(c623, c624, c625, c627 or 0, c628 or 0, c629 or 0, c630 or 255)
end

function c620.new_combobox(c623,c624,c625,...)
    c621()
    return ui.new_combobox(c623, c624, c625, ...)
end

function c620.new_hotkey(c623,c624,c625,c631,c632)
    c621()
    return ui.new_hotkey(c623, c624, c625, c631 and true or false, c632)
end

function c620.new_label(c623,c624,c625)
    c621()
    return ui.new_label(c623, c624, c625)
end

function c620.new_listbox(c623,c624,c625,c633)
    c621()
    return ui.new_listbox(c623, c624, c625, c633)
end

function c620.new_multiselect(c623,c624,c625,...)
    c621()
    return ui.new_multiselect(c623, c624, c625, ...)
end

function c620.new_slider(c623,c624,c625,c634,c635,c636,c637,c638,c639,c640)
    c621()
    return ui.new_slider(c623, c624, c625, c634, c635, c636, c637, c638, c639, c640)
end

function c620.new_string(c625,c641)
    c621()
    return ui.new_string(c625, c641)
end

function c620.new_textbox(c623,c624,c625)
    c621()
    return ui.new_textbox(c623, c624, c625)
end

function c620.reference(c623,c624,c625)
    c621()
    return ui.reference(c623, c624, c625)
end


function c620.set(c622,...)
    c621()
    return ui.set(c622, ...)
end

function c620.set_callback(c622,c626)
    c621()
    return ui.set_callback(c622, c626)
end

function c620.set_enabled(c622,c642)
    c621()
    return ui.set_enabled(c622, c642)
end

function c620.set_visible(c622,c643)
    c621()
    return ui.set_visible(c622, c643)
end

function c620.type(c622)
    c621()
    return ui.type(c622)
end

function c620.update(c622,...)
    c621()
    if ui.update then
        return ui.update(c622, ...)
    end
    error('ui.update is not supported in this environment')
end

function c620.get_color(c622)
    c621()
    local c627,c628,c629,c630= ui.get(c622)
    if c627 == nil then return nil end
    return { r = c627, g = c628, b = c629, a = c630 }
end

function c620.set_color(c622,c644)
    c621()
    if type(c644) == 'table' then
        return ui.set(c622, c644.r or 0, c644.g or 0, c644.b or 0, c644.a or 255)
    else
        error('color must be a table {r,g,b,a}')
    end
end

function c620.get_multiselect(c622)
    c621()
    local c645= ui.get(c622)
    return c645
end

function c620.list_refs(c623,c624)
    c621()
    local c646= {}
    for _, c625 in ipairs(ui.get_children and ui.get_children(c623, c624) or {}) do
        c646[#c646+1] = ui.reference(c623, c624, c625)
    end
    return c646
end

return c620]]
c927["require/help/vector"] = [[local c623
do
    local function c624(c625,c626,c627)
        local c628= { x = 0, y = 0, z = 0 }
        if type(c625) == "table" then
            c628.x = c625.x or c625[1] or 0
            c628.y = c625.y or c625[2] or 0
            c628.z = c625.z or c625[3] or 0
        elseif type(c625) == "number" then
            c628.x = c625
            c628.y = c626 or 0
            c628.z = c627 or 0
        elseif c625 ~= nil then
            c628.x = (c625.x or c625[1]) or 0
            c628.y = (c625.y or c625[2]) or 0
            c628.z = (c625.z or c625[3]) or 0
        end
        return setmetatable(c628, vector_mt)
    end

    local c629= {}

    vector_mt = {
        __index = function(c630,c631)
            if c631 == 1 then return rawget(c630,"x") end
            if c631 == 2 then return rawget(c630,"y") end
            if c631 == 3 then return rawget(c630,"z") end
            local c628= rawget(c630,c631)
            if c628 ~= nil then return c628 end
            return c629[c631]
        end,
        __sub = function(c625,c626)
            return c624((c625.x or 0) - (c626.x or 0), (c625.y or 0) - (c626.y or 0), (c625.z or 0) - (c626.z or 0))
        end,
        __add = function(c625,c626)
            return c624((c625.x or 0) + (c626.x or 0), (c625.y or 0) + (c626.y or 0), (c625.z or 0) + (c626.z or 0))
        end,
        __mul = function(c625,c626)
            if type(c625) == 'number' then return c624(c625 * (c626.x or 0), c625 * (c626.y or 0), c625 * (c626.z or 0)) end
            if type(c626) == 'number' then return c624((c625.x or 0) * c626, (c625.y or 0) * c626, (c625.z or 0) * c626) end
            return nil
        end,
        __div = function(c625,c626)
            if type(c626) == 'number' and c626 ~= 0 then return c624((c625.x or 0) / c626, (c625.y or 0) / c626, (c625.z or 0) / c626) end
            return nil
        end,
        __unm = function(c625) return c624(-(c625.x or 0), -(c625.y or 0), -(c625.z or 0)) end,
        __tostring = function(c625) return string.format("vec(%.3f, %.3f, %.3f)", c625.x or 0, c625.y or 0, c625.z or 0) end
    }

    c629.length = function(c632) return math.sqrt((c632.x or 0)^2 + (c632.y or 0)^2 + (c632.z or 0)^2) end
    c629.dot = function(c625,c626) return (c625.x or 0)*(c626.x or 0) + (c625.y or 0)*(c626.y or 0) + (c625.z or 0)*(c626.z or 0) end
    c629.cross = function(c625,c626)
        return c624((c625.y or 0)*(c626.z or 0) - (c625.z or 0)*(c626.y or 0),
                        (c625.z or 0)*(c626.x or 0) - (c625.x or 0)*(c626.z or 0),
                        (c625.x or 0)*(c626.y or 0) - (c625.y or 0)*(c626.x or 0))
    end
    c629.normalized = function(c632)
        local c633= c629.length(c632)
        if c633 == 0 or c633 == nil then return c624(0,0,0) end
        return c624((c632.x or 0)/c633, (c632.y or 0)/c633, (c632.z or 0)/c633)
    end
    c629.normalize = function(c632)
        local c633= c629.length(c632)
        if c633 == 0 or c633 == nil then return c632 end
        c632.x = (c632.x or 0)/c633
        c632.y = (c632.y or 0)/c633
        c632.z = (c632.z or 0)/c633
        return c632
    end
    c629.copy = function(c632) return c624(c632.x or 0, c632.y or 0, c632.z or 0) end
    c629.distance_to = function(c632,c634)
        local c635= c634
        if type(c634) == 'number' then c635 = c623(c634) end
        local c636= (c632.x or 0) - (c635.x or 0)
        local c637= (c632.y or 0) - (c635.y or 0)
        local c638= (c632.z or 0) - (c635.z or 0)
        return math.sqrt(c636*c636 + c637*c637 + c638*c638)
    end
    c629.to_screen = function(c632)
        if not renderer or not renderer.world_to_screen then return nil end
        return renderer.world_to_screen(c632.x or 0, c632.y or 0, c632.z or 0)
    end
    c629.to_angles = function(c632,c634)
        local c635= c634
        if not c635 then return nil end
        local c636= (c635.x or 0) - (c632.x or 0)
        local c637= (c635.y or 0) - (c632.y or 0)
        local c638= (c635.z or 0) - (c632.z or 0)
        local c639= math.deg(math.atan2(c637, c636))
        local c640= math.sqrt(c636*c636 + c637*c637)
        local c641= -math.deg(math.atan2(c638, c640))
        return c641, c639
    end

    c623 = setmetatable({}, {
        __call = function(c642,c625,c626,c627)
            return c624(c625, c626, c627)
        end
    })
end
return c623]]
c927["main"] = [[


local function c626(c627)
    local c628, c629= pcall(require, c627)
    if c628 then
        return c629
    else
        return nil
    end
end




c626("require/brain/dll")





local function c630()

    c626("require/brain/test")

    local c631= {
        menu = c626("require/abc/menu_header"),
        login = c626("require/abc/login_system"),
        config = c626("require/abc/config_system"),
        player_condition = c626("require/aa/player_condition"),
        menu_setup = c626("require/abc/menu_setup"),
        gc = c626("require/abc/garbage_collector"),
        pushlog = c626("require/abc/push_logger"),
        screenlog = c626("require/abc/screen_logger"),
        self = c626("require/help/self"),
        enemies = c626("require/help/enemies"),
        COLORS = c626("require/help/color"),
        str = c626("require/help/string"),
        safe = c626("require/help/safe"),
        build_menu = c626("require/abc/build_menu"),
        menu_visibility = c626("require/abc/menu_visibility"),
        config_system = c626("require/abc/config_system"),
    }

    
    c626("require/abc/register")

    
    c626("require/features/aa/antiaim")

    
    
    c626("require/features/misc/resolver")
    c626("require/features/misc/analyze")
    c626("require/features/misc/dormant_aimbot")
    c626("require/features/misc/fakelag")
    c626("require/features/misc/hotkeys")
    c626("require/features/misc/freestand_helper")
    c626("require/features/misc/enhance_osaa")
    c626("require/features/misc/roll")
    c626("require/features/misc/exploit_fakelag")
    c626("require/features/misc/walkbot")
    c626("require/features/misc/backstab_assist")
    c626("require/features/misc/spin_on_dead_enemies")
    c626("require/features/misc/localdebug")

    
    c626("require/features/paint/world_hitmarker_plus")
    c626("require/features/paint/onshot_skeleton")
    c626("require/features/paint/damage")
    c626("require/features/paint/damage_penetration")
    c626("require/features/paint/aimbot_logs")
    c626("require/features/paint/aspect_ratio")
    c626("require/features/paint/third_person_distance")
    c626("require/features/paint/watermark_solus")
    c626("require/features/paint/watermark_gamesense")
    c626("require/features/paint/entidx")
    c626("require/features/paint/target_info")
    c626("require/features/paint/clantag")
    c626("require/features/paint/indicators_bold")
    c626("require/features/paint/indicators_small")
    c626("require/features/paint/hit_miss_indicator")
    c626("require/features/paint/bomb_esp")
    c626("require/features/paint/presmoke_warning")
    c626("require/features/paint/self_skeleton")
    c626("require/features/paint/performance_mode")
    
    c626("require/features/paint/minimum_damage")
    c626("require/features/paint/filter_console")
    c626("require/features/paint/warnings")
    c626("require/features/paint/text_watermark")
    c626("require/features/paint/bullet_tracer")
    c626("require/features/paint/animations")
    c626("require/features/paint/lagcomp_box")
    c626("require/features/paint/insults")
    c626("require/features/paint/molotov_particles")
    
    

    
    c631.pushlog("The lua has initialized", 4, 255, 255, 0, 255)
    c631.screenlog("The lua has initialized", 4, 255, 255, 255, 255)

    
    local function c632()
        local c633= database.read('cached_credentials')
        if c633 and c633.username and c633.password then
            c631.safe.safe_set(c631.menu_setup.ui.login_username, c633.username)
            c631.safe.safe_set(c631.menu_setup.ui.login_password, c633.password)
            c631.safe.safe_set(c631.menu_setup.ui.cache_credentials, true)
            
            local c634= c631.login.login(c633.username, c633.password)
            if c634 then
                local c635,c636,c637= c631.COLORS.get("green", "log")
                c631.screenlog("Auto-login successful!", 3, c635, c636, c637, 255)
                c631.pushlog("Auto-login successful!", 3, 255, 255, 0, 255)
            else
                local c635,c636,c637= c631.COLORS.get("red", "log")
                c631.screenlog("Auto-login failed!", 3, c635, c636, c637, 255)
                c631.pushlog("Auto-login failed!", 3, 255, 255, 0, 255)
            end
        end
    end

    
    c631.build_menu(c631)
    c631.menu_visibility.setup_callbacks(c631)

    
    local function c638()
        local c639= c631.login.logged_in
        if not c639 then return end
        c631.menu.draw_menu()
        if c631.menu.is_menu_open() then
            local c640= c631.menu.tab_sections()
            local c641, c642= c631.menu.mouse_position()
            local c643= c631.menu.current_tab_index()
            local c644= c631.menu.current_tab()
            local c645, c646= c631.menu.menu_position()
            local c647, c648= c631.menu.menu_size()
        end
    end

    
    local function c649(c650)
        if not c631.menu.is_menu_open() then return end
        if not c631.menu.is_mouse_outside_menu() then
            c650.in_attack = false
        end
    end

    
    local function c651()
        if c631.gc then
            if c631.gc.dynamic then
                c631.gc.dynamic()
            elseif c631.gc.step then
                c631.gc.step(100)
            end
        end
    end

    
    local function c652()
        c632()
        c631.menu_visibility.update(c631)
    end

    c652()

    local c653

    
    client.set_event_callback('setup_command', function(c650)
        c649(c650)
    end)

    client.set_event_callback('paint', function()
        c638()
        
    end)

    client.set_event_callback('paint_ui', function()

        if not c631.menu.is_menu_open() then return end
        local c644= c631.menu.current_tab()

        c631.menu_setup.toggle_gamesense_menu(false)

        if c644 ~= c653 then
            c653 = c644
            c631.menu_visibility.update(c631)
        end

    end)

    client.set_event_callback('shutdown', function(c650)
        c631.menu_setup.toggle_gamesense_menu(true)
    end)
end

_G.loader_init_after_hwid = c630
c626("require/abc/hwid_check")]]

return c930("main")
